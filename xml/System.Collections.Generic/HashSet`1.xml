<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7e57106e06a17e4a92a26615648326f471aa90dd" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58688452" /></Metadata><TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HashSet&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ISet&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="0a2a9-101">해시 집합에 있는 요소의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-101">The type of elements in the hash set.</span></span></typeparam>
    <summary><span data-ttu-id="0a2a9-102">값 집합을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-102">Represents a set of values.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-103"><xref:System.Collections.Generic.HashSet%601> 클래스는 고성능 작업 집합을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-103">The <xref:System.Collections.Generic.HashSet%601> class provides high-performance set operations.</span></span> <span data-ttu-id="0a2a9-104">집합은 중복 된 요소가 들어 있는 컬렉션 요소가 특정 순서 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-104">A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a2a9-105"><xref:System.Collections.Generic.HashSet%601> 구현 합니다 <xref:System.Collections.Generic.IReadOnlyCollection%601> 로 시작 하는 인터페이스를 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; 이전 버전의.NET Framework는 <xref:System.Collections.Generic.HashSet%601> 클래스가이 인터페이스를 구현 하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-105"><xref:System.Collections.Generic.HashSet%601> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Generic.HashSet%601> class did not implement this interface.</span></span>  
  
 <span data-ttu-id="0a2a9-106">용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-106">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="0a2a9-107"><xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-107">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="0a2a9-108">합니다 <xref:System.Collections.Generic.HashSet%601> 클래스는 수치 연산 집합의 모델에 기반 하며 고성능 집합 작업의 키에 액세스 하려면 유사한 제공 합니다 <xref:System.Collections.Generic.Dictionary%602> 또는 <xref:System.Collections.Hashtable> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-108">The <xref:System.Collections.Generic.HashSet%601> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <xref:System.Collections.Generic.Dictionary%602> or <xref:System.Collections.Hashtable> collections.</span></span> <span data-ttu-id="0a2a9-109">간단히 말해에서 합니다 <xref:System.Collections.Generic.HashSet%601> 클래스는으로 생각할 수 있습니다를 <xref:System.Collections.Generic.Dictionary%602> 값이 없는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-109">In simple terms, the <xref:System.Collections.Generic.HashSet%601> class can be thought of as a <xref:System.Collections.Generic.Dictionary%602> collection without values.</span></span>  
  
 <span data-ttu-id="0a2a9-110"><xref:System.Collections.Generic.HashSet%601> 컬렉션은 정렬 되지 않고 중복 요소를 포함할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-110">A <xref:System.Collections.Generic.HashSet%601> collection is not sorted and cannot contain duplicate elements.</span></span> <span data-ttu-id="0a2a9-111">순서 또는 요소 중복 응용 프로그램에 대 한 성능 보다 더 중요 한 경우 사용을 고려 합니다 <xref:System.Collections.Generic.List%601> 와 함께 클래스는 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-111">If order or element duplication is more important than performance for your application, consider using the <xref:System.Collections.Generic.List%601> class together with the <xref:System.Collections.Generic.List%601.Sort%2A> method.</span></span>  
  
 <span data-ttu-id="0a2a9-112"><xref:System.Collections.Generic.HashSet%601> 여러 수치 연산 집합 더하기 (합집합) 등의 작업을 설정 하 고 집합 빼기를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-112"><xref:System.Collections.Generic.HashSet%601> provides many mathematical set operations, such as set addition (unions) and set subtraction.</span></span> <span data-ttu-id="0a2a9-113">다음 표에 제공 된 <xref:System.Collections.Generic.HashSet%601> 작업 및 해당 하는 수학 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-113">The following table lists the provided <xref:System.Collections.Generic.HashSet%601> operations and their mathematical equivalents.</span></span>  
  
|<span data-ttu-id="0a2a9-114">HashSet 작업</span><span class="sxs-lookup"><span data-stu-id="0a2a9-114">HashSet operation</span></span>|<span data-ttu-id="0a2a9-115">해당 하는 수학</span><span class="sxs-lookup"><span data-stu-id="0a2a9-115">Mathematical equivalent</span></span>|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<span data-ttu-id="0a2a9-116">공용 구조체 또는 설정 추가</span><span class="sxs-lookup"><span data-stu-id="0a2a9-116">Union or set addition</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<span data-ttu-id="0a2a9-117">교집합</span><span class="sxs-lookup"><span data-stu-id="0a2a9-117">Intersection</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<span data-ttu-id="0a2a9-118">집합 빼기</span><span class="sxs-lookup"><span data-stu-id="0a2a9-118">Set subtraction</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="0a2a9-119">대칭 차이 계산</span><span class="sxs-lookup"><span data-stu-id="0a2a9-119">Symmetric difference</span></span>|  
  
 <span data-ttu-id="0a2a9-120">집합 작업 이외에 <xref:System.Collections.Generic.HashSet%601> 클래스 집합의 중복 집합 같은지를 확인 하기 위한 메서드도 제공 및 하위 집합 또는 다른 집합의 상위 집합 인지 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-120">In addition to the listed set operations, the <xref:System.Collections.Generic.HashSet%601> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</span></span>  
  
<span data-ttu-id="0a2a9-121">**.NET framework에만 해당:** 에 대 한 매우 큰 <xref:System.Collections.Generic.HashSet%601> 개체를 설정 하 여 64 비트 시스템에서 2 십억 요소에 최대 용량을 늘릴 수 있습니다는 `enabled` 특성을 [ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) 구성 요소를 `true` 에 런타임 환경입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-121">**.NET Framework only:** For very large <xref:System.Collections.Generic.HashSet%601> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the `enabled` attribute of the [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration element to `true` in the run-time environment.</span></span>  
  
 <span data-ttu-id="0a2a9-122">부터 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Collections.Generic.HashSet%601> 구현 클래스는 <xref:System.Collections.Generic.ISet%601> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-122">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Collections.Generic.HashSet%601> class implements the <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
## <a name="hashset-and-linq-set-operations"></a><span data-ttu-id="0a2a9-123">HashSet 및 LINQ 집합 작업</span><span class="sxs-lookup"><span data-stu-id="0a2a9-123">HashSet and LINQ Set Operations</span></span>  
 <span data-ttu-id="0a2a9-124">LINQ에 대 한 액세스를 제공 합니다 `Distinct`, `Union`, `Intersect` 및 `Except` 구현 하는 모든 데이터 원본에 대 한 작업을 설정 합니다 <xref:System.Collections.IEnumerable> 또는 <xref:System.Linq.IQueryable> 인터페이스.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-124">LINQ provides access to the `Distinct`, `Union`, `Intersect` and `Except` set operations on any data source that implements the <xref:System.Collections.IEnumerable> or <xref:System.Linq.IQueryable> interfaces.</span></span>  <span data-ttu-id="0a2a9-125"><xref:System.Collections.Generic.HashSet%601> 집합 작업의 더 큰 적고 더 안정적인 컬렉션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-125"><xref:System.Collections.Generic.HashSet%601> provides a larger and more robust collection of set operations.</span></span> <span data-ttu-id="0a2a9-126">예를 들어 <xref:System.Collections.Generic.HashSet%601> 비교와 같은 제공 <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> 고 <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-126">For example, <xref:System.Collections.Generic.HashSet%601> provides comparisons such as <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> and <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span></span>  
  
 <span data-ttu-id="0a2a9-127">LINQ의 가장 큰 차이점 작업을 설정 및 <xref:System.Collections.Generic.HashSet%601> operations LINQ 집합 작업 항상 반환할 수 있다는 새 <xref:System.Collections.Generic.IEnumerable%601> 컬렉션 반면는 <xref:System.Collections.Generic.HashSet%601> 해당 메서드는 현재 컬렉션을 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-127">The primary difference between LINQ set operations and <xref:System.Collections.Generic.HashSet%601> operations is that LINQ set operations always return a new <xref:System.Collections.Generic.IEnumerable%601> collection, whereas the <xref:System.Collections.Generic.HashSet%601> equivalent methods modify the current collection.</span></span>  
  
 <span data-ttu-id="0a2a9-128">일반적으로 새 집합을 만들어야 할 경우, 응용 프로그램에 제공 된 설정 작업에만 액세스 해야 하는 경우 LINQ를 사용 하 여 설정에서 작업을 <xref:System.Collections.Generic.IEnumerable%601> 컬렉션 또는 배열의 만으로도 충분 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-128">Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <xref:System.Collections.Generic.IEnumerable%601> collection or array will be sufficient.</span></span> <span data-ttu-id="0a2a9-129">그러나 응용 프로그램에 필요한 추가 설정 작업에 대 한 액세스 또는 바람직하거나 새 컬렉션을 만들 필요가 없으면 사용 하 여는 <xref:System.Collections.Generic.HashSet%601> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-129">However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <xref:System.Collections.Generic.HashSet%601> class.</span></span>  
  
 <span data-ttu-id="0a2a9-130">다음 표는 <xref:System.Collections.Generic.HashSet%601> 작업 및 해당 하는 LINQ 집합 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-130">The following table shows the <xref:System.Collections.Generic.HashSet%601> operations and their equivalent LINQ set operations.</span></span>  
  
|<span data-ttu-id="0a2a9-131">HashSet 작업</span><span class="sxs-lookup"><span data-stu-id="0a2a9-131">HashSet operation</span></span>|<span data-ttu-id="0a2a9-132">LINQ에 해당</span><span class="sxs-lookup"><span data-stu-id="0a2a9-132">LINQ equivalent</span></span>|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|<span data-ttu-id="0a2a9-133">제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-133">Not provided.</span></span>|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="0a2a9-134">제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-134">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|<span data-ttu-id="0a2a9-135">제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-135">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|<span data-ttu-id="0a2a9-136">제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-136">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|<span data-ttu-id="0a2a9-137">제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-137">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|<span data-ttu-id="0a2a9-138">제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-138">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|<span data-ttu-id="0a2a9-139">제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-139">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|<span data-ttu-id="0a2a9-140">제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-140">Not provided.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-141">다음 예제에서는 서로 다른 두 집합을 병합 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-141">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="0a2a9-142">이 예제에서는 두 <xref:System.Collections.Generic.HashSet%601> 개체 이며 각각 홀수 및 짝수 번호를 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-142">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="0a2a9-143">세 번째 <xref:System.Collections.Generic.HashSet%601> 개체는 짝수를 포함 하는 집합에서 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-143">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="0a2a9-144">이 예제에서는 호출는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 홀수 집합 세 번째 집합에 추가 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-144">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a2a9-145"><see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-145">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a2a9-146">비어 있으며 집합 형식에 대한 기본 같음 비교자를 사용하는 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-146">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-147">용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-147">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="0a2a9-148"><xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-148">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="0a2a9-149">이 생성자는 o (1) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-149">This constructor is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-150">다음 예제에서는 만들고 두 값을 채우는 방법을 보여 줍니다. <xref:System.Collections.Generic.HashSet%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-150">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="0a2a9-151">이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-151">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="0a2a9-152">해당 요소가 새 집합에 복사되는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-152">The collection whose elements are copied to the new set.</span></span></param>
        <summary><span data-ttu-id="0a2a9-153">집합 형식에 대한 기본 같음 비교자를 사용하고 지정된 컬렉션에서 복사한 요소가 들어 있으며 복사된 요소 수를 수용하기에 용량이 충분한 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-153">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-154">용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-154">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="0a2a9-155"><xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-155">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="0a2a9-156">경우 `collection` 중복이 포함 집합 각각의 고유한 요소 중 하나가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-156">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="0a2a9-157">예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-157">No exception will be thrown.</span></span> <span data-ttu-id="0a2a9-158">따라서 결과 집합의 크기가의 크기와 동일 `collection`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-158">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="0a2a9-159">이 생성자는 (`n`) 작업, 여기서 `n` 의 요소 수를 `collection` 매개 변수.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-159">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-160">다음 예제에서는 만드는 방법을 보여 줍니다는 <xref:System.Collections.Generic.HashSet%601> 기존 집합을 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-160">The following example shows how to create a <xref:System.Collections.Generic.HashSet%601> collection from an existing set.</span></span> <span data-ttu-id="0a2a9-161">이 예제에서는 두 만들어집니다 홀수 및 짝수 정수를 사용 하 여 각각.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-161">In this example, two sets are created with even and odd integers, respectively.</span></span> <span data-ttu-id="0a2a9-162">세 번째 <xref:System.Collections.Generic.HashSet%601> 개체는 다음 집합에서 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-162">A third <xref:System.Collections.Generic.HashSet%601> object is then created from the even integer set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-163"><paramref name="collection" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-163"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="0a2a9-164">집합의 값을 비교하려면 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하고, 집합 형식에 대한 기본 <see cref="T:System.Collections.Generic.EqualityComparer`1" /> 구현을 사용하려면 <see langword="null" />을(를) 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-164">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="0a2a9-165">비어 있으며 집합 형식에 대한 지정된 같음 비교자를 사용하는 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-165">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-166">용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-166">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="0a2a9-167"><xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-167">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="0a2a9-168">이 생성자는 o (1) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-168">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="0a2a9-169"><see cref="T:System.Collections.Generic.HashSet`1" />의 초기 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-169">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <summary><span data-ttu-id="0a2a9-170">비어 있지만 <paramref name="capacity" /> 항목에 대한 공간이 예약되어 있고 집합 형식에 대한 기본 같음 비교자를 사용하는 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-170">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty, but has reserved space for <paramref name="capacity" /> items and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-171">비교적 비용이 많이 드는 크기가 조정 되므로 (해싱하여 필요)의 값을 기반으로 초기 용량을 설정 하 여 크기를 조정할 필요가 최소화 하려고 하는이 `capacity`입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-171">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="0a2a9-172">해당 요소가 새 집합에 복사되는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-172">The collection whose elements are copied to the new set.</span></span></param>
        <param name="comparer"><span data-ttu-id="0a2a9-173">집합의 값을 비교하려면 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하고, 집합 형식에 대한 기본 <see cref="T:System.Collections.Generic.EqualityComparer`1" /> 구현을 사용하려면 <see langword="null" />을(를) 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-173">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="0a2a9-174">집합 형식에 대한 지정된 같음 비교자를 사용하고 지정된 컬렉션에서 복사한 요소가 들어 있으며 복사된 요소 수를 수용하기에 용량이 충분한 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-174">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-175">용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-175">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="0a2a9-176"><xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-176">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="0a2a9-177">경우 `collection` 중복이 포함 집합 각각의 고유한 요소 중 하나가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-177">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="0a2a9-178">예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-178">No exception will be thrown.</span></span> <span data-ttu-id="0a2a9-179">따라서 결과 집합의 크기가의 크기와 동일 `collection`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-179">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="0a2a9-180">이 생성자는 (`n`) 작업, 여기서 `n` 의 요소 수를 `collection` 매개 변수.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-180">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-181">다음 예제에서는 제공 된 <xref:System.Collections.Generic.IEqualityComparer%601> 의 요소에 대/소문자 구분 비교를 허용 하는 <xref:System.Collections.Generic.HashSet%601> 차량 형식의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-181">The following example uses a supplied <xref:System.Collections.Generic.IEqualityComparer%601> to allow case-insensitive comparisons on the elements of a  <xref:System.Collections.Generic.HashSet%601> collection of vehicle types.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-182"><paramref name="collection" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-182"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="0a2a9-183"><see cref="T:System.Collections.Generic.HashSet`1" />의 초기 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-183">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <param name="comparer"><span data-ttu-id="0a2a9-184">집합의 값을 비교하려면 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하고, 집합 형식에 대한 기본 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하려면 null(Visual Basic의 경우 Nothing)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-184">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null (Nothing in Visual Basic) to use the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="0a2a9-185">집합 형식에 대해 지정된 같음 비교자를 사용하고 <paramref name="capacity" /> 요소를 수용할 수 있을 만큼 용량이 충분한 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-185">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, and has sufficient capacity to accommodate <paramref name="capacity" /> elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-186">비교적 비용이 많이 드는 크기가 조정 되므로 (해싱하여 필요)의 값을 기반으로 초기 용량을 설정 하 여 크기를 조정할 필요가 최소화 하려고 하는이 `capacity`입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-186">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="0a2a9-187"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-187">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="0a2a9-188"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 연결되어 있는 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-188">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-189">serialize된 데이터를 사용하여 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-189">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-190">이 생성자는 스트림을 통해 전송 되는 개체를 다시 구성 하기 위해 역직렬화 하는 동안 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-190">This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</span></span> <span data-ttu-id="0a2a9-191">자세한 내용은 [XML 및 SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-191">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; bool&#xA;override this.Add : 'T -&gt; bool" Usage="hashSet.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="0a2a9-192">집합에 추가할 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-192">The element to add to the set.</span></span></param>
        <summary><span data-ttu-id="0a2a9-193">지정된 요소를 집합에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-193">Adds the specified element to a set.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-194">요소가 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 추가되었으면 <see langword="true" />이고, 요소가 이미 있으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-194"><see langword="true" /> if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; <see langword="false" /> if the element is already present.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-195">하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 이미의 용량과 <xref:System.Collections.Generic.HashSet%601> 개체를 새 항목에 맞게 용량을 자동으로 조정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-195">If <xref:System.Collections.Generic.HashSet%601.Count%2A> already equals the capacity of the <xref:System.Collections.Generic.HashSet%601> object, the capacity is automatically adjusted to accommodate the new item.</span></span>  
  
 <span data-ttu-id="0a2a9-196">경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 작습니다 내부 배열의 용량 보다이 메서드는 o (1) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-196">If <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the capacity of the internal array, this method is an O(1) operation.</span></span> <span data-ttu-id="0a2a9-197">경우는 <xref:System.Collections.Generic.HashSet%601> 개체 크기를 조정 해야,이 메서드는 O 됩니다 (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-197">If the <xref:System.Collections.Generic.HashSet%601> object must be resized, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-198">다음 예제에서는 만들고 두 값을 채우는 방법을 보여 줍니다. <xref:System.Collections.Generic.HashSet%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-198">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="0a2a9-199">이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-199">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashSet.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a2a9-200"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 요소를 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-200">Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> 0으로 설정 된 한 컬렉션의 요소에서 다른 개체에 대 한 참조도 해제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> is set to zero and references to other objects from elements of the collection are also released.</span></span> <span data-ttu-id="0a2a9-202">용량에 대 한 호출 될 때까지 변경 되지 않습니다 <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-202">The capacity remains unchanged until a call to <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> is made.</span></span>  
  
 <span data-ttu-id="0a2a9-203">이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-203">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-204">다음 예제를 만들고 채웁니다는 <xref:System.Collections.Generic.HashSet%601> 다음 삭제 하는 예제 컬렉션과 컬렉션에 의해 참조 되는 메모리를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-204">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, then clears it and releases the memory referenced by the collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'T&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0a2a9-205">집합의 값이 같은지 확인하는 데 사용되는 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-205">Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></summary>
        <value><span data-ttu-id="0a2a9-206">집합의 값이 같은지 확인하는 데 사용되는 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-206">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-207">이 속성 값을 검색하는 것은 O(1) 연산입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-207">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="hashSet.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="0a2a9-208"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 찾을 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-208">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-209"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 지정된 요소가 포함되어 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-209">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-210"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 지정된 요소가 들어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-210"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-211">이 방법은 O(1) 작업에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-211">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-212">다음 예제에서 값을 제거 하는 방법에 설명 된 <xref:System.Collections.Generic.HashSet%601> 사용 하 여 컬렉션을 <xref:System.Collections.Generic.HashSet%601.Remove%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-212">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="0a2a9-213">이 예제는 <xref:System.Collections.Generic.HashSet%601.Contains%2A> 메서드 집합을 제거 하기 전에 값을 포함 하는 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-213">In this example, the <xref:System.Collections.Generic.HashSet%601.Contains%2A> method verifies that the set contains a value before removing it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a2a9-214"><see cref="T:System.Collections.Generic.HashSet`1" /> 컬렉션의 요소를 배열에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-214">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> collection to an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="hashSet.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="0a2a9-215"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 복사한 요소의 대상인 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-215">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="0a2a9-216">배열에는 0부터 시작하는 인덱스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-216">The array must have zero-based indexing.</span></span></param>
        <summary><span data-ttu-id="0a2a9-217"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체의 요소를 배열에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-217">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-218">이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-218">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-219"><paramref name="array" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-219"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="0a2a9-220"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 복사한 요소의 대상인 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-220">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="0a2a9-221">배열에는 0부터 시작하는 인덱스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-221">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="0a2a9-222"><paramref name="array" />에서 복사가 시작되는 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-222">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="0a2a9-223">지정된 배열 인덱스에서 시작하여 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체의 요소를 배열에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-223">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-224">이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-224">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-225"><paramref name="array" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-225"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0a2a9-226"><paramref name="arrayIndex" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="0a2a9-226"><paramref name="arrayIndex" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0a2a9-227"><paramref name="arrayIndex" />가 대상 <paramref name="array" />의 길이보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="0a2a9-227"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="0a2a9-228"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 복사한 요소의 대상인 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-228">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="0a2a9-229">배열에는 0부터 시작하는 인덱스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-229">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="0a2a9-230"><paramref name="array" />에서 복사가 시작되는 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-230">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <param name="count"><span data-ttu-id="0a2a9-231"><paramref name="array" />에 복사할 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-231">The number of elements to copy to <paramref name="array" />.</span></span></param>
        <summary><span data-ttu-id="0a2a9-232">지정된 배열 인덱스에서 시작하여 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 지정된 수의 요소를 배열에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-232">Copies the specified number of elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-233">이 메서드는 O (`n`) 작업, 여기서 `n` 는 `count`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-233">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-234"><paramref name="array" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-234"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0a2a9-235"><paramref name="arrayIndex" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="0a2a9-235"><paramref name="arrayIndex" /> is less than 0.</span></span>  
  
<span data-ttu-id="0a2a9-236">또는</span><span class="sxs-lookup"><span data-stu-id="0a2a9-236">-or-</span></span> 
 <span data-ttu-id="0a2a9-237"><paramref name="count" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="0a2a9-237"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0a2a9-238"><paramref name="arrayIndex" />가 대상 <paramref name="array" />의 길이보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="0a2a9-238"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span>  
  
<span data-ttu-id="0a2a9-239">또는</span><span class="sxs-lookup"><span data-stu-id="0a2a9-239">-or-</span></span> 
 <span data-ttu-id="0a2a9-240"><paramref name="count" />가 <paramref name="index" />에서 대상 <paramref name="array" /> 끝까지 사용 가능한 공간보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="0a2a9-240"><paramref name="count" /> is greater than the available space from the <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0a2a9-241">집합에 포함된 요소 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-241">Gets the number of elements that are contained in a set.</span></span></summary>
        <value><span data-ttu-id="0a2a9-242">집합에 포함된 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-242">The number of elements that are contained in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-243">용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-243">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="0a2a9-244"><xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-244">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="0a2a9-245">항상이 용량은 보다 크거나 같은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-245">The capacity is always greater than or equal to <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span> <span data-ttu-id="0a2a9-246">경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 요소를 추가 하는 동안 용량을 초과, 용량 double 이전 용량 보다 큰 첫 번째 소수로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-246">If <xref:System.Collections.Generic.HashSet%601.Count%2A> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</span></span>  
  
 <span data-ttu-id="0a2a9-247">이 속성 값을 검색하는 것은 O(1) 연산입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-247">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-248">다음 예제에서는 만들고, 채우고, 두 개를 조작 하는 방법을 보여 줍니다 <xref:System.Collections.Generic.HashSet%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-248">The following example demonstrates how to create, populate, and manipulate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="0a2a9-249">이 예제에서는 두 집합의 내용과 및 <xref:System.Collections.Generic.HashSet%601.Count%2A> 콘솔에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-249">In this example, both the contents of the set and <xref:System.Collections.Generic.HashSet%601.Count%2A> display to the console.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberSignature Language="F#" Value="static member CreateSetComparer : unit -&gt; System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;'T&gt;&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.CreateSetComparer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a2a9-250"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 대한 같음 테스트에 사용할 수 있는 <see cref="T:System.Collections.IEqualityComparer" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-250">Returns an <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-251"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 대한 전체 같음 테스트에 사용할 수 있는 <see cref="T:System.Collections.IEqualityComparer" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-251">An <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-252"><xref:System.Collections.IEqualityComparer> 있지만 함께 연결할 수 있습니다 더 깊은 같음 테스트를 수행 하려면 추가 수준의 비교자; 개체 하나만 수준 같음 여부를 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-252">The <xref:System.Collections.IEqualityComparer> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</span></span>  
  
 <span data-ttu-id="0a2a9-253">이 메서드를 호출 하는 것은 o (1) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-253">Calling this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="hashSet.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member ExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.ExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.ExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-254"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 제거할 항목 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-254">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-255">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 지정된 컬렉션의 모든 요소를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-255">Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-256"><xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> 메서드 수치 연산 집합 빼기 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-256">The <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method is the equivalent of mathematical set subtraction.</span></span>  
  
 <span data-ttu-id="0a2a9-257">이 메서드는 O (`n`) 작업 위치 `n` 의 요소 수를 `other` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-257">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-258">다음 예제에서는 두 개의 <xref:System.Collections.Generic.HashSet%601> 겹치는 데이터 집합을 사용 하는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-258">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="0a2a9-259">값의 낮은 범위는 다음을 사용 하 여 더 큰 집합에서 제거 된 <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-259">The lower range of values is then removed from the larger set using the <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-260"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-260"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.HashSet&lt;'T&gt;.Enumerator" Usage="hashSet.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a2a9-261"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 반복되는 열거자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-261">Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-262"><see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> 개체에 대한 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-262">A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-263">합니다 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서) 열거자의 복잡성을 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-263">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="0a2a9-264">따라서 사용 하 여 `foreach` 열거자를 직접 조작 하는 대신 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-264">Therefore, using `foreach` is recommended instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="0a2a9-265">열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-265">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="0a2a9-266">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-266">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="0a2a9-267">이 위치에 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 속성 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-267">At this position, the <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="0a2a9-268">따라서 호출 해야 합니다 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-268">Therefore, you must call the <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="0a2a9-269">합니다 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-269">The <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property returns the same object until <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="0a2a9-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>는 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>를 다음 요소로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> sets <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="0a2a9-271">경우 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-271">If <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="0a2a9-272">열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 반환할 수도 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-272">When the enumerator is at this position, subsequent calls to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="0a2a9-273">마지막으로 호출 하는 경우 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-273">If the last call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="0a2a9-274">설정할 수 없습니다 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 다시; 컬렉션의 첫 번째 요소에 새 열거자 개체를 대신 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-274">You cannot set <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="0a2a9-275">열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-275">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="0a2a9-276">변경에 추가 하는 등 컬렉션을 수정 하거나 요소를 삭제, 열거자가 복구할 유효 하지 않으며을 다음에 호출할 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 또는 <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throw는 <xref:System.InvalidOperationException>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-276">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> or <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="0a2a9-277">열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-277">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="0a2a9-278">열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-278">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="0a2a9-279">여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-279">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="0a2a9-280"><xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-280">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="0a2a9-281">이 방법은 O(1) 작업에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-281">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="0a2a9-282"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-282">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="0a2a9-283"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 연결되어 있는 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-283">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-284"><see cref="T:System.Runtime.Serialization.ISerializable" /> 인터페이스를 구현하고 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 serialize하는 데 필요한 데이터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-284">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-285">이 메서드를 호출 하는 O (`n`) 작업을 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-285">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-286"><paramref name="info" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-286"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="0a2a9-287">serialization 서비스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-287">for providing serialization services.</span></span> <span data-ttu-id="0a2a9-288">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-288">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="0a2a9-289">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span><span class="sxs-lookup"><span data-stu-id="0a2a9-289">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IntersectWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.IntersectWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.IntersectWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-290">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-290">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-291">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 수정하여 해당 개체와 지정된 컬렉션에 동시에 있는 요소만 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-291">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-292">표시 되는 컬렉션을 `other` 매개 변수는를 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-292">If the collection represented by the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="0a2a9-293">그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업을 여기서 `n` 됩니다 <xref:System.Collections.Generic.HashSet%601.Count%2A> 및 `m` 의 요소입니다 `other`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-293">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-294"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-294"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-295">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-295">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-296"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 진 부분 집합인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-296">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-297"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 진 부분 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-297"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-298">빈 집합은 다른 컬렉션의 적절 한 하위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-298">An empty set is a proper subset of any other collection.</span></span> <span data-ttu-id="0a2a9-299">따라서이 메서드는 반환 `true` 현재 표시 되는 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체가 비어 않으면를 `other` 매개 변수는 빈 집합 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-299">Therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty unless the `other` parameter is also an empty set.</span></span>  
  
 <span data-ttu-id="0a2a9-300">이 메서드는 항상 반환 `false` 하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 보다 크거나의 요소 수가 같지 `other`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-300">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="0a2a9-301">표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-301">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, then this method is an O(`n`) operation.</span></span> <span data-ttu-id="0a2a9-302">그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업을 여기서 `n` 됩니다 <xref:System.Collections.Generic.HashSet%601.Count%2A> 및 `m` 의 요소입니다 `other`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-302">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-303">다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-303">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="0a2a9-304">이 예제에서는 `lowNumbers` 는 하위 집합 이자의 진 부분 집합이 `allNumbers` 될 때까지 `allNumbers` 사용 하 여 수정 될를 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 존재 하는 값만 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-304">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="0a2a9-305">한 번 `allNumbers` 하 고 `lowNumbers` 동일 `lowNumbers` 의 하위 집합은 여전히 `allNumbers` 이지만 더 이상 적절 한 하위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-305">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-306"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-306"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-307">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-307">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-308"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 진 상위 집합인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-308">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-309"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 진 포함 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-309"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-310">빈 집합은 다른 컬렉션의 적절 한 상위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-310">An empty set is a proper superset of any other collection.</span></span> <span data-ttu-id="0a2a9-311">따라서이 메서드는 반환 `true` 표시 되는 컬렉션을 `other` 매개 변수는 비어 하지 않는 한 현재 <xref:System.Collections.Generic.HashSet%601> 컬렉션은 비어 있을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-311">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty unless the current <xref:System.Collections.Generic.HashSet%601> collection is also empty.</span></span>  
  
 <span data-ttu-id="0a2a9-312">이 메서드는 항상 반환 `false` 하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 의 요소 수가 보다 작거나 같으면 `other`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-312">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="0a2a9-313">표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-313">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="0a2a9-314">그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업, 여기서 `n` 의 요소입니다 `other` 및 `m` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-314">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-315">다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-315">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="0a2a9-316">이 예제에서는 `allNumbers` 며 상위 집합의 진 `lowNumbers` 될 때까지 `allNumbers` 를 사용 하 여 수정 될는 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 존재 하는 값만 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-316">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="0a2a9-317">한 번 `allNumbers` 및 `lowNumbers` 동일 `allNumbers` 은 여전히 `lowNumbers` 이지만 더 이상 적절 한 상위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-317">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-318"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-318"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-319">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-319">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-320"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 하위 집합인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-320">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-321"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 부분 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-321"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-322">빈 집합이 빈 집합;를 비롯 한 모든 다른 컬렉션의 하위 집합인 따라서이 메서드는 반환 `true` 현재 표시 되는 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체가 비어 있더라도 `other` 매개 변수는 빈 집합.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-322">An empty set is a subset of any other collection, including an empty set; therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty, even if the `other` parameter is an empty set.</span></span>  
  
 <span data-ttu-id="0a2a9-323">이 메서드는 항상 반환 `false` 하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 의 요소 수보다 큽니다 `other`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-323">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="0a2a9-324">표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-324">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="0a2a9-325">그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업을 여기서 `n` 됩니다 <xref:System.Collections.Generic.HashSet%601.Count%2A> 및 `m` 의 요소입니다 `other`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-325">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-326">다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-326">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="0a2a9-327">이 예제에서는 `lowNumbers` 는 하위 집합 이자의 진 부분 집합이 `allNumbers` 될 때까지 `allNumbers` 사용 하 여 수정 될를 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 존재 하는 값만 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-327">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="0a2a9-328">한 번 `allNumbers` 하 고 `lowNumbers` 동일 `lowNumbers` 의 하위 집합은 여전히 `allNumbers` 이지만 더 이상 적절 한 하위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-328">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-329"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-329"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-330">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-330">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-331"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 상위 집합인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-331">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-332"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 포함 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-332"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-333">빈 집합을 포함 하 여 모든 컬렉션은 빈 집합의 상위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-333">All collections, including the empty set, are supersets of the empty set.</span></span> <span data-ttu-id="0a2a9-334">따라서이 메서드는 반환 `true` 표시 되는 컬렉션을 `other` 매개 변수가 비어 경우에 현재 <xref:System.Collections.Generic.HashSet%601> 개체가 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-334">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty, even if the current <xref:System.Collections.Generic.HashSet%601> object is empty.</span></span>  
  
 <span data-ttu-id="0a2a9-335">이 메서드는 항상 반환 `false` 하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 의 요소 수보다 작습니다 `other`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-335">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="0a2a9-336">표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-336">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="0a2a9-337">그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업, 여기서 `n` 의 요소입니다 `other` 및 `m` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-337">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-338">다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-338">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="0a2a9-339">이 예제에서는 `allNumbers` 며 상위 집합의 진 `lowNumbers` 될 때까지 `allNumbers` 를 사용 하 여 수정 될는 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 존재 하는 값만 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-339">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="0a2a9-340">한 번 `allNumbers` 및 `lowNumbers` 동일 `allNumbers` 은 여전히 `lowNumbers` 이지만 더 이상 적절 한 상위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-340">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-341"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-341"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashSet.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sender"><span data-ttu-id="0a2a9-342">deserialization 이벤트의 소스입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-342">The source of the deserialization event.</span></span></param>
        <summary><span data-ttu-id="0a2a9-343"><see cref="T:System.Runtime.Serialization.ISerializable" /> 인터페이스를 구현하고, deserialization이 완료되면 deserialization 이벤트를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-343">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and raises the deserialization event when the deserialization is complete.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-344">이 메서드를 호출 하는 O (`n`) 작업을 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-344">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException"><span data-ttu-id="0a2a9-345">현재 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체와 관련된 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="0a2a9-345">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" /> object is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Overlaps : seq&lt;'T&gt; -&gt; bool&#xA;override this.Overlaps : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.Overlaps other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-346">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-346">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-347">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 지정된 컬렉션이 공통 요소를 공유하는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-347">Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object and a specified collection share common elements.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-348"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 <paramref name="other" />가 최소한 하나의 요소를 공유하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-348"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and <paramref name="other" /> share at least one common element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-349">이 메서드는 O (`n`) 작업, 여기서 `n` 의 요소입니다 `other`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-349">This method is an O(`n`) operation, where `n` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-350">다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-350">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="0a2a9-351">이 예제에서는 `allNumbers` 하 고 `lowNumbers` 공통 요소를 사용 하 여 공유에 표시 되는 <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-351">In this example, `allNumbers` and `lowNumbers` are shown to share common elements using the <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-352"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-352"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="hashSet.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="0a2a9-353">제거할 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-353">The element to remove.</span></span></param>
        <summary><span data-ttu-id="0a2a9-354"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 지정된 요소를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-354">Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-355">요소를 성공적으로 찾아서 제거한 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-355"><see langword="true" /> if the element is successfully found and removed; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="0a2a9-356"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 <paramref name="item" />이 없으면 이 메서드는 <see langword="false" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-356">This method returns <see langword="false" /> if <paramref name="item" /> is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-357">경우는 <xref:System.Collections.Generic.HashSet%601> 개체는 지정된 된 요소를 포함 하지 않습니다, 개체 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-357">If the <xref:System.Collections.Generic.HashSet%601> object does not contain the specified element, the object remains unchanged.</span></span> <span data-ttu-id="0a2a9-358">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-358">No exception is thrown.</span></span>  
  
 <span data-ttu-id="0a2a9-359">이 방법은 O(1) 작업에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-359">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-360">다음 예제에서 값을 제거 하는 방법에 설명 된 <xref:System.Collections.Generic.HashSet%601> 사용 하 여 컬렉션을 <xref:System.Collections.Generic.HashSet%601.Remove%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-360">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="0a2a9-361">이 예제에서는 0 임의로에서 제거 됩니다는 <xref:System.Collections.Generic.HashSet%601> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-361">In this example, zero is arbitrarily removed from the <xref:System.Collections.Generic.HashSet%601> collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveWhere : Predicate&lt;'T&gt; -&gt; int" Usage="hashSet.RemoveWhere match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><span data-ttu-id="0a2a9-362">제거할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-362">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</span></span></param>
        <summary><span data-ttu-id="0a2a9-363"><see cref="T:System.Collections.Generic.HashSet`1" /> 컬렉션에서 지정된 조건자에 정의된 조건과 일치하는 요소를 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-363">Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-364"><see cref="T:System.Collections.Generic.HashSet`1" /> 컬렉션에서 제거된 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-364">The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-365">이 메서드를 호출 하는 O (`n`) 작업을 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-365">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-366">다음 예제에서 값을 제거 하는 방법에 설명 된 <xref:System.Collections.Generic.HashSet%601> 사용 하 여 컬렉션을 <xref:System.Collections.Generic.HashSet%601.Remove%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-366">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="0a2a9-367">이 예제에서는 모든 홀수 정수에서 제거 되는 <xref:System.Collections.Generic.HashSet%601> 컬렉션에 지정 된 대로 `match` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-367">In this example, all odd integers are removed from the <xref:System.Collections.Generic.HashSet%601> collection as specified by the `match` delegate.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-368"><paramref name="match" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-368"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SetEquals : seq&lt;'T&gt; -&gt; bool&#xA;override this.SetEquals : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.SetEquals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-369">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-369">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-370"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 지정된 컬렉션에 같은 요소가 들어 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-370">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object and the specified collection contain the same elements.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-371"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />와 같으면 <see langword="true" />이고, 그렇지 않으면 false입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-371"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is equal to <paramref name="other" />; otherwise, false.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-372">합니다 <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> 메서드가 중복 된 항목 및에서 요소의 순서를 무시 합니다 `other` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-372">The <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method ignores duplicate entries and the order of elements in the `other` parameter.</span></span>  
  
 <span data-ttu-id="0a2a9-373">표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-373">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="0a2a9-374">그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업, 여기서 `n` 의 요소입니다 `other` 및 `m` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-374">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-375">다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-375">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="0a2a9-376">처음에 두 집합 같지를 사용 하 여 보여 줍니다는 <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-376">Initially, the two sets are not equal, which is demonstrated by using the <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method.</span></span> <span data-ttu-id="0a2a9-377">합니다 `allNumbers` <xref:System.Collections.Generic.HashSet%601> 지나면 집합 같은지 개체는 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-377">The `allNumbers`<xref:System.Collections.Generic.HashSet%601> object is then modified, after which the sets are equal.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-378"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-378"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.SymmetricExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-379">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-379">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-380">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 수정하여 해당 개체와 지정된 컬렉션 중 하나에만 있는 요소만 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-380">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-381">경우는 `other` 매개 변수는를 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-381">If the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="0a2a9-382">그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업, 여기서 `n` 의 요소입니다 `other` 및 `m` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-382">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-383">다음 예제에서는 두 개의 <xref:System.Collections.Generic.HashSet%601> 겹치는 데이터 집합을 사용 하는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-383">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="0a2a9-384">값은 낮은 값을 포함 하는 집합은 다음 수정 하 여를 <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> 메서드를 두 집합 모두에 존재 하지 않는 값만 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-384">The set that contains the lower values is then modified, using the <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> method, to contain only the values that are not present in both sets.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-385"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-385"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="0a2a9-386"><see cref="T:System.Collections.Generic.ICollection`1" /> 개체에 추가할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-386">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-387"><see cref="T:System.Collections.Generic.ICollection`1" /> 개체에 항목을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-387">Adds an item to an <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-388">하는 경우 <xref:System.Collections.Generic.List%601.Count%2A> 는 보다 작은 <xref:System.Collections.Generic.List%601.Capacity%2A>,이 메서드는 o (1) 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-388">If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation.</span></span> <span data-ttu-id="0a2a9-389">이 메서드는 O가 용량을 증가 시켜 새 요소를 수용 해야 하는 경우 (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-389">If the capacity must be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a2a9-390"><see cref="T:System.Collections.Generic.ICollection`1" />이 읽기 전용인 경우</span><span class="sxs-lookup"><span data-stu-id="0a2a9-390">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0a2a9-391">컬렉션이 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-391">Gets a value indicating whether a collection is read-only.</span></span></summary>
        <value><span data-ttu-id="0a2a9-392">컬렉션이 읽기 전용이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-392"><see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-393">이 속성 값을 검색하는 것은 O(1) 연산입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-393">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a2a9-394">컬렉션을 반복하는 열거자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-394">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-395">컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.Generic.IEnumerator`1" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-395">An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-396">합니다 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서) 열거자의 복잡성을 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-396">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="0a2a9-397">그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-397">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="0a2a9-398">열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-398">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="0a2a9-399">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-399">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="0a2a9-400">이 위치에 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 속성 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-400">At this position, the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property is undefined.</span></span> <span data-ttu-id="0a2a9-401">따라서 호출 해야 합니다 <xref:System.Collections.IEnumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-401">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span></span>  
  
 <span data-ttu-id="0a2a9-402">합니다 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.IEnumerator.MoveNext%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-402">The <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property returns the same object until <xref:System.Collections.IEnumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="0a2a9-403"><xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>를 다음 요소로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-403"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="0a2a9-404">경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-404">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="0a2a9-405">열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-405">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="0a2a9-406">마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-406">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> is undefined.</span></span> <span data-ttu-id="0a2a9-407">설정할 수 없습니다 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 다시; 컬렉션의 첫 번째 요소에 새 열거자 개체를 대신 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-407">You cannot set <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="0a2a9-408">열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-408">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="0a2a9-409">컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-409">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="0a2a9-410">열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-410">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="0a2a9-411">열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-411">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="0a2a9-412">여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-412">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="0a2a9-413"><xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-413">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="0a2a9-414">이 방법은 O(1) 작업에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-414">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a2a9-415">컬렉션을 반복하는 열거자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-415">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-416">컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-416">An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-417">합니다 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서) 열거자의 복잡성을 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-417">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="0a2a9-418">그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-418">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="0a2a9-419">열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-419">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="0a2a9-420">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-420">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="0a2a9-421"><xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-421"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="0a2a9-422">이 위치에 <xref:System.Collections.IEnumerator.Current%2A> 속성 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-422">At this position, the <xref:System.Collections.IEnumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="0a2a9-423">따라서 호출 해야 합니다 <xref:System.Collections.IEnumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.IEnumerator.Current%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-423">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="0a2a9-424">합니다 <xref:System.Collections.IEnumerator.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-424">The <xref:System.Collections.IEnumerator.Current%2A> property returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="0a2a9-425"><xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-425"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="0a2a9-426">경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-426">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="0a2a9-427">열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-427">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="0a2a9-428">마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-428">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="0a2a9-429"><xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-429">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="0a2a9-430">열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-430">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="0a2a9-431">컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-431">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="0a2a9-432">열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-432">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="0a2a9-433">열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-433">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="0a2a9-434">여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-434">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="0a2a9-435"><xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-435">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="0a2a9-436">이 방법은 O(1) 작업에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-436">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="hashSet.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a2a9-437"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체의 용량을 실제로 포함된 요소 수로 설정하고 구현별로 다른 근방 값으로 올림합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-437">Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-438">사용할 수는 <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> 최소화 하는 메서드를 <xref:System.Collections.Generic.HashSet%601> 는 알 수 없는 새 요소를 추가할 개체의 메모리 오버 헤드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-438">You can use the <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> method to minimize a <xref:System.Collections.Generic.HashSet%601> object's memory overhead once it is known that no new elements will be added.</span></span> <span data-ttu-id="0a2a9-439">완전히 지우려면를 <xref:System.Collections.Generic.HashSet%601> 개체를 참조 하는 모든 메모리를 해제 한 다음 호출한 후이 메서드를 호출 합니다 <xref:System.Collections.Generic.HashSet%601.Clear%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-439">To completely clear a <xref:System.Collections.Generic.HashSet%601> object and release all memory referenced by it, call this method after calling the <xref:System.Collections.Generic.HashSet%601.Clear%2A> method.</span></span>  
  
 <span data-ttu-id="0a2a9-440">이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-440">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-441">다음 예제를 만들고 채웁니다를 <xref:System.Collections.Generic.HashSet%601> 컬렉션, 컬렉션을 지우고 다음 및 참조 하는 메모리를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-441">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, and then clears the collection and releases the memory referenced by it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'T *  -&gt; bool" Usage="hashSet.TryGetValue (equalValue, actualValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="actualValue" Type="T" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="equalValue"><span data-ttu-id="0a2a9-442">검색할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-442">The value to search for.</span></span></param>
        <param name="actualValue"><span data-ttu-id="0a2a9-443">집합에서 검색한 값입니다. 검색에서 일치하는 항목을 찾지 못한 경우 T의 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-443">The value from the set that the search found, or the default value of T when the search yielded no match.</span></span></param>
        <summary><span data-ttu-id="0a2a9-444">집합에서 지정된 값을 검색하여 동일한 값을 찾은 경우 해당 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-444">Searches the set for a given value and returns the equal value it finds, if any.</span></span></summary>
        <returns><span data-ttu-id="0a2a9-445">검색에 성공했는지 여부를 나타내는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-445">A value indicating whether the search was successful.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-446">하지만 현재 있는 값 보다 자세한 데이터를 포함 하는 값을 조회 하거나 (참조의 자세한 공유 발생할 수 있도록) 새로 생성 된 단일 대신 이전에 저장 된 참조를 다시 사용 하려는 경우 유용할 수 있습니다는 비교자 함수 같은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-446">This can be useful when you want to reuse a previously stored reference instead of a newly constructed one (so that more sharing of references can occur) or to look up a value that has more complete data than the value you currently have, although their comparer functions indicate they are equal.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member UnionWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.UnionWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.UnionWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="0a2a9-447">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-447">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="0a2a9-448">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 수정하여 해당 개체와 지정된 컬렉션에 있는 모든 요소를 포함시킵니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-448">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in itself, the specified collection, or both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a2a9-449">이 메서드는 O (`n`) 작업 위치 `n` 의 요소 수를 `other` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-449">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a2a9-450">다음 예제에서는 서로 다른 두 집합을 병합 하는 방법에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-450">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="0a2a9-451">이 예제에서는 두 <xref:System.Collections.Generic.HashSet%601> 개체 이며 각각 홀수 및 짝수 번호를 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-451">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="0a2a9-452">세 번째 <xref:System.Collections.Generic.HashSet%601> 개체는 짝수를 포함 하는 집합에서 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-452">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="0a2a9-453">이 예제에서는 호출는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 홀수 집합 세 번째 집합에 추가 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-453">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a2a9-454"><paramref name="other" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0a2a9-454"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>