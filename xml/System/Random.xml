<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="adf29f522d3625dba7e4bd956743ac3e35b25683" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58716524" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c1050-101">의사(pseudo) 난수 생성기를 나타냅니다. 이 디바이스는 무작위성에 대한 통계적인 특정 요구 사항과 일치하는 숫자 시퀀스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-101">Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1050-102">의사 (pseudo) 난수 숫자 유한 집합에서 동일한 가능성을 가진 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-102">Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</span></span> <span data-ttu-id="c1050-103">선택한 숫자 수학적 알고리즘을 선택한 후에 되지만 충분히 임의의 실무 때문에 완전 한 임의 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-103">The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</span></span> <span data-ttu-id="c1050-104">현재 구현은 <xref:System.Random> 클래스 Donald E. 크누스 무언가 감 난수 생성기 알고리즘의 수정된 된 버전에 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-104">The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</span></span> <span data-ttu-id="c1050-105">자세한 내용은 4. 5.를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="c1050-105">For more information, see D. E.</span></span> <span data-ttu-id="c1050-106">크누스 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-106">Knuth.</span></span> <span data-ttu-id="c1050-107">*The Art of 컴퓨터 프로그래밍에 볼륨 2: Seminumerical 알고리즘*합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-107">*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*.</span></span> <span data-ttu-id="c1050-108">4.0"(addison-Wesley, 읽기, MA, 세 번째 버전, 1997입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-108">Addison-Wesley, Reading, MA, third edition, 1997.</span></span>  
  
 <span data-ttu-id="c1050-109">암호화 보안 난수를 임의의 암호를 만들기 위한 적합 한 것과 같은 생성 하려면 사용 합니다 <xref:System.Security.Cryptography.RNGCryptoServiceProvider> 클래스 또는 클래스를 파생 <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-109">To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c1050-110">항목 내용</span><span class="sxs-lookup"><span data-stu-id="c1050-110">In this topic:</span></span>  
  
 <span data-ttu-id="c1050-111">[난수 생성기의 인스턴스화](#Instantiate) </span><span class="sxs-lookup"><span data-stu-id="c1050-111">[Instantiating the random number generator](#Instantiate) </span></span>  
 <span data-ttu-id="c1050-112">[여러 인스턴스화를 방지합니다.](#Multiple) </span><span class="sxs-lookup"><span data-stu-id="c1050-112">[Avoiding multiple instantiations](#Multiple) </span></span>  
 <span data-ttu-id="c1050-113">[System.Random 클래스와 스레드 안전성](#ThreadSafety) </span><span class="sxs-lookup"><span data-stu-id="c1050-113">[The System.Random class and thread safety](#ThreadSafety) </span></span>  
 <span data-ttu-id="c1050-114">[다양 한 유형의 난수를 생성합니다.](#Functionality) </span><span class="sxs-lookup"><span data-stu-id="c1050-114">[Generating different types of random numbers](#Functionality) </span></span>  
 <span data-ttu-id="c1050-115">[사용자 고유의 알고리즘을 대체](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="c1050-115">[Substituting your own algorithm](#Overriding) </span></span>  
 <span data-ttu-id="c1050-116">[System.Random를 어떻게 사용 하는 중...](#Operations) </span><span class="sxs-lookup"><span data-stu-id="c1050-116">[How do you use System.Random to…](#Operations) </span></span>  
 [<span data-ttu-id="c1050-117">난수 값의 순서를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-117">Retrieve the same sequence of random values</span></span>](#Same)  
 [<span data-ttu-id="c1050-118">난수 값의 고유한 시퀀스를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-118">Retrieve unique sequences of random values</span></span>](#Unique)  
 [<span data-ttu-id="c1050-119">지정된 된 범위에 있는 정수를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-119">Retrieve integers in a specified range</span></span>](#Range)  
 [<span data-ttu-id="c1050-120">지정 된 자릿수를 사용 하 여 정수를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-120">Retrieve integers with a specified number of digits</span></span>](#Digits)  
 [<span data-ttu-id="c1050-121">지정된 된 범위에서 부동 소수점 값을 검색</span><span class="sxs-lookup"><span data-stu-id="c1050-121">Retrieve floating-point values in a specified range</span></span>](#Floats)  
 [<span data-ttu-id="c1050-122">임의의 부울 값을 생성</span><span class="sxs-lookup"><span data-stu-id="c1050-122">Generate random Boolean values</span></span>](#Boolean)  
 [<span data-ttu-id="c1050-123">임의의 64 비트 정수를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-123">Generate random 64-bit integers</span></span>](#Long)  
 [<span data-ttu-id="c1050-124">지정 된 범위의 바이트를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-124">Retrieve bytes in a specified range</span></span>](#Bytes)  
 [<span data-ttu-id="c1050-125">배열 또는 컬렉션에서 요소를 무작위로 검색</span><span class="sxs-lookup"><span data-stu-id="c1050-125">Retrieve an element from an array or collection at random</span></span>](#Array)  
 [<span data-ttu-id="c1050-126">배열 또는 컬렉션에서 고유 요소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-126">Retrieve a unique element from an array or collection</span></span>](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a><span data-ttu-id="c1050-127">난수 생성기의 인스턴스화</span><span class="sxs-lookup"><span data-stu-id="c1050-127">Instantiating the random number generator</span></span>  
 <span data-ttu-id="c1050-128">에 시드 값 (의 의사 (pseudo) 난수 생성 알고리즘에 대 한 시작 값)를 제공 하 여 난수 생성기를 인스턴스화하는 <xref:System.Random.%23ctor%2A> 클래스 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-128">You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.</span></span>  <span data-ttu-id="c1050-129">명시적 또는 암시적으로 시드 값을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-129">You can supply the seed value either explicitly or implicitly:</span></span>  
  
-   <span data-ttu-id="c1050-130"><xref:System.Random.%23ctor%28System.Int32%29> 생성자를 제공 하는 명시적 시드 값을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-130">The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.</span></span>  
  
-   <span data-ttu-id="c1050-131"><xref:System.Random.%23ctor> 생성자 시스템 클록을 사용 하 여 시드 값을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-131">The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value.</span></span> <span data-ttu-id="c1050-132">이것이 난수 생성기를 인스턴스화하는 가장 일반적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-132">This is the most common way of instantiating the random number generator.</span></span>  
  
 <span data-ttu-id="c1050-133">별개의 동일한 초기값을 사용 하는 경우 <xref:System.Random> 개체를 동일한 일련의 난수 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-133">If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers.</span></span> <span data-ttu-id="c1050-134">이 임의 값을 처리 하는 테스트 도구 모음을 만들기 위한 하거나 임의의 숫자에서 해당 데이터를 파생 되는 게임을 재생 하는 데 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-134">This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</span></span> <span data-ttu-id="c1050-135">그러나 <xref:System.Random> 개체가 다른 버전의.NET Framework에서 실행 중인 프로세스에서 동일한 초기값을 사용 하 여 인스턴스화되는 경우에 다른 일련의 임의 숫자를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-135">However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</span></span>  
  
 <span data-ttu-id="c1050-136">여러 가지 임의의 숫자 시퀀스를 생성 하려면 할 수 있습니다 초기값 시간 종속적의 각 새 인스턴스를 사용 하 여 다른 시리즈를 생성 하므로 <xref:System.Random>합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-136">To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>.</span></span> <span data-ttu-id="c1050-137">매개 변수가 있는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자 가져올 수 있습니다는 <xref:System.Int32> 값 틱 수에에서 따른 현재 반면 매개 변수가 없는 <xref:System.Random.%23ctor> 생성자 시스템 시계를 사용 하 여 시드 값을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-137">The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value.</span></span> <span data-ttu-id="c1050-138">그러나 시계 확인에는 한계가 있으므로 사용 하 여 매개 변수가 없는 생성자를 만들 다른 <xref:System.Random> 개체 닫기 연속 해 서에서 동일한 시퀀스로 난수를 생성 하는 난수 생성기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-138">However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers.</span></span> <span data-ttu-id="c1050-139">다음 예제에서는 두 <xref:System.Random> 연속적으로 인스턴스화된 개체는 동일한 일련의 임의 숫자를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-139">The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers.</span></span> <span data-ttu-id="c1050-140">대부분의 Windows 시스템에서 <xref:System.Random> 서로 15 시간 (밀리초) 내에서 만든 개체는 동일한 초기값을 갖고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-140">On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.</span></span>  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 <span data-ttu-id="c1050-141">이 문제를 방지 하려면 만드는 단일 <xref:System.Random> 여러 개체 대신 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-141">To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.</span></span>  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a><span data-ttu-id="c1050-142">여러 인스턴스화를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-142">Avoiding multiple instantiations</span></span>  
 <span data-ttu-id="c1050-143">두 개의 난수 생성기 빽빽한 루프에서 또는 빠르게 연속적으로 초기화 난수 동일한 시퀀스를 생성할 수 있는 두 임의의 수 생성기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-143">Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</span></span> <span data-ttu-id="c1050-144">대부분의 경우에서이 개발자의 의도 아니며 인스턴스화하고 난수 생성기를 초기화 하는 비교적 비용이 많이 드는 프로세스 이므로 성능 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-144">In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</span></span>  
  
 <span data-ttu-id="c1050-145">성능 향상을 위해을 모두 동일한 숫자 시퀀스를 생성 하는 별도 임의의 수 생성기를 실수로 만들지를 하나 만든 것이 좋습니다 <xref:System.Random> 개체를 만드는 대신 시간이 지남에 따라 여러 난수를 생성 합니다. 새 <xref:System.Random> 하나 난수를 생성 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-145">Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.</span></span>  
  
 <span data-ttu-id="c1050-146">그러나는 <xref:System.Random> 클래스에는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-146">However, the <xref:System.Random> class isn't thread safe.</span></span> <span data-ttu-id="c1050-147">호출 하는 경우 <xref:System.Random> 여러 스레드에서 메서드는 다음 섹션에서 설명한 지침을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-147">If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.</span></span>  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a><span data-ttu-id="c1050-148">System.Random 클래스와 스레드 안전성</span><span class="sxs-lookup"><span data-stu-id="c1050-148">The System.Random class and thread safety</span></span>  
 <span data-ttu-id="c1050-149">개별 인스턴스화하는 대신 <xref:System.Random> 개체를 단일 만들어야 하는 것이 좋습니다 <xref:System.Random> 인스턴스를 응용 프로그램에 필요한 모든 임의의 숫자를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-149">Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app.</span></span> <span data-ttu-id="c1050-150">그러나 <xref:System.Random> 개체는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-150">However, <xref:System.Random> objects are not thread safe.</span></span> <span data-ttu-id="c1050-151">앱을 호출 하는 경우 <xref:System.Random> 여러 스레드에서 메서드를 한 번에 하나의 스레드만 난수 생성기를 액세스할 수 있는지 확인 하려면 동기화 개체를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-151">If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</span></span> <span data-ttu-id="c1050-152">되도록 없는 경우는 <xref:System.Random> 스레드로부터 안전한 방식으로 액세스 합니다, 난수를 반환 하는 메서드를 호출 하는 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-152">If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</span></span>  
  
 <span data-ttu-id="c1050-153">다음 예제에서는 C# [lock 문](~/docs/csharp/language-reference/keywords/lock-statement.md) 및 Visual Basic [SyncLock 문](~/docs/visual-basic/language-reference/statements/synclock-statement.md) 스레드로부터 안전한 방식으로 단일 난수 생성기 11 스레드에서 액세스할 수 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-153">The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</span></span> <span data-ttu-id="c1050-154">각 스레드 2 백만 난수 생성, 난수 생성의 수를 계산 하 고 해당 합계를 계산 및 실행 완료 되 면 모든 스레드에 대 한 합계를 업데이트 한 다음</span><span class="sxs-lookup"><span data-stu-id="c1050-154">Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</span></span>  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 <span data-ttu-id="c1050-155">이 예제에서는 다음과 같은 방법으로 스레드로부터의 안전성을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-155">The example ensures thread-safety in the following ways:</span></span>  
  
-   <span data-ttu-id="c1050-156"><xref:System.ThreadStaticAttribute> 특성 총 난수를 생성 하 고 각 스레드에 대 한 합계를 추적 하는 스레드 지역 변수를 정의 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-156">The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</span></span>  
  
-   <span data-ttu-id="c1050-157">잠금 (합니다 `lock` C#의 문은 및 `SyncLock` Visual Basic의 문) 모든 스레드에서 생성 된 모든 임의 숫자의 합을 총 변수에 대 한 액세스를 보호 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-157">A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</span></span>  
  
-   <span data-ttu-id="c1050-158">세마포 (합니다 <xref:System.Threading.CountdownEvent> 개체)를 사용 하는 다른 모든 스레드가 될 때까지 주 스레드 차단 실행이 완료를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-158">A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.</span></span>  
  
-   <span data-ttu-id="c1050-159">이 예제에서는 난수 생성기 난수 생성 메서드를 두 번 연속 호출 0을 반환 하는지 여부를 확인 하 여 손상 되었습니다 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-159">The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</span></span> <span data-ttu-id="c1050-160">예제에서는 손상이 발견 되는 경우는 <xref:System.Threading.CancellationTokenSource> 모든 스레드를 취소 해야 한다는 신호를 보낼 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-160">If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.</span></span>  
  
-   <span data-ttu-id="c1050-161">각 난수를 생성 하기 전에 각 스레드는 상태를 확인 합니다 <xref:System.Threading.CancellationToken> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-161">Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object.</span></span> <span data-ttu-id="c1050-162">이 예제에서는 호출에 취소가 요청 된 경우는 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 스레드를 취소 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-162">If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method to cancel the thread.</span></span>  
  
 <span data-ttu-id="c1050-163">다음 예에서는 동일 하면 첫 번째 사용 한다는 점을 제외 하 고는 <xref:System.Threading.Tasks.Task> 개체 및 대신 람다 식을 <xref:System.Threading.Thread> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-163">The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.</span></span>  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 <span data-ttu-id="c1050-164">다음과 같은 방법으로 첫 번째 예제에서 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-164">It differs from the first example in the following ways:</span></span>  
  
-   <span data-ttu-id="c1050-165">난수 생성의 수 및 각 작업의 합계를 추적 하는 변수에 로컬인 작업을 사용 하지 않아도 되므로 <xref:System.ThreadStaticAttribute> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-165">The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="c1050-166">정적 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 메서드를 사용 하는 주 스레드에서 모든 작업을 완료 되기 전에 완료 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-166">The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method is used to ensure that the main thread doesn't complete before all tasks have finished.</span></span> <span data-ttu-id="c1050-167">에 대 한 필요가 없습니다를 <xref:System.Threading.CountdownEvent> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-167">There is no need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
-   <span data-ttu-id="c1050-168">작업 취소를 결과로 생성 되는 예외에 표시 되는 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-168">The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c1050-169">이전 예제에서는 각 스레드에 의해 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-169">In the previous example, it is handled by each thread.</span></span>  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a><span data-ttu-id="c1050-170">다양 한 유형의 난수를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-170">Generating different types of random numbers</span></span>  
 <span data-ttu-id="c1050-171">난수 생성기의 다음과 같은 유형의 난수를 생성할 수 있도록 하는 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-171">The random number generator provides methods that let you generate the following kinds of random numbers:</span></span>  
  
-   <span data-ttu-id="c1050-172">일련의 <xref:System.Byte> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-172">A series of <xref:System.Byte> values.</span></span> <span data-ttu-id="c1050-173">요소를 반환 하려면 메서드를 원하는 수로 초기화 하는 배열을 전달 하 여 바이트 값의 수를 결정 합니다 <xref:System.Random.NextBytes%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-173">You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method.</span></span> <span data-ttu-id="c1050-174">다음 예제에서는 20 바이트를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-174">The following example generates 20 bytes.</span></span>  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   <span data-ttu-id="c1050-175">단일 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-175">A single integer.</span></span> <span data-ttu-id="c1050-176">0에서 최대값 사이의 정수 것인지를 선택할 수 있습니다 (<xref:System.Int32.MaxValue?displayProperty=nameWithType> -1)를 호출 하 여 합니다 <xref:System.Random.Next> 메서드를 호출 하 여 특정 값을 0 사이의 정수를 <xref:System.Random.Next%28System.Int32%29> 메서드나 를호출하여값의범위내정수<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-176">You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="c1050-177">매개 변수가 있는 오버 로드를 지정 된 최대 값은 없습니다. 즉, 생성 된 실제 최대 개수는 하나에 지정 된 값 미만입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-177">In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</span></span>  
  
     <span data-ttu-id="c1050-178">다음 예제에서는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 10으로-10에서 10 사이의 난수를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-178">The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10.</span></span> <span data-ttu-id="c1050-179">메서드에 두 번째 인수는 난수의 상한 메서드에서 반환 된 난수 값의 범위 지정 하는지 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-179">Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</span></span> <span data-ttu-id="c1050-180">즉, 하나는 메서드를 반환할 수 있는 가장 큰 정수 보다 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-180">In other words, the largest integer that the method can return is one less than this value.</span></span>  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <span data-ttu-id="c1050-181">단일 부동 소수점 값 0.0에서으로 호출 하 여 1.0 보다 작은 <xref:System.Random.NextDouble%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-181">A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="c1050-182">난수 메서드에서 반환 되는 난수의 상한 1 이므로 실제 상한 0.99999999999999978 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-182">The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</span></span> <span data-ttu-id="c1050-183">다음 예제에서는 10 개의 부동 소수점 난수를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-183">The following example generates 10 random floating-point numbers.</span></span>  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="c1050-184"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 사용 하면 반환 되는 난수의 범위를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-184">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number.</span></span> <span data-ttu-id="c1050-185">그러나는 `maxValue` 상위 범위 반환 번호를 지정 하는 매개 변수는 배타적을 포함 하지 않습니다는, 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-185">However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="c1050-186">즉, 메서드 호출 `Next(0, 100)` 0에서 99 사이의 및 not between 0과 100 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-186">This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.</span></span>  
  
 <span data-ttu-id="c1050-187">사용할 수도 있습니다는 <xref:System.Random> 생성 등의 작업에 대 한 클래스 [임의 T:System.Boolean 값](#Boolean)생성, [0 ~ 1 이외의 범위를 사용 하 여 임의의 부동 소수점 값](#Floats), 생성 [임의 64 비트 정수의](#Long), 및 [배열 또는 컬렉션에서 고유 요소를 무작위로 검색](#UniqueArray)합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-187">You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray).</span></span> <span data-ttu-id="c1050-188">이러한 및 다른 일반적인 작업에 대 한 참조를 [를 System.Random 사용 방법...](#Operations)</span><span class="sxs-lookup"><span data-stu-id="c1050-188">For these and other common tasks, see the [How do you use System.Random to…](#Operations)</span></span> <span data-ttu-id="c1050-189">섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-189">section.</span></span>  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a><span data-ttu-id="c1050-190">사용자 고유의 알고리즘을 대체</span><span class="sxs-lookup"><span data-stu-id="c1050-190">Substituting your own algorithm</span></span>  
 <span data-ttu-id="c1050-191">상속 하 여 고유한 난수 생성기를 구현할 수 있습니다는 <xref:System.Random> 클래스 및 사용자 난수 생성 알고리즘을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-191">You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm.</span></span> <span data-ttu-id="c1050-192">사용자 고유의 알고리즘을 제공 하려면 재정의 해야 합니다 <xref:System.Random.Sample%2A> 는 난수 생성 알고리즘을 구현 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-192">To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm.</span></span> <span data-ttu-id="c1050-193">또한 재정의 해야 합니다 <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, 및 <xref:System.Random.NextBytes%2A> 재정의 된 호출을 확인 하는 방법 <xref:System.Random.Sample%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-193">You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method.</span></span> <span data-ttu-id="c1050-194">재정의할 필요가 합니다 <xref:System.Random.Next%28System.Int32%29> 고 <xref:System.Random.NextDouble%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-194">You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.</span></span>  
  
 <span data-ttu-id="c1050-195">파생 되는 예는 <xref:System.Random> 클래스 및 해당 기본 의사 (pseudo) 난수 생성기를 수정 합니다. 참조는 <xref:System.Random.Sample%2A> 참조 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-195">For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.</span></span>  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a><span data-ttu-id="c1050-196">System.Random를 어떻게 사용 하는 중...</span><span class="sxs-lookup"><span data-stu-id="c1050-196">How do you use System.Random to…</span></span>  
 <span data-ttu-id="c1050-197">다음 섹션에 설명 하 고 일부의 응용 프로그램에서 난수를 사용 하려는 방법에 대 한 샘플 코드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-197">The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</span></span>  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a><span data-ttu-id="c1050-198">난수 값의 순서를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-198">Retrieve the same sequence of random values</span></span>  
 <span data-ttu-id="c1050-199">소프트웨어 테스트 시나리오에서 게임 플레이 동일한 시퀀스의 임의 숫자를 생성 하려는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-199">Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</span></span> <span data-ttu-id="c1050-200">임의의 숫자의 순서를 사용 하 여 테스트를 재발을 감지 하 여 버그 수정 확인 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-200">Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</span></span> <span data-ttu-id="c1050-201">임의의 수의 동일한 시퀀스가 게임에서 사용 하 여 이전 게임을 재생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-201">Using the same sequence of random number in games allows you to replay previous games.</span></span>  
  
 <span data-ttu-id="c1050-202">동일한 초기값을 제공 하 여 동일한 난수 시퀀스를 생성할 수 있습니다는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-202">You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="c1050-203">초기값을 의사 (pseudo) 난수 생성 알고리즘에 대 한 시작 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-203">The seed value provides a starting value for the pseudo-random number generation algorithm.</span></span> <span data-ttu-id="c1050-204">다음 예제를 사용 하 여 100100 임의 시드 값으로 인스턴스화하는 <xref:System.Random> 개체 20 개의 임의 부동 소수점 값을 표시 하 고 시드 값을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-204">The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value.</span></span> <span data-ttu-id="c1050-205">이 다음 시드 값을 복원, 새 난수 생성기를 인스턴스화하고 20 같은 임의의 부동 소수점 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-205">It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</span></span>  <span data-ttu-id="c1050-206">Note는 다른 버전의.NET Framework에서 실행 하는 경우 예제에서는 여러 가지 임의의 숫자 시퀀스를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-206">Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</span></span>  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a><span data-ttu-id="c1050-207">고유한 난수 시퀀스를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-207">Retrieve unique sequences of random numbers</span></span>  
 <span data-ttu-id="c1050-208">인스턴스의 다른 시드 값을 제공 하는 <xref:System.Random> 클래스 값의 서로 다른 시퀀스를 생성 하기 위해 각 난수 생성기를 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-208">Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values.</span></span> <span data-ttu-id="c1050-209">초기값을 호출 하 여 명시적으로 제공할 수 있습니다는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자를 암시적으로 호출 하 여를 <xref:System.Random.%23ctor> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-209">You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor.</span></span> <span data-ttu-id="c1050-210">대부분의 개발자는 시스템 클록을 사용 하는 매개 변수가 없는 생성자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-210">Most developers call the parameterless constructor, which uses the system clock.</span></span> <span data-ttu-id="c1050-211">다음 예제에서는이 방법을 사용 하 여 두 인스턴스화할 <xref:System.Random> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="c1050-211">The following example uses this approach to instantiate two <xref:System.Random> instances.</span></span> <span data-ttu-id="c1050-212">각 인스턴스는 일련의 10 임의의 정수를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-212">Each instance displays a series of 10 random integers.</span></span>  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 <span data-ttu-id="c1050-213">그러나 해당 유한 확인으로 인해 시스템 클록은 약 15 밀리초 미만 시간 차이 검색 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-213">However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</span></span> <span data-ttu-id="c1050-214">따라서 코드를 호출 하는 경우는 <xref:System.Random.%23ctor> 오버 로드 두 인스턴스화를 <xref:System.Random> 개체를 연속으로 동일한 초기값을 사용 하 여 개체를 제공 의도치 않게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-214">Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values.</span></span> <span data-ttu-id="c1050-215">이 이전 예제에서 확인 하려면 주석으로 처리 된 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드 호출에서 컴파일 및 다시 실행 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-215">To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method call, and compile and run the example again.</span></span>  
  
 <span data-ttu-id="c1050-216">이를 방지 하려면 단일 인스턴스화하고 권장 <xref:System.Random> 여러 세션 대신 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-216">To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones.</span></span> <span data-ttu-id="c1050-217">그러나 <xref:System.Random> 스레드로부터 안전 하 게 액세스 하는 경우에 몇 가지 동기화 장치를 사용 해야 합니다는 <xref:System.Random> 인스턴스 여러 스레드에서; 자세한 내용은 [은 임의 클래스와 스레드 안전성](#ThreadSafety) 이 이전 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-217">However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic.</span></span> <span data-ttu-id="c1050-218">와 같은 지연 메커니즘을 사용할 수는 또는 <xref:System.Threading.Thread.Sleep%2A> 인스턴스화를 15 개 이상의 밀리초 간격 발생 하는 이전 예에서 사용 된 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-218">Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</span></span>  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a><span data-ttu-id="c1050-219">지정된 된 범위에 있는 정수를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-219">Retrieve integers in a specified range</span></span>  
 <span data-ttu-id="c1050-220">호출 하 여 지정된 된 범위에 있는 정수를 검색할 수 있습니다는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 아래와 난수 생성기를 반환 하 고 싶은 숫자의 상한을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-220">You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</span></span> <span data-ttu-id="c1050-221">상한값은 배타적을 포함 하지 않습니다는, 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-221">The upper bound is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="c1050-222">즉,이 메서드에 의해 반환 되는 값의 범위에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-222">That is, it isn't included in the range of values returned by the method.</span></span> <span data-ttu-id="c1050-223">다음 예제에서는이 메서드를 사용 하 여-10에서 10 사이의 임의의 정수를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-223">The following example uses this method to generate random integers between -10 and 10.</span></span> <span data-ttu-id="c1050-224">참고 11을 지정 하는지, 값으로 원하는 값 보다 1의 `maxValue` 메서드 호출의 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-224">Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.</span></span>  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a><span data-ttu-id="c1050-225">지정 된 자릿수를 사용 하 여 정수를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-225">Retrieve integers with a specified number of digits</span></span>  
 <span data-ttu-id="c1050-226">호출할 수 있습니다는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드는 지정 된 자릿수를 사용 하 여 번호를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-226">You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits.</span></span> <span data-ttu-id="c1050-227">예를 들어, 4 자리 (즉, 1000에서 9999 범위의 숫자)를 사용 하 여 숫자를 검색 하려면 호출을 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 `minValue` 값 1000 및 `maxValue` 값이 다음 예제와 같이 10000입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-227">For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.</span></span>  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a><span data-ttu-id="c1050-228">지정된 된 범위에서 부동 소수점 값을 검색</span><span class="sxs-lookup"><span data-stu-id="c1050-228">Retrieve floating-point values in a specified range</span></span>  
 <span data-ttu-id="c1050-229"><xref:System.Random.NextDouble%2A> 메서드 돌아갑니다 임의의 부동 소수점 값 범위 0에서 1 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-229">The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1.</span></span> <span data-ttu-id="c1050-230">그러나에서는 몇 가지 다른 범위에서 임의의 값을 생성 하려는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-230">However, you'll often want to generate random values in some other range.</span></span>  
  
 <span data-ttu-id="c1050-231">최소 및 최대 원하는 값 간의 간격을 1 인 경우에서 반환 된 숫자에 원하는 시작 간격에서 0 사이의 차이 추가할 수 있습니다는 <xref:System.Random.NextDouble%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-231">If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="c1050-232">다음 예제에서는 10으로 0에서 1 사이의 난수를 생성 하려면이 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-232">The following example does this to generate 10 random numbers between -1 and 0.</span></span>  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 <span data-ttu-id="c1050-233">부동 소수점 난수를 생성 된 하 한은 0 하지만 상한 값이 1 보다 큰 (또는 음수의 경우 해당 하한값은-1 보다 작은 상한 값은 0), 0이 아닌 바인딩으로 임의 숫자를 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-233">To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</span></span> <span data-ttu-id="c1050-234">다음 예제와 20 백만 부동 소수점 난수를 생성 하려면 해당 범위에는 0에서 <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-234">The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1050-235">에 메서드에 의해 생성 된 난수 값의 분포를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-235">In also displays the distribution of the random values generated by the method.</span></span>  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 <span data-ttu-id="c1050-236">같은 임의의 두 값 사이의 부동 소수점 난수를 생성 하려면는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 정수에 대 한 메서드는, 다음 수식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-236">To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:</span></span>  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 <span data-ttu-id="c1050-237">다음 예제에서는 11.0으로 범위를 보이는 난수 1 백만 10.0에서 생성 하 고 해당 배포를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-237">The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</span></span>  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a><span data-ttu-id="c1050-238">임의의 부울 값을 생성</span><span class="sxs-lookup"><span data-stu-id="c1050-238">Generate random Boolean values</span></span>  
 <span data-ttu-id="c1050-239">합니다 <xref:System.Random> 클래스를 생성 하는 메서드를 제공 하지 않습니다 <xref:System.Boolean> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-239">The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values.</span></span> <span data-ttu-id="c1050-240">그러나 사용자 고유의 클래스 또는 작업을 수행 하는 메서드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-240">However, you can define your own class or method to do that.</span></span> <span data-ttu-id="c1050-241">다음 예제에서는 클래스를 정의 `BooleanGenerator`, 단일 메서드를 사용 하 여 `NextBoolean`입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-241">The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`.</span></span> <span data-ttu-id="c1050-242">합니다 `BooleanGenerator` 저장소 클래스는 <xref:System.Random> 개인 변수는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-242">The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable.</span></span> <span data-ttu-id="c1050-243">합니다 `NextBoolean` 메서드 호출을 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드 결과를 전달 하 고는 <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-243">The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c1050-244">참고는 난수의 상한 값을 지정 하려면 2를 인수로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-244">Note that 2 is used as the argument to specify the upper bound of the random number.</span></span> <span data-ttu-id="c1050-245">전용 값을 이므로 메서드 호출 0 또는 1을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-245">Since this is an exclusive value, the method call returns either 0 or 1.</span></span>  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 <span data-ttu-id="c1050-246">난수를 생성 하는 별도 클래스를 만드는 대신 <xref:System.Boolean> 값을이 예제에서는 단일 메서드 정의 하기만 하면 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-246">Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method.</span></span> <span data-ttu-id="c1050-247">그러나 경우에는 <xref:System.Random> 개체는 새 인스턴스화를 방지 하려면 클래스 수준의 변수로 정의 해야 <xref:System.Random> 각 메서드 호출의 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="c1050-247">In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call.</span></span> <span data-ttu-id="c1050-248">Visual basic에서는 Random 인스턴스에서으로 정의할 수 있습니다는 [정적](~/docs/visual-basic/language-reference/modifiers/static.md) 변수에 `NextBoolean` 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-248">In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.</span></span>  <span data-ttu-id="c1050-249">다음 예제에서는 구현을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-249">The following example provides an implementation.</span></span>  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a><span data-ttu-id="c1050-250">임의의 64 비트 정수를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-250">Generate random 64-bit integers</span></span>  
 <span data-ttu-id="c1050-251">오버 로드는 <xref:System.Random.Next%2A> 메서드 32 비트 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-251">The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers.</span></span> <span data-ttu-id="c1050-252">그러나 경우에 따라 64 비트 정수를 사용 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-252">However, in some cases, you might want to work with 64-bit integers.</span></span> <span data-ttu-id="c1050-253">이 작업은 다음과 같이 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-253">You can do this as follows:</span></span>  
  
1.  <span data-ttu-id="c1050-254">호출 된 <xref:System.Random.NextDouble%2A> 메서드를 배정밀도 부동 소수점 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-254">Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.</span></span>  
  
2.  <span data-ttu-id="c1050-255">해당 값에 곱할 <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-255">Multiply that value by <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c1050-256">다음 예제에서는이 방법을 사용 하 여 20 백만 임의 정수 (long)를 생성 및 10 동일한 그룹에이 분류 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-256">The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</span></span> <span data-ttu-id="c1050-257">그런 다음 0에서 각 그룹의 수를 계산 하 여 난수 분포를 계산 <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-257">It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1050-258">예제의 출력에서 볼 수 있듯이 숫자의 정수 (long) 범위를 통해 더 많거나 적은 동일 하 게 분산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-258">As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</span></span>  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 <span data-ttu-id="c1050-259">사용 하 여 비트 조작 하는 다른 기술에서 진정한 난수를 생성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-259">An alternative technique that uses bit manipulation does not generate truly random numbers.</span></span> <span data-ttu-id="c1050-260">이 기술은 호출 <xref:System.Random.Next> 정수 두 개를 왼쪽으로 이동 1에서 32 비트 및 ORs 생성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-260">This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together.</span></span> <span data-ttu-id="c1050-261">이 기술에는 두 가지 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-261">This technique has two limitations:</span></span>  
  
1.  <span data-ttu-id="c1050-262">31 비트의 부호 비트 이기 때문에 결과 정수 (long)의 31 비트의 값은 항상 0입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-262">Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</span></span>  <span data-ttu-id="c1050-263">31 비트 or 연산 하 고 임의 0 또는 1에 왼쪽 시프트 것을 생성 하 여이 문제를 해결할 수 있습니다 원래 임의 정수 (long)를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-263">This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</span></span>  
  
2.  <span data-ttu-id="c1050-264">더 심각 하 게 되므로 확률 값을 반환한 <xref:System.Random.Next> 값은 0, 0x0 0x00000000FFFFFFFF 범위에 있는 경우에 몇 가지 임의의 숫자 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-264">More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</span></span>  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a><span data-ttu-id="c1050-265">지정 된 범위의 바이트를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-265">Retrieve bytes in a specified range</span></span>  
 <span data-ttu-id="c1050-266">오버 로드 된 <xref:System.Random.Next%2A> 메서드를 사용 하면 임의의 숫자의 범위를 지정 하지만 <xref:System.Random.NextBytes%2A> 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-266">The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not.</span></span> <span data-ttu-id="c1050-267">다음 예제에서는 구현 하는 `NextBytes` 메서드는 반환 된 바이트 범위를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-267">The following example implements a `NextBytes` method that lets you specify the range of the returned bytes.</span></span> <span data-ttu-id="c1050-268">정의 된 `Random2` 에서 파생 된 클래스 <xref:System.Random> 오버 로드 하 고 해당 `NextBytes` 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-268">It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.</span></span>  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 <span data-ttu-id="c1050-269">합니다 `NextBytes(Byte[], Byte, Byte)` 메서드 호출을 래핑한는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드 최 솟 값 및 최 댓 값 보다 큰 하나 지정 (이 경우 0과 101) 바이트 배열에서 반환 한다고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-269">The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</span></span> <span data-ttu-id="c1050-270">정수 값으로 반환 되도록 해야 하기 때문에 합니다 <xref:System.Random.Next%2A> 메서드 범위 내에 <xref:System.Byte> 데이터 형식에서는 수 안전 하 게 캐스팅 하 (C#) 또는 변환 (Visual Basic)에서는 정수에서 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-270">Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</span></span>  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a><span data-ttu-id="c1050-271">배열 또는 컬렉션에서 요소를 무작위로 검색</span><span class="sxs-lookup"><span data-stu-id="c1050-271">Retrieve an element from an array or collection at random</span></span>  
 <span data-ttu-id="c1050-272">임의의 숫자 배열 또는 컬렉션에서 값을 검색할 인덱스와 많이 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-272">Random numbers often serve as indexes to retrieve values from arrays or collections.</span></span> <span data-ttu-id="c1050-273">임의 인덱스 값을 검색 하려면 호출할 수 있습니다 합니다 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 메서드를 사용 하 여 배열의 값으로 하한값 해당 `minValue` 인수와 값으로 배열 상한 보다 크지 하나 해당 `maxValue` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-273">To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument.</span></span> <span data-ttu-id="c1050-274">0부터 시작 하 여 배열에 대 한이 설정은 해당 <xref:System.Array.Length%2A> 속성 또는 반환 값 보다 큰 하나는 <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-274">For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c1050-275">다음 예제에서는 임의로 도시 배열을에서 미국의 도시 이름을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-275">The following example randomly retrieves the name of a city in the United States from an array of cities.</span></span>  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a><span data-ttu-id="c1050-276">배열 또는 컬렉션에서 고유 요소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-276">Retrieve a unique element from an array or collection</span></span>  
 <span data-ttu-id="c1050-277">난수 생성기를 중복 값을 반환할 항상 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-277">A random number generator can always return duplicate values.</span></span> <span data-ttu-id="c1050-278">숫자의 범위가 더 작은 또는 생성 된 값 수가 더 커지면으로 중복 가능성이 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-278">As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</span></span> <span data-ttu-id="c1050-279">임의 값은 고유 해야 합니다, 더 많은 성능이 더욱 저하 중복에 대 한 보정을 위해 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-279">If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</span></span>  
  
 <span data-ttu-id="c1050-280">이 시나리오를 처리 하는 방법의 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-280">There are a number of techniques to handle this scenario.</span></span> <span data-ttu-id="c1050-281">일반적인 솔루션 배열 또는 값을 검색할 수 있는 컬렉션 및 부동 소수점 난수를 포함 하는 병렬 배열 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-281">One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</span></span> <span data-ttu-id="c1050-282">첫 번째 배열 만들어진 시점에 임의의 숫자를 사용 하 여 두 번째 배열이 채워진 및 <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> 메서드를 사용 하는 병렬 배열에서 값을 사용 하 여 첫 번째 배열을 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-282">The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is used to sort the first array by using the values in the parallel array.</span></span>  
  
 <span data-ttu-id="c1050-283">예를 들어 카드놀이 게임을 개발 하는 경우 각 카드 한 번만 사용 되는지 확인 하려는 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-283">For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</span></span> <span data-ttu-id="c1050-284">카드를 해당 카드를 이미 처리 여부를 추적 하 고 검색할 난수를 생성 하는 대신 데크를 정렬 하는 난수의 병렬 배열을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-284">Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</span></span> <span data-ttu-id="c1050-285">데크는 정렬 된 후 앱 다음 카드 데크에 인덱스를 나타냅니다에 대 한 포인터를 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-285">Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</span></span>  
  
 <span data-ttu-id="c1050-286">다음 예제에서 이 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-286">The following example illustrates this approach.</span></span> <span data-ttu-id="c1050-287">정의 된 `Card` 플레잉 카드 및 나타내는 클래스 `Dealer` 섞으 카드 데크를 처리 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-287">It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards.</span></span> <span data-ttu-id="c1050-288">`Dealer` 클래스 생성자에는 두 개의 배열을 채웁니다:를 `deck` 클래스 범위에 있는 모든 카드 데크; 및 로컬을 나타내는 배열 `order` 만큼의 요소가 있는 배열은 `deck` 배열 및 채워집니다 임의로 생성 <xref:System.Double> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-288">The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.</span></span>  <span data-ttu-id="c1050-289"><xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> 메서드를 호출 정렬 하는 `deck` 의 값을 기반으로 하는 배열은 `order` 배열.</span><span class="sxs-lookup"><span data-stu-id="c1050-289">The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is then called to sort the `deck` array based on the values in the `order` array.</span></span>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="c1050-290">다음 예제에서는 단일 난수 생성기를 만들고 호출 해당 <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, 및 <xref:System.Random.NextDouble%2A> 서로 다른 범위 내의 난수 시퀀스를 생성 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-290">The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.</span></span>  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 <span data-ttu-id="c1050-291">다음 예제에서는 생성 한 인덱스로 사용 되는 임의의 정수를 배열에서 문자열 값을 검색 하려면.</span><span class="sxs-lookup"><span data-stu-id="c1050-291">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="c1050-292">.NET Framework 1.0 및 1.1에서 파생 된 클래스의 최소 구현을 <see cref="T:System.Random" /> 재정의 하는 데 필요한는 <see cref="M:System.Random.Sample" /> 난수를 생성 하는 것에 대 한 새롭거나 수정 된 알고리즘을 정의 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-292">In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers.</span></span> <span data-ttu-id="c1050-293">파생된 클래스의 기본 클래스 구현을 사용 합니다는 <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, 및 <see cref="M:System.Random.NextDouble" /> 파생된 클래스 구현을 호출 하는 방법의 <see cref="M:System.Random.Sample" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-293">The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span>  
  
<span data-ttu-id="c1050-294">.NET Framework 2.0 이상에서는의 동작에에서는 <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, 및 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드는 이러한 메서드는 파생된 클래스 구현을 호출 하지 않을 수 있도록 변경한는 <see cref="M:System.Random.Sample" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-294">In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span> <span data-ttu-id="c1050-295">클래스에서 파생 되는 결과적으로, <see cref="T:System.Random" /> .NET Framework 2.0을 대상으로 하 고 나중에 이러한 세 가지 방법을 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-295">As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</span></span></para></block>
    <block subset="none" type="usage"><para><span data-ttu-id="c1050-296">난수 생성기 구현의 <see cref="T:System.Random" /> 클래스는.NET Framework의 주 버전 간에 동일 하 게 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-296">The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework.</span></span> <span data-ttu-id="c1050-297">결과적으로, 동일한 초기값을 다른 버전의.NET Framework에서 동일한 의사 (pseudo) 난수 시퀀스 하면는 가정 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-297">As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</span></span></para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c1050-298"><see cref="T:System.Random" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-298">Initializes a new instance of the <see cref="T:System.Random" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c1050-299">시간에 따라 달라지는 시드 값을 사용하여 <see cref="T:System.Random" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-299">Initializes a new instance of the <see cref="T:System.Random" /> class, using a time-dependent default seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1050-300">기본 시드 값은 시스템 클록에서 파생 되며 확인에는 한계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-300">The default seed value is derived from the system clock and has finite resolution.</span></span> <span data-ttu-id="c1050-301">결과적으로 다른 <xref:System.Random> 기본 생성자를 호출 하 여 연속적으로에서 만든 개체에는 동일한 기본 시드 값 있고, 따라서 난수의 동일한 집합을 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-301">As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</span></span> <span data-ttu-id="c1050-302">단일을 사용 하 여이 문제를 방지할 수 있습니다 <xref:System.Random> 모든 난수를 생성 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-302">This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers.</span></span> <span data-ttu-id="c1050-303">시스템 클록에서 반환 된 시드 값을 수정 하 고 다음이 새 초기값을 명시적으로 제공 하 여 묶어 사용할 수도 있습니다는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-303">You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="c1050-304">자세한 내용은 참조는 <xref:System.Random.%23ctor%28System.Int32%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-304">For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="c1050-305">숫자의 임의 시퀀스를 생성 하 여 난수 생성기를 하려는 경우이 생성자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-305">Call this constructor if you want your random number generator to generate a random sequence of numbers.</span></span> <span data-ttu-id="c1050-306">고정된 될 다른 난수 생성기에 대해 동일한 난수 시퀀스를 생성 하려면 호출을 <xref:System.Random.%23ctor%28System.Int32%29> 고정된 초기값을 사용 하 여 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-306">To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value .</span></span> <span data-ttu-id="c1050-307">이 <xref:System.Random> 생성자 오버 로드는 임의의 숫자를 사용 하는 앱을 테스트 하는 경우에 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-307">This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.</span></span>  
  
 <span data-ttu-id="c1050-308">난수 생성기를 인스턴스화한 후 호출 개별 <xref:System.Random> 메서드를 같은 <xref:System.Random.Next> 또는 <xref:System.Random.NextDouble>, 난수를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-308">Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1050-309">다음 예제에서는 기본 생성자를 사용 하 여 3 개를 인스턴스화하기 위해 <xref:System.Random> 개체 및 각각에 대 한 5 개의 임의 정수 시퀀스를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-309">The following example uses the default constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each.</span></span> <span data-ttu-id="c1050-310">때문에 처음 두 <xref:System.Random> 개체 닫기 연속 해 서에서, 시스템 클록에 따라 동일한 시드 값을 사용 하 여 인스턴스화되는 만들어지고, 따라서 난수 동일한 시퀀스를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-310">Because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</span></span> <span data-ttu-id="c1050-311">반면, 세 번째의 기본 생성자 <xref:System.Random> 개체를 호출 하 여 일으킬 2 초 지연 후 호출 된 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-311">On the other hand, the default constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c1050-312">이 세 번째 다른 초기값을 생성 하므로 <xref:System.Random> 개체를 임의 숫자의 서로 다른 시퀀스를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-312">Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.</span></span>  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed"><span data-ttu-id="c1050-313">의사(pseudo) 난수 시퀀스의 시작 값을 계산하는 데 사용되는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-313">A number used to calculate a starting value for the pseudo-random number sequence.</span></span> <span data-ttu-id="c1050-314">음수를 지정하면 이 숫자의 절대 값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-314">If a negative number is specified, the absolute value of the number is used.</span></span></param>
        <summary><span data-ttu-id="c1050-315">지정된 시드 값을 사용하여 <see cref="T:System.Random" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-315">Initializes a new instance of the <see cref="T:System.Random" /> class, using the specified seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1050-316">다른 동일한 시드 값을 제공 <xref:System.Random> 개체 하면 각 인스턴스가 동일한 시퀀스 난수를 생성 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-316">Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers.</span></span> <span data-ttu-id="c1050-317">난수 생성기를 사용 하는 앱을 테스트 하는 경우에 자주 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-317">This is often done when testing apps that rely on random number generators.</span></span>  
  
 <span data-ttu-id="c1050-318">응용 프로그램에서 다른 난수 시퀀스에 필요한 경우 다른 초기값을 사용 하 여 반복적으로이 생성자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-318">If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</span></span> <span data-ttu-id="c1050-319">고유한 시드 값을 생성 하는 한 가지 방법은 해당 시간에 따라 달라 지도록 방법은입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-319">One way to produce a unique seed value is to make it time-dependent.</span></span> <span data-ttu-id="c1050-320">예를 들어 초기값으로 시스템 클록에서 파생 되는 <xref:System.Random.%23ctor> 오버 로드 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-320">For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does.</span></span> <span data-ttu-id="c1050-321">그러나 시스템 클록의 다른 초기값을 사용 하 여이 생성자의 여러 호출을 제공 하기에 충분 한 해상도 없을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-321">However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</span></span> <span data-ttu-id="c1050-322">처음 두에 나온 것 처럼이 인해 동일한 시퀀스의 의사 (pseudo) 난수를 생성 하는 난수 생성기의 <xref:System.Random> 다음 예제에서는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-322">This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example.</span></span> <span data-ttu-id="c1050-323">이 방지 하려면 각 호출 또는 호출에서 시드 값을 식별 하는 알고리즘을 적용 합니다 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드를 제공 하는 각 생성자는 다른 시드 값을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-323">To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to ensure that you provide each constructor with a different seed value.</span></span>  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 <span data-ttu-id="c1050-324">또 다른 옵션은 단일 인스턴스화할 <xref:System.Random> 응용 프로그램에서 모든 난수를 생성 하는 데 사용할 수 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-324">Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application.</span></span> <span data-ttu-id="c1050-325">이 상당히 듭니다 난수 생성기를 인스턴스화 하므로 성능이 약간 향상을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-325">This yields slightly better performance, since instantiating a random number generator is fairly expensive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1050-326">다음 예제에서는 <xref:System.Random> 초기값 매개 변수를 사용 하 고 임의 정수 및 double 값의 시퀀스를 생성 하는 클래스 생성자를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-326">The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</span></span> <span data-ttu-id="c1050-327">예제 순서가 생성 되는 때를 <xref:System.Random> 개체 생성자 및 초기값 매개 변수를 사용 하 여 다시 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-327">The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c1050-328">임의의 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-328">Returns a random integer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c1050-329">음수가 아닌 임의의 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-329">Returns a non-negative random integer.</span></span></summary>
        <returns><span data-ttu-id="c1050-330">0보다 크거나 같고 <see cref="F:System.Int32.MaxValue" />보다 작은 부호 있는 32비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-330">A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1050-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> 0에서 그 값의 범위가 난수를 생성 보다 작은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> generates a random number whose value ranges from 0 to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1050-332">난수 값 범위를 0에서 다른 양수 값을 생성 하려면 사용 된 <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-332">To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="c1050-333">다른 범위 내의 난수를 생성 하려면 사용 된 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-333">To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1050-334">다음 예에서는 호출을 반복된 합니다 <xref:System.Random.Next%2A> 특정 개수의 사용자가 요청한 난수를 생성 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-334">The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user.</span></span> <span data-ttu-id="c1050-335"><xref:System.Console.ReadLine%2A?displayProperty=nameWithType> 메서드는 고객 입력을 가져오는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-335">The <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> method is used to get customer input.</span></span>  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 <span data-ttu-id="c1050-336">다음 예제에서 클래스를 파생 <xref:System.Random> 에서 생성 하는 균일 분포에서 해당 배포와 다른 난수 시퀀스를 생성 하는 <xref:System.Random.Sample%2A> 기본 클래스의 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-336">The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span> <span data-ttu-id="c1050-337">재정의 <xref:System.Random.Sample%2A> 임의의 숫자와 재정의의 분포를 제공 하는 메서드는 <xref:System.Random.Next%2A?displayProperty=nameWithType> 일련의 임의 숫자를 사용 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-337">It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=nameWithType> method to use series of random numbers.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="c1050-338">클래스를 파생 하는 경우.NET Framework 버전 2.0부터 <see cref="T:System.Random" /> 시키고 합니다 <see cref="M:System.Random.Sample" /> 메서드를 파생된 클래스 구현에 의해 제공 된 분산이 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 구현 된 <see cref="M:System.Random.Next" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-338">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method.</span></span> <span data-ttu-id="c1050-339">균일 분포 기본 반환 하는 대신 <see cref="T:System.Random" /> 클래스가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-339">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="c1050-340">이 동작의 전반적인 성능이 개선 된 <see cref="T:System.Random" /> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-340">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="c1050-341">이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 파생된 클래스에서 메서드를 재정의 해야 합니다 <see cref="M:System.Random.Next" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-341">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue"><span data-ttu-id="c1050-342">생성될 난수의 상한(제외)입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-342">The exclusive upper bound of the random number to be generated.</span></span> <span data-ttu-id="c1050-343"><paramref name="maxValue" />는 0보다 크거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-343"><paramref name="maxValue" /> must be greater than or equal to 0.</span></span></param>
        <summary><span data-ttu-id="c1050-344">지정된 최댓값보다 작은 음수가 아닌 임의의 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-344">Returns a non-negative random integer that is less than the specified maximum.</span></span></summary>
        <returns><span data-ttu-id="c1050-345">0보다 크거나 같고 <paramref name="maxValue" />보다 작은 부호 있는 32비트 정수이므로 반환 값의 범위에는 대개 0이 포함되지만 <paramref name="maxValue" />는 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-345">A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />; that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="c1050-346">하지만 <paramref name="maxValue" />가 0과 같으면 <paramref name="maxValue" />가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-346">However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1050-347">합니다 <xref:System.Random.Next%28System.Int32%29> 오버 로드는 반환 난수의 범위 0 ~ `maxValue` -1입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-347">The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` - 1.</span></span> <span data-ttu-id="c1050-348">그러나 경우 `maxValue` 가 0 이면 메서드에서 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-348">However, if `maxValue` is 0, the method returns 0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1050-349">다음 예제에서는 다양 한 오버 로드를 사용 하 여 난수를 생성 합니다 <xref:System.Random.Next%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-349">The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.</span></span>  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 <span data-ttu-id="c1050-350">다음 예제에서는 생성 한 인덱스로 사용 되는 임의의 정수를 배열에서 문자열 값을 검색 하려면.</span><span class="sxs-lookup"><span data-stu-id="c1050-350">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="c1050-351">배열의 가장 높은 인덱스 하나 보다 작은 길이, 값 이므로 <xref:System.Array.Length%2A?displayProperty=nameWithType> 속성으로 제공 되는 `maxValue` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-351">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1050-352"><paramref name="maxValue" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="c1050-352"><paramref name="maxValue" /> is less than 0.</span></span></exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue"><span data-ttu-id="c1050-353">반환되는 난수의 하한(포함)입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-353">The inclusive lower bound of the random number returned.</span></span></param>
        <param name="maxValue"><span data-ttu-id="c1050-354">반환되는 난수의 상한(제외)입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-354">The exclusive upper bound of the random number returned.</span></span> <span data-ttu-id="c1050-355"><paramref name="maxValue" />는 <paramref name="minValue" />보다 크거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-355"><paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</span></span></param>
        <summary><span data-ttu-id="c1050-356">지정된 범위 내의 임의의 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-356">Returns a random integer that is within a specified range.</span></span></summary>
        <returns><span data-ttu-id="c1050-357"><paramref name="minValue" />보다 크거나 같고 <paramref name="maxValue" />보다 작은 부호 있는 32비트 정수이므로 반환 값의 범위에는 <paramref name="minValue" />가 포함되지만 <paramref name="maxValue" />는 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-357">A 32-bit signed integer greater than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />; that is, the range of return values includes <paramref name="minValue" /> but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="c1050-358"><paramref name="minValue" />가 <paramref name="maxValue" />와 같은 경우에는 <paramref name="minValue" />가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-358">If <paramref name="minValue" /> equals <paramref name="maxValue" />, <paramref name="minValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1050-359">합니다 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 오버 로드는 해당 범위에서 임의의 정수 반환 `minValue` 에 `maxValue` -1입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-359">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` - 1.</span></span> <span data-ttu-id="c1050-360">그러나 경우 `maxValue` equals `minValue`, 메서드가 반환 `minValue`합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-360">However, if `maxValue` equals `minValue`, the method returns `minValue`.</span></span>  
  
 <span data-ttu-id="c1050-361">다른 오버 로드와 달리는 <xref:System.Random.Next%2A> 만 음수가 아닌 값을 반환 하는 메서드를이 메서드는 음수 임의의 정수를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-361">Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1050-362">다음 예제에서는 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 세 개의 서로 다른 범위를 사용 하 여 난수를 생성 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-362">The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to generate random integers with three distinct ranges.</span></span> <span data-ttu-id="c1050-363">정확한 출력의 예제에서 전달 되는 시스템 제공 시드 값에 따라 달라 집니다는 <xref:System.Random> 클래스 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-363">Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.</span></span>  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 <span data-ttu-id="c1050-364">다음 예제에서는 생성 한 인덱스로 사용 되는 임의의 정수를 배열에서 문자열 값을 검색 하려면.</span><span class="sxs-lookup"><span data-stu-id="c1050-364">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="c1050-365">배열의 가장 높은 인덱스 하나 보다 작은 길이, 값 이므로 <xref:System.Array.Length%2A?displayProperty=nameWithType> 속성으로 제공 되는 `maxValue` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-365">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1050-366"><paramref name="minValue" />가 <paramref name="maxValue" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="c1050-366"><paramref name="minValue" /> is greater than <paramref name="maxValue" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="c1050-367">클래스를 파생 하는 경우.NET Framework 버전 2.0부터 <see cref="T:System.Random" /> 시키고 합니다 <see cref="M:System.Random.Sample" /> 메서드를 파생된 클래스 구현에 의해 제공 된 분산이 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 구현의 합니다 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 경우 메서드 오버 로드 간의 차이 <paramref name="minValue" /> 및 <paramref name="maxValue" /> 매개 변수 보다 크거나 <see cref="F:System.Int32.MaxValue" />합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-367">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />.</span></span> <span data-ttu-id="c1050-368">균일 분포 기본 반환 하는 대신 <see cref="T:System.Random" /> 클래스가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-368">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="c1050-369">이 동작의 전반적인 성능이 개선 된 <see cref="T:System.Random" /> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-369">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="c1050-370">이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 파생된 클래스에서 메서드를 재정의 해야 합니다 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-370">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="c1050-371">난수를 포함하는 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-371">An array of bytes to contain random numbers.</span></span></param>
        <summary><span data-ttu-id="c1050-372">지정된 바이트 배열의 요소를 난수로 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-372">Fills the elements of a specified array of bytes with random numbers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1050-373">0 보다 크거나 바이트 배열의 각 요소는 임의의 수로 설정 되어 보다 작거나 같음 <xref:System.Byte.MaxValue>합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-373">Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.</span></span>  
  
 <span data-ttu-id="c1050-374">예를 들어, 임의의 암호를 만드는 데 적합 한 암호화 보안된 난수를 생성 하려면 메서드를 같은 사용 <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-374">For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1050-375">다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Random.NextBytes%2A> 메서드를 임의 바이트 값으로 바이트 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-375">The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.</span></span>  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1050-376"><paramref name="buffer" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-376"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="c1050-377">클래스를 파생 하는 경우.NET Framework 버전 2.0부터 <see cref="T:System.Random" /> 시키고 합니다 <see cref="M:System.Random.Sample" /> 메서드를 파생된 클래스 구현에 의해 제공 된 분산이 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 구현 된 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-377">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span> <span data-ttu-id="c1050-378">균일 분포 기본 반환 하는 대신 <see cref="T:System.Random" /> 클래스가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-378">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="c1050-379">이 동작의 전반적인 성능이 개선 된 <see cref="T:System.Random" /> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-379">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="c1050-380">이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 파생된 클래스에서 메서드를 재정의 해야 합니다 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-380">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span></para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c1050-381">0.0보다 크거나 같고 1.0보다 작은 부동 소수점 난수입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-381">Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</span></span></summary>
        <returns><span data-ttu-id="c1050-382">0.0보다 크거나 같고 1.0보다 작은 배정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-382">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1050-383">이 메서드에서 반환 된 임의 수의 실제 상한을 0.99999999999999978 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-383">The actual upper bound of the random number returned by this method is 0.99999999999999978.</span></span>  
  
 <span data-ttu-id="c1050-384">0.0과 1.0 이외의 범위 내에서 임의의 부동 소수점 값을 검색할의 "지정된 된 범위에서 부동 소수점 값을 검색" 섹션을 참조 합니다 <xref:System.Random> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-384">To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <xref:System.Random> class topic.</span></span>  
  
 <span data-ttu-id="c1050-385">이 메서드는 공용 버전의 보호 된 메서드, <xref:System.Random.Sample%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-385">This method is the public version of the protected method, <xref:System.Random.Sample%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1050-386">다음 예제에서는 <xref:System.Random.NextDouble%2A> 임의 double 값의 시퀀스를 생성 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-386">The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 <span data-ttu-id="c1050-387">다음 예제에서는 <xref:System.Random.NextDouble%2A> 100 개의 난수를 생성 하는 메서드 번호 및 해당 빈도 분포를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-387">The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.</span></span>  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c1050-388">0.0과 1.0 사이의 임의의 부동 소수점 숫자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-388">Returns a random floating-point number between 0.0 and 1.0.</span></span></summary>
        <returns><span data-ttu-id="c1050-389">0.0보다 크거나 같고 1.0보다 작은 배정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-389">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1050-390">서로 다른 무작위 분포 또는 다른 임의의 수 생성기 원칙을 생성 하려면에서 클래스를 파생 합니다 <xref:System.Random> 클래스를 재정의 합니다 <xref:System.Random.Sample%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-390">To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c1050-391">합니다 <xref:System.Random.Sample%2A> 메서드는 `protected`, 즉, 내 에서만 액세스할 수 있는지를 <xref:System.Random> 클래스와 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-391">The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes.</span></span> <span data-ttu-id="c1050-392">0에서 1 사이의 난수를 생성 하는 <xref:System.Random> 인스턴스를 호출 합니다 <xref:System.Random.NextDouble%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c1050-392">To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1050-393">다음 예제에서 클래스를 파생 <xref:System.Random> 재정의 <xref:System.Random.Sample%2A> 난수 분포를 생성 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-393">The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers.</span></span> <span data-ttu-id="c1050-394">이 분포는 균일 분포에서 생성 된 다른는 <xref:System.Random.Sample%2A> 메서드의 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-394">This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="c1050-395">클래스를 파생 하는 경우.NET Framework 버전 2.0부터 <see cref="T:System.Random" /> 시키고 합니다 <see cref="M:System.Random.Sample" /> 메서드를 파생된 클래스 구현에 의해 제공 된 분산이 <see cref="M:System.Random.Sample" /> 메서드가 기본 클래스에 대 한 호출에서 사용 되지 않습니다 다음 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-395">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:</span></span> 
<span data-ttu-id="c1050-396">-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> 메서드</span><span class="sxs-lookup"><span data-stu-id="c1050-396">-   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span>  
  
<span data-ttu-id="c1050-397">-   <see cref="M:System.Random.Next" /> 메서드</span><span class="sxs-lookup"><span data-stu-id="c1050-397">-   The <see cref="M:System.Random.Next" /> method.</span></span>  
  
<span data-ttu-id="c1050-398">- <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 메서드인 경우 (<paramref name="maxValue" /> - <paramref name="minValue" />) 보다 크면 <see cref="F:System.Int32.MaxValue" />합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-398">-   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.</span></span>  
  
<span data-ttu-id="c1050-399">균일 분포는 기본 제공 하는 대신 <see cref="T:System.Random" /> 클래스가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-399">Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="c1050-400">이 동작의 전반적인 성능이 개선 된 <see cref="T:System.Random" /> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-400">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="c1050-401">구현을 호출 하도록이 동작을 수정 하는 <see cref="M:System.Random.Sample" /> 메서드는 파생된 클래스에서 재정의 해야 이러한 세 가지 멤버의 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-401">To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members.</span></span> <span data-ttu-id="c1050-402">예제에서는 그림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c1050-402">The example provides an illustration.</span></span></para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>