<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="141a68639e235f7a6395008619801a2c4a25aef8" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57915895" /></Metadata><TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="d73e6-101">항목의 형식은 <see cref="System.Span`1" />합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-101">The type of items in the <see cref="System.Span`1" />.</span></span></typeparam>
    <summary><span data-ttu-id="d73e6-102">인접한 임의의 메모리 영역에 대해 형식 및 메모리 안전 표현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-102">Provides a type- and memory-safe representation of a contiguous region of arbitrary memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

<span data-ttu-id="d73e6-103">`Span<T>` 는 관리형 힙이 아닌 스택에 할당되는 [ref 구조체](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types) 입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-103">`Span<T>` is a [ref struct](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types) that is allocated on the stack rather than on the managed heap.</span></span> <span data-ttu-id="d73e6-104">Ref 구조체 형식을 제한 하는 수준을 올릴 수 없습니다를 넣을 수 없습니다, 형식의 변수에 할당할 수 없는 관리 되는 힙에 하도록 많은 <xref:System.Object>, `dynamic` 임의의 인터페이스 형식에서 필드 일 수 없습니다 또는 참조 형식 있으며에서 사용할 수 없습니다 `await` 고 `yield` 경계입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-104">Ref struct types have a number of restrictions to ensure that they cannot be promoted to the managed heap, including that they can't be boxed, they can't be assigned to variables of type <xref:System.Object>, `dynamic` or to any interface type, they can't be fields in a reference type, and they can't be used across `await` and `yield` boundaries.</span></span> <span data-ttu-id="d73e6-105">또한 두 개의 메서드를 호출 <xref:System.Span%601.Equals(System.Object)> 하 고 <xref:System.Span%601.GetHashCode%2A>을 throw를 <xref:System.NotSupportedException>입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-105">In addition, calls to two methods, <xref:System.Span%601.Equals(System.Object)> and <xref:System.Span%601.GetHashCode%2A>, throw a <xref:System.NotSupportedException>.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="d73e6-106">스택 전용 형식 이므로 `Span<T>` 힙에 버퍼에 대 한 참조를 저장 해야 하는 많은 시나리오에 적합 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-106">Because it is a stack-only type, `Span<T>` is unsuitable for many scenarios that require storing references to buffers on the heap.</span></span> <span data-ttu-id="d73e6-107">이것이 asynchrous 메서드 호출을 수행 하는 루틴의 예를 들어 true입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-107">This is true, for example, of routines that make asynchrous method calls.</span></span> <span data-ttu-id="d73e6-108">이러한 시나리오에 대 한 무료 따르면 <xref:System.Memory%601?displayProperty=nameWithType> 고 <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-108">For such scenarios, you can use the complimentary <xref:System.Memory%601?displayProperty=nameWithType> and <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> types.</span></span>

<span data-ttu-id="d73e6-109">변경할 수 없는 또는 읽기 전용으로 구조를 나타내는 범위를 사용 하 여 <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-109">For spans that represent immutable or read-only structures, use <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>.</span></span>

## <a name="spant-and-memory"></a><span data-ttu-id="d73e6-110">범위\<T > 및 메모리</span><span class="sxs-lookup"><span data-stu-id="d73e6-110">Span\<T> and memory</span></span>

<span data-ttu-id="d73e6-111">`Span<T>` 연속 임의의 메모리 영역을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-111">A `Span<T>` represents a contiguous region of arbitrary memory.</span></span> <span data-ttu-id="d73e6-112">`Span<T>` 인스턴스는 배열의 요소나 배열의 일부를 포함 하는 데 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-112">A `Span<T>` instance is often used to hold the elements of an array or a portion of an array.</span></span> <span data-ttu-id="d73e6-113">그러나 배열 달리를 `Span<T>` 인스턴스는 기본 메모리 관리 되는 메모리를 가리킬 수 또는 메모리에서 관리 되는 스택.</span><span class="sxs-lookup"><span data-stu-id="d73e6-113">Unlike an array, however, a `Span<T>` instance can point to managed memory, native memory, or memory managed on the stack.</span></span> <span data-ttu-id="d73e6-114">다음 예제에서는 한 `Span<Byte>` 배열에서:</span><span class="sxs-lookup"><span data-stu-id="d73e6-114">The following example creates a `Span<Byte>` from an array:</span></span>

[!code-csharp[Creating a Span\<Byte> from an array](~/samples/snippets/csharp/api/system/span/program.cs#1)]
     
<span data-ttu-id="d73e6-115">다음 예제에서는 `Span<Byte>` 100 바이트의 네이티브 메모리에서:</span><span class="sxs-lookup"><span data-stu-id="d73e6-115">The following example creates a `Span<Byte>` from 100 bytes of native memory:</span></span>

[!code-csharp[Creating a Span\<Byte> from native memory](~/samples/snippets/csharp/api/system/span/program.cs#2)]

<span data-ttu-id="d73e6-116">다음 예제는 C# [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) 100 바이트의 스택 메모리를 할당 하는 키워드:</span><span class="sxs-lookup"><span data-stu-id="d73e6-116">The following example uses the C# [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) keyword to allocate 100 bytes of memory on the stack:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#3)]

<span data-ttu-id="d73e6-117">때문에 `Span<T>` 메모리의 메서드는 임의의 블록과 추상화 합니다 `Span<T>` 클래스 및 메서드를 `Span<T>` 매개 변수에서 작동 `Span<T>` 캡슐화 하는 메모리의 종류에 관계 없이 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-117">Because `Span<T>` is an abstraction over an arbitrary block of memory, methods of the `Span<T>` class and methods with `Span<T>` parameters operate on any `Span<T>` object regardless of the kind of memory it encapsulates.</span></span> <span data-ttu-id="d73e6-118">예를 들어, 각 범위를 초기화 하 고 다음 예제와 같이 단일 초기화 및 계산 방법으로 해당 요소의 합계를 변경할 수 있습니다를 계산 하는 코드의 개별 구역이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-118">For example, each of the separate sections of code that initialize the span and calculate the sum of its elements can be changed into single initialization and calculation methods, as the following example illustrates:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#4)]

## <a name="spant-and-arrays"></a><span data-ttu-id="d73e6-119">범위\<T > 및 배열</span><span class="sxs-lookup"><span data-stu-id="d73e6-119">Span\<T> and arrays</span></span>

<span data-ttu-id="d73e6-120">배열을 래핑하는 경우 `Span<T>` 의 예제에서와 마찬가지로 배열 전체를 래핑할 수 합니다 [범위\<T > 및 메모리](#spant-and-memory) 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-120">When it wraps an array, `Span<T>` can wrap an entire array, as it did in the examples in the [Span\<T> and memory](#spant-and-memory) section.</span></span> <span data-ttu-id="d73e6-121">조각화 지원 하므로 `Span<T>` 배열 내의 모든 연속 범위를 가리킬 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-121">Because it supports slicing, `Span<T>` can also point to any contiguous range within the array.</span></span>  

<span data-ttu-id="d73e6-122">다음 예제에서는 10 요소 정수 배열의 중간 다섯 개 요소의 조각을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-122">The following example creates a slice of the middle five elements of a 10-element integer array.</span></span> <span data-ttu-id="d73e6-123">코드 조각에서 각 정수 값을 두 배로 증가 하는 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-123">Note that the code doubles the values of each integer in the slice.</span></span> <span data-ttu-id="d73e6-124">출력에서 볼 수 있듯이 배열의 값 범위에서 변경한 내용이 반영 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-124">As the output shows, the changes made by the span are reflected in the values of the array.</span></span>

[!code-csharp[Creating a slice from a portion of a span](~/samples/snippets/csharp/api/system/span/slice/program.cs)]

## <a name="spant-and-slices"></a><span data-ttu-id="d73e6-125">범위\<T > 및 조각</span><span class="sxs-lookup"><span data-stu-id="d73e6-125">Span\<T> and slices</span></span>

<span data-ttu-id="d73e6-126">`Span<T>` 두 오버 로드를 포함 합니다 <xref:System.Span%601.Slice%2A> 조각이 지정된 된 인덱스에서 시작 하는 현재 범위에서 구성 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="d73e6-126">`Span<T>` includes two overloads of the <xref:System.Span%601.Slice%2A> method that form a slice out of the current span that starts at a specified index.</span></span> <span data-ttu-id="d73e6-127">따라서에서 해당 데이터를 처리 하는 `Span<T>` 최소 성능에 영향을 데이터 처리 파이프라인의 부분에서 필요에 따라 처리할 수 있는 논리 영역 집합으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-127">This makes it possible to treat the data in a `Span<T>` as a set of logical chunks that can be processed as needed by portions of a data processing pipeline with minimal performance impact.</span></span> <span data-ttu-id="d73e6-128">예를 들어 최신 서버 프로토콜은 종종 텍스트를 기반으로 하므로 문자열에서 부분 문자열을 조작이 특히 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-128">For example, since modern server protocols are often text-based, manipulation of strings and substrings is particularly important.</span></span> <span data-ttu-id="d73e6-129">에 <xref:System.String> 클래스의 주요 메서드 부분 문자열을 추출 하는 것에 대 한 <xref:System.String.Substring%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-129">In the <xref:System.String> class, the major method for extracting substrings is <xref:System.String.Substring%2A>.</span></span> <span data-ttu-id="d73e6-130">광범위 한 문자열 조작에 의존 하는 데이터 파이프라인에 대 한 용도 이후 몇 가지 성능 저하를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-130">For data pipelines that rely on extensive string manipulation, its use offers some performance penalties, since it:</span></span>

1. <span data-ttu-id="d73e6-131">부분 문자열을 저장할 새 문자열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-131">Creates a new string to hold the substring.</span></span>

2. <span data-ttu-id="d73e6-132">원래 문자열에서 문자의 하위 집합을 새 문자열을 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-132">Copies a subset of the characters from the original string to the new string.</span></span>

<span data-ttu-id="d73e6-133">이 할당 및 복사 작업 중 하나를 사용 하 여 제거할 수 있습니다 `Span<T>` 또는 <xref:System.ReadOnlySpan%601>다음 예제와 같이:</span><span class="sxs-lookup"><span data-stu-id="d73e6-133">This allocation and copy operation can be eliminated by using either `Span<T>` or <xref:System.ReadOnlySpan%601>, as the following example shows:</span></span>

[!code-csharp[Creating a slice from a substring](~/samples/snippets/csharp/api/system/span/slice2/program.cs)]


      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; array" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="d73e6-134"><see cref="T:System.Span`1" /> 개체를 만들 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-134">The array from which to create the <see cref="T:System.Span`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d73e6-135">지정된 배열 전체에 새로운 <see cref="T:System.Span`1" /> 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-135">Creates a new <see cref="T:System.Span`1" /> object over the entirety of a specified array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="d73e6-136">경우 `array` 됩니다 `null`,이 생성자를 반환을 `null` `Span<T>`합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-136">If `array` is `null`, this constructor returns a `null` `Span<T>`.</span></span>

      ]]></format>
        </remarks>
        <exception cref="T:System.TypeMismatchException"><span data-ttu-id="d73e6-137"><paramref name="T" />는 참조 형식이며, <paramref name="array" />는 <paramref name="T" /> 형식의 배열이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-137"><paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="d73e6-138">메모리에서 지정된 바이트 수의 시작 주소에 대한 포인터.</span><span class="sxs-lookup"><span data-stu-id="d73e6-138">A pointer to the starting address of a specified number of bytes in memory.</span></span></param>
        <param name="length"><span data-ttu-id="d73e6-139"><see cref="T:System.Span`1" />에 포함될 바이트 수 입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-139">The number of bytes to be included in the <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="d73e6-140">지정된 메모리 주소에서 시작하는 지정된 바이트 수로부터 새 <see cref="T:System.Span`1" /> 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-140">Creates a new <see cref="T:System.Span`1" /> object  from a specified number of bytes starting at a specified memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        This constructor should be used with care, since it creates arbitrarily typed `T`s from a `void*`-typed block of memory, and `length` is not checked. However, if the constructor succeeds in creating a new <xref:System.Span%601> object, all subsequent uses are correct.        

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d73e6-141"><paramref name="T" />는 참조 형식이거나 포인터를 포함하므로 관리되지 않는 메모리에 저장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-141"><paramref name="T" /> is a reference type or contains pointers and therefore cannot be stored in unmanaged memory.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d73e6-142"><paramref name="length" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-142"><paramref name="length" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="start" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="d73e6-143">소스 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-143">The source array.</span></span></param>
        <param name="start"><span data-ttu-id="d73e6-144">새 <see cref="T:System.Span`1" />에 포함할 첫 번째 요소의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-144">The index of the first element to include in the new <see cref="T:System.Span`1" />.</span></span></param>
        <param name="length"><span data-ttu-id="d73e6-145">새 <see cref="T:System.Span`1" />에 포함할 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-145">The number of elements to include in the new <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="d73e6-146">지정된 인덱스에서 시작하는 배열의 지정된 요소 수를 포함하는 새 <see cref="T:System.Span`1" /> 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-146">Creates a new <see cref="T:System.Span`1" /> object that includes a specified number of elements of an array starting at a specified index.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d73e6-147"><paramref name="array" />가 <see langword="null" />이지만, <paramref name="start" /> 또는 <paramref name="length" />는 0이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-147"><paramref name="array" /> is <see langword="null" />, but <paramref name="start" /> or <paramref name="length" /> is non-zero.</span></span>

<span data-ttu-id="d73e6-148">또는</span><span class="sxs-lookup"><span data-stu-id="d73e6-148">-or-</span></span>

<span data-ttu-id="d73e6-149"><paramref name="start" />가 배열의 범위 밖에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-149"><paramref name="start" /> is outside the bounds of the array.</span></span>

<span data-ttu-id="d73e6-150">또는</span><span class="sxs-lookup"><span data-stu-id="d73e6-150">-or-</span></span>

<span data-ttu-id="d73e6-151"><paramref name="start" /> 및 <paramref name="length" />가 배열의 요소 수를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-151"><paramref name="start" /> and <paramref name="length" /> exceeds the number of elements in the array.</span></span></exception>
        <exception cref="T:System.TypeMismatchException"><span data-ttu-id="d73e6-152"><paramref name="T" />는 참조 형식이며, <paramref name="array" />는 <paramref name="T" /> 형식의 배열이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-152"><paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="span.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d73e6-153">이 <see cref="T:System.Span`1" /> 개체의 콘텐츠를 지웁니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-153">Clears the contents of this <see cref="T:System.Span`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="d73e6-154">합니다 `Clear` 항목을 설정 하는 메서드는 <xref:System.Span%601> 기본값으로 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-154">The `Clear` method sets the items in the <xref:System.Span%601> object to their default values.</span></span> <span data-ttu-id="d73e6-155">항목을 제거 하지 않습니다는 <xref:System.Span%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-155">It does not remove items from the <xref:System.Span%601>.</span></span>  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="span.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="d73e6-156">대상 <see cref="System.Span`1" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-156">The destination <see cref="System.Span`1" /> object.</span></span></param>
        <summary><span data-ttu-id="d73e6-157">이 <see cref="System.Span`1" />의 콘텐츠를 대상 <see cref="System.Span`1" />로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-157">Copies the contents of this <see cref="System.Span`1" /> into a destination <see cref="System.Span`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="d73e6-158">이 메서드는 모두 복사 `source` 에 `destination` 경우에 `source` 및 `destination` 겹칩니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-158">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d73e6-159"><paramref name="destination" />이 원본 <see cref="System.Span`1" />보다 짧습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-159"><paramref name="destination" /> is shorter than the source <see cref="System.Span`1" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d73e6-160">빈 <see cref="T:System.Span`1" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-160">Returns an empty <see cref="T:System.Span`1" /> object.</span></span></summary>
        <value><span data-ttu-id="d73e6-161">빈 <see cref="T:System.Span`1" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-161">An empty <see cref="T:System.Span`1" /> object.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="span.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="d73e6-162">지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-162">Not supported.</span></span></param>
        <summary><span data-ttu-id="d73e6-163">이 메서드의 호출은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-163">Calls to this method are not supported.</span></span></summary>
        <returns><span data-ttu-id="d73e6-164">이 메서드의 호출은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-164">Calls to this method are not supported.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="d73e6-165">에 대 한 호출을 <xref:System.Span%601.Equals%2A> 메서드가 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-165">Calls to the <xref:System.Span%601.Equals%2A> method are not supported.</span></span> <span data-ttu-id="d73e6-166">에 대 한 호출을 <xref:System.Span%601.Equals%2A> 생성 되는 두 개의 결과 중 하나:</span><span class="sxs-lookup"><span data-stu-id="d73e6-166">Calls to the <xref:System.Span%601.Equals%2A> methods produce either of two results:</span></span>

- <span data-ttu-id="d73e6-167">경우 `obj` 되는 <xref:System.Span%601>, 컴파일러 오류 CS1503를 생성 하는 메서드 호출: "변환할 수 없습니다 'System.Span'에서 'object'." 때문에 이것이 <xref:System.Span%601> 되는 [ref 구조체](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) 넣을 수 없습니다 하 고로 변환할 수 없습니다는 <xref:System.Object>합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-167">If `obj` is a <xref:System.Span%601>, the method call generates compiler error CS1503: "cannot convert from 'System.Span' to 'object'." This is because <xref:System.Span%601> is a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) that cannot be boxed and therefore cannot be converted to an <xref:System.Object>.</span></span>

- <span data-ttu-id="d73e6-168">경우 유형의 `obj` 아닙니다를 <xref:System.Span%601>, 메서드 호출에서 throw를 <xref:System.NotSupportedException>입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-168">If the type of `obj` is not a <xref:System.Span%601>, the method call throws a <xref:System.NotSupportedException>.</span></span> 

<span data-ttu-id="d73e6-169">비교할 두 개의 <xref:System.Span%601> 개체가 같은지를 사용 하 여는 <xref:System.Span%601.op_Equality%2A> 비교 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-169">To compare two <xref:System.Span%601> objects for equality, use the <xref:System.Span%601.op_Equality%2A> comparison operator.</span></span>

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d73e6-170">이 메서드의 호출은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-170">Calls to this method are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="span.Fill value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="d73e6-171">범위의 각 요소에 할당할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-171">The value to assign to each element of the span.</span></span></param>
        <summary><span data-ttu-id="d73e6-172">지정된 값으로 이 범위의 요소를 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-172">Fills the elements of this span with a specified value.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Span&lt;'T&gt;.Enumerator" Usage="span.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d73e6-173">이 <see cref="T:System.Span`1" />에 대한 열거자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-173">Returns an enumerator for this <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="d73e6-174">이 범위에 대한 열거자입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-174">An enumerator for this span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="d73e6-175">호출 하는 대신 합니다 <xref:System.Span%601.GetEnumerator%2A> 메서드를 직접 사용할 수는 C# `foreach` 문 및 Visual Basic `For Each`... `Next` 구문을 사용 열거 하는 <xref:System.Span%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-175">Instead of calling the <xref:System.Span%601.GetEnumerator%2A> method directly, you can use the C# `foreach` statement and the Visual Basic `For Each`...`Next` construct to enumerate a <xref:System.Span%601>.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="span.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("GetHashCode() on Span will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d73e6-176"><see cref="T:System.NotSupportedException" />를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-176">Throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="d73e6-177">이 메서드를 호출하면 <see cref="T:System.NotSupportedException" />이 항상 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-177">Calls to this method always throw a <see cref="T:System.NotSupportedException" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d73e6-178">이 메서드의 호출은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-178">Calls to this method are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; " Usage="span.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d73e6-179">인덱스 0에서 <see cref="T:System.Span`1" />의 마지막 요소에 대한 참조를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-179">Returns a reference to the element of the <see cref="T:System.Span`1" /> at index zero.</span></span></summary>
        <returns><span data-ttu-id="d73e6-180">인덱스 0에서 <see cref="T:System.Span`1" /> 요소에 대한 참조이거나 <see cref="M:System.Span`1.IsEmpty" />가 <see langword="true" />인 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-180">A reference to the element of the <see cref="T:System.Span`1" /> at index zero, or <see langword="null" /> if <see cref="M:System.Span`1.IsEmpty" /> is  <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="d73e6-181">합니다 `GetPinnableReference` 메서드가 반환 되는 [ref 구조체](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type)합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-181">The `GetPinnableReference` method returns a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type).</span></span> <span data-ttu-id="d73e6-182">고정할 수는 <xref:System.Span%601> 메모리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-182">It can be used for pinning a <xref:System.Span%601> in memory.</span></span> <span data-ttu-id="d73e6-183">사용을 지원 해야는 <xref:System.Span%601> 내에서 [고정](~/docs/csharp/language-reference/keywords/fixed-statement.md) 문입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-183">It is required to support the use of a <xref:System.Span%601> within a [fixed](~/docs/csharp/language-reference/keywords/fixed-statement.md) statement.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Span&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d73e6-184">현재 <see cref="T:System.Span`1" />가 비어 있는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-184">Returns a value that indicates whether the current <see cref="T:System.Span`1" /> is empty.</span></span></summary>
        <value><span data-ttu-id="d73e6-185"><see langword="true" /> 현재 범위가 비어 있는 경우 그렇지 않으면 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-185"><see langword="true" /> if the current span is empty; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Index) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[Index] { T % get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Item(Index) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="d73e6-186">요소의 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-186">The zero-based index of the element.</span></span></param>
        <summary><span data-ttu-id="d73e6-187">지정된 인덱스(0부터 시작)에서 요소를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-187">Gets the element at the specified zero-based index.</span></span></summary>
        <value><span data-ttu-id="d73e6-188">지정한 인덱스의 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-188">The element at the specified index.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="d73e6-189"><paramref name="index" />가 0보다 작거나 <see cref="P:System.Span`1.Length" />보다 크거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-189"><paramref name="index" /> is less than zero or greater than or equal to <see cref="P:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Span`1&lt;!T&gt; Item(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Span&lt;T&gt; default[Range] { Span&lt;T&gt; get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Item(Range) : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Span&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d73e6-190">현재 범위의 길이를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-190">Returns the length of the current span.</span></span></summary>
        <value><span data-ttu-id="d73e6-191">현재 범위의 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-191">The length of the current span.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="d73e6-192">비교할 첫 번째 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-192">The first span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="d73e6-193">비교할 두 번째 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-193">The second span to compare.</span></span></param>
        <summary><span data-ttu-id="d73e6-194">두 <see cref="T:System.Span`1" /> 개체가 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-194">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="d73e6-195">두 <see cref="T:System.Span`1" /> 개체가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-195"><see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="d73e6-196">두 개의 <xref:System.Span%601> 동일한 길이 및 해당 요소의 경우 개체가 같은지 `left` 및 `right` 동일한 메모리를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-196">Two <xref:System.Span%601> objects are equal if they have the same length and the corresponding elements of `left` and `right` point to the same memory.</span></span> <span data-ttu-id="d73e6-197">같음 테스트를 수행 하는 참고 *되지* 내용이 같은지 여부를 확인 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-197">Note that the test for equality does *not* attempt to determine whether the contents are equal.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="segment"><span data-ttu-id="d73e6-198"><see cref="T:System.Span`1" />로 변환될 배열 세그먼트입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-198">The array segment to be converted to a <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="d73e6-199"><see cref="T:System.ArraySegment`1" />을 <see cref="T:System.Span`1" />로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-199">Defines an implicit conversion of an <see cref="T:System.ArraySegment`1" /> to a <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="d73e6-200">배열 세그먼트에 해당하는 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-200">A span that corresponds to the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Span&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="d73e6-201"><see cref="T:System.ReadOnlySpan`1" />으로 변환할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-201">The object to convert to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></param>
        <summary><span data-ttu-id="d73e6-202"><see cref="T:System.Span`1" />을 <see cref="T:System.ReadOnlySpan`1" />로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-202">Defines an implicit conversion of a <see cref="T:System.Span`1" /> to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
        <returns><span data-ttu-id="d73e6-203">현재 인스턴스에 해당하는 읽기 전용 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-203">A read-only span that corresponds to the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="d73e6-204"><see cref="T:System.Span`1" />로 변환할 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-204">The array to convert to a <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="d73e6-205">배열을 <see cref="T:System.Span`1" />로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-205">Defines an implicit conversion of an array to a <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="d73e6-206"><paramref name="array" />에 해당하는 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-206">The span that corresponds to <paramref name="array" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="System.Span&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="d73e6-207">비교할 첫 번째 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-207">The first span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="d73e6-208">비교할 두 번째 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-208">The second span to compare.</span></span></param>
        <summary><span data-ttu-id="d73e6-209">두 <see cref="T:System.Span`1" /> 개체가 같지 않은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-209">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="d73e6-210">두 <see cref="T:System.Span`1" /> 개체가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-210"><see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="d73e6-211">두 개의 <xref:System.Span%601> 개체가 같은지 없거나 길이가 다른 경우의 해당 요소 `left` 고 `right` 동일한 메모리를 가리키지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-211">Two <xref:System.Span%601> objects are equal if they have different lengths or if the corresponding elements of `left` and `right` do not point to the same memory.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; Span&lt;'T&gt;" Usage="span.Slice start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="d73e6-212">조각을 시작할 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-212">The index at which to begin the slice.</span></span></param>
        <summary><span data-ttu-id="d73e6-213">지정된 인덱스로 시작되는 현재 범위에서 하나의 조각을 형성합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-213">Forms a slice out of the current span that begins at a specified index.</span></span></summary>
        <returns><span data-ttu-id="d73e6-214"><paramref name="index" />에서 스팬의 끝까지 현재 범위의 모든 요소로 구성된 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-214">A span that consists of all elements of the current span from <paramref name="index" /> to the end of the span.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d73e6-215"><paramref name="index" />가 0보다 작거나 <see cref="T:System.Span`1.Length" />보다 크거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-215"><paramref name="index" /> is less than zero or greater than or equal to <see cref="T:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; Span&lt;'T&gt;" Usage="span.Slice (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="d73e6-216">이 조각을 시작할 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-216">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="d73e6-217">조각에 대한 원하는 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-217">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="d73e6-218">지정된 길이 대해 지정된 인덱스에서 시작하는 현재 범위에서 벗어난 조각을 형성합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-218">Forms a slice out of the current span starting at a specified index for a specified length.</span></span></summary>
        <returns><span data-ttu-id="d73e6-219"><paramref name="index" />에서 시작하는 현재 범위로부터 <paramref name="length" /> 요소를 구성하는 &gt; 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-219">&gt;A span that consists of <paramref name="length" /> elements from the current span starting at <paramref name="index" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d73e6-220"><paramref name="start" /> 또는 <paramref name="start" /> + <paramref name="index" />가 0보다 작거나 <see cref="T:System.Span`1.Length" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-220"><paramref name="start" /> or <paramref name="start" /> + <paramref name="index" /> is less than zero or greater than <see cref="T:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="span.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d73e6-221">이 범위의 콘텐츠를 새 배열로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-221">Copies the contents of this span into a new array.</span></span></summary>
        <returns><span data-ttu-id="d73e6-222">현재 범위에서 데이터를 포함하는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-222">An array containing the data in the current span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="d73e6-223">이 메서드는 힙 할당을 수행 하 고 따라서 가능한 경우 피해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-223">This method performs a heap allocation and therefore should be avoided if possible.</span></span> <span data-ttu-id="d73e6-224">이 Api는 지원 되는 경우 작업이 필요한 경우도 해당 <xref:System.Span%601> 개체를 사용할 수 없는 있지만 api는 배열을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-224">It it sometimes necessary when APIs that support <xref:System.Span%601> objects are not available but APIs that work with arrays are.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="span.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d73e6-225">이 <see cref="T:System.Span`1" /> 개체의 문자열 표현을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-225">Returns the string representation of this <see cref="T:System.Span`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="d73e6-226">이 <see cref="T:System.Span`1" /> 개체의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-226">The string representation of this <see cref="T:System.Span`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="d73e6-227">에 대 한를 `Span<Char>`, `ToString` 메서드가 반환 되는 <xref:System.String> 가리키는 문자가 포함 된를 <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="d73e6-227">For a `Span<Char>`, the `ToString` method returns a <xref:System.String> that contains the characters pointed to by the <xref:System.Span%601>.</span></span> <span data-ttu-id="d73e6-228">를 반환 합니다는 <xref:System.String> 형식 및 요소 수의 이름으로는 <xref:System.Span%601> 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-228">Otherwise, it returns a <xref:System.String> with the name of the type and the number of elements that the <xref:System.Span%601> contains.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="span.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="d73e6-229">복사 작업의 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-229">The target of the copy operation.</span></span></param>
        <summary><span data-ttu-id="d73e6-230">현재 <see cref="T:System.Span`1" />을 대상 <see cref="T:System.Span`1" />에 복사하려고 시도하고 복사 작업의 성공 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-230">Attempts to copy the current <see cref="T:System.Span`1" /> to a destination <see cref="T:System.Span`1" /> and returns a value that indicates whether the copy operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="d73e6-231">복사 작업이 성공적으로 수행되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-231"><see langword="true" /> if the copy operation succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="d73e6-232">이 메서드는 모두 복사 `source` 에 `destination` 경우에 `source` 및 `destination` 겹칩니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-232">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

<span data-ttu-id="d73e6-233">하는 경우 `destination` 원본 보다 짧은 <xref:System.Span%601>,이 메서드는 반환 `false`에 데이터가 기록 됩니다 `destination`합니다.</span><span class="sxs-lookup"><span data-stu-id="d73e6-233">If `destination` is shorter than the source <xref:System.Span%601>, this method returns `false`, and no data is written to `destination`.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>