<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8897d1a2bd54a4001b860c84aaed5561013a0d5b" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58740544" /></Metadata><TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="387d3-101">열거형을 비트 필드 즉, 플래그 집합으로 처리할 수 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-101">Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="387d3-102">비트 필드는 열거형 상수는 일반적으로 함께 요소 목록을 사용 하는 반면 조합에서 발생할 수 있는 요소의 목록에 대 한 일반적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-102">Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</span></span> <span data-ttu-id="387d3-103">따라서 비트 필드는 열거 상수에는 없는 반면 명명 되지 않은 값을 생성 하는 비트 OR 연산을 함께 사용 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-103">Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</span></span> <span data-ttu-id="387d3-104">언어와 열거형 상수는 비트 필드의 용도에 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-104">Languages vary in their use of bit fields compared to enumeration constants.</span></span>  
  
## <a name="attributes-of-the-flagsattribute"></a><span data-ttu-id="387d3-105">FlagsAttribute 특성</span><span class="sxs-lookup"><span data-stu-id="387d3-105">Attributes of the FlagsAttribute</span></span>  
 <span data-ttu-id="387d3-106"><xref:System.AttributeUsageAttribute> 이 클래스에 적용 되 고 해당 <xref:System.AttributeUsageAttribute.Inherited%2A> 속성을 지정 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-106"><xref:System.AttributeUsageAttribute> is applied to this class, and its <xref:System.AttributeUsageAttribute.Inherited%2A> property specifies `false`.</span></span> <span data-ttu-id="387d3-107">이 특성은 열거형에만 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-107">This attribute can only be applied to enumerations.</span></span>  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a><span data-ttu-id="387d3-108">FlagsAttribute 열거형에 대 한 지침</span><span class="sxs-lookup"><span data-stu-id="387d3-108">Guidelines for FlagsAttribute and Enum</span></span>  
  
-   <span data-ttu-id="387d3-109">사용 된 <xref:System.FlagsAttribute> 연산을 (AND, OR, 포함 또는 제외)은 숫자 값에 수행 해야 하는 경우에 열거형에 대 한 사용자 지정 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-109">Use the <xref:System.FlagsAttribute> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</span></span>  
  
-   <span data-ttu-id="387d3-110">즉, 1, 2, 4, 8 등에 2의 거듭제곱 열거형 상수를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-110">Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</span></span> <span data-ttu-id="387d3-111">이 조합 된 열거형 상수의 개별 플래그가 겹치지 않을 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-111">This means the individual flags in combined enumeration constants do not overlap.</span></span>  
  
-   <span data-ttu-id="387d3-112">자주 사용 되는 플래그 조합에 대 한 열거형된 상수를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-112">Consider creating an enumerated constant for commonly used flag combinations.</span></span> <span data-ttu-id="387d3-113">예를 들어, 파일 I/O 작업에 사용 되는 열거형을 사용 하는 경우 포함 하는 열거형된 상수 `Read = 1` 하 고 `Write = 2`, 열거 된 상수를 만드는 것이 좋습니다 `ReadWrite = Read OR Write`를 결합 하는 합니다 `Read` 및 `Write` 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-113">For example, if you have an enumeration used for file I/O operations that contains the enumerated constants `Read = 1` and `Write = 2`, consider creating the enumerated constant `ReadWrite = Read OR Write`, which combines the `Read` and `Write` flags.</span></span> <span data-ttu-id="387d3-114">또한 플래그를 결합 하는 데 사용 하 고 비트 OR 연산에는 간단한 작업에 대 한 요구 하지 않아야 하는 경우에 따라 고급 개념을 간주 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-114">In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</span></span>  
  
-   <span data-ttu-id="387d3-115">여러 플래그 위치가 혼란 스러운 코드를 만들 수 있습니다 및 코딩 오류는 것이 좋습니다을 1로 설정 될 수 있으므로 플래그 열거 상수 음수를 정의 하는 경우에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-115">Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</span></span>  
  
-   <span data-ttu-id="387d3-116">플래그 열거형된 상수 플래그에 해당 하지 않는 0으로 숫자 값에서 모든 비트를 설정 하는 숫자 값 사이 비트 AND 연산을 수행 하는 숫자 값에는 플래그가 설정 되어 있는지 여부를 테스트 하는 편리한 방법 그런 다음 해당 작업의 결과 플래그 열거 된 상수와 같은지 여부를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-116">A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</span></span>  
  
-   <span data-ttu-id="387d3-117">사용 하 여 `None` 열거형 상수의 값이 0 인 플래그의 이름으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-117">Use `None` as the name of the flag enumerated constant whose value is zero.</span></span> <span data-ttu-id="387d3-118">사용할 수 없습니다는 `None` 결과 항상 0 때문에 플래그를 테스트 하려면 비트 AND 연산의 열거 된 상수입니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-118">You cannot use the `None` enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</span></span> <span data-ttu-id="387d3-119">그러나 논리를 수행할 수 비트 숫자 값을 비교 하지 및 `None` 숫자 값의 모든 비트가 설정 되었는지 여부를 결정 하는 열거형된 상수입니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-119">However, you can perform a logical, not a bitwise, comparison between the numeric value and the `None` enumerated constant to determine whether any bits in the numeric value are set.</span></span>  
  
     <span data-ttu-id="387d3-120">플래그 열거형을 대신 열거형 값을 만드는 경우 가치가 여전히 만들기는 `None` 열거형된 상수입니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-120">If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a `None` enumerated constant.</span></span> <span data-ttu-id="387d3-121">기본적으로 0으로 열거형에 사용 되는 메모리가 초기화 되는 이유는 공용 언어 런타임에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-121">The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</span></span> <span data-ttu-id="387d3-122">따라서 값이 0 인 상수를 정의 하지 않는 경우 생성 될 때 열거형 잘못 된 값을 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-122">Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</span></span>  
  
     <span data-ttu-id="387d3-123">응용 프로그램을 나타내는 필요한 명확한 기본 사례를 경우에 값이 기본값을 나타내는 0 인 열거형된 상수를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-123">If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</span></span> <span data-ttu-id="387d3-124">기본 사례가 없는 경우에 다른 열거형된 상수 중 하나에서 표시 되지 않는 경우를 의미 하는 0 값이 열거형된 상수를 사용 하 여 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-124">If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</span></span>  
  
-   <span data-ttu-id="387d3-125">열거형 값에서 열거형 자체로의 상태를 미러링 하는 용도로 정의 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-125">Do not define an enumeration value solely to mirror the state of the enumeration itself.</span></span> <span data-ttu-id="387d3-126">예를 들어 단순히 열거형의 끝을 표시 하는 열거형된 상수를 정의 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-126">For example, do not define an enumerated constant that merely marks the end of the enumeration.</span></span> <span data-ttu-id="387d3-127">열거형의 마지막 값을 확인 하는 경우 해당 값에 대 한 명시적으로 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-127">If you need to determine the last value of the enumeration, check for that value explicitly.</span></span> <span data-ttu-id="387d3-128">또한 범위 내 모든 값이 유효한 경우 첫 번째 및 마지막 열거 된 상수에 대 한 범위를 확인을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-128">In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</span></span>  
  
-   <span data-ttu-id="387d3-129">나중에 사용 하도록 예약 된 열거 상수를 지정 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="387d3-129">Do not specify enumerated constants that are reserved for future use.</span></span>  
  
-   <span data-ttu-id="387d3-130">메서드 또는 값으로 열거형된 상수를 사용 하는 속성을 정의할 때에 값의 유효성을 검사 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-130">When you define a method or property that takes an enumerated constant as a value, consider validating the value.</span></span> <span data-ttu-id="387d3-131">이유는이 숫자 값을 열거형에 정의 되지 않은 경우에 숫자 열거형 값으로 캐스팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-131">The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="387d3-132">다음 예제를 사용 합니다 `FlagsAttribute` 특성 및에 영향을 보여 줍니다는 <xref:System.Enum.ToString%2A> 메서드를 사용 하 여 `FlagsAttribute` 에 <xref:System.Enum> 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-132">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 <span data-ttu-id="387d3-133">다음 예제에서는 두 가지 색상 관련 열거형 `SingleHue` 고 `MultiHue`입니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-133">The following example defines two color-related enumerations, `SingleHue` and `MultiHue`.</span></span> <span data-ttu-id="387d3-134">후자에 `FlagsAttribute` 특성; 전자 않습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-134">The latter has the `FlagsAttribute` attribute; the former does not.</span></span> <span data-ttu-id="387d3-135">이 예제에서는 정수, 열거형 형식의 기본 값을 나타내지 않는 정수를 포함 하 여 범위 열거형 형식 및 표시 하는 해당 문자열 표현으로 캐스팅 하는 경우 동작의 차이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-135">The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</span></span>   <span data-ttu-id="387d3-136">예를 들어 3으로 표현할 수 없는 점에 유의 `SingleHue` 3의 기본 값 없기 때문에 값 `SingleHue` 멤버 반면 합니다 `FlagsAttribute` 특성을 사용 하면 3으로 표현할 수는 `MultiHue` 값 `Black, Red`.</span><span class="sxs-lookup"><span data-stu-id="387d3-136">For example, note that 3 cannot be represented as a `SingleHue` value because 3 is not the underlying value of any `SingleHue` member, whereas the `FlagsAttribute` attribute makes it possible to represent 3 as a `MultiHue` value of `Black, Red`.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="387d3-137"><see cref="T:System.FlagsAttribute" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-137">Initializes a new instance of the <see cref="T:System.FlagsAttribute" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="387d3-138">다음 예제에서는 정의 `PhoneService` 전화 회사에서 제공 되는 통신의 형태를 나타내는 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-138">The following example defines a `PhoneService` enumeration that represents forms of communication provided by a telephone company.</span></span> <span data-ttu-id="387d3-139">세 가지 다른 에너지가 제공 하는 서비스를 나타내는 세 개의 변수를 초기화 하 고 나타냅니다는 에너지가 에너지가 휴대폰 서비스만 있고 어떤 가구 휴대폰와 land 줄 서비스가 서비스가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-139">It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</span></span> <span data-ttu-id="387d3-140">마지막으로 암시적으로 호출 하 여 <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> 각 가계에 제공 되는 서비스 유형을 표시 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-140">Finally, it implicitly calls the <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> method to display the types of service provided to each household.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 <span data-ttu-id="387d3-141">다음 예제를 사용 합니다 `FlagsAttribute` 특성 및에 영향을 보여 줍니다는 <xref:System.Enum.ToString%2A> 메서드를 사용 하 여 `FlagsAttribute` 에 <xref:System.Enum> 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="387d3-141">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>