<Type Name="FieldInfo" FullName="System.Reflection.FieldInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="70b927cf8afbecc2d13acdbc0f9fb4e1d5d70078" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58721827" /></Metadata><TypeSignature Language="C#" Value="public abstract class FieldInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._FieldInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit FieldInfo extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._FieldInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.FieldInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class FieldInfo&#xA;Inherits MemberInfo&#xA;Implements _FieldInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FieldInfo abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_FieldInfo" />
  <TypeSignature Language="F#" Value="type FieldInfo = class&#xA;    inherit MemberInfo&#xA;    interface _FieldInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._FieldInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._FieldInfo))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ce584-101">필드의 특성을 검색하고 필드 메타데이터에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-101">Discovers the attributes of a field and provides access to field metadata.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-102">필드 정보는 메타 데이터에서 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-102">The field information is obtained from metadata.</span></span> <span data-ttu-id="ce584-103"><xref:System.Reflection.FieldInfo> 클래스에 public 생성자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-103">The <xref:System.Reflection.FieldInfo> class does not have a public constructor.</span></span> <span data-ttu-id="ce584-104"><xref:System.Reflection.FieldInfo> 개체 중 하나를 호출 하 여 가져온 합니다 <xref:System.Type.GetFields%2A> 또는 <xref:System.Type.GetField%2A> 메서드를 `Type` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-104"><xref:System.Reflection.FieldInfo> objects are obtained by calling either the <xref:System.Type.GetFields%2A> or <xref:System.Type.GetField%2A> method of a `Type` object.</span></span>  
  
 <span data-ttu-id="ce584-105">필드는 클래스에 정의 된 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-105">Fields are variables defined in the class.</span></span> <span data-ttu-id="ce584-106"><xref:System.Reflection.FieldInfo> 클래스 내의 필드에 대 한 메타 데이터에 대 한 액세스를 제공 하 고 필드에 대 한 동적 집합 및 가져오기 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-106"><xref:System.Reflection.FieldInfo> provides access to the metadata for a field within a class and provides dynamic set and get functionality for the field.</span></span> <span data-ttu-id="ce584-107">클래스 호출 될 때까지 메모리에 로드 되지 않습니다 또는 get 개체에서 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-107">The class is not loaded into memory until invoke or get is called on the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-108">다음 예제에서는 합니다 <xref:System.Type.GetFields%2A?displayProperty=nameWithType> 필드와 관련 된 정보를 얻을 수 있는 메서드는 <xref:System.Reflection.FieldInfo> 클래스 및 필드 특성을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-108">The following example uses the <xref:System.Type.GetFields%2A?displayProperty=nameWithType> method to get the field-related information from the <xref:System.Reflection.FieldInfo> class, and then displays field attributes.</span></span>  
  
 [!code-cpp[FieldInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo/CPP/fieldinfo.cpp#1)]
 [!code-csharp[FieldInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo/CS/fieldinfo.cs#1)]
 [!code-vb[FieldInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo/VB/fieldinfo.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="ce584-109">상속자에 대 한 완전 신뢰 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-109">for full trust for inheritors.</span></span> <span data-ttu-id="ce584-110">부분적으로 신뢰할 수 있는 코드에서이 클래스를 상속할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-110">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="ce584-111">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-111">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="ce584-112"><see cref="T:System.Reflection.FieldInfo" />에서 상속하는 경우 <see cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" /> 및 <see cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" /> 멤버를 재정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-112">When you inherit from <see cref="T:System.Reflection.FieldInfo" />, you must override the following members: <see cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" /> and <see cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />.</span></span></para></block>
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected FieldInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; FieldInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce584-113"><see langword="FieldInfo" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-113">Initializes a new instance of the <see langword="FieldInfo" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ce584-114">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-114">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ce584-115">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ce584-115">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.FieldAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As FieldAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::FieldAttributes Attributes { System::Reflection::FieldAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.FieldAttributes" Usage="System.Reflection.FieldInfo.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-116">이 필드와 관련된 특성을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-116">Gets the attributes associated with this field.</span></span></summary>
        <value><span data-ttu-id="ce584-117">이 필드에 대한 <see langword="FieldAttributes" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-117">The <see langword="FieldAttributes" /> for this field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-118">모든 멤버는 특정 형식의 멤버와 관련 하 여 정의 된 특성 집합을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-118">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span> <span data-ttu-id="ce584-119">`FieldAttributes` 이 필드가 private 필드, 정적 필드 및 등 인지 여부를 사용자에 게 알립니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-119">`FieldAttributes` informs the user whether this field is the private field, a static field, and so on.</span></span>  
  
 <span data-ttu-id="ce584-120">가져오려는 합니다 `Attributes` 속성을 먼저 클래스를 가져옵니다 `Type`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-120">To get the `Attributes` property, first get the class `Type`.</span></span> <span data-ttu-id="ce584-121">`Type`, 가져오기는 `FieldInfo`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-121">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="ce584-122">`FieldInfo`, 가져오기는 `Attributes`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-122">From the `FieldInfo`, get the `Attributes`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-123">다음 코드 예제에서는 세 개의 필드 및 필드 특성을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-123">The following code example builds three fields and displays their field attributes.</span></span> <span data-ttu-id="ce584-124">A `FieldAttributes` 값 모두 같은 둘 이상의 특성을 포함할 수 있습니다 `Public` 고 `Literal`세 번째 필드에 표시 된 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-124">A `FieldAttributes` value can contain more than one attribute, such as both `Public` and `Literal`, as shown in the third field.</span></span>  
  
 [!code-cpp[Classic FieldAttributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldAttributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldAttributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldAttributes Example/CS/source.cs#1)]
 [!code-vb[Classic FieldAttributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldAttributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="fieldInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ce584-125">이 인스턴스와 비교할 개체 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-125">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ce584-126">@FSHO2@이 인스턴스가 지정한 개체와 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-126">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="ce584-127"><see langword="true" />가 이 인스턴스의 형식 및 값과 같으면 <paramref name="obj" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-127"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeFieldHandle FieldHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeFieldHandle FieldHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.FieldHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FieldHandle As RuntimeFieldHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeFieldHandle FieldHandle { RuntimeFieldHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldHandle : RuntimeFieldHandle" Usage="System.Reflection.FieldInfo.FieldHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.FieldHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeFieldHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-128">필드의 내부 메타데이터 표현에 대한 핸들인 <see langword="RuntimeFieldHandle" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-128">Gets a <see langword="RuntimeFieldHandle" />, which is a handle to the internal metadata representation of a field.</span></span></summary>
        <value><span data-ttu-id="ce584-129">필드의 내부 메타데이터 표현에 대한 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-129">A handle to the internal metadata representation of a field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-130">핸들을 획득 된 appdomain에만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-130">The handles are valid only in the appdomain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-131">다음 예제에서는 MyClass.MyField 필드 정보를 검색 하 고 필드 핸들을 사용 하 여 연결 된 필드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-131">The following example retrieves MyClass.MyField field information and displays the field associated with the field handle.</span></span>  
  
 [!code-cpp[FieldInfo_FieldHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_FieldHandle/CPP/fieldinfo_fieldhandle.cpp#1)]
 [!code-csharp[FieldInfo_FieldHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_FieldHandle/CS/fieldinfo_fieldhandle.cs#1)]
 [!code-vb[FieldInfo_FieldHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_FieldHandle/VB/fieldinfo_fieldhandle.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldType">
      <MemberSignature Language="C#" Value="public abstract Type FieldType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type FieldType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.FieldType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FieldType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ FieldType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldType : Type" Usage="System.Reflection.FieldInfo.FieldType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.FieldType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-132">이 필드 개체의 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-132">Gets the type of this field object.</span></span></summary>
        <value><span data-ttu-id="ce584-133">이 필드 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-133">The type of this field object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-134">형식이 몇 가지 기본 데이터 형식을 같은 `String`, `Boolean`, 또는 `GUID`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-134">The type is some primitive data type, such as `String`, `Boolean`, or `GUID`.</span></span>  
  
 <span data-ttu-id="ce584-135">가져오려는 합니다 `FieldType` 속성을 먼저 클래스를 가져옵니다 `Type`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-135">To get the `FieldType` property, first get the class `Type`.</span></span> <span data-ttu-id="ce584-136">`Type`, 가져오기는 `FieldInfo`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-136">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="ce584-137">`FieldInfo`, 가져오기는 `FieldType` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-137">From the `FieldInfo`, get the `FieldType` value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-138">다음 예에서는 필드를 만들고, 해당 형식을 가져옵니다 및 <xref:System.Reflection.FieldInfo>를 표시 하 고 해당 <xref:System.Reflection.FieldInfo.FieldType%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-138">The following example creates a field, gets its type and <xref:System.Reflection.FieldInfo>, and displays its <xref:System.Reflection.FieldInfo.FieldType%2A>.</span></span>  
  
 [!code-cpp[Classic FieldInfo.FieldType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.FieldType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.FieldType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFieldFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ce584-139">핸들이 나타내는 필드의 <see cref="T:System.Reflection.FieldInfo" />를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-139">Gets a <see cref="T:System.Reflection.FieldInfo" /> for the field represented by a handle.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFieldFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetFieldFromHandle (RuntimeFieldHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetFieldFromHandle(valuetype System.RuntimeFieldHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFieldFromHandle (handle As RuntimeFieldHandle) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetFieldFromHandle(RuntimeFieldHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetFieldFromHandle : RuntimeFieldHandle -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.FieldInfo.GetFieldFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="ce584-140">필드의 내부 메타데이터 표현에 대한 핸들이 들어 있는 <see cref="T:System.RuntimeFieldHandle" /> 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-140">A <see cref="T:System.RuntimeFieldHandle" /> structure that contains the handle to the internal metadata representation of a field.</span></span></param>
        <summary><span data-ttu-id="ce584-141">지정된 핸들이 나타내는 필드의 <see cref="T:System.Reflection.FieldInfo" />를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-141">Gets a <see cref="T:System.Reflection.FieldInfo" /> for the field represented by the specified handle.</span></span></summary>
        <returns><span data-ttu-id="ce584-142"><paramref name="handle" />로 지정된 필드를 나타내는 <see cref="T:System.Reflection.FieldInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-142">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field specified by <paramref name="handle" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-143">핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-143">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-144">다음 코드 예제에서는 합니다 <xref:System.Type.GetFields%2A?displayProperty=nameWithType> 메서드를 <xref:System.Reflection.FieldInfo> 형식의 필드에 대 한 개체를 가져옵니다를 <xref:System.RuntimeFieldHandle> 한 다음 각 필드에 검색에 대 한 구조는 <xref:System.Reflection.FieldInfo> 합니다 가오버이로드를사용하여핸들에서개체<xref:System.Reflection.FieldInfo.GetFieldFromHandle%2A>메서드.</span><span class="sxs-lookup"><span data-stu-id="ce584-144">The following code example uses the <xref:System.Type.GetFields%2A?displayProperty=nameWithType> method to get <xref:System.Reflection.FieldInfo> objects for the fields of a type, gets a <xref:System.RuntimeFieldHandle> structure for each field, and then retrieves the <xref:System.Reflection.FieldInfo> objects from the handles using this overload of the <xref:System.Reflection.FieldInfo.GetFieldFromHandle%2A> method.</span></span>  
  
 [!code-cpp[FieldInfo_GetFieldFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle/CPP/fieldinfo_getfieldfromhandle.cpp#1)]
 [!code-csharp[FieldInfo_GetFieldFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle/CS/fieldinfo_getfieldfromhandle.cs#1)]
 [!code-vb[FieldInfo_GetFieldFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle/VB/fieldinfo_getfieldfromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce584-145"><paramref name="handle" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-145"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ce584-146">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-146">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ce584-147">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ce584-147">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFieldFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetFieldFromHandle (RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetFieldFromHandle(valuetype System.RuntimeFieldHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFieldFromHandle (handle As RuntimeFieldHandle, declaringType As RuntimeTypeHandle) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="F#" Value="static member GetFieldFromHandle : RuntimeFieldHandle * RuntimeTypeHandle -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.FieldInfo.GetFieldFromHandle (handle, declaringType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeFieldHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="ce584-148">필드의 내부 메타데이터 표현에 대한 핸들이 들어 있는 <see cref="T:System.RuntimeFieldHandle" /> 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-148">A <see cref="T:System.RuntimeFieldHandle" /> structure that contains the handle to the internal metadata representation of a field.</span></span></param>
        <param name="declaringType"><span data-ttu-id="ce584-149">필드를 정의하는 제네릭 형식에 대한 핸들이 들어 있는 <see cref="T:System.RuntimeTypeHandle" /> 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-149">A <see cref="T:System.RuntimeTypeHandle" /> structure that contains the handle to the generic type that defines the field.</span></span></param>
        <summary><span data-ttu-id="ce584-150">지정된 제네릭 형식에 대해 지정된 핸들이 나타내는 필드의 <see cref="T:System.Reflection.FieldInfo" />를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-150">Gets a <see cref="T:System.Reflection.FieldInfo" /> for the field represented by the specified handle, for the specified generic type.</span></span></summary>
        <returns><span data-ttu-id="ce584-151"><paramref name="handle" />으로 지정된 제네릭 형식에서 <paramref name="declaringType" />로 지정된 필드를 나타내는 <see cref="T:System.Reflection.FieldInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-151">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-152">핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-152">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="ce584-153">하는 것이 좋습니다 `declaringType` 는 생성 된 런타임 형식 핸들 형식은 항상 `handle` 에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-153">The recommended practice is that `declaringType` should always be the runtime type handle of the constructed type that `handle` belongs to.</span></span> <span data-ttu-id="ce584-154">즉, 경우 `handle` 에 속하는 필드에 대 한 런타임 필드 핸들 `MyType<int>` (`MyType(Of Integer)` Visual Basic의), `declaringType` 에 대 한 런타임 형식 핸들이 `MyType<int>`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-154">That is, if `handle` is a runtime field handle for a field that belongs to `MyType<int>` (`MyType(Of Integer)` in Visual Basic), `declaringType` is the runtime type handle for `MyType<int>`.</span></span> <span data-ttu-id="ce584-155">런타임 필드 핸들 제네릭 형식 정의의 필드를 나타내는 경우가 아니면 제네릭 형식 정의의 런타임 형식 핸들을 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="ce584-155">Do not use the runtime type handle of the generic type definition, unless the runtime field handle represents a field on the generic type definition.</span></span>  
  
 <span data-ttu-id="ce584-156">구현에 따라서는 호환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-156">Implementations are compatible in some cases.</span></span> <span data-ttu-id="ce584-157">예를 들어, 단일 구현은 참조 형식을 제네릭 형식 인수를 사용 하 여 특정 제네릭 형식 정의에서 생성 된 모든 형식에서 공유 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-157">For example, a single implementation is shared by all types that are constructed from a particular generic type definition by using reference types for the generic type arguments.</span></span> <span data-ttu-id="ce584-158">예를 들어 `MyType<string>`하십시오 `MyType<object>`, 및 `MyType<ArrayList>` 모두 동일한 구현을 공유 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-158">For example, `MyType<string>`, `MyType<object>`, and `MyType<ArrayList>` all share the same implementation.</span></span> <span data-ttu-id="ce584-159">이 이런 경우에 <xref:System.Reflection.FieldInfo> 반환 되는 개체 형식에 필드를 나타냅니다는 `declaringType` 의 원본 소스에 관계 없이 지정 `handle`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-159">In this situation, the <xref:System.Reflection.FieldInfo> object that is returned represents a field on the type that `declaringType` specifies, regardless of the original source of `handle`.</span></span> <span data-ttu-id="ce584-160">생성 된 형식의 제네릭 형식 인수를 참조 유형은 하는 경우에 작동 하기 때문에이 방법은 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-160">This practice is not recommended, because it works only if the generic type arguments of the constructed type are reference types.</span></span>  
  
 <span data-ttu-id="ce584-161">제네릭 인수 값 형식인 경우 생성 된 형식의 런타임 형식 핸들에서 생성 된 동일한 제네릭 매개 변수 위치에서 참조 형식을 갖는 또는 다른 값 형식을 해당 위치에 있는 런타임 필드 핸들와 호환 되지 않습니다. .</span><span class="sxs-lookup"><span data-stu-id="ce584-161">If a generic argument is a value type, the runtime type handle of the constructed type is not compatible with runtime field handles from constructions that have a reference type in the same generic parameter position, or that have a different value type in that position.</span></span> <span data-ttu-id="ce584-162">이런 경우, 사용 하는 유일한 방법은 <xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%2CSystem.RuntimeTypeHandle%29?displayProperty=nameWithType> 오버 로드 되어 있는지 확인 하는 것 `declaringType` 생성 된 형식에 대 한 런타임 형식 핸들은 `handle` 에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-162">In that case, the only way to use the <xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%2CSystem.RuntimeTypeHandle%29?displayProperty=nameWithType> overload is to ensure that `declaringType` is the runtime type handle for the constructed type that `handle` belongs to.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-163">다음 예제에서는 검색 하는 방법을 보여 줍니다 <xref:System.Reflection.FieldInfo> 생성 된 제네릭 클래스의 필드에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-163">The following example shows how to retrieve <xref:System.Reflection.FieldInfo> objects for fields on constructed generic classes.</span></span> <span data-ttu-id="ce584-164">이 예제에서는 제네릭 형식 정의 `Test<T>` (`Test(Of T)` Visual Basic에서) 라는 단일 필드를 사용 하 여 `TestField`, 형식의 `T`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-164">The example defines the generic type `Test<T>` (`Test(Of T)` in Visual Basic) with a single field named `TestField`, of type `T`.</span></span> <span data-ttu-id="ce584-165">예제 가져옵니다 합니다 <xref:System.RuntimeFieldHandle> 및 <xref:System.RuntimeTypeHandle> 경우 여기서 `T` 는 <xref:System.String>, 하 고 다음을 보여 줍니다:</span><span class="sxs-lookup"><span data-stu-id="ce584-165">The example gets the <xref:System.RuntimeFieldHandle> and <xref:System.RuntimeTypeHandle> for the case where `T` is <xref:System.String>, and demonstrates the following:</span></span>  
  
-   <span data-ttu-id="ce584-166">예외가 발생 하는 경우는 <xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%29> 메서드 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-166">An exception is thrown if the <xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%29> method overload is used.</span></span> <span data-ttu-id="ce584-167">필드 형식의 개체인 경우에 마찬가지 `T`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-167">This is true even if the field is not of type `T`.</span></span>  
  
-   <span data-ttu-id="ce584-168">A <xref:System.Reflection.FieldInfo> 런타임 형식 핸들 런타임 필드 핸들으로 동일한 구조에서이 경우에 경우 성공적으로 검색 됩니다 `Test<string>`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-168">A <xref:System.Reflection.FieldInfo> is retrieved successfully if the runtime type handle is from the same construction as the runtime field handle, in this case `Test<string>`.</span></span>  
  
-   <span data-ttu-id="ce584-169">런타임 형식 핸들 경우 호환 되는 생성,이 예에서 `Test<object>`, <xref:System.Reflection.FieldInfo> 호환 생성 시 필드를 검색에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-169">If the runtime type handle is from a compatible construction, in this case `Test<object>`, a <xref:System.Reflection.FieldInfo> for the field on the compatible construction is retrieved.</span></span>  
  
-   <span data-ttu-id="ce584-170">런타임 형식 핸들 호환 되는 생성에서 없으면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-170">If the runtime type handle is not from a compatible construction, an exception is thrown.</span></span> <span data-ttu-id="ce584-171">에 대 한 값 형식이 지정 되는 예제의 경우 `T`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-171">In this case, a value type is specified for `T`.</span></span>  
  
 [!code-csharp[FieldInfo_GetFieldFromHandle2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle2/cs/source.cs#1)]
 [!code-vb[FieldInfo_GetFieldFromHandle2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce584-172"><paramref name="handle" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-172"><paramref name="handle" /> is invalid.</span></span>  
  
<span data-ttu-id="ce584-173">또는</span><span class="sxs-lookup"><span data-stu-id="ce584-173">-or-</span></span> 
 <span data-ttu-id="ce584-174"><paramref name="declaringType" />이 <paramref name="handle" />과 호환되지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="ce584-174"><paramref name="declaringType" /> is not compatible with <paramref name="handle" />.</span></span> <span data-ttu-id="ce584-175">예를 들어 <paramref name="declaringType" />은 제네렉 형식 정의의 런타임 형식 핸들이며 <paramref name="handle" />은 생성된 형식에서 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-175">For example, <paramref name="declaringType" /> is the runtime type handle of the generic type definition, and <paramref name="handle" /> comes from a constructed type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ce584-176">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-176">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ce584-177">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ce584-177">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="fieldInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce584-178">이 인스턴스의 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-178">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="ce584-179">부호 있는 32비트 정수 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-179">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOptionalCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetOptionalCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetOptionalCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetOptionalCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOptionalCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetOptionalCustomModifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetOptionalCustomModifiers : unit -&gt; Type[]&#xA;override this.GetOptionalCustomModifiers : unit -&gt; Type[]" Usage="fieldInfo.GetOptionalCustomModifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce584-180">필드의 선택적 사용자 지정 한정자를 식별하는 형식의 배열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-180">Gets an array of types that identify the optional custom modifiers of the field.</span></span></summary>
        <returns><span data-ttu-id="ce584-181"><see cref="T:System.Runtime.CompilerServices.IsConst" />와 같은 현재 필드의 선택적 사용자 지정 한정자를 식별하는 <see cref="T:System.Type" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-181">An array of <see cref="T:System.Type" /> objects that identify the optional custom modifiers of the current field, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-182">합니다 <xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A> 고 <xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A> 메서드가 관리 되는 컴파일러의 디자이너를 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-182">The <xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A> and <xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A> methods are provided for designers of managed compilers.</span></span> <span data-ttu-id="ce584-183">사용자 지정 한정자에 대 한 자세한 내용은 참조 하세요. <xref:System.Runtime.CompilerServices.IsBoxed> 및 관련 클래스는 <xref:System.Runtime.CompilerServices> 네임 스페이스 및 ECMA Partition II 문서의 메타 데이터 사양입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-183">For more information on custom modifiers, see <xref:System.Runtime.CompilerServices.IsBoxed> and related classes in the <xref:System.Runtime.CompilerServices> namespace and the metadata specification in the ECMA Partition II documentation.</span></span> <span data-ttu-id="ce584-184">이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ce584-184">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRawConstantValue">
      <MemberSignature Language="C#" Value="public virtual object GetRawConstantValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetRawConstantValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetRawConstantValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRawConstantValue () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetRawConstantValue();" />
      <MemberSignature Language="F#" Value="abstract member GetRawConstantValue : unit -&gt; obj&#xA;override this.GetRawConstantValue : unit -&gt; obj" Usage="fieldInfo.GetRawConstantValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce584-185">컴파일러에서 필드와 연결한 리터럴 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-185">Returns a literal value associated with the field by a compiler.</span></span></summary>
        <returns><span data-ttu-id="ce584-186">필드와 연결된 리터럴 값이 포함된 <see cref="T:System.Object" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-186">An <see cref="T:System.Object" /> that contains the literal value associated with the field.</span></span> <span data-ttu-id="ce584-187">리터럴 값이 요소 값 0인 클래스 형식인 경우 반환 값은 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-187">If the literal value is a class type with an element value of zero, the return value is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-188">이 메서드는 관리 되는 컴파일러 및 코드 분석기 디자이너용 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-188">This method is provided for designers of managed compilers and code analyzers.</span></span>  
  
 <span data-ttu-id="ce584-189">실행 컨텍스트와 리플렉션 전용 컨텍스트에 모두에서이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-189">This method can be used in both the execution context and the reflection-only context.</span></span>  
  
 <span data-ttu-id="ce584-190">관리 되지 않는 메타 데이터의 고정 테이블 필드, 매개 변수 및 속성에 대 한 상수 값을 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-190">In unmanaged metadata, the Constant table is used to store constant values for fields, parameters, and properties.</span></span> <span data-ttu-id="ce584-191">상수 정보 런타임 동작 직접 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-191">Constant information does not directly influence runtime behavior.</span></span> <span data-ttu-id="ce584-192">컴파일러는 컴파일 타임에이 정보를 검사 메타 데이터를 가져올 때입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-192">Compilers inspect this information, at compile time, when importing metadata.</span></span> <span data-ttu-id="ce584-193">를 사용 하는 경우 컴파일러에서 Microsoft MSIL (intermediate language) 스트림에 상수 값이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-193">If used, the value of a constant is embedded in the Microsoft intermediate language (MSIL) stream the compiler emits.</span></span> <span data-ttu-id="ce584-194">런타임에 상수 테이블에 액세스 하는 MSIL 지침이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-194">There are no MSIL instructions that can be used to access the Constant table at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-195">상수 값의 고정 테이블에 대 한 자세한 내용은 ECMA Partition II 설명서를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="ce584-195">For more information on constant values and the Constant table, see the ECMA Partition II documentation.</span></span> <span data-ttu-id="ce584-196">이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ce584-196">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ce584-197">관리되지 않는 메타데이터의 고정 테이블에 현재 필드에 대한 상수 값이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-197">The Constant table in unmanaged metadata does not contain a constant value for the current field.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ce584-198">값의 형식이 CLS(공용 언어 사양)에서 허용하는 형식 중 하나가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-198">The type of the value is not one of the types permitted by the Common Language Specification (CLS).</span></span> <span data-ttu-id="ce584-199">ECMA Partition II 사양 메타데이터 논리 형식: 다른 구조, 서명에서 사용되는 요소 형식을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ce584-199">See the ECMA Partition II specification Metadata Logical Format: Other Structures, Element Types used in Signatures.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ce584-200">필드에 대한 상수 값이 설정되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-200">The constant value for the field is not set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequiredCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetRequiredCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetRequiredCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetRequiredCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRequiredCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetRequiredCustomModifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetRequiredCustomModifiers : unit -&gt; Type[]&#xA;override this.GetRequiredCustomModifiers : unit -&gt; Type[]" Usage="fieldInfo.GetRequiredCustomModifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce584-201">속성의 필수 사용자 지정 한정자를 식별하는 형식의 배열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-201">Gets an array of types that identify the required custom modifiers of the property.</span></span></summary>
        <returns><span data-ttu-id="ce584-202"><see cref="T:System.Type" /> 또는 <see cref="T:System.Runtime.CompilerServices.IsConst" />와 같은 현재 속성의 필수적 사용자 지정 한정자를 식별하는 <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-202">An array of <see cref="T:System.Type" /> objects that identify the required custom modifiers of the current property, such as <see cref="T:System.Runtime.CompilerServices.IsConst" /> or <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-203">합니다 <xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A> 고 <xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A> 메서드가 관리 되는 컴파일러의 디자이너를 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-203">The <xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A> and <xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A> methods are provided for designers of managed compilers.</span></span> <span data-ttu-id="ce584-204">사용자 지정 한정자에 대 한 자세한 내용은 참조 하세요. <xref:System.Runtime.CompilerServices.IsBoxed> 및 관련 클래스는 <xref:System.Runtime.CompilerServices> 네임 스페이스 및 ECMA Partition II 문서의 메타 데이터 사양입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-204">For more information on custom modifiers, see <xref:System.Runtime.CompilerServices.IsBoxed> and related classes in the <xref:System.Runtime.CompilerServices> namespace and the metadata specification in the ECMA Partition II documentation.</span></span> <span data-ttu-id="ce584-205">이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ce584-205">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="fieldInfo.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract object GetValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ GetValue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member GetValue : obj -&gt; obj" Usage="fieldInfo.GetValue obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetValue(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ce584-206">필드 값이 반환될 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-206">The object whose field value will be returned.</span></span></param>
        <summary><span data-ttu-id="ce584-207">파생 클래스에서 재정의된 경우 지정된 개체에서 지원하는 필드의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-207">When overridden in a derived class, returns the value of a field supported by a given object.</span></span></summary>
        <returns><span data-ttu-id="ce584-208">이 인스턴스에서 반영한 필드의 값을 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-208">An object containing the value of the field reflected by this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-209">정적 필드 이면 `obj` 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-209">If the field is static, `obj` is ignored.</span></span> <span data-ttu-id="ce584-210">비정적 필드에 대 한 `obj` 상속 하거나 필드를 선언 하는 클래스의 인스턴스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-210">For non-static fields, `obj` should be an instance of a class that inherits or declares the field.</span></span> <span data-ttu-id="ce584-211">반환 형식이 `GetValue` 는 `Object`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-211">Note that the return type of `GetValue` is `Object`.</span></span> <span data-ttu-id="ce584-212">예를 들어 필드가 기본 부울 값을 갖는 경우 값을 인스턴스의 `Object` 와 적절 한 부울 값이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-212">For example, if the field holds a Boolean primitive value, an instance of `Object` with the appropriate Boolean value is returned.</span></span> <span data-ttu-id="ce584-213">값을 반환 하기 전에 `GetValue` 사용자에 대 한 액세스 권한이 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-213">Before returning the value, `GetValue` checks to see if the user has access permission.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-214">완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-214">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="ce584-215">즉, 개인 생성자, 메서드, 필드 및 속성 액세스 하 고 수 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 통해 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-215">That is, private constructors, methods, fields, and properties can be accessed and invoked through reflection whenever the code is fully trusted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-216">부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-216">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="ce584-217">(참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="ce584-217">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce584-218">이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-218">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-219">다음 예제에서는 <xref:System.Reflection.FieldInfo.GetValue%2A> 정적 필드의 값을 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-219">The following example uses the <xref:System.Reflection.FieldInfo.GetValue%2A> method to retrieve the value of a static field.</span></span> <span data-ttu-id="ce584-220">값을 `obj` 인수가 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-220">Note that the value of the `obj` argument is `null`.</span></span>  
  
 [!code-cpp[getfldval#1](~/samples/snippets/cpp/VS_Snippets_CLR/GetFldVal/CPP/getfldval.cpp#1)]
 [!code-csharp[getfldval#1](~/samples/snippets/csharp/VS_Snippets_CLR/GetFldVal/CS/getfldval.cs#1)]
 [!code-vb[getfldval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GetFldVal/VB/getfldval.vb#1)]  
  
 <span data-ttu-id="ce584-221">다음 예제에서는 배열을 검색 <xref:System.Reflection.FieldInfo> 의 필드를 나타내는 개체를 `FieldsClass` 형식 및 호출 합니다 <xref:System.Reflection.FieldInfo.GetValue%2A> 에 대 한 각 필드의 값을 표시 하는 `fieldsInst` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-221">The following example retrieves an array of <xref:System.Reflection.FieldInfo> objects that represents the fields of the `FieldsClass` type, and then calls the <xref:System.Reflection.FieldInfo.GetValue%2A> to display the value of each field for the `fieldsInst` object.</span></span>  
  
 [!code-cpp[FieldInfo_GetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_GetValue/CPP/fieldinfo_getvalue.cpp#1)]
 [!code-csharp[FieldInfo_GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_GetValue/CS/fieldinfo_getvalue.cs#1)]
 [!code-vb[FieldInfo_GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_GetValue/VB/fieldinfo_getvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="ce584-222"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 <see cref="T:System.Exception" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-222">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="ce584-223">필드가 비정적이며 <paramref name="obj" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-223">The field is non-static and <paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ce584-224">필드가 리터럴로 표시되지만 필드에 허용된 리터럴 형식이 하나도 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-224">A field is marked literal, but the field does not have one of the accepted literal types.</span></span></exception>
        <exception cref="T:System.FieldAccessException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="ce584-225"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.MemberAccessException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-225">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="ce584-226">호출자에게 이 필드에 액세스할 수 있는 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-226">The caller does not have permission to access this field.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce584-227"><paramref name="obj" /> 클래스에서 메서드를 선언하지도 않고 상속하지도 않은 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-227">The method is neither declared nor inherited by the class of <paramref name="obj" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ce584-228">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-228">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ce584-229">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ce584-229">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetValueDirect">
      <MemberSignature Language="C#" Value="public virtual object GetValueDirect (TypedReference obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValueDirect(valuetype System.TypedReference obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueDirect (obj As TypedReference) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetValueDirect(TypedReference obj);" />
      <MemberSignature Language="F#" Value="abstract member GetValueDirect : TypedReference -&gt; obj&#xA;override this.GetValueDirect : TypedReference -&gt; obj" Usage="fieldInfo.GetValueDirect obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetValueDirect(System.TypedReference)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.TypedReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ce584-230">특정 위치에 대한 관리되는 포인터와 해당 위치에 저장될 수 있는 형식의 런타임 표현을 캡슐화하는 <see cref="T:System.TypedReference" /> 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-230">A <see cref="T:System.TypedReference" /> structure that encapsulates a managed pointer to a location and a runtime representation of the type that might be stored at that location.</span></span></param>
        <summary><span data-ttu-id="ce584-231">지정된 개체에서 지원하는 필드 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-231">Returns the value of a field supported by a given object.</span></span></summary>
        <returns><span data-ttu-id="ce584-232">필드 값을 포함하는 <see langword="Object" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-232">An <see langword="Object" /> containing a field value.</span></span></returns>
        <remarks>To be added.</remarks>
        <altCompliant cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" />
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ce584-233">호출자에게 대체할 수 있는 CLS(공용 언어 사양)가 필요하지만 이 메서드가 대신 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-233">The caller requires the Common Language Specification (CLS) alternative, but called this method instead.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ce584-234">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-234">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ce584-235">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ce584-235">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAssembly : bool" Usage="System.Reflection.FieldInfo.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-236"><see cref="F:System.Reflection.FieldAttributes.Assembly" />에서 이 필드의 잠재적 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 필드는 같은 어셈블리의 다른 형식에만 표시되고 어셈블리 외부의 파생 형식에는 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-236">Gets a value indicating whether the potential visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.Assembly" />; that is, the field is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span></span></summary>
        <value><span data-ttu-id="ce584-237"><see cref="F:System.Reflection.FieldAttributes.Assembly" />에서 이 필드의 표시 유형을 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-237"><see langword="true" /> if the visibility of this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.Assembly" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-238">필드의 실제 표시 여부는 해당 형식의 표시 유형과로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-238">The actual visibility of a field is limited by the visibility of its type.</span></span> <span data-ttu-id="ce584-239">합니다 <xref:System.Reflection.FieldInfo.IsAssembly%2A> 속성 수 있습니다 `true` 필드의 경우 있지만 경우 private 중첩 된 형식의 필드는 필드를 포함 하는 형식 외부에서 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-239">The <xref:System.Reflection.FieldInfo.IsAssembly%2A> property might be `true` for a field, but if it is a field of a private nested type then the field is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="ce584-240">필드의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.FieldAttributes.Assembly?displayProperty=nameWithType> 만 표시 한정자가 하는 경우 `internal` (`Friend` Visual Basic에서).</span><span class="sxs-lookup"><span data-stu-id="ce584-240">The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="ce584-241">이 속성은 `false` 필드에 대 한 `protected internal` C#에서 (`Protected Friend` Visual Basic에서는 `protected public` c + +에서); 사용을 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> 이러한 필드를 식별 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-241">This property is `false` for fields that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> property to identify such fields.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-242">다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 필드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>를 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-242">The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-243">Visual Basic 및 C# 언어를 사용 하 여 필드를 정의할 수 없습니다 <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-243">The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamily" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamily : bool" Usage="System.Reflection.FieldInfo.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-244"><see cref="F:System.Reflection.FieldAttributes.Family" />에서 이 필드의 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 필드는 해당 클래스 및 파생 클래스에만 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-244">Gets a value indicating whether the visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.Family" />; that is, the field is visible only within its class and derived classes.</span></span></summary>
        <value><span data-ttu-id="ce584-245"><see cref="F:System.Reflection.FieldAttributes.Family" />에서 이 필드에 대한 액세스를 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-245"><see langword="true" /> if access to this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.Family" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-246">필드의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.FieldAttributes.Family?displayProperty=nameWithType> 만 표시 한정자가 하는 경우 `protected`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-246">The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="ce584-247">이 속성은 `false` 필드에 대 한 `protected internal` C#에서 (`Protected Friend` Visual Basic에서는 `protected public` c + +에서); 사용을 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> 이러한 필드를 식별 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-247">This property is `false` for fields that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> property to identify such fields.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-248">다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 필드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>를 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-248">The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-249">Visual Basic 및 C# 언어를 사용 하 여 필드를 정의할 수 없습니다 <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-249">The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Type" />
        <altmember cref="P:System.Reflection.FieldInfo.IsAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyAndAssembly : bool" Usage="System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-250"><see cref="F:System.Reflection.FieldAttributes.FamANDAssem" />에서 이 필드의 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 필드는 같은 어셈블리에 있는 경우에만 파생 클래스에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-250">Gets a value indicating whether the visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.FamANDAssem" />; that is, the field can be accessed from derived classes, but only if they are in the same assembly.</span></span></summary>
        <value><span data-ttu-id="ce584-251"><see cref="F:System.Reflection.FieldAttributes.FamANDAssem" />에서 이 필드에 대한 액세스를 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-251"><see langword="true" /> if access to this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-252">필드에 있으면 <xref:System.Reflection.FieldAttributes.FamANDAssem> 수준 표시를 호출할 수 있습니다 다른 형식에서가 아니라 하지만 동일한 어셈블리에 있는 파생된 클래스에 있는 멤버에서입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-252">If a field has <xref:System.Reflection.FieldAttributes.FamANDAssem> level visibility, it can be called from any member in a derived class that is also in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="ce584-253">필드의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> 표시 한정자가 하는 경우 `protected private` c + +에서입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-253">The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="ce584-254">Visual Basic 또는 C#에서 이러한 가시성을 사용 하 여 필드를 정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-254">Fields with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-255">다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 필드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>를 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-255">The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-256">Visual Basic 및 C# 언어를 사용 하 여 필드를 정의할 수 없습니다 <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-256">The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="P:System.Reflection.FieldInfo.IsAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyOrAssembly : bool" Usage="System.Reflection.FieldInfo.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-257"><see cref="F:System.Reflection.FieldAttributes.FamORAssem" />에서 이 필드의 잠재적 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 필드는 파생 클래스(있는 경우) 및 같은 어셈블리의 클래스에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-257">Gets a value indicating whether the potential visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.FamORAssem" />; that is, the field can be accessed by derived classes wherever they are, and by classes in the same assembly.</span></span></summary>
        <value><span data-ttu-id="ce584-258"><see cref="F:System.Reflection.FieldAttributes.FamORAssem" />에서 이 필드에 대한 액세스를 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-258"><see langword="true" /> if access to this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-259">필드에 있으면 <xref:System.Reflection.FieldAttributes.FamORAssem> 수준 표시 유형이 호출 될 수 파생된 클래스에서 모든 멤버 또는 멤버는 같은 어셈블리에 있지만 다른 형식에서는 상속할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-259">If a field has <xref:System.Reflection.FieldAttributes.FamORAssem> level visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="ce584-260">필드의 실제 표시 여부는 해당 형식의 표시 유형과로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-260">The actual visibility of a field is limited by the visibility of its type.</span></span> <span data-ttu-id="ce584-261">합니다 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> 속성 수 있습니다 `true` 필드의 경우 있지만 경우 private 중첩 된 형식의 필드는 필드를 포함 하는 형식 외부에서 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-261">The <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> property might be `true` for a field, but if it is a field of a private nested type then the field is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="ce584-262">필드의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.FieldAttributes.FamORAssem?displayProperty=nameWithType> 표시 한정자가 하는 경우 `protected internal` C#에서 (`Protected Friend` Visual Basic에서는 `protected public` c + +에서).</span><span class="sxs-lookup"><span data-stu-id="ce584-262">The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-263">다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 필드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>를 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-263">The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-264">Visual Basic 및 C# 언어를 사용 하 여 필드를 정의할 수 없습니다 <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-264">The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="P:System.Reflection.FieldInfo.IsAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsInitOnly">
      <MemberSignature Language="C#" Value="public bool IsInitOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsInitOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitOnly : bool" Usage="System.Reflection.FieldInfo.IsInitOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsInitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-265">필드가 생성자의 본문에만 적용될 수 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-265">Gets a value indicating whether the field can only be set in the body of the constructor.</span></span></summary>
        <value><span data-ttu-id="ce584-266">필드에 <see langword="true" /> 특성 집합이 있으면 <see langword="InitOnly" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-266"><see langword="true" /> if the field has the <see langword="InitOnly" /> attribute set; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-267">반환된 값이 `true`, 필드를 초기화할 수만 및 이후 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-267">If the returned value is `true`, the field can only be initialized, and is read-only thereafter.</span></span>  
  
 <span data-ttu-id="ce584-268">가져오려는 합니다 `IsInitOnly` 속성을 먼저 클래스를 가져옵니다 `Type`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-268">To get the `IsInitOnly` property, first get the class `Type`.</span></span> <span data-ttu-id="ce584-269">`Type`, 가져오기는 `FieldInfo`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-269">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="ce584-270">`FieldInfo`, 가져오기는 `IsInitOnly` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-270">From the `FieldInfo`, get the `IsInitOnly` property.</span></span> <span data-ttu-id="ce584-271">Public이 아닌 필드에 액세스 하려면 결합 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 중 하나 또는 모두를 사용 하 여 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 하 고 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 에 `GetField` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ce584-271">To access a non-public field, combine <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> with either or both of <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in the `GetField` method.</span></span>  
  
 <span data-ttu-id="ce584-272">`IsInitOnly` 속성을 설정 하는 경우는 <xref:System.Reflection.FieldAttributes.InitOnly?displayProperty=nameWithType> 특성이 설정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-272">The `IsInitOnly` property is set when the <xref:System.Reflection.FieldAttributes.InitOnly?displayProperty=nameWithType> attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-273">다음 예제에서는 두 개의 필드가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-273">In the following example, two fields are created.</span></span> <span data-ttu-id="ce584-274">두 번째 필드는 읽기 전용, set 접근자가 없고 필요 하 고 `IsInitOnly` 로 설정 된 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-274">The second field is read-only, having no set accessor, and `IsInitOnly` is set to `true`.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsInitOnly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsInitOnly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsInitOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example/VB/source.vb#1)]  
  
 <span data-ttu-id="ce584-275">이 코드의 결과는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-275">This code produces the following output:</span></span>  
  
 <span data-ttu-id="ce584-276">Reflection.FieldInfo</span><span class="sxs-lookup"><span data-stu-id="ce584-276">Reflection.FieldInfo</span></span>  
  
 <span data-ttu-id="ce584-277">-A-Myfielda 수정 IsInitOnly = False</span><span class="sxs-lookup"><span data-stu-id="ce584-277">Myfielda - A- modified, IsInitOnly = False</span></span>  
  
 <span data-ttu-id="ce584-278">Myfieldb-B 읽기 전용 필드를 IsInitOnly = True</span><span class="sxs-lookup"><span data-stu-id="ce584-278">Myfieldb - B readonly field, IsInitOnly = True</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="IsLiteral">
      <MemberSignature Language="C#" Value="public bool IsLiteral { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLiteral" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsLiteral" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLiteral As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLiteral { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLiteral : bool" Usage="System.Reflection.FieldInfo.IsLiteral" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsLiteral</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-279">값을 컴파일 타임에만 쓰고 변경할 수 없는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-279">Gets a value indicating whether the value is written at compile time and cannot be changed.</span></span></summary>
        <value><span data-ttu-id="ce584-280">필드에 <see langword="true" /> 특성 집합이 있으면 <see langword="Literal" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-280"><see langword="true" /> if the field has the <see langword="Literal" /> attribute set; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-281">`IsLiteral` 속성을 설정 하는 경우는 `FieldAttributes.Literal` 특성이 설정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-281">The `IsLiteral` property is set when the `FieldAttributes.Literal` attribute is set.</span></span> <span data-ttu-id="ce584-282">이 특성을 설정 하는 경우 필드를 변경할 수 없습니다 하며 일정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-282">If this attribute is set, the field cannot be changed and is constant.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotSerialized">
      <MemberSignature Language="C#" Value="public bool IsNotSerialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotSerialized" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsNotSerialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotSerialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotSerialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotSerialized : bool" Usage="System.Reflection.FieldInfo.IsNotSerialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsNotSerialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-283">이 필드에 <see langword="NotSerialized" /> 특성이 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-283">Gets a value indicating whether this field has the <see langword="NotSerialized" /> attribute.</span></span></summary>
        <value><span data-ttu-id="ce584-284">필드에 <see langword="true" /> 특성 집합이 있으면 <see langword="NotSerialized" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-284"><see langword="true" /> if the field has the <see langword="NotSerialized" /> attribute set; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-285">합니다 `IsNotSerialized` 속성이 반환 `true` 필드를 사용 하 여 표시 되 면를 `FieldAttributes.NotSerialized` 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-285">The `IsNotSerialized` property returns `true` when the field is marked with the `FieldAttributes.NotSerialized` flag.</span></span> <span data-ttu-id="ce584-286">이 플래그는 필드를 설정 하는 경우 필드 형식이 원격 serialize 할 필요가 없습니다 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-286">When this flag is set on a field, it indicates that the field does not have to be serialized when the type is remoted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-287">다음 예제에서는 MyClass의 필드의 필드 정보를 가져오고, 필드를 serialize 할 수 있는지 확인 하 고 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-287">The following example gets the field information of the fields of MyClass, determines if the fields can be serialized, and displays the results.</span></span>  
  
 [!code-cpp[FieldInfo_IsNotSerialized#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsNotSerialized/CPP/fieldinfo_isnotserialized.cpp#1)]
 [!code-csharp[FieldInfo_IsNotSerialized#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsNotSerialized/CS/fieldinfo_isnotserialized.cs#1)]
 [!code-vb[FieldInfo_IsNotSerialized#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsNotSerialized/VB/fieldinfo_isnotserialized.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPinvokeImpl">
      <MemberSignature Language="C#" Value="public bool IsPinvokeImpl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPinvokeImpl" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsPinvokeImpl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPinvokeImpl As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPinvokeImpl { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPinvokeImpl : bool" Usage="System.Reflection.FieldInfo.IsPinvokeImpl" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsPinvokeImpl</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-288">해당 <see langword="PinvokeImpl" /> 속성이 <see cref="T:System.Reflection.FieldAttributes" />에 설정되어 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-288">Gets a value indicating whether the corresponding <see langword="PinvokeImpl" /> attribute is set in <see cref="T:System.Reflection.FieldAttributes" />.</span></span></summary>
        <value><span data-ttu-id="ce584-289"><see langword="true" /> 특성이 <see cref="T:System.Reflection.FieldAttributes" />에 설정되어 있으면 <see langword="PinvokeImpl" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-289"><see langword="true" /> if the <see langword="PinvokeImpl" /> attribute is set in <see cref="T:System.Reflection.FieldAttributes" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ce584-290">다음 예제에서는 클래스를 만들고 표시 이름, 필드 및 <xref:System.Reflection.FieldInfo.IsPinvokeImpl%2A> 필드의 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-290">The following example creates a class and displays the name, field and <xref:System.Reflection.FieldInfo.IsPinvokeImpl%2A> property value of the field.</span></span>  
  
 [!code-cpp[FieldInfo_IsPInvokeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl/CPP/fieldinfo_ispinvokeimpl.cpp#1)]
 [!code-csharp[FieldInfo_IsPInvokeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl/CS/fieldinfo_ispinvokeimpl.cs#1)]
 [!code-vb[FieldInfo_IsPInvokeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl/VB/fieldinfo_ispinvokeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrivate : bool" Usage="System.Reflection.FieldInfo.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-291">private 필드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-291">Gets a value indicating whether the field is private.</span></span></summary>
        <value><span data-ttu-id="ce584-292">private 필드이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-292"><see langword="true" /> if the field is private; otherwise; <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-293">전용 필드 멤버 함수 에서만에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-293">Private fields are accessible only from member functions.</span></span>  
  
 <span data-ttu-id="ce584-294">`IsPrivate` 속성을 설정 하는 경우는 `FieldAttributes.Private` 특성이 설정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-294">The `IsPrivate` property is set when the `FieldAttributes.Private` attribute is set.</span></span>  
  
 <span data-ttu-id="ce584-295">가져오려는 합니다 `IsPrivate` 속성을 먼저 클래스를 가져옵니다 `Type`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-295">To get the `IsPrivate` property, first get the class `Type`.</span></span> <span data-ttu-id="ce584-296">`Type`, 가져오기는 `FieldInfo`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-296">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="ce584-297">`FieldInfo`, 가져오기는 `IsPrivate` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-297">From the `FieldInfo`, get the `IsPrivate` property.</span></span> <span data-ttu-id="ce584-298">Public이 아닌 필드에 액세스 하려면 설정 합니다 `BindingFlags` 를 `NonPublic`, 및 `Static` 또는 `Instance` 에 `GetField` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ce584-298">To access a non-public field, set the `BindingFlags` to `NonPublic`, and either `Static` or `Instance` in the `GetField` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-299">다음 예제에서는 private 클래스의 필드 인지 여부를 나타내는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-299">The following example returns a value indicating whether or not the field of the class is private.</span></span>  
  
 [!code-cpp[FieldInfo_IsPrivate#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsPrivate/CPP/fieldinfo_isprivate.cpp#1)]
 [!code-csharp[FieldInfo_IsPrivate#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsPrivate/CS/fieldinfo_isprivate.cs#1)]
 [!code-vb[FieldInfo_IsPrivate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsPrivate/VB/fieldinfo_isprivate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Reflection.FieldInfo.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-300">public 필드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-300">Gets a value indicating whether the field is public.</span></span></summary>
        <value><span data-ttu-id="ce584-301">public 필드이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-301"><see langword="true" /> if this field is public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-302">공용 필드는 액세스할 수 있는 어디에서 나 해당 클래스가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-302">Public fields are accessible everywhere their corresponding classes are visible.</span></span>  
  
 <span data-ttu-id="ce584-303">`IsPublic` 속성을 설정 하는 경우는 `FieldAttributes.Public` 특성이 설정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-303">The `IsPublic` property is set when the `FieldAttributes.Public` attribute is set.</span></span>  
  
 <span data-ttu-id="ce584-304">가져오려는 합니다 `IsPublic` 속성을 먼저 클래스를 가져옵니다 `Type`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-304">To get the `IsPublic` property, first get the class `Type`.</span></span> <span data-ttu-id="ce584-305">`Type`, 가져오기는 `FieldInfo`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-305">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="ce584-306">`FieldInfo`, 가져오기는 `IsPublic` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-306">From the `FieldInfo`, get the `IsPublic` property.</span></span> <span data-ttu-id="ce584-307">보호 된 필드를 public이 아닌 경우 언제 든 지 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-307">If the field is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="ce584-308">Public이 아닌 필드에 액세스 하려면 설정 합니다 `BindingFlags` 를 `NonPublic`를 지정 `BindingFlags.Instance` 또는 `BindingFlags.Static`에 대 한 사용를 `GetField` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ce584-308">To access a nonpublic field, set the `BindingFlags` to `NonPublic`, specify either `BindingFlags.Instance` or `BindingFlags.Static`, and use this for the `GetField` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-309">다음 예제에서는 클래스의 필드에 public 또는 private 인지 여부를 나타내는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-309">The following example returns a value indicating whether or not the field of the class is public or private.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.FieldInfo.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-310">현재 필드가 현재 신뢰 수준에서 보안에 중요한 필드이거나 보안 안전에 중요한 필드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-310">Gets a value that indicates whether the current field is security-critical or security-safe-critical at the current trust level.</span></span></summary>
        <value><span data-ttu-id="ce584-311">현재 필드가 보안에 중요한 필드이거나 보안 안전에 중요한 필드인 경우 <see langword="true" />이고 투명 필드인 경우 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-311"><see langword="true" /> if the current field is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-312">합니다 <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에서 필드의 투명도 수준을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-312">The <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="ce584-313">이러한 속성의 조합도 표에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-313">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="ce584-314">보안 수준</span><span class="sxs-lookup"><span data-stu-id="ce584-314">Security level</span></span>|<span data-ttu-id="ce584-315">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="ce584-315">IsSecurityCritical</span></span>|<span data-ttu-id="ce584-316">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="ce584-316">IsSecuritySafeCritical</span></span>|<span data-ttu-id="ce584-317">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="ce584-317">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="ce584-318">중요</span><span class="sxs-lookup"><span data-stu-id="ce584-318">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="ce584-319">안전 중요</span><span class="sxs-lookup"><span data-stu-id="ce584-319">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="ce584-320">투명</span><span class="sxs-lookup"><span data-stu-id="ce584-320">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="ce584-321">이러한 속성을 사용 하는 것은 어셈블리 및 해당 형식과 멤버의 보안 주석을 검사 하 고 현재 신뢰 수준 검사 런타임 규칙을 복제 하는 보다 훨씬 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-321">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ce584-322">부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-322">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="ce584-323">어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임에서 어셈블리의 보안 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-323">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="ce584-324">어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-324">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="ce584-325">런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-325">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="ce584-326">반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-326">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="ce584-327">사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-327">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="ce584-328">리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-328">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="ce584-329">투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-329">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.FieldInfo.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-330">현재 필드가 현재 신뢰 수준에서 보안 안전에 중요한 필드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-330">Gets a value that indicates whether the current field is security-safe-critical at the current trust level.</span></span></summary>
        <value><span data-ttu-id="ce584-331">현재 필드가 현재 신뢰 수준에서 보안 안전에 중요한 필드인 경우 <see langword="true" />이고 보안에 중요한 필드이거나 투명 필드인 경우 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-331"><see langword="true" /> if the current field is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-332">합니다 <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에서 필드의 투명도 수준을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-332">The <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="ce584-333">이러한 속성의 조합도 표에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-333">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="ce584-334">보안 수준</span><span class="sxs-lookup"><span data-stu-id="ce584-334">Security level</span></span>|<span data-ttu-id="ce584-335">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="ce584-335">IsSecurityCritical</span></span>|<span data-ttu-id="ce584-336">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="ce584-336">IsSecuritySafeCritical</span></span>|<span data-ttu-id="ce584-337">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="ce584-337">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="ce584-338">중요</span><span class="sxs-lookup"><span data-stu-id="ce584-338">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="ce584-339">안전 중요</span><span class="sxs-lookup"><span data-stu-id="ce584-339">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="ce584-340">투명</span><span class="sxs-lookup"><span data-stu-id="ce584-340">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="ce584-341">이러한 속성을 사용 하는 것은 어셈블리 및 해당 형식과 멤버의 보안 주석을 검사 하 고 현재 신뢰 수준 검사 런타임 규칙을 복제 하는 보다 훨씬 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-341">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ce584-342">부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-342">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="ce584-343">어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임에서 어셈블리의 보안 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-343">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="ce584-344">어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-344">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="ce584-345">런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-345">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="ce584-346">반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-346">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="ce584-347">사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-347">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="ce584-348">리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-348">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="ce584-349">투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-349">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.FieldInfo.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-350">현재 필드가 현재 신뢰 수준에서 투명 필드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-350">Gets a value that indicates whether the current field is transparent at the current trust level.</span></span></summary>
        <value><span data-ttu-id="ce584-351">필드가 현재 신뢰 수준에서 보안에 투명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-351"><see langword="true" /> if the field is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-352">합니다 <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에서 필드의 투명도 수준을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-352">The <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="ce584-353">이러한 속성의 조합도 표에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-353">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="ce584-354">보안 수준</span><span class="sxs-lookup"><span data-stu-id="ce584-354">Security level</span></span>|<span data-ttu-id="ce584-355">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="ce584-355">IsSecurityCritical</span></span>|<span data-ttu-id="ce584-356">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="ce584-356">IsSecuritySafeCritical</span></span>|<span data-ttu-id="ce584-357">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="ce584-357">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="ce584-358">중요</span><span class="sxs-lookup"><span data-stu-id="ce584-358">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="ce584-359">안전 중요</span><span class="sxs-lookup"><span data-stu-id="ce584-359">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="ce584-360">투명</span><span class="sxs-lookup"><span data-stu-id="ce584-360">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="ce584-361">이러한 속성을 사용 하는 것은 어셈블리 및 해당 형식과 멤버의 보안 주석을 검사 하 고 현재 신뢰 수준 검사 런타임 규칙을 복제 하는 보다 훨씬 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-361">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ce584-362">부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-362">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="ce584-363">어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임에서 어셈블리의 보안 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-363">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="ce584-364">어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-364">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="ce584-365">런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-365">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="ce584-366">반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-366">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="ce584-367">사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-367">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="ce584-368">리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-368">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="ce584-369">투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-369">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.FieldInfo.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.FieldInfo.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-370">해당 <see langword="SpecialName" /> 특성이 <see cref="T:System.Reflection.FieldAttributes" /> 열거자에 설정되어 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-370">Gets a value indicating whether the corresponding <see langword="SpecialName" /> attribute is set in the <see cref="T:System.Reflection.FieldAttributes" /> enumerator.</span></span></summary>
        <value><span data-ttu-id="ce584-371"><see langword="true" /> 특성이 <see cref="T:System.Reflection.FieldAttributes" />에 설정되어 있으면 <see langword="SpecialName" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-371"><see langword="true" /> if the <see langword="SpecialName" /> attribute is set in <see cref="T:System.Reflection.FieldAttributes" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-372">로 시작 하거나 밑줄 문자 (_), 속성 접근자 및 메서드를 오버 로드할 연산자를 포함 하는 이름을 일부 컴파일러에서 특수 하 게 처리 해야 하는 이름의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-372">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of names that might require special treatment by some compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-373">다음 예제에서는 클래스의 필드는 SpecialName 특성을 포함 하는지 여부를 나타내는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-373">The following example returns a value indicating whether or not the fields in the class contain a SpecialName attribute.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStatic : bool" Usage="System.Reflection.FieldInfo.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-374">정적 필드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-374">Gets a value indicating whether the field is static.</span></span></summary>
        <value><span data-ttu-id="ce584-375">이 필드가 정적 필드이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-375"><see langword="true" /> if this field is static; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-376">필드는 정적 필드의 복사본 하나 형식의 모든 인스턴스에서 공유 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-376">When a field is static, one copy of the field is shared by all instances of the type.</span></span>  
  
 <span data-ttu-id="ce584-377">`IsStatic` 속성을 설정 하는 경우는 `FieldAttributes.Static` 특성이 설정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-377">The `IsStatic` property is set when the `FieldAttributes.Static` attribute is set.</span></span>  
  
 <span data-ttu-id="ce584-378">가져오려는 합니다 `IsStatic` 속성을 먼저 클래스를 가져옵니다 `Type`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-378">To get the `IsStatic` property, first get the class `Type`.</span></span> <span data-ttu-id="ce584-379">`Type`, 가져오기는 `FieldInfo`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-379">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="ce584-380">`FieldInfo`, 가져오기는 `IsStatic` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-380">From the `FieldInfo`, get the `IsStatic` property.</span></span> <span data-ttu-id="ce584-381">Public이 아닌 필드에 액세스 하려면 설정 합니다 `BindingFlags` 를 `NonPublic` 에 `GetField` 메서드는 내게 필요한 옵션 설정 및 `Instance` 또는 `Static`.</span><span class="sxs-lookup"><span data-stu-id="ce584-381">To access a non-public field, set the `BindingFlags` to `NonPublic` in the `GetField` method and set the accessibility to `Instance` or `Static`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-382">다음 예제에서는 지정된 된 필드는 정적 함수 이며 결과 표시 하는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-382">The following example determines whether the specified field is static and displays the result.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsStatic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsStatic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsStatic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="ce584-383">이 코드의 결과는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-383">This code produces the following output:</span></span>  
  
 <span data-ttu-id="ce584-384">Reflection.FieldInfo</span><span class="sxs-lookup"><span data-stu-id="ce584-384">Reflection.FieldInfo</span></span>  
  
 <span data-ttu-id="ce584-385">Myfielda-전용 필드입니다. IsStatic-False</span><span class="sxs-lookup"><span data-stu-id="ce584-385">Myfielda - A private field; IsStatic - False</span></span>  
  
 <span data-ttu-id="ce584-386">Myfieldb-B 정적 필드입니다. IsStatic-True</span><span class="sxs-lookup"><span data-stu-id="ce584-386">Myfieldb - B static field; IsStatic - True</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Reflection.FieldInfo.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce584-387">이 멤버가 필드임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-387">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a field.</span></span></summary>
        <value><span data-ttu-id="ce584-388">이 멤버가 필드임을 나타내는 <see cref="T:System.Reflection.MemberTypes" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-388">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-389">이 속성을 재정의 <xref:System.Reflection.MemberInfo.MemberType%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-389">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A>.</span></span> <span data-ttu-id="ce584-390">따라서 집합을 조사할 때 <xref:System.Reflection.MemberInfo> 개체에서 반환 된 배열에 예를 들어 <xref:System.Type.GetMembers%2A> - <xref:System.Reflection.MemberInfo.MemberType%2A> 속성에서 반환 <xref:System.Reflection.MemberTypes.Field?displayProperty=nameWithType> 지정된 된 멤버 필드를가 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-390">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.Field?displayProperty=nameWithType> only when a given member is a field.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-391">다음 예제에서는 지정된 된 멤버는 필드와 결과 표시 하는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-391">The following example determines whether the specified member is a field and displays the result.</span></span>  
  
 [!code-cpp[Classic FieldInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example/VB/source.vb#1)]  
  
 <span data-ttu-id="ce584-392">이 코드의 결과는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-392">This code produces the following output:</span></span>  
  
 <span data-ttu-id="ce584-393">Reflection.FieldInfo</span><span class="sxs-lookup"><span data-stu-id="ce584-393">Reflection.FieldInfo</span></span>  
  
 <span data-ttu-id="ce584-394">Myfield.field-전용 필드입니다. MemberType 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-394">Myfield.field - a private field; MemberType is a Field</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.FieldInfo left, class System.Reflection.FieldInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As FieldInfo, right As FieldInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::FieldInfo ^ left, System::Reflection::FieldInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.FieldInfo * System.Reflection.FieldInfo -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.FieldInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.FieldInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ce584-395">비교할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-395">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ce584-396">비교할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-396">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="ce584-397">두 <see cref="T:System.Reflection.FieldInfo" /> 개체가 같은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-397">Indicates whether two <see cref="T:System.Reflection.FieldInfo" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="ce584-398"><see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-398"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.FieldInfo left, class System.Reflection.FieldInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As FieldInfo, right As FieldInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::FieldInfo ^ left, System::Reflection::FieldInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.FieldInfo * System.Reflection.FieldInfo -&gt; bool" Usage="System.Reflection.FieldInfo.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.FieldInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.FieldInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ce584-399">비교할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-399">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ce584-400">비교할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-400">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="ce584-401">두 <see cref="T:System.Reflection.FieldInfo" /> 개체가 같지 않은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-401">Indicates whether two <see cref="T:System.Reflection.FieldInfo" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="ce584-402"><see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-402"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ce584-403">지정된 값에 대한 개체의 필드 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-403">Sets the value of the field for the given object to the given value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object obj, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (obj As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetValue(System::Object ^ obj, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj -&gt; unit&#xA;override this.SetValue : obj * obj -&gt; unit" Usage="fieldInfo.SetValue (obj, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.SetValue(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ce584-404">필드 값이 설정될 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-404">The object whose field value will be set.</span></span></param>
        <param name="value"><span data-ttu-id="ce584-405">필드에 할당할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-405">The value to assign to the field.</span></span></param>
        <summary><span data-ttu-id="ce584-406">지정된 개체에서 지원하는 필드 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-406">Sets the value of the field supported by the given object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-407">이 메서드는 할당 `value` 개체의이 인스턴스에 의해 리플렉션된 필드 `obj`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-407">This method will assign `value` to the field reflected by this instance on object `obj`.</span></span> <span data-ttu-id="ce584-408">정적 필드 이면 `obj` 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-408">If the field is static, `obj` will be ignored.</span></span> <span data-ttu-id="ce584-409">비정적 필드에 대 한 `obj` 상속 하거나 필드를 선언 하는 클래스의 인스턴스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-409">For non-static fields, `obj` should be an instance of a class that inherits or declares the field.</span></span> <span data-ttu-id="ce584-410">이 새 값으로 전달 되는 `Object`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-410">The new value is passed as an `Object`.</span></span> <span data-ttu-id="ce584-411">예를 들어, 필드의 형식이 부울, 인스턴스의 경우 `Object` 와 적절 한 부울 값이 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-411">For example, if the field's type is Boolean, an instance of `Object` with the appropriate Boolean value is passed.</span></span> <span data-ttu-id="ce584-412">값을 설정 하기 전에 `SetValue` 사용자에 대 한 액세스 권한이 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-412">Before setting the value, `SetValue` checks to see if the user has access permission.</span></span> <span data-ttu-id="ce584-413">이 마지막 메서드는 다음을 호출 하는 데 편리한 메서드입니다 `SetValue` 메서드.</span><span class="sxs-lookup"><span data-stu-id="ce584-413">This final method is a convenience method for calling the following `SetValue` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-414">완전히 신뢰할 수 있는 코드에 액세스 하 고 private 생성자, 메서드, 필드 및 리플렉션을 사용 하 여 속성을 호출 하는 데 필요한 권한을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-414">Fully trusted code has the permissions that are needed to access and invoke private constructors, methods, fields, and properties using reflection.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-415">부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-415">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="ce584-416">(참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="ce584-416">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce584-417">이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-417">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce584-418">다음 예에서는 필드의 값을 설정, 가져옵니다 및 값을 표시, 필드를 수정 및 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-418">The following example sets the value of a field, gets and displays the value, modifies the field, and displays the result.</span></span>  
  
 [!code-cpp[FieldInfo_SetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_SetValue/CPP/fieldinfo_setvalue.cpp#1)]
 [!code-csharp[FieldInfo_SetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_SetValue/CS/fieldinfo_setvalue.cs#1)]
 [!code-vb[FieldInfo_SetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_SetValue/VB/fieldinfo_setvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FieldAccessException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="ce584-419"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.MemberAccessException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-419">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="ce584-420">호출자에게 이 필드에 액세스할 수 있는 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-420">The caller does not have permission to access this field.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="ce584-421"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 <see cref="T:System.Exception" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-421">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="ce584-422"><paramref name="obj" /> 매개 변수가 <see langword="null" />이고 필드는 인스턴스 필드인 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-422">The <paramref name="obj" /> parameter is <see langword="null" /> and the field is an instance field.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce584-423">필드가 이벤트에 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-423">The field does not exist on the object.</span></span>  
  
<span data-ttu-id="ce584-424">또는</span><span class="sxs-lookup"><span data-stu-id="ce584-424">-or-</span></span> 
<span data-ttu-id="ce584-425"><paramref name="value" /> 매개 변수를 변환하고 필드에 저장할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-425">The <paramref name="value" /> parameter cannot be converted and stored in the field.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ce584-426">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-426">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ce584-427">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ce584-427">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ce584-428">init 전용 필드를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-428">for updating init-only fields.</span></span> <span data-ttu-id="ce584-429">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span><span class="sxs-lookup"><span data-stu-id="ce584-429">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Object ^ obj, System::Object ^ value, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj * System.Reflection.BindingFlags * System.Reflection.Binder * System.Globalization.CultureInfo -&gt; unit" Usage="fieldInfo.SetValue (obj, value, invokeAttr, binder, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ce584-430">필드 값이 설정될 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-430">The object whose field value will be set.</span></span></param>
        <param name="value"><span data-ttu-id="ce584-431">필드에 할당할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-431">The value to assign to the field.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="ce584-432">필요한 바인딩 형식을 지정하는 <see langword="Binder" /> 필드(예: <see langword="Binder.CreateInstance" /> 또는 <see langword="Binder.ExactBinding" />)입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-432">A field of <see langword="Binder" /> that specifies the type of binding that is desired (for example, <see langword="Binder.CreateInstance" /> or <see langword="Binder.ExactBinding" />).</span></span></param>
        <param name="binder"><span data-ttu-id="ce584-433">리플렉션을 통해 바인딩, 인수의 형식 변환 및 멤버 호출을 가능하게 하는 속성 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-433">A set of properties that enables the binding, coercion of argument types, and invocation of members through reflection.</span></span> <span data-ttu-id="ce584-434"><paramref name="binder" />가 <see langword="null" />이면 <see langword="Binder.DefaultBinding" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-434">If <paramref name="binder" /> is <see langword="null" />, then <see langword="Binder.DefaultBinding" /> is used.</span></span></param>
        <param name="culture"><span data-ttu-id="ce584-435">특정 문화권의 소프트웨어 기본 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-435">The software preferences of a particular culture.</span></span></param>
        <summary><span data-ttu-id="ce584-436">파생 클래스에 재정의할 때 지정된 개체에서 지원하는 필드 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-436">When overridden in a derived class, sets the value of the field supported by the given object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-437">이 메서드는 할당 `value` 의이 인스턴스에 의해 리플렉션된 필드 `obj`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-437">This method will assign `value` to the field reflected by this instance on `obj`.</span></span> <span data-ttu-id="ce584-438">정적 필드 이면 `obj` 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-438">If the field is static, `obj` will be ignored.</span></span> <span data-ttu-id="ce584-439">비정적 필드에 대 한 `obj` 상속 하거나 필드를 선언 하는 클래스의 인스턴스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-439">For non-static fields, `obj` should be an instance of a class that inherits or declares the field.</span></span> <span data-ttu-id="ce584-440">이 새 값으로 전달 되는 `Object`합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-440">The new value is passed as an `Object`.</span></span> <span data-ttu-id="ce584-441">예를 들어, 필드의 형식은 `Boolean`, 인스턴스의 `Object` 와 적절 한 부울 값이 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-441">For example, if the field's type is `Boolean`, an instance of `Object` with the appropriate Boolean value is passed.</span></span> <span data-ttu-id="ce584-442">값을 설정 하기 전에 `SetValue` 사용자에 대 한 액세스 권한이 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-442">Before setting the value, `SetValue` checks to see if the user has access permission.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-443">완전히 신뢰할 수 있는 코드에 액세스 하 고 private 생성자, 메서드, 필드 및 리플렉션을 사용 하 여 속성을 호출 하는 데 필요한 권한을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-443">Fully trusted code has the permissions that are needed to access and invoke private constructors, methods, fields, and properties using reflection.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce584-444">부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-444">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="ce584-445">(참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="ce584-445">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce584-446">이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-446">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FieldAccessException"><span data-ttu-id="ce584-447">호출자에게 이 필드에 액세스할 수 있는 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-447">The caller does not have permission to access this field.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="ce584-448"><paramref name="obj" /> 매개 변수가 <see langword="null" />이고 필드는 인스턴스 필드인 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-448">The <paramref name="obj" /> parameter is <see langword="null" /> and the field is an instance field.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce584-449">필드가 이벤트에 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-449">The field does not exist on the object.</span></span>  
  
<span data-ttu-id="ce584-450">또는</span><span class="sxs-lookup"><span data-stu-id="ce584-450">-or-</span></span> 
<span data-ttu-id="ce584-451"><paramref name="value" /> 매개 변수를 변환하고 필드에 저장할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-451">The <paramref name="value" /> parameter cannot be converted and stored in the field.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ce584-452">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-452">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ce584-453">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ce584-453">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ce584-454">init 전용 필드를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-454">for updating init-only fields.</span></span> <span data-ttu-id="ce584-455">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span><span class="sxs-lookup"><span data-stu-id="ce584-455">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValueDirect">
      <MemberSignature Language="C#" Value="public virtual void SetValueDirect (TypedReference obj, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValueDirect(valuetype System.TypedReference obj, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValueDirect (obj As TypedReference, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetValueDirect(TypedReference obj, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetValueDirect : TypedReference * obj -&gt; unit&#xA;override this.SetValueDirect : TypedReference * obj -&gt; unit" Usage="fieldInfo.SetValueDirect (obj, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.SetValueDirect(System.TypedReference,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.TypedReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ce584-456">위치의 관리되는 포인터와 해당 위치에서 저장될 수 있는 형식의 런타임 표현을 캡슐화하는 <see cref="T:System.TypedReference" /> 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-456">A <see cref="T:System.TypedReference" /> structure that encapsulates a managed pointer to a location and a runtime representation of the type that can be stored at that location.</span></span></param>
        <param name="value"><span data-ttu-id="ce584-457">필드에 할당할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-457">The value to assign to the field.</span></span></param>
        <summary><span data-ttu-id="ce584-458">지정된 개체에서 지원하는 필드 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-458">Sets the value of the field supported by the given object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ce584-459">부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-459">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="ce584-460">(참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="ce584-460">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce584-461">이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-461">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ce584-462">호출자에게 대체할 수 있는 CLS(공용 언어 사양)가 필요하지만 이 메서드가 대신 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="ce584-462">The caller requires the Common Language Specification (CLS) alternative, but called this method instead.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ce584-463">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-463">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ce584-464">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ce584-464">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _FieldInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _FieldInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_FieldInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="ce584-465">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-465">Reserved for future use.</span></span> <span data-ttu-id="ce584-466">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-466">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="ce584-467">매핑할 전달된 이름의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-467">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="ce584-468">매핑할 이름의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-468">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="ce584-469">이름을 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-469">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="ce584-470">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-470">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="ce584-471">이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-471">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-472">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-472">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ce584-473">에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-473">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ce584-474">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-474">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetType">
      <MemberSignature Language="C#" Value="Type _FieldInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._FieldInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _FieldInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._FieldInfo.GetType() = System::Runtime::InteropServices::_FieldInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce584-475"><see cref="T:System.Type" /> 형식을 나타내는 <see cref="T:System.Reflection.FieldInfo" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-475">Gets a <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.FieldInfo" /> type.</span></span></summary>
        <returns><span data-ttu-id="ce584-476"><see cref="T:System.Reflection.FieldInfo" /> 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-476">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.FieldInfo" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _FieldInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _FieldInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_FieldInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="ce584-477">반환할 형식 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-477">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="ce584-478">형식 정보의 로캘 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-478">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="ce584-479">요청된 형식 정보 개체에 대한 포인터를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-479">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="ce584-480">인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-480">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-481">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-481">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ce584-482">에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-482">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ce584-483">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-483">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _FieldInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _FieldInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_FieldInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="ce584-484">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-484">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="ce584-485">개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</span><span class="sxs-lookup"><span data-stu-id="ce584-485">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-486">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-486">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ce584-487">에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-487">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ce584-488">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-488">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.Invoke">
      <MemberSignature Language="C#" Value="void _FieldInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _FieldInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_FieldInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="ce584-489">멤버를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-489">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="ce584-490">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-490">Reserved for future use.</span></span> <span data-ttu-id="ce584-491">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-491">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="ce584-492">인수를 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-492">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="ce584-493">호출의 컨텍스트를 설명하는 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-493">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="ce584-494">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-494">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="ce584-495">결과를 저장할 위치에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-495">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="ce584-496">예외 정보가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-496">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="ce584-497">오류가 있는 첫 번째 인수의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-497">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="ce584-498">개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-498">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce584-499">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-499">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ce584-500">에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-500">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ce584-501">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ce584-501">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>