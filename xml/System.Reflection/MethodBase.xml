<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ecd2f74956892406bf8baa3f481d29611cf68570" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57933562" /></Metadata><TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <TypeSignature Language="F#" Value="type MethodBase = class&#xA;    inherit MemberInfo&#xA;    interface _MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="687de-101">메서드와 생성자에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-101">Provides information about methods and constructors.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-102">`MethodBase` 기본 클래스인 <xref:System.Reflection.MethodInfo> 고 <xref:System.Reflection.ConstructorInfo>입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-102">`MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="687de-103">상속자에 대 한 완전 신뢰 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-103">for full trust for inheritors.</span></span> <span data-ttu-id="687de-104">부분적으로 신뢰할 수 있는 코드에서이 클래스를 상속할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-104">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="687de-105">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-105">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="687de-106">상속 하는 경우 <see langword="MethodBase" />, 다음 멤버를 재정의 해야 합니다: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />를 <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />를 <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> 하십시오 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, 및 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-106">When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span></span></para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="687de-107"><see cref="T:System.Reflection.MethodBase" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-107">Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="687de-108">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-108">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="687de-109">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="687de-109">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.MethodBase.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-110">이 메서드와 관련된 특성을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-110">Gets the attributes associated with this method.</span></span></summary>
        <value><span data-ttu-id="687de-111"><see cref="T:System.Reflection.MethodAttributes" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-111">One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-112">모든 멤버는 특정 형식의 멤버와 관련 하 여 정의 된 특성 집합을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-112">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span>  
  
 <span data-ttu-id="687de-113">가져오려는 <xref:System.Reflection.MethodAttributes>, 먼저 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-113">To get the <xref:System.Reflection.MethodAttributes>, first get the type.</span></span> <span data-ttu-id="687de-114">형식에서 메서드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-114">From the type, get the method.</span></span> <span data-ttu-id="687de-115">메서드에서 가져오기는 <xref:System.Reflection.MethodAttributes>합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-115">From the method, get the <xref:System.Reflection.MethodAttributes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-116">다음 코드 예제에서는 사용자 정의 메서드 Mymethod의 특성을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-116">The following code example displays the attributes of the user-defined method Mymethod.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 <span data-ttu-id="687de-117">이 코드의 결과는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-117">This code produces the following output:</span></span>  
  
 <span data-ttu-id="687de-118">Reflection.MethodBase.Attributes 샘플</span><span class="sxs-lookup"><span data-stu-id="687de-118">Reflection.MethodBase.Attributes Sample</span></span>  
  
 <span data-ttu-id="687de-119">Mymethodbase Void Mymethod (Int32, System.String ByRef System.String ByRef) =</span><span class="sxs-lookup"><span data-stu-id="687de-119">Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</span></span>  
  
 <span data-ttu-id="687de-120">PrivateScope</span><span class="sxs-lookup"><span data-stu-id="687de-120">PrivateScope</span></span>  
  
 <span data-ttu-id="687de-121">FamANDAssem</span><span class="sxs-lookup"><span data-stu-id="687de-121">FamANDAssem</span></span>  
  
 <span data-ttu-id="687de-122">패밀리</span><span class="sxs-lookup"><span data-stu-id="687de-122">Family</span></span>  
  
 <span data-ttu-id="687de-123">Public</span><span class="sxs-lookup"><span data-stu-id="687de-123">Public</span></span>  
  
 <span data-ttu-id="687de-124">HideBySig</span><span class="sxs-lookup"><span data-stu-id="687de-124">HideBySig</span></span>  
  
 <span data-ttu-id="687de-125">ReuseSlot</span><span class="sxs-lookup"><span data-stu-id="687de-125">ReuseSlot</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="687de-126">사용 합니다 <see cref="P:System.Reflection.MethodBase.Attributes" /> 메서드는 지 여부를 결정 하는 속성 <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />등.</span><span class="sxs-lookup"><span data-stu-id="687de-126">Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</span></span></para></block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.MethodBase.CallingConvention" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-127">이 메서드에 대한 호출 규칙을 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-127">Gets a value indicating the calling conventions for this method.</span></span></summary>
        <value><span data-ttu-id="687de-128">이 메서드에 대한 <see cref="T:System.Reflection.CallingConventions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-128">The <see cref="T:System.Reflection.CallingConventions" /> for this method.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-129">제네릭 메서드에 할당되지 않은 제네릭 형식 매개 변수가 포함되어 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-129">Gets a value indicating whether the generic method contains unassigned generic type parameters.</span></span></summary>
        <value><span data-ttu-id="687de-130">현재 <see cref="T:System.Reflection.MethodBase" /> 개체가 할당되지 않은 제네릭 형식 매개 변수를 포함하는 제네릭 메서드를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-130"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-131">메서드 자체의 형식 인수 또는 바깥쪽 형식에 개방형 생성된 형식 또는 제네릭 형식 정의 되지 않은 경우에 제네릭 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-131">A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</span></span> <span data-ttu-id="687de-132">형식 임의로 복잡할 수 있으므로이 재귀 결정을 내릴는 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-132">Because types can be arbitrarily complex, making this recursive determination is difficult.</span></span> <span data-ttu-id="687de-133">편의 위해 및 오류의 가능성을 줄이기 위해는 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성을 호출할 수 있는 닫힌된 생성 된 메서드를 구분 하기 위한 표준 방법이 제공 및 개방형 생성 메서드 일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-133">For convenience, and to reduce the chance of error, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="687de-134">경우는 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성이 반환 `true`, 메서드를 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-134">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, the method cannot be invoked.</span></span>  
  
 <span data-ttu-id="687de-135"><xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성 형식 매개 변수를 재귀적으로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-135">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="687de-136">예를 들어 반환 `true` 개방형 형식에서 모든 메서드에 대 한 `A<T>` (`A(Of T)` Visual Basic의) 경우에 자체 메서드는 제네릭이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="687de-136">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="687de-137">동작을 사용 하 여이 대조해 보세요 합니다 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 반환 하는 속성 `false` 이러한 메서드에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-137">Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.</span></span>  
  
 <span data-ttu-id="687de-138">마찬가지로, 합니다 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property 매개 변수 반환 `true` 모든 생성자는 개방형 형식에 대해도 생성자 없습니다 자체의 형식 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-138">Similarly, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.</span></span>  
  
 <span data-ttu-id="687de-139">제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-139">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="687de-140">제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-140">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBase.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="687de-141">이 인스턴스와 비교할 개체 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-141">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="687de-142">@FSHO2@이 인스턴스가 지정한 개체와 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-142">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="687de-143"><see langword="true" />가 이 인스턴스의 형식 및 값과 같으면 <paramref name="obj" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-143"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberSignature Language="F#" Value="static member GetCurrentMethod : unit -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetCurrentMethod " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="687de-144">실행 중인 메서드를 나타내는 <see langword="MethodBase" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-144">Returns a <see langword="MethodBase" /> object representing the currently executing method.</span></span></summary>
        <returns><span data-ttu-id="687de-145"><see cref="M:System.Reflection.MethodBase.GetCurrentMethod" />는 실행 중인 메서드 내에서 호출되고 해당 메서드에 대한 정보를 반환하는 static 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-145"><see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> is a static method that is called from within an executing method and that returns information about that method.</span></span>  
  
<span data-ttu-id="687de-146">실행 중인 메서드를 나타내는 <see langword="MethodBase" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-146">A <see langword="MethodBase" /> object representing the currently executing method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-147">제네릭 형식에서 현재 실행 중인 메서드에 정의 된 경우는 <xref:System.Reflection.MethodInfo> 에서 반환 하는 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 에서 제네릭 형식 정의 가져옵니다 (즉, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> 반환 `true`).</span><span class="sxs-lookup"><span data-stu-id="687de-147">If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is obtained from the generic type definition (that is, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> returns `true`).</span></span> <span data-ttu-id="687de-148">따라서 메서드는 호출 되었을 때 사용 된 형식 인수를 반영 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-148">Therefore, it does not reflect the type arguments that were used when the method was called.</span></span> <span data-ttu-id="687de-149">예를 들어 메서드 `M()` 제네릭 형식에 정의 된 `C<T>` (`C(Of T)` Visual Basic의), 및 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 에서 호출 됩니다 `C<string>.M()`, 한 다음 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 반환 `C<T>.M()` (`C(Of T).M()` Visual Basic의).</span><span class="sxs-lookup"><span data-stu-id="687de-149">For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is called from `C<string>.M()`, then <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).</span></span>  
  
 <span data-ttu-id="687de-150">현재 실행 중인 메서드는 제네릭 메서드 이면 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 제네릭 메서드 정의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-150">If the currently executing method is a generic method, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns the generic method definition.</span></span> <span data-ttu-id="687de-151">제네릭 메서드의 제네릭 형식에 정의 된 경우는 <xref:System.Reflection.MethodInfo> 에서 제네릭 형식 정의 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-151">If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-152">다음 예제에서는 두 가지 종류를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-152">The following example defines two types.</span></span> <span data-ttu-id="687de-153">첫 번째는 제네릭이 아닌 클래스 `TestClass`, 생성자를 메서드가 포함 `GetValue`, 및 라는 읽기-쓰기 속성 `GetValue`.</span><span class="sxs-lookup"><span data-stu-id="687de-153">The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`.</span></span> <span data-ttu-id="687de-154">두 번째는 라는 제네릭 클래스 `TestClass<T>` 생성자를 포함 하는 한 `GetValue` 메서드와 제네릭 메서드를 `ConvertValue<Y>`입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-154">The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`.</span></span> <span data-ttu-id="687de-155">각 생성자, 메서드 및 속성 접근자에 대 한 호출을 포함 합니다 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="687de-155">Each constructor, method, and property accessor includes a call to the <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="687de-156">이 멤버가 런타임에 바인딩된 메커니즘을 사용하여 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-156">This member was invoked with a late-binding mechanism.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="687de-157">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-157">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="687de-158">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="687de-158">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBase.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="687de-159">제네릭 메서드의 형식 인수나 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-159">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span></summary>
        <returns><span data-ttu-id="687de-160">제네릭 메서드의 형식 인수나 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-160">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span> <span data-ttu-id="687de-161">현재 메서드가 제네릭 메서드가 아니면 빈 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-161">Returns an empty array if the current method is not a generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-162">반환된 된 배열 요소의 제네릭 메서드의 형식 매개 변수 목록에 나타나는 순서는입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-162">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="687de-163">현재 메서드는 폐쇄형된 생성된 메서드 경우 (즉, 합니다 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성에서 반환 `false`)를 반환 하는 배열을 <xref:System.Reflection.MethodBase.GetGenericArguments%2A> 메서드는 제네릭 메서드의 제네릭 형식 매개 변수에 할당 된 형식을 포함 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-163">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="687de-164">현재 메서드가 제네릭 메서드 정의 인 경우 배열 형식 매개 변수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-164">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="687de-165">현재 메서드가 개방형 생성된 메서드 이면 (즉, 합니다 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성이 반환 `true`) 일부 형식 매개 변수 및 형식에는 특정 형식이 할당 된 바깥쪽 제네릭 형식의 매개 변수 할당 된 형식으로 매개 변수 배열 포함 형식 및 형식 모두 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-165">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="687de-166">사용 된 <xref:System.Type.IsGenericParameter%2A> 구분 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-166">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="687de-167">이 시나리오의 데모를 제공 하는 코드 예제를 참조 하세요.를 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-167">For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="687de-168">.NET Framework 버전 2.0에서는 제네릭 생성자가 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-168">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="687de-169">이 속성이 throw <xref:System.NotSupportedException> 파생된 클래스에서 재정의 되지 않으면 하므로 예외가 현재 인스턴스 형식의 경우 <xref:System.Reflection.ConstructorInfo>합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-169">This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="687de-170">제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-170">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="687de-171">제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-171">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="687de-172">현재 개체가 <see cref="T:System.Reflection.ConstructorInfo" />인 경우.</span><span class="sxs-lookup"><span data-stu-id="687de-172">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />.</span></span> <span data-ttu-id="687de-173">.NET Framework 버전 2.0에서는 제네릭 생성자가 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-173">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="687de-174">이 예외는 이 메서드가 파생 클래스에서 재정의되지 않은 경우의 기본 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-174">This exception is the default behavior if this method is not overridden in a derived class.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBase.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="687de-175">이 인스턴스의 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-175">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="687de-176">부호 있는 32비트 정수 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-176">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodBody : unit -&gt; System.Reflection.MethodBody&#xA;override this.GetMethodBody : unit -&gt; System.Reflection.MethodBody" Usage="methodBase.GetMethodBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="687de-177">파생 클래스에서 재정의된 경우, 현재 메서드의 MSIL 스트림, 지역 변수 및 예외에 액세스할 수 있도록 하는 <see cref="T:System.Reflection.MethodBody" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-177">When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span></span></summary>
        <returns><span data-ttu-id="687de-178">현재 메서드의 MSIL 스트림, 지역 변수 및 예외에 액세스할 수 있도록 하는 <see cref="T:System.Reflection.MethodBody" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-178">A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-179">재정의할 필요가 없습니다를 <xref:System.Reflection.MethodBase.GetMethodBody%2A> 사용 하기 위해.</span><span class="sxs-lookup"><span data-stu-id="687de-179">You do not have to override the <xref:System.Reflection.MethodBase.GetMethodBody%2A> in order to use it.</span></span> <span data-ttu-id="687de-180">호출할 수 있습니다 합니다 <xref:System.Reflection.MethodBase.GetMethodBody%2A> 메서드를 <xref:System.Reflection.MethodInfo> 및 <xref:System.Reflection.ConstructorInfo> 개체를 이러한 클래스의 런타임 버전에서의 메서드를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-180">You can call the <xref:System.Reflection.MethodBase.GetMethodBody%2A> method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes.</span></span> <span data-ttu-id="687de-181">예를 들어, 런타임 버전의를 <xref:System.Reflection.MethodInfo> 클래스에서 파생 되는 <xref:System.Reflection.MethodInfo> 클래스에서 파생 됩니다는 <xref:System.Reflection.MethodBase> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-181">For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-182">다음 코드 예제에서는 라는 테스트 메서드를 정의 `MethodBodyExample` 해당 로컬 변수 정보 및 예외 처리 절을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-182">The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses.</span></span> <span data-ttu-id="687de-183"><xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> 메서드는 가져오는 데는 <xref:System.Reflection.MethodBody> 테스트 메서드에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-183">The <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.</span></span>  
  
 <span data-ttu-id="687de-184">합니다 <xref:System.Reflection.MethodBody.LocalVariables%2A> 속성은의 목록을 구하는 데 <xref:System.Reflection.LocalVariableInfo> 개체 및 해당 형식 및 인덱스 표시 순서.</span><span class="sxs-lookup"><span data-stu-id="687de-184">The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order.</span></span> <span data-ttu-id="687de-185"><xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> 속성 예외 처리 절의 목록을 가져오는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-185">The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-186">모든 컴퓨터 언어 <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> 절.</span><span class="sxs-lookup"><span data-stu-id="687de-186">Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span></span> <span data-ttu-id="687de-187">Visual Basic 예제에서는 Visual Basic을 사용 하 여 필터 절, `When` 다른 언어에 대 한 예제에서 생략 되는 식입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-187">The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.</span></span>  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="687de-188">이 메서드는 파생 클래스에서 재정의되지 않으면 유효하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-188">This method is invalid unless overridden in a derived class.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="687de-189">멤버에 대 한 메타 데이터에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-189">for the access to metadata for members.</span></span> <span data-ttu-id="687de-190">권한 값: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="687de-190">Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="687de-191">지정된 핸들을 사용하여 메서드 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-191">Gets method information using the specified handle.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="687de-192">메서드의 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-192">The method's handle.</span></span></param>
        <summary><span data-ttu-id="687de-193">메서드의 내부 메타데이터 표현(핸들)을 사용하여 메서드 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-193">Gets method information by using the method's internal metadata representation (handle).</span></span></summary>
        <returns><span data-ttu-id="687de-194">메서드에 대한 정보가 들어 있는 <see langword="MethodBase" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-194">A <see langword="MethodBase" /> containing information about the method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-195">핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-195">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="687de-196"><paramref name="handle" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-196"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="687de-197">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-197">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="687de-198">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="687de-198">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle * RuntimeTypeHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle (handle, declaringType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="687de-199">생성자 또는 메서드의 내부 메타데이터 표현에 대한 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-199">A handle to the internal metadata representation of a constructor or method.</span></span></param>
        <param name="declaringType"><span data-ttu-id="687de-200">생성자 또는 메서드를 정의하는 제네릭 형식에 대한 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-200">A handle to the generic type that defines the constructor or method.</span></span></param>
        <summary><span data-ttu-id="687de-201">지정된 제네릭 형식에 대해 지정된 핸들이 나타내는 생성자 또는 메서드의 <see cref="T:System.Reflection.MethodBase" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-201">Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</span></span></summary>
        <returns><span data-ttu-id="687de-202"><paramref name="handle" />으로 지정된 제네릭 형식에서 <paramref name="declaringType" />로 지정된 메서드 또는 생성자를 나타내는 <see cref="T:System.Reflection.MethodBase" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-202">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-203">핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-203">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="687de-204">A <xref:System.RuntimeMethodHandle> 생성자 또는 메서드의 제네릭 형식에 대 한 구조는 다른 나타낼 수 있습니다 <xref:System.Reflection.MethodBase> 제네릭 형식의 형식 매개 변수에 대해 지정 된 형식에 따라 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-204">A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type.</span></span> <span data-ttu-id="687de-205">예를 들어 경우 `class G<T>` (`class G(Of T)` Visual basic에서는 `generic <T> ref class G` c + +에서) 형식을 반환 하는 메서드가 `T`의 <xref:System.Reflection.MethodBase> 와 같은 생성 된 클래스에서 메서드에 대 한 개체 `G<int>` 합니다 다릅니다<xref:System.Reflection.MethodBase>제네릭 형식 정의에서 해당 메서드에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-205">For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="687de-206"><paramref name="handle" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-206"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="687de-207">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-207">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="687de-208">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="687de-208">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBase.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="687de-209">파생 클래스에서 재정의할 때 <see cref="T:System.Reflection.MethodImplAttributes" /> 플래그를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-209">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</span></span></summary>
        <returns><span data-ttu-id="687de-210"><see langword="MethodImplAttributes" /> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-210">The <see langword="MethodImplAttributes" /> flags.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="687de-211">다음 예제에서는 동적 어셈블리에서 생성자를 정의 하 고 사용 하 여는 <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> 기본적으로 설정 되는 메서드 구현 플래그를 표시 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-211">The following example defines a constructor in a dynamic assembly and then uses the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method to display the method implementation flags that are set by default.</span></span>  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="687de-212">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-212">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="687de-213">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="687de-213">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBase.GetParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="687de-214">파생 클래스에서 재정의되면 지정한 메서드나 생성자의 매개 변수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-214">When overridden in a derived class, gets the parameters of the specified method or constructor.</span></span></summary>
        <returns><span data-ttu-id="687de-215">이 <see langword="ParameterInfo" /> 인스턴스에 의해 리플렉션된 메서드나 생성자의 시그니처와 일치하는 정보가 포함된 <see langword="MethodBase" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-215">An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="687de-216">다음 예제에서는 합니다 <xref:System.Reflection.MethodBase.GetParameters%2A> 의 매개 변수를 검색 하는 메서드는 `Invoke` 대리자 메서드.</span><span class="sxs-lookup"><span data-stu-id="687de-216">The following example uses the <xref:System.Reflection.MethodBase.GetParameters%2A> method to retrieve the parameters of the `Invoke` method of a delegate.</span></span>  
  
 <span data-ttu-id="687de-217">이 예제에서는 명명 된 대리자를 정의 합니다. `MyDelegate` 명명 된 이벤트 `ev` 형식의 `MyDelegate`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-217">The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`.</span></span> <span data-ttu-id="687de-218">코드를 `Main` 메서드 이벤트 시그니처를 대리자 형식의 이벤트를 가져와서 검색 가져오기는 `Invoke` 메서드는 대리자 형식으로 다음 검색 및 매개 변수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-218">The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.</span></span>  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="687de-219">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="687de-220">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="687de-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="methodBase.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="687de-221">이 <see langword="MethodInfo" /> 인스턴스에 의해 리플렉션된 메서드나 생성자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-221">Invokes the method or constructor reflected by this <see langword="MethodInfo" /> instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * obj[] -&gt; obj&#xA;override this.Invoke : obj * obj[] -&gt; obj" Usage="methodBase.Invoke (obj, parameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="687de-222">메서드 또는 생성자를 호출할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-222">The object on which to invoke the method or constructor.</span></span> <span data-ttu-id="687de-223">메서드가 static이면 이 인수는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-223">If a method is static, this argument is ignored.</span></span> <span data-ttu-id="687de-224">생성자가 static이면 이 인수는 <see langword="null" /> 또는 생성자를 정의하는 클래스의 인스턴스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-224">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span></span></param>
        <param name="parameters"><span data-ttu-id="687de-225">호출된 메서드 또는 생성자에 대한 인수 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-225">An argument list for the invoked method or constructor.</span></span> <span data-ttu-id="687de-226">호출되는 메서드 또는 생성자의 매개 변수와 개수, 순서, 형식이 동일한 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-226">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span></span> <span data-ttu-id="687de-227">매개 변수가 없는 경우 <paramref name="parameters" />는 <see langword="null" />이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-227">If there are no parameters, <paramref name="parameters" /> should be <see langword="null" />.</span></span>  
  
<span data-ttu-id="687de-228">이 인스턴스로 나타내는 메서드 또는 생성자가 <see langword="ref" /> 매개 변수(Visual Basic의 <see langword="ByRef" />)를 사용하는 경우 이 함수를 사용하여 메서드 또는 생성자를 호출하기 위해 해당 매개 변수에 특별한 특성이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-228">If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</span></span> <span data-ttu-id="687de-229">값으로 명시적으로 초기화되지 않은 이 배열의 모든 개체는 해당 개체 형식에 대해 기본값을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-229">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span></span> <span data-ttu-id="687de-230">참조 형식 요소의 경우 이 값은 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-230">For reference-type elements, this value is <see langword="null" />.</span></span> <span data-ttu-id="687de-231">값 형식 요소의 경우 이 값은 특정 요소 형식에 따라 0, 0.0 또는 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-231">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span></span></param>
        <summary><span data-ttu-id="687de-232">지정된 매개 변수를 사용하여 현재 인스턴스로 나타낸 메서드 또는 생성자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-232">Invokes the method or constructor represented by the current instance, using the specified parameters.</span></span></summary>
        <returns><span data-ttu-id="687de-233">호출된 메서드의 반환 값을 포함하는 개체이거나 생성자의 경우는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-233">An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-234">이 호출 하는 편의 메서드를 <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> 메서드 오버 로드를 전달 <xref:System.Reflection.BindingFlags.Default> 에 대 한 `invokeAttr` 및 `null` 에 대 한 `binder` 및 `culture`.</span><span class="sxs-lookup"><span data-stu-id="687de-234">This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for `invokeAttr` and `null` for `binder` and `culture`.</span></span>  
  
 <span data-ttu-id="687de-235">호출 된 메서드가 예외를 throw 하는 경우는 <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> 메서드 예외를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-235">If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> method returns the exception.</span></span>  
  
 <span data-ttu-id="687de-236">사용 하 여 정적 메서드를 호출 하려면 해당 <xref:System.Reflection.MethodInfo> 개체를 전달 `null` 에 대 한 `obj`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-236">To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-237">이 메서드 오버 로드 인스턴스 생성자 호출을 사용 하는 경우에 대 한 제공 된 개체가 `obj` 다시 초기화 됩니다; 즉, 모든 인스턴스 이니셜라이저 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-237">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="687de-238">반환 값은 `null`입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-238">The return value is `null`.</span></span> <span data-ttu-id="687de-239">클래스 생성자를 호출 하는 경우 클래스를 다시 초기화 됩니다. 즉, 모든 클래스 이니셜라이저가 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-239">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="687de-240">반환 값은 `null`입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-240">The return value is `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-241">부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-241">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="687de-242">(참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="687de-242">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="687de-243">이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-243">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="687de-244">현재 메서드의 매개 변수 값 형식 및 해당 인수 이면 `parameters` 는 `null`, 런타임에 값 형식의 0으로 초기화 된 인스턴스를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-244">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-245">다음 코드 예제에서는 리플렉션을 사용 하 여 동적 메서드 조회 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="687de-245">The following code example demonstrates dynamic method lookup using reflection.</span></span> <span data-ttu-id="687de-246">사용할 수 없습니다는 <xref:System.Reflection.MethodInfo> 런타임에 바인딩을 재정의 확인할 수 없습니다 때문에 파생된 클래스에서 재정의 된 메서드를 호출 하는 기본 클래스에서 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-246">Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</span></span>  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="687de-247"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 <see cref="T:System.Exception" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-247">In the<see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="687de-248"><paramref name="obj" /> 매개 변수가 <see langword="null" />이고 메서드가 static이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="687de-248">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span></span>  
  
<span data-ttu-id="687de-249">또는</span><span class="sxs-lookup"><span data-stu-id="687de-249">-or-</span></span> 
<span data-ttu-id="687de-250">메서드가 <paramref name="obj" /> 클래스에서 선언되지도 않고 상속되지도 않은 경우</span><span class="sxs-lookup"><span data-stu-id="687de-250">The method is not declared or inherited by the class of <paramref name="obj" />.</span></span>  
  
<span data-ttu-id="687de-251">또는</span><span class="sxs-lookup"><span data-stu-id="687de-251">-or-</span></span> 
<span data-ttu-id="687de-252">static 생성자가 호출되고 <paramref name="obj" />가 <see langword="null" />도 아니고 생성자를 선언한 클래스의 인스턴스도 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="687de-252">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="687de-253"><paramref name="parameters" /> 배열의 요소가 이 인스턴스에서 리플렉트된 메서드 또는 생성자의 시그니처와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="687de-253">The elements of the <paramref name="parameters" /> array do not match the signature of the method or constructor reflected by this instance.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="687de-254">호출된 메서드 또는 생성자가 예외를 throw하는 경우</span><span class="sxs-lookup"><span data-stu-id="687de-254">The invoked method or constructor throws an exception.</span></span>  
  
<span data-ttu-id="687de-255">또는</span><span class="sxs-lookup"><span data-stu-id="687de-255">-or-</span></span> 
<span data-ttu-id="687de-256">현재 인스턴스가 확인할 수 없는 코드를 포함하는 <see cref="T:System.Reflection.Emit.DynamicMethod" />인 경우</span><span class="sxs-lookup"><span data-stu-id="687de-256">The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code.</span></span> <span data-ttu-id="687de-257"><see cref="T:System.Reflection.Emit.DynamicMethod" />에 대한 설명에서 "확인" 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-257">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><span data-ttu-id="687de-258"><paramref name="parameters" /> 배열에 올바른 수의 인수가 포함되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="687de-258">The <paramref name="parameters" /> array does not have the correct number of arguments.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="687de-259"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.MemberAccessException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-259">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="687de-260">호출자에 현재 인스턴스로 나타내는 메서드 또는 생성자를 실행할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-260">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="687de-261">이 메서드를 선언하는 형식이 오픈 제네릭 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-261">The type that declares the method is an open generic type.</span></span> <span data-ttu-id="687de-262">즉, <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 선언 형식에 대해 <see langword="true" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-262">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="687de-263">현재 인스턴스는 <see cref="T:System.Reflection.Emit.MethodBuilder" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-263">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="687de-264">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-264">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="687de-265">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="687de-265">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBase.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="687de-266">메서드 또는 생성자를 호출할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-266">The object on which to invoke the method or constructor.</span></span> <span data-ttu-id="687de-267">메서드가 static이면 이 인수는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-267">If a method is static, this argument is ignored.</span></span> <span data-ttu-id="687de-268">생성자가 static이면 이 인수는 <see langword="null" /> 또는 생성자를 정의하는 클래스의 인스턴스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-268">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="687de-269"><see cref="T:System.Reflection.BindingFlags" />의 비트 플래그 0개 이상으로 조합된 비트 마스크입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-269">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span> <span data-ttu-id="687de-270"><paramref name="binder" />가 <see langword="null" />이면 이 매개 변수에는 값 <see cref="F:System.Reflection.BindingFlags.Default" />가 할당됩니다. 따라서, 전달되는 모든 값은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-270">If <paramref name="binder" /> is <see langword="null" />, this parameter is assigned the value <see cref="F:System.Reflection.BindingFlags.Default" />; thus, whatever you pass in is ignored.</span></span></param>
        <param name="binder"><span data-ttu-id="687de-271">리플렉션을 사용하여 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see langword="MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-271">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="687de-272"><paramref name="binder" />가 <see langword="null" />이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-272">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="parameters"><span data-ttu-id="687de-273">호출된 메서드 또는 생성자에 대한 인수 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-273">An argument list for the invoked method or constructor.</span></span> <span data-ttu-id="687de-274">호출되는 메서드 또는 생성자의 매개 변수와 개수, 순서, 형식이 동일한 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-274">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span></span> <span data-ttu-id="687de-275">이 목록은 매개 변수가 없으면 <see langword="null" />이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-275">If there are no parameters, this should be <see langword="null" />.</span></span>  
  
<span data-ttu-id="687de-276">이 인스턴스가 나타내는 메서드나 생성자에 ByRef 매개 변수가 있으면 해당 매개 변수에 특수한 특성이 없어도 이 함수를 사용하여 메서드나 생성자를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-276">If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</span></span> <span data-ttu-id="687de-277">값으로 명시적으로 초기화되지 않은 이 배열의 모든 개체는 해당 개체 형식에 대해 기본값을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-277">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span></span> <span data-ttu-id="687de-278">참조 형식 요소의 경우 이 값은 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-278">For reference-type elements, this value is <see langword="null" />.</span></span> <span data-ttu-id="687de-279">값 형식 요소의 경우 이 값은 특정 요소 형식에 따라 0, 0.0 또는 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-279">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span></span></param>
        <param name="culture"><span data-ttu-id="687de-280">형식의 강제 변환을 제어하는 데 사용되는 <see langword="CultureInfo" />의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-280">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="687de-281">이 매개 변수가 <see langword="null" />이면 현재 스레드에 대한 <see langword="CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-281">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="687de-282">예를 들어 1,000은 각 문화권마다 다르게 표현되므로 1,000을 나타내는 <see langword="String" />을 <see langword="Double" /> 값으로 변환하기 위해 이 매개 변수가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-282">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span></span></param>
        <summary><span data-ttu-id="687de-283">파생 클래스에서 재정의된 경우, 지정된 매개 변수를 사용하여 리플렉션된 메서드나 생성자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-283">When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</span></span></summary>
        <returns><span data-ttu-id="687de-284">호출된 메서드의 반환 값이 포함된 <see langword="Object" />이거나, 생성자일 경우 <see langword="null" />이거나, 메서드의 반환 형식이 <see langword="null" />인 경우 <see langword="void" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-284">An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />.</span></span> <span data-ttu-id="687de-285">이 메서드나 생성자를 호출하기 전에 <see langword="Invoke" />는 사용자에게 액세스 권한이 있는지 확인한 다음 매개 변수가 올바른지 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-285">Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-286">이 인스턴스에 의해 리플렉션된 메서드를 호출 하는 동적으로 `obj`, 지정된 된 매개 변수를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-286">Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters.</span></span> <span data-ttu-id="687de-287">메서드가 정적 이면는 `obj` 매개 변수가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-287">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="687de-288">비정적 메서드에 대해 `obj` 상속 하거나 메서드를 선언 하 고,이 클래스와 동일한 형식 이어야 하는 클래스의 인스턴스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-288">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="687de-289">메서드 매개 변수가 없는의 값이 있으면 `parameters` 있어야 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-289">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="687de-290">그렇지 않은 경우 개수, 형식 및에서 요소의 순서 `parameters` 수, 형식 및이 인스턴스에서 리플 렉 트 메서드에 대 한 매개 변수의 순서와 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-290">Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
 <span data-ttu-id="687de-291">에 대 한 호출의 선택적 매개 변수를 생략할 수 없습니다 `Invoke`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-291">You may not omit optional parameters in calls to `Invoke`.</span></span> <span data-ttu-id="687de-292">선택적 매개 변수를 생략 하는 메서드를 호출 하려면 호출 해야 `Type.InvokeMember` 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-292">To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-293">이 메서드 오버 로드 인스턴스 생성자 호출을 사용 하는 경우에 대 한 제공 된 개체가 `obj` 다시 초기화 됩니다; 즉, 모든 인스턴스 이니셜라이저 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-293">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="687de-294">반환 값은 `null`입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-294">The return value is `null`.</span></span> <span data-ttu-id="687de-295">클래스 생성자를 호출 하는 경우 클래스를 다시 초기화 됩니다. 즉, 모든 클래스 이니셜라이저가 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-295">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="687de-296">반환 값은 `null`입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-296">The return value is `null`.</span></span>  
  
 <span data-ttu-id="687de-297">기본 값으로 전달 매개 변수에 대 한 일반 확대 이루어집니다 (Int16-> Int32, 예를 들어).</span><span class="sxs-lookup"><span data-stu-id="687de-297">For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example).</span></span> <span data-ttu-id="687de-298">값으로 전달 참조 매개 변수에 대 한 일반적인 참조 확대 (기본 클래스 및 인터페이스 형식에 기본 클래스를 파생된 클래스) 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-298">For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</span></span> <span data-ttu-id="687de-299">그러나 참조로 전달 기본 매개 변수 형식이 정확히 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-299">However, for pass-by-reference primitive parameters, the types must match exactly.</span></span> <span data-ttu-id="687de-300">참조로 전달 참조 매개 변수에 대 한 일반 확대 계속 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-300">For pass-by-reference reference parameters, the normal widening still applies.</span></span>  
  
 <span data-ttu-id="687de-301">예를 들어 메서드를 반영 하 여이 인스턴스는 변수로 선언 `public boolean Compare(String a, String b)`, 한 다음 `parameters` 의 배열 이어야 `Objects` 길이가 2 인 되도록 `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span><span class="sxs-lookup"><span data-stu-id="687de-301">For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span></span>  
  
 <span data-ttu-id="687de-302">현재 메서드의 매개 변수 값 형식 및 해당 인수 이면 `parameters` 는 `null`, 런타임에 값 형식의 0으로 초기화 된 인스턴스를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-302">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
 <span data-ttu-id="687de-303">리플렉션 가상 메서드를 호출 하는 경우 동적 메서드 조회를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-303">Reflection uses dynamic method lookup when invoking virtual methods.</span></span> <span data-ttu-id="687de-304">예를 들어, 클래스 B는 클래스에서 상속 하 고 모두 M 이라는 가상 메서드를 구현 합니다. 이제 있다고 가정 하 고는 `MethodInfo` A. 클래스에 M을 나타내는 개체 사용 하는 경우는 `Invoke` 리플렉션 클래스 2. 제공한 구현을 사용 합니다. 그런 다음 M b 형식의 개체에서 호출할 메서드 형식 B의 개체를 A로 캐스팅 하는 경우에 클래스 B에 의해 지정 된 구현이 사용 됩니다 (아래 코드 샘플 참조).</span><span class="sxs-lookup"><span data-stu-id="687de-304">For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</span></span>  
  
 <span data-ttu-id="687de-305">반면에 메서드가 가상이 아닌 경우 다음 리플렉션은 구현을 사용 형식이 올 지정한는 `MethodInfo` 대상으로 전달 되는 개체의 유형에 관계 없이 가져온 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-305">On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.</span></span>  
  
 <span data-ttu-id="687de-306">완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-306">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="687de-307">즉, 개인 생성자, 메서드, 필드 및 속성 액세스 하 고 수 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 통해 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-307">That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="687de-308">호출 된 메서드가 예외를 throw 하는 경우 `TargetInvocationException.GetException` 예외를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-308">If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception.</span></span> <span data-ttu-id="687de-309">이 구현에서 throw 된 `NotSupportedException`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-309">This implementation throws a `NotSupportedException`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-310">부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-310">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="687de-311">(참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="687de-311">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="687de-312">이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-312">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-313">다음 예제에서는 모든 멤버를 <xref:System.Reflection.Binder?displayProperty=nameWithType> 오버 로드를 사용 하 여 클래스 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-313">The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=nameWithType> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="687de-314">Private 메서드 `CanConvertFrom` 지정된 된 형식에 대 한 호환 되는 형식을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-314">The private method `CanConvertFrom` finds compatible types for a given type.</span></span> <span data-ttu-id="687de-315">사용자 지정 바인딩 시나리오에서 호출 멤버의 다른 예제를 보려면 [를 사용 하 여 형식 동적 로드 및](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-315">For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="687de-316"><paramref name="obj" /> 매개 변수가 <see langword="null" />이고 메서드가 static이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="687de-316">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span></span>  
  
<span data-ttu-id="687de-317">또는</span><span class="sxs-lookup"><span data-stu-id="687de-317">-or-</span></span> 
<span data-ttu-id="687de-318">메서드가 <paramref name="obj" /> 클래스에서 선언되지도 않고 상속되지도 않은 경우</span><span class="sxs-lookup"><span data-stu-id="687de-318">The method is not declared or inherited by the class of <paramref name="obj" />.</span></span>  
  
<span data-ttu-id="687de-319">또는</span><span class="sxs-lookup"><span data-stu-id="687de-319">-or-</span></span> 
<span data-ttu-id="687de-320">static 생성자가 호출되고 <paramref name="obj" />가 <see langword="null" />도 아니고 생성자를 선언한 클래스의 인스턴스도 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="687de-320">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="687de-321"><paramref name="parameters" /> 매개 변수의 형식이 이 인스턴스에 의해 리플렉션된 메서드 또는 생성자의 시그니처와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="687de-321">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</span></span></exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><span data-ttu-id="687de-322"><paramref name="parameters" /> 배열에 올바른 수의 인수가 포함되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="687de-322">The <paramref name="parameters" /> array does not have the correct number of arguments.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="687de-323">호출된 메서드 또는 생성자가 예외를 throw하는 경우</span><span class="sxs-lookup"><span data-stu-id="687de-323">The invoked method or constructor throws an exception.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="687de-324">호출자에 현재 인스턴스로 나타내는 메서드 또는 생성자를 실행할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-324">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="687de-325">이 메서드를 선언하는 형식이 오픈 제네릭 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-325">The type that declares the method is an open generic type.</span></span> <span data-ttu-id="687de-326">즉, <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 선언 형식에 대해 <see langword="true" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-326">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="687de-327">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-327">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="687de-328">연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="687de-328">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md"><span data-ttu-id="687de-329">동적으로 형식 로드 및 사용</span><span class="sxs-lookup"><span data-stu-id="687de-329">Dynamically Loading and Using Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Reflection.MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-330">이 메서드가 추상 메서드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-330">Gets a value indicating whether the method is abstract.</span></span></summary>
        <value><span data-ttu-id="687de-331">해당 메서드가 추상 메서드이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-331"><see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-332">기본 클래스에 선언 된 추상 멤버 및에 제공 된 구현이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-332">An abstract member is declared on a base class and has no implementation supplied.</span></span>  
  
 <span data-ttu-id="687de-333">가져오려는 <xref:System.Reflection.MethodBase>, 먼저 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-333">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="687de-334">형식에서 메서드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-334">From the type, get the method.</span></span> <span data-ttu-id="687de-335">메서드에서 가져오기는 `MethodBase`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-335">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="687de-336">경우는 `MethodBase` 또는 생성자가 public이 아닌, 보호 되 고 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-336">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="687de-337">Public이 아닌 메서드에 액세스 하려면 설정 합니다 <xref:System.Reflection.BindingFlags> 마스크를 `NonPublic` 에서 `GetMethod`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-337">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-338">다음 예제에서는 지정 된 메서드가 추상 이며 결과 표시 하는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-338">The following example determines whether specified the method is abstract and displays the result.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAssembly : bool" Usage="System.Reflection.MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-339"><see cref="F:System.Reflection.MethodAttributes.Assembly" />에서 이 메서드나 생성자의 잠재적 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 메서드나 생성자는 같은 어셈블리의 다른 형식에만 표시되고 어셈블리 외부의 파생 형식에는 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-339">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span></span></summary>
        <value><span data-ttu-id="687de-340"><see cref="F:System.Reflection.MethodAttributes.Assembly" />에서 이 메서드나 생성자의 표시 유형을 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-340"><see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-341">해당 형식의 표시 유형과 메서드의 실제 가시성 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-341">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="687de-342">합니다 <xref:System.Reflection.MethodBase.IsAssembly%2A> 속성 수 있습니다 `true` 메서드의 경우 있지만 경우 전용 중첩된 형식 메서드의 메서드를 포함 하는 형식 외부에 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-342">The <xref:System.Reflection.MethodBase.IsAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="687de-343">메서드 또는 생성자의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> 만 표시 한정자가 하는 경우 `internal` (`Friend` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="687de-343">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="687de-344">이 속성은 `false` 메서드를 위한 `protected internal` C#에서 (`Protected Friend` Visual basic에서는 `protected public` c + +에서); 사용 하 여는 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> 이러한 메서드를 식별 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-344">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-345">다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 메서드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>를 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-345">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-346">Visual Basic 및 C# 언어를 사용 하 여 메서드를 정의할 수 없습니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-346">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructor : bool" Usage="System.Reflection.MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-347">메서드가 생성자인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-347">Gets a value indicating whether the method is a constructor.</span></span></summary>
        <value><span data-ttu-id="687de-348">이 메서드가 <see cref="T:System.Reflection.ConstructorInfo" /> 개체가 나타내는 생성자이면 <see langword="true" />이고(<see cref="T:System.Reflection.Emit.ConstructorBuilder" /> 개체에 대한 설명 부분 참조), 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-348"><see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="687de-349"><xref:System.Reflection.MethodBase.IsConstructor%2A> 속성이 반환 `false` 에 대 한를 <xref:System.Reflection.Emit.ConstructorBuilder> 경우가 아니면 동적 형식의 개체를 <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> 플래그에 포함 된를 `attributes` 생성자가 정의 될 때 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-349">The <xref:System.Reflection.MethodBase.IsConstructor%2A> property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag was included in the `attributes` parameter when the constructor was defined.</span></span> <span data-ttu-id="687de-350">생략 된 <xref:System.Reflection.MethodAttributes.RTSpecialName> 플래그 내보낸된 생성자의 정확성에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-350">Omitting the <xref:System.Reflection.MethodAttributes.RTSpecialName> flag does not affect the correctness of the emitted constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamily : bool" Usage="System.Reflection.MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-351"><see cref="F:System.Reflection.MethodAttributes.Family" />에서 이 메서드나 생성자의 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 메서드나 생성자는 해당 클래스 및 파생 클래스에만 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-351">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family" />; that is, the method or constructor is visible only within its class and derived classes.</span></span></summary>
        <value><span data-ttu-id="687de-352"><see cref="F:System.Reflection.MethodAttributes.Family" />에서 이 메서드나 생성자에 대한 액세스를 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-352"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-353">메서드 또는 생성자의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> 만 표시 한정자가 하는 경우 `protected`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-353">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="687de-354">이 속성은 `false` 메서드를 위한 `protected internal` C#에서 (`Protected Friend` Visual basic에서는 `protected public` c + +에서); 사용 하 여는 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> 이러한 메서드를 식별 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-354">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-355">다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 메서드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>를 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-355">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-356">Visual Basic 및 C# 언어를 사용 하 여 메서드를 정의할 수 없습니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-356">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyAndAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-357"><see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />에서 이 메서드나 생성자의 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 메서드나 생성자는 같은 어셈블리에 있는 경우에만 파생 클래스에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-357">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</span></span></summary>
        <value><span data-ttu-id="687de-358"><see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />에서 이 메서드나 생성자에 대한 액세스를 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-358"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-359">메서드 또는 생성자의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 표시 한정자가 하는 경우 `protected private` c + +에서입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-359">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="687de-360">Visual Basic 또는 C#에서 이러한 가시성을 사용 하 여 메서드를 정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-360">Methods with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-361">다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 메서드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>를 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-361">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-362">Visual Basic 및 C# 언어를 사용 하 여 메서드를 정의할 수 없습니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-362">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyOrAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-363"><see cref="F:System.Reflection.MethodAttributes.FamORAssem" />에서 이 메서드나 생성자의 잠재적 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 메서드나 생성자는 파생 클래스(있는 경우) 및 같은 어셈블리의 클래스에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-363">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</span></span></summary>
        <value><span data-ttu-id="687de-364"><see cref="F:System.Reflection.MethodAttributes.FamORAssem" />에서 이 메서드나 생성자에 대한 액세스를 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-364"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-365">형식 멤버에 <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> 가시성을 호출할 수 있습니다 파생된 클래스에서 모든 멤버 또는 멤버는 같은 어셈블리에 있지만 다른 형식에서는 상속할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-365">If a type member has <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="687de-366">해당 형식의 표시 유형과 메서드의 실제 가시성 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-366">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="687de-367">합니다 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> 속성 수 있습니다 `true` 메서드의 경우 있지만 경우 전용 중첩된 형식 메서드의 메서드를 포함 하는 형식 외부에 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-367">The <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="687de-368">메서드 또는 생성자의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> 표시 한정자가 하는 경우 `protected internal` C#에서 (`Protected Friend` Visual basic에서는 `protected public` c + +에서).</span><span class="sxs-lookup"><span data-stu-id="687de-368">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-369">다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 메서드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>를 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-369">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-370">Visual Basic 및 C# 언어를 사용 하 여 메서드를 정의할 수 없습니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-370">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFinal : bool" Usage="System.Reflection.MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-371">이 메서드가 <see langword="final" />인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-371">Gets a value indicating whether this method is <see langword="final" />.</span></span></summary>
        <value><span data-ttu-id="687de-372">이 메서드가 <see langword="final" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-372"><see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-373">메서드를 재정의할 수 있는지 확인 하지 않았는지 확인 하기에 충분 하 <xref:System.Reflection.MethodBase.IsVirtual%2A> 는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-373">To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`.</span></span> <span data-ttu-id="687de-374">재정의할, 메서드에 대 한 `IsVirtual` 이어야 합니다 `true` 하 고 `IsFinal` 여야 합니다 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-374">For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`.</span></span> <span data-ttu-id="687de-375">예를 들어 메서드 비가상 이며 수 있지만 인터페이스 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-375">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="687de-376">공용 언어 런타임에서 인터페이스 멤버를 구현 하는 모든 메서드를 표시 합니다 필요 `virtual`따라서 컴파일러는 메서드 표시 `virtual final`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-376">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="687de-377">메서드가로 표시 되어 있는 경우 되므로 `virtual` 되지만 재정의할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-377">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="687de-378">메서드는 재정의할 수 있는지 여부를 확실 하 게 설정 하 고, 이와 같은 코드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-378">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 <span data-ttu-id="687de-379">하는 경우 `IsVirtual` 됩니다 `false` 또는 `IsFinal` 는 `true`, 다음 메서드를 재정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-379">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-380">다음 예제에서는 표시 `false` 에 대 한 `IsFinal`,이 생각 하면 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-380">The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable.</span></span> <span data-ttu-id="687de-381">코드 인쇄 `false` MyMethod 표시 되지 않는 경우에 `virtual` 재정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-381">The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.MethodBase.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-382">메서드가 제네릭 메서드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-382">Gets a value indicating whether the method is generic.</span></span></summary>
        <value><span data-ttu-id="687de-383">현재 <see cref="T:System.Reflection.MethodBase" />가 제네릭 메서드를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-383"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-384">사용 하 여는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성을 확인 하는지 여부를 현재 <xref:System.Reflection.MethodBase> 개체는 제네릭 메서드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="687de-384">Use the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method.</span></span> <span data-ttu-id="687de-385">사용 하 여는 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성을 확인 하는지 여부를 현재 <xref:System.Reflection.MethodBase> 개체는 열려 있는 생성 된 메서드 또는 폐쇄형된 생성된 메서드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="687de-385">Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-386">기본적으로 제네릭을 사용할 수 없습니다. 이 속성은 반환 `false` 파생된 클래스에서 재정의 되지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="687de-386">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="687de-387">이 속성을 반환 하므로 제네릭 생성자는.NET Framework 버전 2.0에서에서 지원 되지 않습니다 `false` 현재 인스턴스 형식의 경우 <xref:System.Reflection.ConstructorInfo>합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-387">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
<span data-ttu-id="687de-388">다음 표에서 제네릭 메서드와 관련 된 용어에 대 한 고정 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-388">The following table summarizes the invariant conditions for terms specific to generic methods.</span></span> <span data-ttu-id="687de-389">와 같은 제네릭 리플렉션에 사용 되는 다른 용어에 대 한 *제네릭 형식 매개 변수* 하 고 *제네릭 형식*를 참조는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-389">For other terms used in generic reflection, such as *generic type parameter* and *generic type*, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>   

|<span data-ttu-id="687de-390">용어</span><span class="sxs-lookup"><span data-stu-id="687de-390">Term</span></span>|<span data-ttu-id="687de-391">고정 조건이</span><span class="sxs-lookup"><span data-stu-id="687de-391">Invariant condition</span></span>| 
|---|---| 
|<span data-ttu-id="687de-392">제네릭 메서드 정의</span><span class="sxs-lookup"><span data-stu-id="687de-392">generic method definition</span></span>| <span data-ttu-id="687de-393"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition> 속성이 `true`일 경우(이 속성은</span><span class="sxs-lookup"><span data-stu-id="687de-393">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> property is `true`.</span></span> <br /><span data-ttu-id="687de-394">제네릭 메서드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-394">Defines a generic method.</span></span> <span data-ttu-id="687de-395">생성된 된 메서드를 호출 하 여 만들어집니다 합니다 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 메서드는 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내는 개체를 형식 인수의 배열을 지정 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-395">A constructed method is created by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method on a <xref:System.Reflection.MethodInfo> object that represents a generic method definition, and specifying an array of type arguments.</span></span> <br /><span data-ttu-id="687de-396"><xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 제네릭 메서드 정의에 대해서만 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-396">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be called only on generic method definitions.</span></span> <br/><span data-ttu-id="687de-397">모든 제네릭 메서드 정의 된 제네릭 메서드를 이지만 메서드라고 해 서 해당 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-397">Any generic method definition is a generic method, but the converse is not true.</span></span>|    
|<span data-ttu-id="687de-398">제네릭 메서드(generic method)</span><span class="sxs-lookup"><span data-stu-id="687de-398">generic method</span></span>|<span data-ttu-id="687de-399">`IsGenericMethod` 속성이 `true`일 경우(이 속성은</span><span class="sxs-lookup"><span data-stu-id="687de-399">The `IsGenericMethod` property is `true`.</span></span> <br/> <span data-ttu-id="687de-400">제네릭 메서드 정의 열려 있는 생성 된 메서드 또는 폐쇄형된 생성된 메서드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-400">Can be a generic method definition, an open constructed method, or a closed constructed method.</span></span>| 
|<span data-ttu-id="687de-401">open 메서드 생성된</span><span class="sxs-lookup"><span data-stu-id="687de-401">open constructed method</span></span>|<span data-ttu-id="687de-402"><xref:System.Reflection.MethodBase.ContainsGenericParameters> 속성이 `true`일 경우(이 속성은</span><span class="sxs-lookup"><span data-stu-id="687de-402">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `true`.</span></span> <br/><span data-ttu-id="687de-403">개방형 생성된 메서드를 호출 하는 것이 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-403">It is not possible to invoke an open constructed method.</span></span>|  
|<span data-ttu-id="687de-404">폐쇄형 생성된 메서드</span><span class="sxs-lookup"><span data-stu-id="687de-404">closed constructed method</span></span>|<span data-ttu-id="687de-405"><xref:System.Reflection.MethodBase.ContainsGenericParameters> 속성이 `false`일 경우(이 속성은</span><span class="sxs-lookup"><span data-stu-id="687de-405">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `false`.</span></span> <br/><span data-ttu-id="687de-406">검사를 재귀적으로 메서드에 할당 되지 않은 제네릭 매개 변수가 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="687de-406">When examined recursively, the method has no unassigned generic parameters.</span></span> <span data-ttu-id="687de-407">포함 하는 형식에 제네릭 형식 매개 변수가 없습니다 및 형식 인수를 제네릭 형식 매개 변수가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-407">The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</span></span> <br/><span data-ttu-id="687de-408">메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-408">The method can be invoked.</span></span>|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-409">메서드가 제네릭 메서드 정의인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-409">Gets a value indicating whether the method is a generic method definition.</span></span></summary>
        <value><span data-ttu-id="687de-410">현재 <see cref="T:System.Reflection.MethodBase" /> 개체가 제네릭 메서드 정의를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-410"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-411">하는 경우 현재 <xref:System.Reflection.MethodBase> 는 제네릭 메서드 정의 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="687de-411">If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:</span></span>  
  
-   <span data-ttu-id="687de-412"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> 속성이 `true`일 경우(이 속성은</span><span class="sxs-lookup"><span data-stu-id="687de-412">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property is `true`.</span></span>  
  
-   <span data-ttu-id="687de-413">각 <xref:System.Type> 에서 반환 된 배열에 있는 개체는 <xref:System.Reflection.MethodBase.GetGenericArguments%2A> 메서드:</span><span class="sxs-lookup"><span data-stu-id="687de-413">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:</span></span>  
  
    -   <span data-ttu-id="687de-414"><xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> 속성이 `true`일 경우(이 속성은</span><span class="sxs-lookup"><span data-stu-id="687de-414">The <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> property is `true`.</span></span>  
  
    -   <span data-ttu-id="687de-415"><xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> 속성 현재 인스턴스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-415">The <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> property returns the current instance.</span></span>  
  
    -   <span data-ttu-id="687de-416"><xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> 속성의 위치와 동일 합니다 <xref:System.Type> 배열에 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-416">The <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="687de-417">기본적으로 제네릭을 사용할 수 없습니다. 이 속성은 반환 `false` 파생된 클래스에서 재정의 되지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="687de-417">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="687de-418">이 속성을 반환 하므로 제네릭 생성자는.NET Framework 버전 2.0에서에서 지원 되지 않습니다 `false` 현재 인스턴스 형식의 경우 <xref:System.Reflection.ConstructorInfo>합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-418">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="687de-419">제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-419">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="687de-420">제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-420">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHideBySig : bool" Usage="System.Reflection.MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-421">동일한 시그니처가 있는 동일한 종류의 멤버만을 파생 클래스에서 숨길 수 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-421">Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</span></span></summary>
        <value><span data-ttu-id="687de-422">멤버를 시그니처로 숨길 수 있으면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-422"><see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-423">C#을 사용 하 여 파생된 클래스의 멤버는 선언 하는 경우 `new` 한정자 또는 Visual Basic `Shadows` 한정자 기본 클래스에서 동일한 이름의 멤버를 숨길 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-423">When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class.</span></span> <span data-ttu-id="687de-424">C# 서명 함으로써 기본 클래스 멤버를 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="687de-424">C# hides base class members by signature.</span></span> <span data-ttu-id="687de-425">기본 클래스 멤버를 여러 오버 로드가 있으면 숨겨져 있는 유일한 즉, 동일한 시그니처가 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-425">That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</span></span> <span data-ttu-id="687de-426">반면, Visual Basic 기본 클래스 오버 로드를 모두 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="687de-426">By contrast, Visual Basic hides all the base class overloads.</span></span> <span data-ttu-id="687de-427">따라서 <xref:System.Reflection.MethodBase.IsHideBySig%2A> 반환 `false` Visual Basic을 사용 하 여 선언 된 멤버에 `Shadows` 한정자, 및 `true` C#을 사용 하 여 선언 된 멤버에 `new` 한정자입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-427">Thus, <xref:System.Reflection.MethodBase.IsHideBySig%2A> returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="687de-428">이 속성 메서드에 게 있는지 여부를 확인 하지 않습니다는 <xref:System.Reflection.MethodAttributes.NewSlot> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-428">This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute.</span></span> <span data-ttu-id="687de-429">중 하나를 사용 하 여 선언 된 메서드를 `new` 또는 `Shadows` 한정자를 <xref:System.Reflection.MethodAttributes.NewSlot> 특성은 아니지만 사용 하 여 선언 된 메서드만 `new` (즉, C# 메서드만) 갖습니다는 <xref:System.Reflection.MethodBase.IsHideBySig%2A> 로설정하는속성`true`.</span><span class="sxs-lookup"><span data-stu-id="687de-429">A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, but only methods declared with `new` (that is, only C# methods) will have the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property set to `true`.</span></span>  <span data-ttu-id="687de-430">메서드가 있는지 여부를 결정 하는 <xref:System.Reflection.MethodAttributes.NewSlot> 특성에 다음과 비슷한 코드를 사용 하 여: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` C# 또는 `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` Visual Basic의 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-430">To determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic.</span></span> <span data-ttu-id="687de-431">단, 하는 모든 방법을 사용 하 여 선언 되지만 `new` 또는 `Shadows` 가 합니다 <xref:System.Reflection.MethodAttributes.NewSlot> 특성에 있는 모든 메서드를 <xref:System.Reflection.MethodAttributes.NewSlot> 특성으로 선언 되 `new` 또는 `Shadows`.</span><span class="sxs-lookup"><span data-stu-id="687de-431">Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute are declared with `new` or `Shadows`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-432">다음 코드 예제는 오버 로드 된 메서드를 사용 하 여 기본 클래스 및 오버 로드 중 하나를 숨기는 파생된 클래스를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-432">The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</span></span> <span data-ttu-id="687de-433">Visual Basic 버전의 코드 예제는 <xref:System.Reflection.MethodBase.IsHideBySig%2A> 속성이 반환 `false` 파생된 클래스의 멤버에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-433">In the Visual Basic version of the code example, the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property returns `false` for the member in the derived class.</span></span> <span data-ttu-id="687de-434">속성은 C# 버전의 코드 예제에서는 반환 `true` 파생된 클래스의 멤버에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-434">In the C# version of the code sample, the property returns `true` for the member in the derived class.</span></span>  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrivate : bool" Usage="System.Reflection.MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-435">이 멤버가 전용인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-435">Gets a value indicating whether this member is private.</span></span></summary>
        <value><span data-ttu-id="687de-436">이 메서드에 대한 액세스가 클래스 자신의 다른 멤버로 제한되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-436"><see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-437">형식 멤버에 `Private` 수준 표시 유형이 호출 될 수 같은 클래스에 없는 다른 모든 멤버에서입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-437">If a type member has `Private` level visibility, it can be called from any member in the same class and no others.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Reflection.MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-438">이 메서드가 public 메서드인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-438">Gets a value indicating whether this is a public method.</span></span></summary>
        <value><span data-ttu-id="687de-439">이 메서드가 public 메서드이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-439"><see langword="true" /> if this method is public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-440">가져오려는 <xref:System.Reflection.MethodBase>, 먼저 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-440">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="687de-441">형식에서 메서드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-441">From the type, get the method.</span></span> <span data-ttu-id="687de-442">메서드에서 가져오기는 `MethodBase`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-442">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="687de-443">경우는 `MethodBase` 또는 생성자가 public이 아닌, 보호 되 고 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-443">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="687de-444">Public이 아닌 메서드에 액세스 하려면 설정 합니다 <xref:System.Reflection.BindingFlags> 마스크를 `NonPublic` 에서 `GetMethod`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-444">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-445">다음 예제에서는 <xref:System.Reflection.MethodBase.IsPublic%2A> 속성을 지정된 된 메서드가 공용 인지 여부를 나타내는 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-445">The following example uses the <xref:System.Reflection.MethodBase.IsPublic%2A> property to display a message that indicates whether the specified method is public.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-446">현재 메서드나 생성자가 현재 신뢰 수준에서 보안에 중요한 형식이거나 보안 안전에 중요한 형식이어서 중요한 작업을 수행할 수 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-446">Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="687de-447">현재 메서드나 생성자가 현재 신뢰 수준에서 보안에 중요하거나 보안 안전에 중요한 경우 <see langword="true" />이고 투명한 경우 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-447"><see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-448">합니다 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 속성 메서드 또는 생성자는 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에서의 투명도 수준을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-448">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="687de-449">이러한 속성의 조합도 표에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-449">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="687de-450">보안 수준</span><span class="sxs-lookup"><span data-stu-id="687de-450">Security level</span></span>|<span data-ttu-id="687de-451">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="687de-451">IsSecurityCritical</span></span>|<span data-ttu-id="687de-452">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="687de-452">IsSecuritySafeCritical</span></span>|<span data-ttu-id="687de-453">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="687de-453">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="687de-454">중요</span><span class="sxs-lookup"><span data-stu-id="687de-454">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="687de-455">안전 중요</span><span class="sxs-lookup"><span data-stu-id="687de-455">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="687de-456">투명</span><span class="sxs-lookup"><span data-stu-id="687de-456">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="687de-457">이러한 속성을 사용 하는 것은 어셈블리 및 해당 형식과 멤버의 보안 주석을 검사 하 고 현재 신뢰 수준 검사 런타임 규칙을 복제 하는 보다 훨씬 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-457">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="687de-458">부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="687de-458">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="687de-459">어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임은 어셈블리의 보안 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-459">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="687de-460">어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-460">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="687de-461">런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-461">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="687de-462">반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-462">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="687de-463">사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-463">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="687de-464">리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-464">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="687de-465">투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-465">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="687de-466">리플렉션의 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="687de-466">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="687de-467">.NET Framework 버전 4.0의 보안 변경 내용</span><span class="sxs-lookup"><span data-stu-id="687de-467">Security Changes in the .NET Framework Version 4.0</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-468">현재 메서드나 생성자가 현재 신뢰 수준에서 보안 안전에 중요한 형식인지 즉, 중요한 작업을 수행할 수 있고 투명 코드로 액세스할 수 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-468">Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="687de-469">현재 메서드나 생성자가 현재 신뢰 수준에서 보안 안전에 중요한 경우 <see langword="true" />이고 보안에 중요하거나 투명한 경우 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-469"><see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-470">합니다 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 속성 메서드 또는 생성자는 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에서의 투명도 수준을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-470">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="687de-471">이러한 속성의 조합도 표에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-471">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="687de-472">보안 수준</span><span class="sxs-lookup"><span data-stu-id="687de-472">Security level</span></span>|<span data-ttu-id="687de-473">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="687de-473">IsSecurityCritical</span></span>|<span data-ttu-id="687de-474">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="687de-474">IsSecuritySafeCritical</span></span>|<span data-ttu-id="687de-475">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="687de-475">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="687de-476">중요</span><span class="sxs-lookup"><span data-stu-id="687de-476">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="687de-477">안전 중요</span><span class="sxs-lookup"><span data-stu-id="687de-477">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="687de-478">투명</span><span class="sxs-lookup"><span data-stu-id="687de-478">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="687de-479">이러한 속성을 사용 하는 것은 어셈블리 및 해당 형식과 멤버의 보안 주석을 검사 하 고 현재 신뢰 수준 검사 런타임 규칙을 복제 하는 보다 훨씬 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-479">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="687de-480">부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="687de-480">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="687de-481">어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임은 어셈블리의 보안 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-481">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="687de-482">어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-482">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="687de-483">런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-483">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="687de-484">반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-484">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="687de-485">사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-485">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="687de-486">리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-486">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="687de-487">투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-487">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="687de-488">리플렉션의 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="687de-488">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="687de-489">.NET Framework 버전 4.0의 보안 변경 내용</span><span class="sxs-lookup"><span data-stu-id="687de-489">Security Changes in the .NET Framework Version 4.0</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-490">현재 메서드나 생성자가 현재 신뢰 수준에서 투명하여 중요한 작업을 수행할 수 없는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-490">Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="687de-491">현재 메서드나 생성자가 현재 신뢰 수준에서 보안에 투명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-491"><see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-492">이 속성을 반환 하는 경우 `true`는 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> 하 고 <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> 속성 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-492">If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="687de-493">합니다 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 속성 메서드 또는 생성자는 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에서의 투명도 수준을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-493">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="687de-494">이러한 속성을 사용 하는 것은 어셈블리 및 해당 형식과 멤버의 보안 주석을 검사 하 고 현재 신뢰 수준 검사 런타임 규칙을 복제 하는 보다 훨씬 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-494">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="687de-495">부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="687de-495">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="687de-496">어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임은 어셈블리의 보안 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-496">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="687de-497">어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="687de-497">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="687de-498">런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-498">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="687de-499">반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-499">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="687de-500">사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-500">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="687de-501">리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-501">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="687de-502">투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-502">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="687de-503">리플렉션의 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="687de-503">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="687de-504">.NET Framework 버전 4.0의 보안 변경 내용</span><span class="sxs-lookup"><span data-stu-id="687de-504">Security Changes in the .NET Framework Version 4.0</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-505">이 메서드의 이름이 특수한지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-505">Gets a value indicating whether this method has a special name.</span></span></summary>
        <value><span data-ttu-id="687de-506">이 메서드의 이름이 특수하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-506"><see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-507"><xref:System.Reflection.MethodAttributes.SpecialName> 비트가 멤버 (예: 속성 접근자와 메서드를 오버 로드할 연산자) 일부 컴파일러에서 특별 한 방식으로 처리 되는 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-507">The <xref:System.Reflection.MethodAttributes.SpecialName> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="687de-508">이 예제에는 사용 방법을 보여 줍니다. <xref:System.Reflection.MethodBase.IsSpecialName%2A> 필터 내부 또는 전용 멤버 목록에서.</span><span class="sxs-lookup"><span data-stu-id="687de-508">This example shows a use of <xref:System.Reflection.MethodBase.IsSpecialName%2A> to filter internal or private members out of a list.</span></span>  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStatic : bool" Usage="System.Reflection.MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-509">메서드가 <see langword="static" />인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-509">Gets a value indicating whether the method is <see langword="static" />.</span></span></summary>
        <value><span data-ttu-id="687de-510">이 메서드가 <see langword="static" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-510"><see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-511">정적 멤버를 클래스의 인스턴스 데이터를 암시적으로 참조 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-511">A static member cannot implicitly reference instance data in a class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVirtual : bool" Usage="System.Reflection.MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-512">메서드가 <see langword="virtual" />인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-512">Gets a value indicating whether the method is <see langword="virtual" />.</span></span></summary>
        <value><span data-ttu-id="687de-513">이 메서드가 <see langword="virtual" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-513"><see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-514">가상 멤버는 클래스의 인스턴스 데이터를 참조할 수 있습니다 및 클래스의 인스턴스를 통해 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-514">A virtual member may reference instance data in a class and must be referenced through an instance of the class.</span></span>  
  
 <span data-ttu-id="687de-515">메서드를 재정의할 수 있는지 확인 하지 않았는지 확인 하기에 충분 하 `IsVirtual` 는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-515">To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`.</span></span> <span data-ttu-id="687de-516">재정의할, 메서드에 대 한 `IsVirtual` 이어야 합니다 `true` 하 고 <xref:System.Reflection.MethodBase.IsFinal%2A> 여야 합니다 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-516">For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`.</span></span> <span data-ttu-id="687de-517">예를 들어 메서드 비가상 이며 수 있지만 인터페이스 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-517">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="687de-518">공용 언어 런타임에서 인터페이스 멤버를 구현 하는 모든 메서드를 표시 합니다 필요 `virtual`따라서 컴파일러는 메서드 표시 `virtual final`합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-518">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="687de-519">메서드가로 표시 되어 있는 경우 되므로 `virtual` 되지만 재정의할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-519">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="687de-520">메서드는 재정의할 수 있는지 여부를 확실 하 게 설정 하 고, 이와 같은 코드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-520">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 <span data-ttu-id="687de-521">하는 경우 `IsVirtual` 됩니다 `false` 또는 `IsFinal` 는 `true`, 다음 메서드를 재정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-521">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
 <span data-ttu-id="687de-522">현재 메서드를 호출 하 여 기본 클래스의 메서드를 재정의 하는지 여부를 확인할 수 있습니다는 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="687de-522">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="687de-523">다음 예제에서는 구현 하는 `IsOverride` 이 작업을 수행 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-523">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="687de-524">다음 예제에서는 표시 `false` 에 대 한 `IsFinal`, 하다 고 생각 하 게 될 것입니다 `MyMethod` 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-524">The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable.</span></span> <span data-ttu-id="687de-525">코드 인쇄 `false` 하더라도 `MyMethod` 표시 되지 않는 `virtual` 재정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-525">The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.MethodBase.MethodHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-526">메서드의 내부 메타데이터 표현에 대한 핸들을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-526">Gets a handle to the internal metadata representation of a method.</span></span></summary>
        <value><span data-ttu-id="687de-527"><see cref="T:System.RuntimeMethodHandle" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-527">A <see cref="T:System.RuntimeMethodHandle" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-528">핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-528">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-529">메서드 구현의 특성을 지정하는 <see cref="T:System.Reflection.MethodImplAttributes" /> 플래그를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-529">Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</span></span></summary>
        <value><span data-ttu-id="687de-530">메서드 구현 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-530">The method implementation flags.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-531">자세한 내용은 <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-531">See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="687de-532">비교할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-532">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="687de-533">비교할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-533">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="687de-534">두 <see cref="T:System.Reflection.MethodBase" /> 개체가 같은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="687de-534">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="687de-535"><see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-535"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="System.Reflection.MethodBase.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="687de-536">비교할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-536">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="687de-537">비교할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-537">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="687de-538">두 <see cref="T:System.Reflection.MethodBase" /> 개체가 같지 않은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="687de-538">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="687de-539"><see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-539"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="687de-540">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-540">Reserved for future use.</span></span> <span data-ttu-id="687de-541">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-541">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="687de-542">매핑할 전달된 이름의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-542">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="687de-543">매핑할 이름의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-543">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="687de-544">이름을 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-544">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="687de-545">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-545">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="687de-546">이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-546">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-547">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-547">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="687de-548">에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-548">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="687de-549">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-549">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="687de-550">이 멤버에 대한 설명은 <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="687de-550">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span></span></summary>
        <returns><span data-ttu-id="687de-551">이 멤버에 대한 설명은 <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-551">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-552">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-552">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-553"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-553">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="687de-554">반환할 형식 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-554">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="687de-555">형식 정보의 로캘 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-555">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="687de-556">요청된 형식 정보 개체에 대한 포인터를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-556">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="687de-557">인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-557">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-558">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-558">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="687de-559">에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-559">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="687de-560">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-560">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="687de-561">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="687de-561">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="687de-562">개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</span><span class="sxs-lookup"><span data-stu-id="687de-562">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-563">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-563">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="687de-564">에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-564">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="687de-565">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-565">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="687de-566">멤버를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-566">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="687de-567">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-567">Reserved for future use.</span></span> <span data-ttu-id="687de-568">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-568">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="687de-569">인수를 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-569">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="687de-570">호출의 컨텍스트를 설명하는 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-570">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="687de-571">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-571">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="687de-572">결과를 저장할 위치에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-572">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="687de-573">예외 정보가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-573">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="687de-574">오류가 있는 첫 번째 인수의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="687de-574">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="687de-575">개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-575">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-576">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-576">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="687de-577">에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="687de-577">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="687de-578">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-578">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-579">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="687de-579">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span></span></summary>
        <value><span data-ttu-id="687de-580">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-580">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-581">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-581">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-582"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-582">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-583">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-583">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span></span></summary>
        <value><span data-ttu-id="687de-584">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-584">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-585">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-585">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-586"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-586">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-587">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-587">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span></span></summary>
        <value><span data-ttu-id="687de-588">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-588">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-589">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-589">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-590"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-590">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-591">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-591">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span></span></summary>
        <value><span data-ttu-id="687de-592">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-592">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-593">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-593">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-594"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-594">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-595">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-595">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span></span></summary>
        <value><span data-ttu-id="687de-596">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-596">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-597">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-597">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-598"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-598">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-599">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-599">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span></span></summary>
        <value><span data-ttu-id="687de-600">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-600">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-601">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-601">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-602"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-602">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-603">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-603">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span></span></summary>
        <value><span data-ttu-id="687de-604">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-604">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-605">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-605">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-606"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-606">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-607">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-607">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span></span></summary>
        <value><span data-ttu-id="687de-608">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-608">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-609">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-609">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-610"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-610">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-611">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-611">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span></span></summary>
        <value><span data-ttu-id="687de-612">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-612">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-613">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-613">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-614"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-614">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-615">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-615">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span></span></summary>
        <value><span data-ttu-id="687de-616">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-616">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-617">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-617">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-618"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-618">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-619">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-619">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span></span></summary>
        <value><span data-ttu-id="687de-620">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-620">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-621">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-621">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-622"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-622">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-623">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-623">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span></span></summary>
        <value><span data-ttu-id="687de-624">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-624">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-625">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-625">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-626"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-626">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="687de-627">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-627">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span></span></summary>
        <value><span data-ttu-id="687de-628">이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="687de-628">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="687de-629">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="687de-629">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="687de-630"><xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="687de-630">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>