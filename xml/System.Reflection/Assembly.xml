<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6cb498a4f3e0b27726279e22104a375be85ad97e" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56363427" /></Metadata><TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="84bad-101">다시 사용 및 버전 지정이 가능한, 공용 언어 런타임 응용 프로그램의 자체 설명 빌딩 블록인 어셈블리를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-101">Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-102">사용 된 <xref:System.Reflection.Assembly> 어셈블리, 어셈블리에 포함 된 형식을 검색 하 고 해당 형식의 인스턴스를 만들 수의 메타 데이터 및 구성 요소를 탐색 하려면 어셈블리를 로드 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-102">Use the <xref:System.Reflection.Assembly> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</span></span>  
  
 <span data-ttu-id="84bad-103">배열을 가져오려면 <xref:System.Reflection.Assembly> 어셈블리를 현재 나타내는 로드 애플리케이션 도메인 (예를 들어, 애플리케이션의 기본 도메인 간단한 프로젝트를)를 사용 하 여 개체를 <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-103">To get an array of <xref:System.Reflection.Assembly> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="84bad-104">어셈블리를 동적으로 로드 하는 <xref:System.Reflection.Assembly> 정적 메서드를 제공 하는 클래스 (`Shared` Visual Basic의 메서드).</span><span class="sxs-lookup"><span data-stu-id="84bad-104">To load assemblies dynamically, the <xref:System.Reflection.Assembly> class provides the following static methods (`Shared` methods in Visual Basic).</span></span> <span data-ttu-id="84bad-105">어셈블리 로드 작업이 발생 하는 애플리케이션 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-105">Assemblies are loaded into the application domain where the load operation occurs.</span></span>  
  
-   <span data-ttu-id="84bad-106">어셈블리를 로드 하는 권장된 방법은 사용 하는 것은 <xref:System.AppDomain.Load%2A> 표시 이름을 사용 하 여 로드할 어셈블리를 식별 하는 메서드 (예를 들어, "System.Windows.Forms, 버전 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089 =").</span><span class="sxs-lookup"><span data-stu-id="84bad-106">The recommended way to load assemblies is to use the <xref:System.AppDomain.Load%2A> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</span></span> <span data-ttu-id="84bad-107">어셈블리에 대 한 검색에 설명 된 규칙을 따릅니다 [런타임 어셈블리를 찾는 방법](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-107">The search for the assembly follows the rules described in [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span></span>  
  
-   <span data-ttu-id="84bad-108">합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드를 사용 하면 실행 아니라 리플렉션을 위해 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-108">The <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods enable you to load an assembly for reflection, but not for execution.</span></span> <span data-ttu-id="84bad-109">예를 들어 32 비트 플랫폼에서 실행 되는 코드에서 64 비트 플랫폼을 대상으로 하는 어셈블리를 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-109">For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</span></span>  
  
-   <span data-ttu-id="84bad-110">합니다 <xref:System.Reflection.Assembly.LoadFile%2A> 고 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 어셈블리 경로로 식별 해야 하는 드문 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-110">The <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A> methods are provided for rare scenarios in which an assembly must be identified by path.</span></span>  
  
 <span data-ttu-id="84bad-111">가져올는 <xref:System.Reflection.Assembly> 사용 하 여 현재 실행 중인 어셈블리에 대 한 개체는 <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-111">To get an <xref:System.Reflection.Assembly> object for the currently executing assembly, use the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method.</span></span>  
  
 <span data-ttu-id="84bad-112">많은 멤버를 <xref:System.Reflection.Assembly> 클래스는 어셈블리에 대 한 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-112">Many members of the <xref:System.Reflection.Assembly> class provide information about an assembly.</span></span> <span data-ttu-id="84bad-113">예:</span><span class="sxs-lookup"><span data-stu-id="84bad-113">For example:</span></span>  
  
-   <span data-ttu-id="84bad-114">합니다 <xref:System.Reflection.Assembly.GetName%2A> 메서드가 반환 되는 <xref:System.Reflection.AssemblyName> 어셈블리 표시 이름 부분에 대 한 액세스를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-114">The <xref:System.Reflection.Assembly.GetName%2A> method returns an <xref:System.Reflection.AssemblyName> object that provides access to the parts of the assembly display name.</span></span>  
  
-   <span data-ttu-id="84bad-115"><xref:System.Reflection.Assembly.GetCustomAttributes%2A> 메서드는 어셈블리에 적용할 특성을 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-115">The <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method lists the attributes applied to the assembly.</span></span>  
  
-   <span data-ttu-id="84bad-116"><xref:System.Reflection.Assembly.GetFiles%2A> 메서드는 어셈블리 매니페스트가 있는 파일에 대 한 액세스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-116">The <xref:System.Reflection.Assembly.GetFiles%2A> method provides access to the files in the assembly manifest.</span></span>  
  
-   <span data-ttu-id="84bad-117"><xref:System.Reflection.Assembly.GetManifestResourceNames%2A> 메서드 어셈블리 매니페스트에서 리소스의 이름을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-117">The <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> method provides the names of the resources in the assembly manifest.</span></span>  
  
 <span data-ttu-id="84bad-118"><xref:System.Reflection.Assembly.GetTypes%2A> 메서드는 어셈블리의 모든 형식을 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-118">The <xref:System.Reflection.Assembly.GetTypes%2A> method lists all the types in the assembly.</span></span> <span data-ttu-id="84bad-119"><xref:System.Reflection.Assembly.GetExportedTypes%2A> 메서드 호출자가 어셈블리 외부에 표시 되는 형식을 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-119">The <xref:System.Reflection.Assembly.GetExportedTypes%2A> method lists the types that are visible to callers outside the assembly.</span></span> <span data-ttu-id="84bad-120"><xref:System.Reflection.Assembly.GetType%2A> 어셈블리에서 특정 형식을 검색할 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-120">The <xref:System.Reflection.Assembly.GetType%2A> method can be used to search for a particular type in the assembly.</span></span> <span data-ttu-id="84bad-121"><xref:System.Reflection.Assembly.CreateInstance%2A> 메서드를 사용 하 여 어셈블리에서 형식의 인스턴스를 만들고 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-121">The <xref:System.Reflection.Assembly.CreateInstance%2A> method can be used to search for and create instances of types in the assembly.</span></span>  
  
 <span data-ttu-id="84bad-122">어셈블리에 대 한 자세한 내용은 "애플리케이션 도메인 및 어셈블리" 섹션을 참조 합니다 [애플리케이션 도메인](~/docs/framework/app-domains/application-domains.md) 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-122">For more information on assemblies, see the "Application Domains and Assemblies" section in the [Application Domains](~/docs/framework/app-domains/application-domains.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-123">다음 코드 예제에는 현재 실행 중인 어셈블리를 가져올, 해당 어셈블리에 포함 된 형식의 인스턴스를 만들고, 런타임에 바인딩을 사용 하 여 형식의 메서드 중 하나를 호출 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-123">The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</span></span> <span data-ttu-id="84bad-124">코드 예제에서는이 목적을 위해 라는 클래스를 정의 `Example`, 라는 메서드를 사용 하 여 `SampleMethod`입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-124">For this purpose, the code example defines a class named `Example`, with a method named `SampleMethod`.</span></span> <span data-ttu-id="84bad-125">클래스의 생성자는 메서드의 반환 값을 계산 하는 데 사용 되는 정수를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-125">The constructor of the class accepts an integer, which is used to compute the return value of the method.</span></span>  
  
 <span data-ttu-id="84bad-126">코드 예제에서는 또한의 사용을 보여 줍니다 합니다 <xref:System.Reflection.Assembly.GetName%2A> 메서드는 <xref:System.Reflection.AssemblyName> 어셈블리의 전체 이름을 구문 분석 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-126">The code example also demonstrates the use of the <xref:System.Reflection.Assembly.GetName%2A> method to obtain an <xref:System.Reflection.AssemblyName> object that can be used to parse the full name of the assembly.</span></span> <span data-ttu-id="84bad-127">이 예제에서는 어셈블리의 버전 번호를 표시 합니다 <xref:System.Reflection.Assembly.CodeBase%2A> 속성인 및 <xref:System.Reflection.Assembly.EntryPoint%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="84bad-127">The example displays the version number of the assembly, the <xref:System.Reflection.Assembly.CodeBase%2A> property, and the <xref:System.Reflection.Assembly.EntryPoint%2A> property.</span></span>  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="84bad-128">상속자에 대 한 완전 신뢰 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-128">for full trust for inheritors.</span></span> <span data-ttu-id="84bad-129">부분적으로 신뢰할 수 있는 코드에서이 클래스를 상속할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-129">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="84bad-130">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-130">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md"><span data-ttu-id="84bad-131">응용 프로그램 도메인</span><span class="sxs-lookup"><span data-stu-id="84bad-131">Application Domains</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-132"><see cref="T:System.Reflection.Assembly" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-132">Initializes a new instance of the <see cref="T:System.Reflection.Assembly" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-133">파생된 클래스에서 생성 하는 동안이 생성자가 호출 <xref:System.Reflection.Assembly> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-133">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Assembly> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-134">예를 들어 <see cref="T:System.Reflection.AssemblyName" /> 개체에 원래 지정된 어셈블리 위치를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-134">Gets the location of the assembly as specified originally, for example, in an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span></summary>
        <value><span data-ttu-id="84bad-135">원래 지정된 어셈블리 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-135">The location of the assembly as specified originally.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-136">로드 된 매니페스트가 들어 있는 파일의 절대 경로 가져오려면는 <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> 속성 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-136">To get the absolute path to the loaded manifest-containing file, use the <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="84bad-137">오버 로드를 사용 하 여 어셈블리를 바이트 배열로 로드 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 바이트 배열을 사용 하는 메서드를이 속성에는 로드 된 어셈블리의 위치가 아닌 메서드의 호출자의 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-137">If the assembly was loaded as a byte array, using an overload of the <xref:System.Reflection.Assembly.Load%2A> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-138">다음 예제에서는 <xref:System.Reflection.Assembly.CodeBase%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-138">The following example uses the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-139">경로에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-139">for access to the path.</span></span> <span data-ttu-id="84bad-140">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-140">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-141">이 어셈블리에서 형식을 찾은 다음 시스템 활성기를 사용하여 해당 형식의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-141">Locates a type from this assembly and creates an instance of it using the system activator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="84bad-142">찾을 형식의 <see cref="P:System.Type.FullName" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-142">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <summary><span data-ttu-id="84bad-143">대/소문자 구분 검색 기능을 사용하여 이 어셈블리에서 지정된 형식을 찾은 다음 시스템 활성기를 사용하여 해당 형식의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-143">Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="84bad-144"><see langword="null" />을 찾을 수 있는 경우 기본 생성자로 만든 지정된 형식의 인스턴스이며, 그렇지 않은 경우는 <paramref name="typeName" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-144">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="84bad-145">형식은 문화권 또는 활성화 특성을 지정하지 않고 <see cref="T:System.Reflection.BindingFlags" />를 <see langword="Public" /> 또는 <see langword="Instance" />로 설정하여 기본 바인더를 사용하여 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-145">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-146">런타임에서 찾을 수 없으면 `typeName` 에 <xref:System.Reflection.Assembly> 인스턴스를 반환 합니다 `null` 예외를 throw 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-146">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="84bad-147">이 때문에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-147">This might happen because:</span></span>  
  
-   <span data-ttu-id="84bad-148">형식의 정규화 된 이름을 지정 하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-148">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="84bad-149">정규화 된 형식 이름을 지정한 이지만 해당 사례 형식의 소문자가 일치 하지 않습니다 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-149">You've specified the fully qualified type name, but its case doesn't match the case of the type's <xref:System.Type.FullName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="84bad-150">대/소문자 구분 비교 `typeName` 형식의 전체 이름을 사용 하 여 호출 합니다 <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> 오버 로드 하 고 지정 `true` 에 대 한는 `ignoreCase` 인수.</span><span class="sxs-lookup"><span data-stu-id="84bad-150">For a case-insensitive comparison of `typeName` with the type's full name, call the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specify `true` for the `ignoreCase` argument.</span></span>  
  
-   <span data-ttu-id="84bad-151">현재에서 형식이 없는 <xref:System.Reflection.Assembly> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="84bad-151">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-152">다음 예제에서는 정의 `Person` 클래스 및 호출 된 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 메서드를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-152">The following example defines a `Person` class and calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-153"><paramref name="typeName" />이 빈 문자열("") 또는 null 문자로 시작하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-153"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="84bad-154">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-154">-or-</span></span> 
<span data-ttu-id="84bad-155">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-155">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-156"><paramref name="typeName" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-156"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="84bad-157">일치하는 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-157">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-158"><paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-158"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-159"><paramref name="typeName" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-159"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="84bad-160">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-160">-or-</span></span> 
<span data-ttu-id="84bad-161">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-161">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-162"><paramref name="typeName" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-162"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-163">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-163">-or-</span></span> 
 <span data-ttu-id="84bad-164"><paramref name="typeName" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-164"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-165">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-165">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-166">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-166">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="84bad-167">찾을 형식의 <see cref="P:System.Type.FullName" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-167">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="84bad-168">형식 이름의 대/소문자를 무시하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-168"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="84bad-169">대/소문자 구분 검색 기능을 선택적으로 사용하여, 지정된 형식을 이 어셈블리에서 찾은 다음 시스템 활성기를 사용하여 해당 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-169">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="84bad-170"><see langword="null" />을 찾을 수 있는 경우 기본 생성자로 만든 지정된 형식의 인스턴스이며, 그렇지 않은 경우는 <paramref name="typeName" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-170">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="84bad-171">형식은 문화권 또는 활성화 특성을 지정하지 않고 <see cref="T:System.Reflection.BindingFlags" />를 <see langword="Public" /> 또는 <see langword="Instance" />로 설정하여 기본 바인더를 사용하여 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-171">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-172">런타임에서 찾을 수 없으면 `typeName` 에 <xref:System.Reflection.Assembly> 인스턴스를 반환 합니다 `null` 예외를 throw 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-172">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="84bad-173">이 때문에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-173">This might happen because:</span></span>  
  
-   <span data-ttu-id="84bad-174">형식의 정규화 된 이름을 지정 하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-174">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="84bad-175">현재에서 형식이 없는 <xref:System.Reflection.Assembly> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="84bad-175">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-176">다음 예제에서는 정의 `Person` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-176">The following example defines a `Person` class.</span></span> <span data-ttu-id="84bad-177">그런 다음 호출 하는 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 를 인스턴스화하기 위한 메서드를 하지만의 대/소문자를 `typeName` 인수 형식의 일치 하지 않는 <xref:System.Type.FullName%2A> 속성, 메서드는 반환 `null`.</span><span class="sxs-lookup"><span data-stu-id="84bad-177">It then calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it, but because the casing of the `typeName` argument doesn't match that of the type's <xref:System.Type.FullName%2A> property, the method returns `null`.</span></span> <span data-ttu-id="84bad-178">이 예제에서는 동일한 문자열을 전달 하는 경우는 <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> 오버 로드 하 고 비교, 대/소문자 이어야 함을 지정 합니다 `Person` 클래스를 찾을 수 및 `Person` 이 개체가 인스턴스화.</span><span class="sxs-lookup"><span data-stu-id="84bad-178">When the example passes the same string to the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specifies that the comparison should be case-insensitive, the `Person` class is found, and a `Person` object is successfully instantiated.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-179"><paramref name="typeName" />이 빈 문자열("") 또는 null 문자로 시작하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-179"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="84bad-180">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-180">-or-</span></span> 
<span data-ttu-id="84bad-181">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-181">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="84bad-182">일치하는 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-182">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-183"><paramref name="typeName" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-183"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-184"><paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-184"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-185"><paramref name="typeName" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-185"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="84bad-186">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-186">-or-</span></span> 
<span data-ttu-id="84bad-187">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-187">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-188"><paramref name="typeName" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-188"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-189">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-189">-or-</span></span> 
 <span data-ttu-id="84bad-190"><paramref name="typeName" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-190"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-191">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-191">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-192">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-192">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="84bad-193">찾을 형식의 <see cref="P:System.Type.FullName" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-193">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="84bad-194">형식 이름의 대/소문자를 무시하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-194"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="84bad-195">검색 수행 방법에 영향을 주는 비트 마스크입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-195">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="84bad-196">이 값은 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-196">The value is a combination of bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="84bad-197">리플렉션을 사용하여 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see langword="MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-197">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="84bad-198"><paramref name="binder" />가 <see langword="null" />이면 기본 바인더가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-198">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="84bad-199">생성자에 전달되는 인수를 포함하는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-199">An array that contains the arguments to be passed to the constructor.</span></span> <span data-ttu-id="84bad-200">이 인수 배열은 실행될 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-200">This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</span></span> <span data-ttu-id="84bad-201">기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 <see langword="null" />이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-201">If the default constructor is desired, <paramref name="args" /> must be an empty array or <see langword="null" />.</span></span></param>
        <param name="culture"><span data-ttu-id="84bad-202">형식의 강제 변환을 제어하는 데 사용되는 <see langword="CultureInfo" />의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-202">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="84bad-203">이 매개 변수가 <see langword="null" />이면 현재 스레드에 대한 <see langword="CultureInfo" />가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-203">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="84bad-204">예를 들어 1,000은 각 문화권마다 다르게 표현되므로 1,000을 나타내는 <see langword="String" />을 <see langword="Double" /> 값으로 변환하기 위해 이 매개 변수가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-204">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="84bad-205">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-205">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="84bad-206">일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-206">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  <span data-ttu-id="84bad-207">이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-207">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="84bad-208">클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-208">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="84bad-209">분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-209">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="84bad-210">대/소문자 구분 검색 기능을 선택적으로 사용하고 지정된 문화권, 인수, 바인딩 및 활성화 특성을 사용하여, 지정된 형식을 이 어셈블리에서 찾은 다음 시스템 활성기를 사용하여 해당 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-210">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</span></span></summary>
        <returns><span data-ttu-id="84bad-211">지정된 형식의 인스턴스 또는 <see langword="null" />이 없으면 <paramref name="typeName" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-211">An instance of the specified type, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="84bad-212">제공된 인수는 형식을 확인하고 인스턴스를 만드는 데 사용된 생성자를 바인딩하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-212">The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-213"><paramref name="typeName" />이 빈 문자열("") 또는 null 문자로 시작하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-213"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="84bad-214">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-214">-or-</span></span> 
<span data-ttu-id="84bad-215">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-215">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-216"><paramref name="typeName" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-216"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="84bad-217">일치하는 생성자를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-217">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="84bad-218">비어 있지 않은 활성화 특성 배열이 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 형식에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-218">A non-empty activation attributes array is passed to a type that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-219"><paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-219"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-220"><paramref name="typeName" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-220"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="84bad-221">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-221">-or-</span></span> 
<span data-ttu-id="84bad-222">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-222">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-223"><paramref name="typeName" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-223"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-224">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-224">-or-</span></span> 
 <span data-ttu-id="84bad-225"><paramref name="typeName" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-225"><paramref name="typeName" /> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-226">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-226">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-227">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-227">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-228">대리자의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-228">to create an instance of a delegate.</span></span> <span data-ttu-id="84bad-229">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="84bad-229">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="84bad-230">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-230">The display name of an assembly.</span></span></param>
        <param name="typeName"><span data-ttu-id="84bad-231">형식의 전체 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-231">The full name of a type.</span></span></param>
        <summary><span data-ttu-id="84bad-232">어셈블리의 표시 이름에 의해 정규화된 형식의 이름을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-232">Creates the name of a type qualified by the display name of its assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-233">어셈블리의 표시 이름으로 정규화된 이 형식의 전체 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-233">The full name of the type qualified by the display name of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-234">반환된 된 문자열의 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-234">The format of the returned string is:</span></span>  
  
 <span data-ttu-id="84bad-235">\<FullTypeName>, \<AssemblyDisplayName></span><span class="sxs-lookup"><span data-stu-id="84bad-235">\<FullTypeName>, \<AssemblyDisplayName></span></span>  
  
 <span data-ttu-id="84bad-236">참조 <xref:System.Reflection.AssemblyName> 형식의 어셈블리의 표시 이름에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-236">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
 <span data-ttu-id="84bad-237">공용 언어 런타임의 버전의 변경 내용에 맞게, 직접 정규화 된 이름을 생성 하는 대신이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-237">To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</span></span>  <span data-ttu-id="84bad-238">정규화 된 어셈블리 이름에 대 한 자세한 내용은 <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-238">For information about qualified assembly names, see <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-239">이 어셈블리의 사용자 지정 특성을 포함하는 컬렉션을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-239">Gets a collection that contains this assembly's custom attributes.</span></span></summary>
        <value><span data-ttu-id="84bad-240">이 어셈블리의 사용자 지정 특성을 포함하는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-240">A collection that contains this assembly's custom attributes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-241">이 어셈블리에 정의된 형식의 컬렉션을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-241">Gets a collection of the types defined in this assembly.</span></span></summary>
        <value><span data-ttu-id="84bad-242">이 어셈블리에 정의된 형식의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-242">A collection of the types defined in this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-243"><xref:System.Reflection.Assembly.DefinedTypes%2A> 속성은 비교할 합니다 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 메서드는 <xref:System.Reflection.Assembly.DefinedTypes%2A> 속성의 컬렉션을 반환 <xref:System.Reflection.TypeInfo> 개체 및 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 의 배열을 반환 합니다 <xref:System.Type> 개체.</span><span class="sxs-lookup"><span data-stu-id="84bad-243">The <xref:System.Reflection.Assembly.DefinedTypes%2A> property is comparable to the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method, except that the <xref:System.Reflection.Assembly.DefinedTypes%2A> property returns a collection of <xref:System.Reflection.TypeInfo> objects, and the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method returns an array of <xref:System.Type> objects.</span></span>  
  
 <span data-ttu-id="84bad-244">반환된 된 배열에는 중첩된 형식이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-244">The returned array includes nested types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-245">이 어셈블리의 진입점을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-245">Gets the entry point of this assembly.</span></span></summary>
        <value><span data-ttu-id="84bad-246">이 어셈블리의 진입점을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-246">An object that represents the entry point of this assembly.</span></span> <span data-ttu-id="84bad-247">예를 들어 어셈블리가 DLL이어서 진입점을 찾을 수 없는 경우에는 <see langword="null" />이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-247">If no entry point is found (for example, the assembly is a DLL), <see langword="null" /> is returned.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="84bad-248">이 인스턴스와 비교할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-248">The object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="84bad-249">이 어셈블리와 지정된 개체가 서로 같은지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-249">Determines whether this assembly and the specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="84bad-250"><see langword="true" />가 이 인스턴스와 같으면 <paramref name="o" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-250"><see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-251"><xref:System.Reflection.Assembly.Equals%2A> 메서드를 확인 하려면 참조 같음 테스트를 수행 하는지 여부를 현재 인스턴스 및 `o` 같은지 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-251">The <xref:System.Reflection.Assembly.Equals%2A> method performs a test for reference equality to determine whether the current instance and `o` are equal.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-252">코드베이스를 나타내는 URI를 가져옵니다(이스케이프 문자 포함).</span><span class="sxs-lookup"><span data-stu-id="84bad-252">Gets the URI, including escape characters, that represents the codebase.</span></span></summary>
        <value><span data-ttu-id="84bad-253">이스케이프 문자를 포함하는 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-253">A URI with escape characters.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-254">경로에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-254">for access to the path.</span></span> <span data-ttu-id="84bad-255">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-255">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-256">이 어셈블리의 증명을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-256">Gets the evidence for this assembly.</span></span></summary>
        <value><span data-ttu-id="84bad-257">이 어셈블리에 대한 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-257">The evidence for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-258">증명 정보는 코드에 부여할 수 있는 권한 같이 보안 정책을 결정하기 위해 입력하는 정보 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-258">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-259">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-259">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-260">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-260">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-261">이 어셈블리에 정의된 형식 중 어셈블리 외부에서 볼 수 있는 public 형식의 컬렉션을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-261">Gets a collection of the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <value><span data-ttu-id="84bad-262">이 어셈블리에 정의된 형식 중 어셈블리 외부에서 볼 수 있는 public 형식의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-262">A collection of the public types defined in this assembly that are visible outside the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-263">어셈블리의 표시 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-263">Gets the display name of the assembly.</span></span></summary>
        <value><span data-ttu-id="84bad-264">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-264">The display name of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-265">참조 <xref:System.Reflection.AssemblyName> 형식의 어셈블리의 표시 이름에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-265">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-266">표시 이름을 구문 분석 하려면 사용자 고유의 코드를 작성 하는 것은 좋지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-266">Writing your own code to parse display names is not recommended.</span></span> <span data-ttu-id="84bad-267">대신, 표시 이름을 전달 합니다 <xref:System.Reflection.AssemblyName.%23ctor%2A> 생성자를 구문 분석 하 고 새의 적절 한 필드를 채웁니다 <xref:System.Reflection.AssemblyName>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-267">Instead, pass the display name to the <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, which parses it and populates the appropriate fields of the new <xref:System.Reflection.AssemblyName>.</span></span>  
  
 <span data-ttu-id="84bad-268">.NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-268">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="84bad-269">그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Reflection.Assembly.FullName%2A> 호환성을 위해 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-269">However, it is not included in the string returned by the <xref:System.Reflection.Assembly.FullName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="84bad-270"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="84bad-270">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-271">다음 예제에서는 현재 실행 중인 어셈블리의 표시 이름 및 포함 된 어셈블리의 표시 이름을 검색 합니다 <xref:System.Int32> 형식 (`int` C#에서 `Integer` Visual basic에서).</span><span class="sxs-lookup"><span data-stu-id="84bad-271">The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <xref:System.Int32> type (`int` in C#, `Integer` in Visual Basic).</span></span>  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="84bad-272">정규화된 형식 이름 지정</span><span class="sxs-lookup"><span data-stu-id="84bad-272">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="84bad-273">어셈블리에서 반환될 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-273">An object representing a type in the assembly that will be returned.</span></span></param>
        <summary><span data-ttu-id="84bad-274">지정된 형식이 정의되어 있는 현재 로드된 어셈블리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-274">Gets the currently loaded assembly in which the specified type is defined.</span></span></summary>
        <returns><span data-ttu-id="84bad-275">지정된 형식이 정의되어 있는 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-275">The assembly in which the specified type is defined.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-276">이 메서드 호출의 값을 검색 하는 것은 <xref:System.Type.Assembly?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-276">Calling this method is equivalent to retrieving the value of the  <xref:System.Type.Assembly?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="84bad-277">그러나는 <xref:System.Type.Assembly?displayProperty=nameWithType> 속성에는 일반적으로 뛰어난 성능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-277">However, the <xref:System.Type.Assembly?displayProperty=nameWithType> property typically offers superior performance.</span></span>  
  
 <span data-ttu-id="84bad-278">이 메서드를 호출 하려면 있어야를 <xref:System.Type> 개체 클래스 정의 되어 있는 어셈블리가 이미 로드 되어 있어야 함을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-278">In order to call this method, you must have a <xref:System.Type> object, which means that the assembly in which the class is defined must already be loaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-279">다음 예제에서는 포함 된 어셈블리를 검색 합니다 <xref:System.Int32> 형식과 해당 이름 및 파일 위치를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-279">The following example retrieves the assembly that contains the <xref:System.Int32> type and displays its name and file location.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-280"><paramref name="type" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-280"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-281">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-281">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-282">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-282">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-283">현재 실행 중인 메서드를 호출한 메서드의 <see cref="T:System.Reflection.Assembly" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-283">Returns the <see cref="T:System.Reflection.Assembly" /> of the method that invoked the currently executing method.</span></span></summary>
        <returns><span data-ttu-id="84bad-284">현재 실행 중인 메서드를 호출하는 메서드의 <see langword="Assembly" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-284">The <see langword="Assembly" /> object of the method that invoked the currently executing method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-285">호출 하는 메서드를 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 메서드는 시간 (JIT) 컴파일러에 의해 확장 된 인라인 또는 해당 호출자에 게 확장 된 인라인 인 경우 어셈블리는 반환한 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 예기치 않게 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-285">If the method that calls the <xref:System.Reflection.Assembly.GetCallingAssembly%2A> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <xref:System.Reflection.Assembly.GetCallingAssembly%2A> may differ unexpectedly.</span></span> <span data-ttu-id="84bad-286">예를 들어 다음 메서드 및 어셈블리를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-286">For example, consider the following methods and assemblies:</span></span>  
  
-   <span data-ttu-id="84bad-287">메서드 `M1` 어셈블리에서 `A1` 호출 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-287">Method `M1` in assembly `A1` calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
-   <span data-ttu-id="84bad-288">메서드 `M2` 어셈블리에서 `A2` 호출 `M1`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-288">Method `M2` in assembly `A2` calls `M1`.</span></span>  
  
-   <span data-ttu-id="84bad-289">메서드 `M3` 어셈블리에서 `A3` 호출 `M2`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-289">Method `M3` in assembly `A3` calls `M2`.</span></span>  
  
 <span data-ttu-id="84bad-290">때 `M1` 인라인 화 되지 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A2`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-290">When `M1` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="84bad-291">때 `M1` 인라인 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A3`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-291">When `M1` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span> <span data-ttu-id="84bad-292">마찬가지로, `M2` 인라인 화 되지 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A2`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-292">Similarly, when `M2` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="84bad-293">때 `M2` 인라인 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A3`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-293">When `M2` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span>  
  
 <span data-ttu-id="84bad-294">이 효과도 발생 하면 `M1` 마무리 호출에서 실행 되 `M2`, 때나 `M2` 마무리 호출에서 실행 되 `M3`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-294">This effect also occurs when `M1` executes as a tail call from `M2`, or when `M2` executes as a tail call from `M3`.</span></span> <span data-ttu-id="84bad-295">JIT 컴파일러를 방지할 수 있습니다 인라인 호출 하는 메서드 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>를 적용 하 여는 <xref:System.Runtime.CompilerServices.MethodImplAttribute> 특성과 <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> 플래그를 이지만 마무리 호출을 방지 하는 것에 대 한 유사한 메커니즘이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-295">You can prevent the JIT compiler from inlining the method that calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, by applying the <xref:System.Runtime.CompilerServices.MethodImplAttribute> attribute with the <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flag, but there is no similar mechanism for preventing tail calls.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-296">다음 예에서는 현재 메서드의 호출 어셈블리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-296">The following example gets the calling assembly of the current method.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-297">이 어셈블리에 대한 사용자 지정 특성을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-297">Gets the custom attributes for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="84bad-298">이 인수는 <see cref="T:System.Reflection.Assembly" /> 형식의 개체에 대해 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-298">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="84bad-299">이 어셈블리에 대한 사용자 지정 특성을 모두 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-299">Gets all the custom attributes for this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-300">이 어셈블리에 대한 사용자 지정 특성이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-300">An array that contains the custom attributes for this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-301">이 메서드는 해당 구현 <xref:System.Reflection.ICustomAttributeProvider> 인터페이스 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-301">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="84bad-302">따라서는 `inherit` 무시 하는 경우에 매개 변수를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-302">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="84bad-303">의사 (pseudo) 특성을 특성이 있는 경우 설정 해야 하는 핵심적인 메타 데이터의 비트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-303">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="84bad-304">형식에 대 한 메타 데이터를 확장 하 고 유형과 함께 저장 되는 사용자 지정 특성을 달리 의사 (pseudo) 특성을 형식에 대 한 메타 데이터를 수정 하 고 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-304">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="84bad-305">결과 비트 중 일부 기존 리플렉션 Api를 사용 하 여 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-305">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="84bad-306">다음 표에서 다양 한 의사 (pseudo) 특성 및 리플렉션을 사용할 수 있는 비트에 대 한 접근자입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-306">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="84bad-307">의사 (pseudo) 특성</span><span class="sxs-lookup"><span data-stu-id="84bad-307">Pseudo-Attribute</span></span>|<span data-ttu-id="84bad-308">메타 데이터 비트</span><span class="sxs-lookup"><span data-stu-id="84bad-308">Metadata Bits</span></span>|<span data-ttu-id="84bad-309">리플렉션 접근자</span><span class="sxs-lookup"><span data-stu-id="84bad-309">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="84bad-310">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-310">DllImportAttribute</span></span>|<span data-ttu-id="84bad-311">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="84bad-311">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="84bad-312">DLL 이름</span><span class="sxs-lookup"><span data-stu-id="84bad-312">DLL name</span></span>|<span data-ttu-id="84bad-313">일반 메서드/전역 메서드 특성에 대 한 PInvokeMap에 없는 접근자입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-313">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="84bad-314">DLL 이름에 대 한 접근자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-314">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="84bad-315">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-315">GuidAttribute</span></span>|<span data-ttu-id="84bad-316">실제 사용자 지정 특성으로 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-316">Stored as a real custom attribute.</span></span>|<span data-ttu-id="84bad-317">실제 사용자 지정 특성으로 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-317">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="84bad-318">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-318">ComImportAttribute</span></span>|<span data-ttu-id="84bad-319">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="84bad-319">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="84bad-320">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="84bad-320">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="84bad-321">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-321">SerializableAttribute</span></span>|<span data-ttu-id="84bad-322">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="84bad-322">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="84bad-323">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="84bad-323">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="84bad-324">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-324">NonSerializedAttribute</span></span>|<span data-ttu-id="84bad-325">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="84bad-325">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="84bad-326">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="84bad-326">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="84bad-327">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-327">MethodImplAttribute</span></span>|<span data-ttu-id="84bad-328">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="84bad-328">CorMethodImpl</span></span>|<span data-ttu-id="84bad-329">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="84bad-329">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="84bad-330">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="84bad-330">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="84bad-331">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-331">MarshalAsAttribute</span></span>|<span data-ttu-id="84bad-332">다양 한 비트입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-332">Various bits.</span></span>|<span data-ttu-id="84bad-333">접근자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-333">No accessor.</span></span>|  
|<span data-ttu-id="84bad-334">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-334">PreserveSigAttribute</span></span>|<span data-ttu-id="84bad-335">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="84bad-335">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="84bad-336">MethodInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="84bad-336">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="84bad-337">ConstructorInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="84bad-337">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="84bad-338">InAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-338">InAttribute</span></span>|<span data-ttu-id="84bad-339">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="84bad-339">CorParamAttr.pdIn</span></span>|<span data-ttu-id="84bad-340">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="84bad-340">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="84bad-341">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-341">OutAttribute</span></span>|<span data-ttu-id="84bad-342">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="84bad-342">CorParamAttr.pdOut</span></span>|<span data-ttu-id="84bad-343">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="84bad-343">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="84bad-344">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-344">StructLayoutAttribute</span></span>|<span data-ttu-id="84bad-345">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="84bad-345">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="84bad-346">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="84bad-346">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="84bad-347">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="84bad-347">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="84bad-348">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="84bad-348">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="84bad-349">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="84bad-349">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="84bad-350">클래스 압축 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-350">Class packing.</span></span>|<span data-ttu-id="84bad-351">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="84bad-351">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="84bad-352">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="84bad-352">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="84bad-353">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="84bad-353">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="84bad-354">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="84bad-354">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="84bad-355">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="84bad-355">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="84bad-356">접근자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-356">No accessor.</span></span>|  
|<span data-ttu-id="84bad-357">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-357">FieldOffsetAttribute</span></span>|<span data-ttu-id="84bad-358">필드 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-358">Field offset.</span></span>|<span data-ttu-id="84bad-359">접근자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-359">No accessor.</span></span>|  
|<span data-ttu-id="84bad-360">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-360">AssemblyLoadAttribute</span></span>|<span data-ttu-id="84bad-361">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="84bad-361">CorAssemblyFlags</span></span>|<span data-ttu-id="84bad-362">접근자 또는 열거자 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-362">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-363">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-363">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-364">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-364">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="84bad-365">사용자 지정 특성이 반환될 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-365">The type for which the custom attributes are to be returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="84bad-366">이 인수는 <see cref="T:System.Reflection.Assembly" /> 형식의 개체에 대해 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-366">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="84bad-367">형식에 의해 지정된 대로, 이 어셈블리에 대한 사용자 지정 특성을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-367">Gets the custom attributes for this assembly as specified by type.</span></span></summary>
        <returns><span data-ttu-id="84bad-368"><paramref name="attributeType" />에 의해 지정된 대로 이 어셈블리에 대한 사용자 지정 특성이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-368">An array that contains the custom attributes for this assembly as specified by <paramref name="attributeType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-369">이 메서드는 해당 구현 <xref:System.Reflection.ICustomAttributeProvider> 인터페이스 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-369">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="84bad-370">따라서는 `inherit` 무시 하는 경우에 매개 변수를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-370">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="84bad-371">의사 (pseudo) 특성을 특성이 있는 경우 설정 해야 하는 핵심적인 메타 데이터의 비트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-371">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="84bad-372">형식에 대 한 메타 데이터를 확장 하 고 유형과 함께 저장 되는 사용자 지정 특성을 달리 의사 (pseudo) 특성을 형식에 대 한 메타 데이터를 수정 하 고 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-372">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="84bad-373">결과 비트 중 일부 기존 리플렉션 Api를 사용 하 여 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-373">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="84bad-374">다음 표에서 다양 한 의사 (pseudo) 특성 및 리플렉션을 사용할 수 있는 비트에 대 한 접근자입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-374">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="84bad-375">의사 (pseudo) 특성</span><span class="sxs-lookup"><span data-stu-id="84bad-375">Pseudo-Attribute</span></span>|<span data-ttu-id="84bad-376">메타 데이터 비트</span><span class="sxs-lookup"><span data-stu-id="84bad-376">Metadata Bits</span></span>|<span data-ttu-id="84bad-377">리플렉션 접근자</span><span class="sxs-lookup"><span data-stu-id="84bad-377">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="84bad-378">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-378">DllImportAttribute</span></span>|<span data-ttu-id="84bad-379">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="84bad-379">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="84bad-380">DLL 이름</span><span class="sxs-lookup"><span data-stu-id="84bad-380">DLL name</span></span>|<span data-ttu-id="84bad-381">일반 메서드/전역 메서드 특성에 대 한 PInvokeMap에 없는 접근자입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-381">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="84bad-382">DLL 이름에 대 한 접근자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-382">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="84bad-383">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-383">GuidAttribute</span></span>|<span data-ttu-id="84bad-384">실제 사용자 지정 특성으로 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-384">Stored as a real custom attribute.</span></span>|<span data-ttu-id="84bad-385">실제 사용자 지정 특성으로 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-385">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="84bad-386">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-386">ComImportAttribute</span></span>|<span data-ttu-id="84bad-387">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="84bad-387">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="84bad-388">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="84bad-388">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="84bad-389">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-389">SerializableAttribute</span></span>|<span data-ttu-id="84bad-390">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="84bad-390">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="84bad-391">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="84bad-391">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="84bad-392">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-392">NonSerializedAttribute</span></span>|<span data-ttu-id="84bad-393">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="84bad-393">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="84bad-394">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="84bad-394">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="84bad-395">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-395">MethodImplAttribute</span></span>|<span data-ttu-id="84bad-396">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="84bad-396">CorMethodImpl</span></span>|<span data-ttu-id="84bad-397">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="84bad-397">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="84bad-398">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="84bad-398">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="84bad-399">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-399">MarshalAsAttribute</span></span>|<span data-ttu-id="84bad-400">다양 한 비트입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-400">Various bits.</span></span>|<span data-ttu-id="84bad-401">접근자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-401">No accessor.</span></span>|  
|<span data-ttu-id="84bad-402">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-402">PreserveSigAttribute</span></span>|<span data-ttu-id="84bad-403">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="84bad-403">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="84bad-404">MethodInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="84bad-404">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="84bad-405">ConstructorInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="84bad-405">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="84bad-406">InAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-406">InAttribute</span></span>|<span data-ttu-id="84bad-407">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="84bad-407">CorParamAttr.pdIn</span></span>|<span data-ttu-id="84bad-408">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="84bad-408">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="84bad-409">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-409">OutAttribute</span></span>|<span data-ttu-id="84bad-410">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="84bad-410">CorParamAttr.pdOut</span></span>|<span data-ttu-id="84bad-411">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="84bad-411">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="84bad-412">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-412">StructLayoutAttribute</span></span>|<span data-ttu-id="84bad-413">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="84bad-413">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="84bad-414">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="84bad-414">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="84bad-415">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="84bad-415">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="84bad-416">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="84bad-416">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="84bad-417">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="84bad-417">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="84bad-418">클래스 압축 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-418">Class packing.</span></span>|<span data-ttu-id="84bad-419">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="84bad-419">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="84bad-420">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="84bad-420">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="84bad-421">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="84bad-421">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="84bad-422">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="84bad-422">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="84bad-423">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="84bad-423">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="84bad-424">접근자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-424">No accessor.</span></span>|  
|<span data-ttu-id="84bad-425">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-425">FieldOffsetAttribute</span></span>|<span data-ttu-id="84bad-426">필드 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-426">Field offset.</span></span>|<span data-ttu-id="84bad-427">접근자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-427">No accessor.</span></span>|  
|<span data-ttu-id="84bad-428">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="84bad-428">AssemblyLoadAttribute</span></span>|<span data-ttu-id="84bad-429">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="84bad-429">CorAssemblyFlags</span></span>|<span data-ttu-id="84bad-430">접근자 또는 열거자 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-430">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-431"><paramref name="attributeType" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-431"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-432"><paramref name="attributeType" />이 런타임 형식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-432"><paramref name="attributeType" /> is not a runtime type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-433">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-433">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-434">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-434">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-435"><see cref="T:System.Reflection.Assembly" /> 개체로 표현되는, 현재 <see cref="T:System.Reflection.CustomAttributeData" />에 적용된 특성 관련 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-435">Returns information about the attributes that have been applied to the current <see cref="T:System.Reflection.Assembly" />, expressed as <see cref="T:System.Reflection.CustomAttributeData" /> objects.</span></span></summary>
        <returns><span data-ttu-id="84bad-436">현재 어셈블리에 적용된 특성에 대한 데이터를 나타내는 <see cref="T:System.Reflection.CustomAttributeData" /> 개체의 제네릭 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-436">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-437">리플렉션 전용 컨텍스트에 리플렉션 전용 컨텍스트에 로드 되는 코드에서 직접 사용자 지정 특성이 정의 되어 있는 경우 코드의 사용자 지정 특성을 검사할이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-437">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="84bad-438">와 같은 메서드 <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> 고 <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> 특성의 인스턴스를 만들기 때문에 이러한 경우에 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-438">Methods like <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="84bad-439">리플렉션 전용 컨텍스트에서 코드를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-439">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="84bad-440">자세한 내용 및 예를 들어 코드를 실행 하는 것에 대 한 참조를 <xref:System.Reflection.CustomAttributeData> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-440">For more information and for example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-441">기본 응용 프로그램 도메인에 있는 프로세스 실행 파일을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-441">Gets the process executable in the default application domain.</span></span> <span data-ttu-id="84bad-442">이 실행 파일은 다른 응용 프로그램 도메인에서 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />에 의해 실행된 첫 번째 실행 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-442">In other application domains, this is the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span></summary>
        <returns><span data-ttu-id="84bad-443">어셈블리는 기본 응용 프로그램 도메인에 있는 프로세스 실행 파일이거나 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />에 의해 실행된 첫 번째 실행 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-443">The assembly that is the process executable in the default application domain, or the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span> <span data-ttu-id="84bad-444">비관리 코드에서 호출한 경우에는 <see langword="null" />이 반환될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-444">Can return <see langword="null" /> when called from unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-445">합니다 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 메서드를 반환할 수 있습니다 `null` 경우 관리 되는 어셈블리를 관리 되지 않는 애플리케이션에서 로드 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-445">The <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method can return `null` when a managed assembly has been loaded from an unmanaged application.</span></span> <span data-ttu-id="84bad-446">예를 들어 관리 되지 않는 애플리케이션 C#에 대 한 호출에서 작성 한 COM 구성 요소의 인스턴스를 만듭니다는 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 관리 되는 어셈블리 보다는 비관리 코드 진입점 프로세스에 있어서 메서드는 C# 구성 요소에서 null을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-446">For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-447">현재 실행 중인 코드가 포함된 어셈블리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-447">Gets the assembly that contains the code that is currently executing.</span></span></summary>
        <returns><span data-ttu-id="84bad-448">현재 실행 중인 코드가 포함된 어셈블리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-448">The assembly that contains the code that is currently executing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-449">성능상의 이유로 알 수 없는 디자인 타임에 어셈블리는 현재 실행 중인 경우에이 메서드를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-449">For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</span></span> <span data-ttu-id="84bad-450">검색 하는 권장된 방법은 <xref:System.Reflection.Assembly> 현재 어셈블리를 나타내는 개체를 사용 하는 것은 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 다음 예제와 같이 어셈블리에서 형식의 속성을 찾을.</span><span class="sxs-lookup"><span data-stu-id="84bad-450">The recommended way to retrieve an <xref:System.Reflection.Assembly> object that represents the current assembly is to use the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property of a type found in the assembly, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 <span data-ttu-id="84bad-451">현재 실행 중인 코드를 호출한 메서드를 포함 하는 어셈블리를 가져오려면 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-451">To get the assembly that contains the method that called the currently executing code, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-452">다음 예제에서는 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 현재 실행 중인 어셈블리를 가져올 속성 형식을 기반으로 해당 어셈블리에 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-452">The following example uses the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property to get the currently executing assembly based on a type contained in that assembly.</span></span> <span data-ttu-id="84bad-453">또한 호출을 <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> 표시를 반환 하는 방법은 <xref:System.Reflection.Assembly> 동일한 어셈블리를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-453">It also calls the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method to show that it returns an <xref:System.Reflection.Assembly> object that represents the same assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-454">이 어셈블리에 정의된 형식 중 어셈블리 외부에서 볼 수 있는 public 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-454">Gets the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-455">이 어셈블리에 정의되어 있고 어셈블리 외부에서 볼 수 있는 형식을 나타내는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-455">An array that represents the types defined in this assembly that are visible outside the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-456">Public 형식 및 다른 공용 형식에 중첩 된 public 형식의 하는 어셈블리 외부에 표시 형식 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-456">The only types visible outside an assembly are public types and public types nested within other public types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-457">다양 한 액세스 수준 및 호출을 사용 하 여 클래스 수를 정의 하는 다음 코드 샘플 <xref:System.Reflection.Assembly.GetExportedTypes%2A> 어셈블리 외부에서 표시 되는 것을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-457">The following code sample defines a number of classes with various access levels, and calls <xref:System.Reflection.Assembly.GetExportedTypes%2A> to display the ones that are visible from outside the assembly.</span></span>  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="84bad-458">어셈블리가 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-458">The assembly is a dynamic assembly.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-459">종속 어셈블리를 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-459">Unable to load a dependent assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="84bad-460">지정된 파일의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-460">The name of the specified file.</span></span> <span data-ttu-id="84bad-461">파일 경로는 포함하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-461">Do not include the path to the file.</span></span></param>
        <summary><span data-ttu-id="84bad-462">이 어셈블리의 매니페스트 파일 테이블에서 지정된 파일에 대한 <see cref="T:System.IO.FileStream" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-462">Gets a <see cref="T:System.IO.FileStream" /> for the specified file in the file table of the manifest of this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-463">파일이 없는 경우 지정된 파일 또는 <see langword="null" />을 포함하는 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-463">A stream that contains the specified file, or <see langword="null" /> if the file is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-464">이 메서드는 공용 및 개인 리소스 파일을 모두에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-464">This method works on both public and private resource files.</span></span>  
  
 <span data-ttu-id="84bad-465">`name` 파일 경로가 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-465">The `name` should not include the path to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-466">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-466">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-467"><paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-467">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-468"><paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-468">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-469"><paramref name="name" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-469"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-470"><paramref name="name" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-470"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-471">경로 지정 된 파일을 읽는 데 필요한 권한입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-471">for access to the path and for reading the specified file.</span></span> <span data-ttu-id="84bad-472">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="84bad-472">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-473">어셈블리 매니페스트의 파일 테이블에 있는 파일을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-473">Gets the files in the file table of an assembly manifest.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-474">어셈블리 매니페스트의 파일 테이블에 있는 파일을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-474">Gets the files in the file table of an assembly manifest.</span></span></summary>
        <returns><span data-ttu-id="84bad-475">파일을 포함하는 스트림의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-475">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-476">이 메서드는 공용 및 개인 리소스 파일에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-476">This method works on public and private resource files.</span></span>  
  
 <span data-ttu-id="84bad-477">이 오버 로드는 호출에 해당 하는 <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> 오버 로드 하 고 지정 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-477">This overload is equivalent to calling the <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> overload and specifying `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-478">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-478">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-479">파일을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-479">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-480">파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-480">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="84bad-481">리소스 모듈을 포함하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-481"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="84bad-482">리소스 모듈의 포함 여부를 지정하여 어셈블리 매니페스트의 파일 테이블에서 파일을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-482">Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="84bad-483">파일을 포함하는 스트림의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-483">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-484">이 메서드는 공용 및 개인 리소스 파일에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-484">This method works on public and private resource files.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-485">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-485">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-486">파일을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-486">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-487">파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-487">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-488">이 인스턴스의 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-488">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="84bad-489">부호 있는 32비트 정수 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-489">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-490">이 어셈블리의 일부인 로드된 모듈을 모두 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-490">Gets all the loaded modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-491">이 어셈블리의 일부인 로드된 모듈을 모두 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-491">Gets all the loaded modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-492">모듈의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-492">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="84bad-493">리소스 모듈을 포함하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-493"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="84bad-494">이 어셈블리의 일부인 로드된 모듈을 모두 가져오며 리소스 모듈의 포함 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-494">Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="84bad-495">모듈의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-495">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName"><span data-ttu-id="84bad-496">리소스의 이름(대/소문자 구분)입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-496">The case-sensitive name of the resource.</span></span></param>
        <summary><span data-ttu-id="84bad-497">지정된 리소스가 지속되는 방법에 대한 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-497">Returns information about how the given resource has been persisted.</span></span></summary>
        <returns><span data-ttu-id="84bad-498">리소스의 토폴로지에 대한 정보로 채워진 개체이거나, 리소스를 찾을 수 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-498">An object that is populated with information about the resource's topology, or <see langword="null" /> if the resource is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-499">리소스 정보 리소스 호출자에 게 표시 되는지 또는 호출자에 게 하는 경우에 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-499">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-500"><paramref name="resourceName" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-500"><paramref name="resourceName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-501"><paramref name="resourceName" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-501">The <paramref name="resourceName" /> parameter is an empty string ("").</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-502">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-502">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-503">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-503">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-504">이 어셈블리에 있는 모든 리소스의 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-504">Returns the names of all the resources in this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-505">모든 리소스의 이름이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-505">An array that contains the names of all the resources.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-506">다음과 같이이 메서드에서 반환 된 배열의 각 리소스 이름을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-506">You can use each resource name in the array returned by this method as follows:</span></span>  
  
-   <span data-ttu-id="84bad-507">리소스 이름을 전달할 수 있습니다는 <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> 메서드는 리소스에 대 한 추가 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-507">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> method to get additional information about the resource.</span></span>  
  
-   <span data-ttu-id="84bad-508">.Resources 파일 확장명을 제거 하 고 전달할 수 이름을 이진.resources 파일을 식별 하는 경우는 <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> 리소스 관리자를 인스턴스화하는 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-508">If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructor to instantiate the resource manager.</span></span>  
  
-   <span data-ttu-id="84bad-509">리소스 이름을 전달할 수 있습니다는 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 검색 하는 메서드를 <xref:System.IO.Stream> 개체를 전달할 수 있습니다는 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-509">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
-   <span data-ttu-id="84bad-510">리소스 이름을 전달할 수 있습니다는 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 검색 하는 메서드를 <xref:System.IO.Stream> 개체를 전달할 수 있습니다는 <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-510">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
 <span data-ttu-id="84bad-511">리소스 정보 리소스 호출자에 게 표시 되는지 또는 호출자에 게 하는 경우에 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-511">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-512">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-512">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-513">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-513">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-514">지정된 매니페스트 리소스를 이 어셈블리에서 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-514">Loads the specified manifest resource from this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="84bad-515">요청된 매니페스트 리소스의 이름(대/소문자 구분)입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-515">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="84bad-516">지정된 매니페스트 리소스를 이 어셈블리에서 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-516">Loads the specified manifest resource from this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-517">매니페스트 리소스이거나 컴파일하는 동안 리소스가 지정되지 않은 경우 또는 호출자가 리소스를 볼 수 없는 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-517">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-518">매니페스트 리소스는 컴파일 타임에 어셈블리에 포함 된 리소스 (예: 이미지 파일).</span><span class="sxs-lookup"><span data-stu-id="84bad-518">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="84bad-519">매니페스트 리소스에 대 한 자세한 내용은 참조 하세요. [Microsoft.NET Framework 리소스의 기본](https://go.microsoft.com/fwlink/?LinkId=204554) MSDN 라이브러리에서.</span><span class="sxs-lookup"><span data-stu-id="84bad-519">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="84bad-520">리소스 정보 리소스 호출자에 게 표시 되는지 또는 호출자에 게 하는 경우에 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-520">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-521">이 메서드는 반환 `null` 다른 어셈블리의 전용 리소스에 액세스 하 고 호출자에 게 없는 경우 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-521">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="84bad-522">어셈블리 매니페스트 리소스 파일을 나열 하는 경우 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 반환을 <xref:System.IO.Stream> 시 디스크에 리소스 파일을 찾을 수 없는 경우에 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-522">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="84bad-523">리소스 파일을 찾을 수 없습니다를 전달 하는 경우 결과 <xref:System.IO.Stream> 개체를 <xref:System.Resources.ResourceReader> 생성자에 의해는 <xref:System.ArgumentException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-523">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-524"><paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-524">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-525"><paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-525">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="84bad-526"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-526">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="84bad-527">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-527">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-528"><paramref name="name" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-528"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-529"><paramref name="name" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-529"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="84bad-530">리소스 길이는 <see cref="F:System.Int64.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-530">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-531">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-531">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-532">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-532">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md"><span data-ttu-id="84bad-533">어셈블리 매니페스트</span><span class="sxs-lookup"><span data-stu-id="84bad-533">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="84bad-534">해당 네임스페이스가 매니페스트 리소스 이름의 범위를 지정하는 데 사용된 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-534">The type whose namespace is used to scope the manifest resource name.</span></span></param>
        <param name="name"><span data-ttu-id="84bad-535">요청된 매니페스트 리소스의 이름(대/소문자 구분)입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-535">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="84bad-536">지정된 형식의 네임스페이스에 의해 범위가 지정된 매니페스트 리소스를 이 어셈블리에서 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-536">Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-537">매니페스트 리소스이거나 컴파일하는 동안 리소스가 지정되지 않은 경우 또는 호출자가 리소스를 볼 수 없는 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-537">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-538">예를 들어의 전체 이름을 지정 하는 경우 `type` "MyNameSpace.MyClasses"은 및 `name` "MyNameSpace.Net" 라는 리소스 검색을 오버 로드는 "Net",이 메서드는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-538">For example, if the full name specified for `type` is "MyNameSpace.MyClasses" and `name` is "Net", this method overload searches for a resource named "MyNameSpace.Net".</span></span>  
  
 <span data-ttu-id="84bad-539">매니페스트 리소스는 컴파일 타임에 어셈블리에 포함 된 리소스 (예: 이미지 파일).</span><span class="sxs-lookup"><span data-stu-id="84bad-539">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="84bad-540">매니페스트 리소스에 대 한 자세한 내용은 참조 하세요. [Microsoft.NET Framework 리소스의 기본](https://go.microsoft.com/fwlink/?LinkId=204554) MSDN 라이브러리에서.</span><span class="sxs-lookup"><span data-stu-id="84bad-540">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="84bad-541">리소스 정보 리소스 호출자에 게 표시 되는지 또는 호출자에 게 하는 경우에 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-541">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-542">이 메서드는 반환 `null` 다른 어셈블리의 전용 리소스에 액세스 하 고 호출자에 게 없는 경우 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-542">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="84bad-543">어셈블리 매니페스트 리소스 파일을 나열 하는 경우 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 반환을 <xref:System.IO.Stream> 시 디스크에 리소스 파일을 찾을 수 없는 경우에 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-543">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="84bad-544">리소스 파일을 찾을 수 없습니다를 전달 하는 경우 결과 <xref:System.IO.Stream> 개체를 <xref:System.Resources.ResourceReader> 생성자에 의해는 <xref:System.ArgumentException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-544">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-545"><paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-545">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-546"><paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-546">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-547">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-547">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-548"><paramref name="name" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-548"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-549"><paramref name="name" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-549"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="84bad-550">리소스 길이는 <see cref="F:System.Int64.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-550">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="84bad-551">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-551">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="84bad-552">연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="84bad-552">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md"><span data-ttu-id="84bad-553">어셈블리 매니페스트</span><span class="sxs-lookup"><span data-stu-id="84bad-553">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="84bad-554">요청되는 모듈의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-554">The name of the module being requested.</span></span></param>
        <summary><span data-ttu-id="84bad-555">이 어셈블리에 있는 지정된 모듈을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-555">Gets the specified module in this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-556">요청되는 모듈 또는 모듈이 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-556">The module being requested, or <see langword="null" /> if the module is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-557">이 메서드는 파일 이름에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-557">This method works on file names.</span></span>  
  
 <span data-ttu-id="84bad-558">클래스는 `Reflection.Emit` 네임 스페이스는 동적 모듈에 대 한 범위 이름을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-558">Classes in the `Reflection.Emit` namespace emit the scope name for a dynamic module.</span></span> <span data-ttu-id="84bad-559">범위 이름으로 확인할 수 있습니다는 <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-559">The scope name can be determined by the <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="84bad-560">전달 하려는 모듈의 종류 `Assembly.GetModule`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-560">Pass the kind of module you want to `Assembly.GetModule`.</span></span> <span data-ttu-id="84bad-561">예를 들어, 어셈블리 매니페스트가 포함 된 모듈을 사용 하도록 하려는 경우 모듈의 범위 이름을 전달 `GetModule`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-561">For example, if you want the module that contains the assembly manifest, pass the scope name of the module to `GetModule`.</span></span> <span data-ttu-id="84bad-562">그렇지 않은 경우 모듈의 파일 이름을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-562">Otherwise, pass the file name of the module.</span></span> <span data-ttu-id="84bad-563">어셈블리 중 하나에 의해 로드 된 `Load` 메서드는 byte 매개 변수는 모듈 하나만 있고 매니페스트 모듈입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-563">Assemblies loaded by one of the `Load` methods that have a byte[] parameter have only one module, and that is the manifest module.</span></span> <span data-ttu-id="84bad-564">항상 범위 이름을 사용 하 여 이러한 모듈을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-564">Always seek these modules using the scope name.</span></span>  
  
 <span data-ttu-id="84bad-565">형식을 사용 하 여 특정 모듈에서 검색할 수 있습니다 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-565">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="84bad-566">호출 `Module.GetType` 모듈 매니페스트를 포함 하는 시작 하지 않습니다 전체 어셈블리를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-566">Calling `Module.GetType` on the module containing the manifest will not initiate a search of the entire assembly.</span></span> <span data-ttu-id="84bad-567">에서는 이기는 모듈에 관계 없이 어셈블리에서 형식을 검색 하려면 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-567">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-568"><paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-568">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-569"><paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-569">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-570">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-570">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-571"><paramref name="name" />을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-571"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-572"><paramref name="name" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-572"><paramref name="name" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-573">이 어셈블리의 일부인 모듈을 모두 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-573">Gets all the modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-574">이 어셈블리의 일부인 모듈을 모두 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-574">Gets all the modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-575">모듈의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-575">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-576">이 메서드는 공용 및 개인 리소스 파일에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-576">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-577">파일 이름 확장명을 사용 하 여 모듈을 내보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-577">Modules must be emitted with file name extensions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-578">다음 예제에서는 반환 되는 어셈블리 매니페스트가 포함 된 배열에서 모듈의 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-578">The following example displays the name of the module in the returned array that contains the assembly manifest.</span></span>  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-579">로드할 모듈은 파일 이름 확장명을 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-579">The module to be loaded does not specify a file name extension.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="84bad-580">리소스 모듈을 포함하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-580"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="84bad-581">이 어셈블리의 일부인 모듈을 모두 가져오며 리소스 모듈의 포함 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-581">Gets all the modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="84bad-582">모듈의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-582">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-583">이 메서드는 공용 및 개인 리소스 파일에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-583">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-584">파일 이름 확장명을 사용 하 여 모듈을 내보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-584">Modules must be emitted with file name extensions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-585">이 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-585">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-586">이 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-586">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-587">이 어셈블리에 대해 완전히 구문 분석된 표시 이름을 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-587">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-588">어셈블리의 경로에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-588">for access to the path of the assembly.</span></span> <span data-ttu-id="84bad-589">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-589">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName"><span data-ttu-id="84bad-590">어셈블리를 섀도 복사한 후 <see langword="true" />를 어셈블리 위치로 설정하려면 <see cref="P:System.Reflection.Assembly.CodeBase" />이고, <see langword="false" />를 원래 위치로 설정하려면 <see cref="P:System.Reflection.Assembly.CodeBase" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-590"><see langword="true" /> to set the <see cref="P:System.Reflection.Assembly.CodeBase" /> to the location of the assembly after it was shadow copied; <see langword="false" /> to set <see cref="P:System.Reflection.Assembly.CodeBase" /> to the original location.</span></span></param>
        <summary><span data-ttu-id="84bad-591">이 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져오며 <paramref name="copiedName" />에 의해 지정된 대로 코드베이스를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-591">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly, setting the codebase as specified by <paramref name="copiedName" />.</span></span></summary>
        <returns><span data-ttu-id="84bad-592">이 어셈블리에 대해 완전히 구문 분석된 표시 이름을 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-592">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-593">어셈블리의 경로에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-593">for access to the path of the assembly.</span></span> <span data-ttu-id="84bad-594">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-594">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="84bad-595">serialization 정보로 채울 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-595">The object to be populated with serialization information.</span></span></param>
        <param name="context"><span data-ttu-id="84bad-596">serialization의 대상 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-596">The destination context of the serialization.</span></span></param>
        <summary><span data-ttu-id="84bad-597">이 어셈블리를 다시 인스턴스화하는 데 필요한 데이터가 모두 포함된 serialization 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-597">Gets serialization information with all of the data needed to reinstantiate this assembly.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-598"><paramref name="info" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-598"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="84bad-599">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-599">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="84bad-600">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-600">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-601">이 어셈블리가 참조하는 모든 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-601">Gets the <see cref="T:System.Reflection.AssemblyName" /> objects for all the assemblies referenced by this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-602">이 어셈블리가 참조하는 모든 어셈블리의 완전 구문 분석된 표시 이름이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-602">An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="84bad-603">부터 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> 의 속성을 <xref:System.Reflection.AssemblyName> 이 메서드에 의해 반환 되는 개체는 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> 참조 된 어셈블리에 대 한 해시 알고리즘이 없는 경우 또는 참조 된 어셈블리의 해시 알고리즘이 아닌 경우 로 식별 되는 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-603">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property of an <xref:System.Reflection.AssemblyName> object that is returned by this method is <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="84bad-604">이전 버전의.NET Framework에는 <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> 반환 되는 속성 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> 이런에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-604">In previous versions of the .NET Framework, the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property returned <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in this situation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-605">다음 코드 예제에서는 호출 된 <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-605">The following code example demonstrates calling the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> method.</span></span> <span data-ttu-id="84bad-606">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Assembly> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-606">This code example is part of a larger example provided for the <xref:System.Reflection.Assembly> class.</span></span>  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-607">위성 어셈블리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-607">Gets the satellite assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="84bad-608">지정된 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-608">The specified culture.</span></span></param>
        <summary><span data-ttu-id="84bad-609">지정된 문화권에 대한 위성 어셈블리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-609">Gets the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="84bad-610">지정된 위성 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-610">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-611">위성 어셈블리에 지역화할 수 없는 실행 코드와 기본 또는 중립 문화권으로 사용 되는 단일 문화권에 대 한 리소스를 포함 하는 기본 애플리케이션 어셈블리와 구별 하 여 지역화 된 리소스를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-611">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="84bad-612">현재 어셈블리 버전을 사용 하려면이 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-612">Call this method to use your current assembly version.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-613"><paramref name="culture" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-613"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-614">어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-614">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-615">파일 이름이 일치하는 위성 어셈블리가 있지만 <see langword="CultureInfo" />가 지정된 어셈블리와 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-615">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> did not match the one specified.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-616">위성 어셈블리가 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-616">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="84bad-617">지정된 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-617">The specified culture.</span></span></param>
        <param name="version"><span data-ttu-id="84bad-618">위성 어셈블리의 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-618">The version of the satellite assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-619">지정된 문화권에 대한 지정된 버전의 위성 어셈블리를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-619">Gets the specified version of the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="84bad-620">지정된 위성 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-620">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-621">위성 어셈블리에 지역화할 수 없는 실행 코드와 기본 또는 중립 문화권으로 사용 되는 단일 문화권에 대 한 리소스를 포함 하는 기본 애플리케이션 어셈블리와 구별 하 여 지역화 된 리소스를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-621">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="84bad-622">호출 된 <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> 오버 로드를 현재 어셈블리 버전을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-622">Call the <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload to use your current assembly version.</span></span>  
  
 <span data-ttu-id="84bad-623">하는 경우 `version` 는 `null`, 리소스와 주 어셈블리가 서명 된 경우 현재 어셈블리 버전이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-623">If `version` is `null`, the current assembly version is used if both the resource and main assemblies are signed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-624"><paramref name="culture" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-624"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-625">파일 이름이 일치하는 위성 어셈블리가 있지만 <see langword="CultureInfo" /> 또는 버전이 지정된 어셈블리와 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-625">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> or the version did not match the one specified.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-626">어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-626">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-627">위성 어셈블리가 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-627">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-628">지정된 형식을 나타내는 <see cref="T:System.Type" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-628">Gets the <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="84bad-629">형식의 전체 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-629">The full name of the type.</span></span></param>
        <summary><span data-ttu-id="84bad-630">어셈블리 인스턴스에서 지정된 이름을 가진 <see cref="T:System.Type" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-630">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance.</span></span></summary>
        <returns><span data-ttu-id="84bad-631">지정된 클래스를 나타내는 개체이며 클래스가 없는 경우 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-631">An object that represents the specified class, or <see langword="null" /> if the class is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-632">이 메서드는 현재 어셈블리 인스턴스에서 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-632">This method only searches the current assembly instance.</span></span> <span data-ttu-id="84bad-633">`name` 어셈블리를 제외한 네임 스페이스 매개 변수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-633">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="84bad-634">다른 어셈블리의 형식 검색 하려면 사용 된 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 메서드 오버 로드를 어셈블리 표시 이름을 형식 이름의 일부로 선택적으로 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-634">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-635">형식을 다른 어셈블리로 전달 되었습니다, 하는 경우 여전히이 메서드에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-635">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="84bad-636">형식 전달에 대 한 내용은 참조 하세요 [공용 언어 런타임의 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-636">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-637">다음 예제에서는 추상 `MeansOfTransportation` 클래스는 `Transportation` 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-637">The following example defines an abstract `MeansOfTransportation` class in the `Transportation` namespace.</span></span> <span data-ttu-id="84bad-638">호출를 <xref:System.Reflection.Assembly.GetType%28System.String%29> 검색 하는 방법 해당 <xref:System.Type> 개체를 호출 합니다 <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> 배열을 가져올 메서드를 <xref:System.Reflection.PropertyInfo> 속성을 추상화 하는 형식에서 정보를 표시 한 다음 형식의 속성을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-638">It calls the <xref:System.Reflection.Assembly.GetType%28System.String%29> method to retrieve its <xref:System.Type> object, calls the <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> method to get an array of <xref:System.Reflection.PropertyInfo> objects that represent the type's properties, and then displays information on the type's abstract properties.</span></span> <span data-ttu-id="84bad-639">에 대 한 호출을 <xref:System.Reflection.Assembly.GetType%28System.String%29> 메서드 형식의 정규화 된 이름 (즉, 해당 네임 스페이스의 형식 이름과 함께)를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-639">Note that the call to the <xref:System.Reflection.Assembly.GetType%28System.String%29> method uses the type's fully qualified name (that is, its namespace along with its type name).</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-640"><paramref name="name" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-640"><paramref name="name" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-641"><paramref name="name" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-641"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-642"><paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-642"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="84bad-643"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-643">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block><span data-ttu-id="84bad-644">
          <paramref name="name" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-644">
          <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="84bad-645">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-645">-or-</span></span> 
<span data-ttu-id="84bad-646">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-646">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-647"><paramref name="name" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-647"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-648">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-648">-or-</span></span> 
 <span data-ttu-id="84bad-649"><paramref name="name" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-649"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="84bad-650">형식의 전체 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-650">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="84bad-651">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-651"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="84bad-652">어셈블리 인스턴스에서 지정된 이름을 가진 <see cref="T:System.Type" /> 개체를 가져오고, 형식을 찾을 수 없는 경우 선택적으로 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-652">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="84bad-653">지정된 클래스를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-653">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-654">이 메서드는 현재 어셈블리 인스턴스에서 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-654">This method only searches the current assembly instance.</span></span> <span data-ttu-id="84bad-655">`name` 어셈블리를 제외한 네임 스페이스 매개 변수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-655">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="84bad-656">다른 어셈블리의 형식 검색 하려면 사용 된 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 메서드 오버 로드를 어셈블리 표시 이름을 형식 이름의 일부로 선택적으로 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-656">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-657">형식을 다른 어셈블리로 전달 되었습니다, 하는 경우 여전히이 메서드에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-657">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="84bad-658">형식 전달에 대 한 내용은 참조 하세요 [공용 언어 런타임의 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-658">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="84bad-659">`throwOnError` 형식을 찾을 수 없으면 어떻게 되나요 매개 변수에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-659">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="84bad-660">Throw 될 수 있는 다른 모든 예외에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-660">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="84bad-661">특히, 형식을 찾았지만 로드할 수 없으면 <xref:System.TypeLoadException> throw 할 수 있습니다 경우에 `throwOnError` 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-661">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-662"><paramref name="name" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-662"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="84bad-663">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-663">-or-</span></span> 
<span data-ttu-id="84bad-664"><paramref name="name" />의 길이가 1024자를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-664">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-665"><paramref name="name" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-665"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="84bad-666"><paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-666"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-667"><paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-667"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-668"><paramref name="name" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-668"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="84bad-669">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-669">-or-</span></span> 
<span data-ttu-id="84bad-670">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-670">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-671"><paramref name="name" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-671"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-672">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-672">-or-</span></span> 
 <span data-ttu-id="84bad-673"><paramref name="name" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-673"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="84bad-674">형식의 전체 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-674">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="84bad-675">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-675"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="84bad-676">형식 이름의 대/소문자를 무시하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-676"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="84bad-677">대/소문자를 무시할지 여부와 형식이 없으면 예외를 throw할지를 선택적으로 지정하여 어셈블리 인스턴스에서 지정된 이름을 가진 <see cref="T:System.Type" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-677">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="84bad-678">지정된 클래스를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-678">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-679">이 메서드는 현재 어셈블리 인스턴스에서 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-679">This method only searches the current assembly instance.</span></span> <span data-ttu-id="84bad-680">`name` 어셈블리를 제외한 네임 스페이스 매개 변수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-680">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="84bad-681">다른 어셈블리의 형식 검색 하려면 사용 된 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 메서드 오버 로드를 어셈블리 표시 이름을 형식 이름의 일부로 선택적으로 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-681">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-682">형식을 다른 어셈블리로 전달 되었습니다, 하는 경우 여전히이 메서드에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-682">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="84bad-683">형식 전달에 대 한 내용은 참조 하세요 [공용 언어 런타임의 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-683">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="84bad-684">`throwOnError` 형식을 찾을 수 없으면 어떻게 되나요 매개 변수에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-684">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="84bad-685">Throw 될 수 있는 다른 모든 예외에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-685">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="84bad-686">특히, 형식을 찾았지만 로드할 수 없으면 <xref:System.TypeLoadException> throw 할 수 있습니다 경우에 `throwOnError` 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-686">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-687"><paramref name="name" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-687"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="84bad-688">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-688">-or-</span></span> 
<span data-ttu-id="84bad-689"><paramref name="name" />의 길이가 1024자를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-689">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-690"><paramref name="name" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-690"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="84bad-691"><paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-691"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-692"><paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-692"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-693"><paramref name="name" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-693"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="84bad-694">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-694">-or-</span></span> 
<span data-ttu-id="84bad-695">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-695">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-696"><paramref name="name" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-696"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-697">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-697">-or-</span></span> 
 <span data-ttu-id="84bad-698"><paramref name="name" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-698"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-699">이 어셈블리에 정의되어 있는 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-699">Gets the types defined in this assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-700">이 어셈블리에 정의되어 있는 모든 형식이 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-700">An array that contains all the types that are defined in this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-701">반환된 된 배열에는 중첩된 형식이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-701">The returned array includes nested types.</span></span>  
  
 <span data-ttu-id="84bad-702">경우는 <xref:System.Reflection.Assembly.GetTypes%2A> 어셈블리가 로드 되지 않은 (예를 들어 경우 두 번째 어셈블리의 형식에서 파생), 어셈블리의 형식에 종속 되는 어셈블리 및 형식에 메서드를 호출을 <xref:System.Reflection.ReflectionTypeLoadException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-702">If the <xref:System.Reflection.Assembly.GetTypes%2A> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <xref:System.Reflection.ReflectionTypeLoadException> is thrown.</span></span> <span data-ttu-id="84bad-703">예를 들어, 첫 번째 어셈블리를 사용 하 여 로드 된 경우 발생할 수 있습니다 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 또는 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드 및 두 번째 어셈블리 로드 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-703">For example, this can happen if the first assembly was loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods, and the second assembly was not loaded.</span></span> <span data-ttu-id="84bad-704">사용 하 여 로드 된 어셈블리를 사용 하 여 발생할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 및 <xref:System.Reflection.Assembly.LoadFile%2A> 두 번째 어셈블리를 찾을 수 없는 경우 메서드를 <xref:System.Reflection.Assembly.GetTypes%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-704">It can also happen with assemblies loaded using the <xref:System.Reflection.Assembly.Load%2A> and <xref:System.Reflection.Assembly.LoadFile%2A> methods if the second assembly cannot be located when the <xref:System.Reflection.Assembly.GetTypes%2A> method is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-705">형식을 다른 어셈블리로 전달 되었습니다, 반환된 된 배열에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-705">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="84bad-706">형식 전달에 대 한 내용은 참조 하세요 [공용 언어 런타임의 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-706">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="84bad-707">컬렉션을 검색할 <xref:System.Reflection.TypeInfo> 개체의 배열이 아닌 <xref:System.Type> 개체를 사용 하 여는 <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-707">To retrieve a collection of <xref:System.Reflection.TypeInfo> objects instead of an array of <xref:System.Type> objects, use the <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-708">다음 예제에서는 지정된 된 어셈블리의 형식에 대 한 메서드의 매개 변수를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-708">The following example displays parameters of one method on a type in the specified assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="84bad-709">어셈블리에 로드할 수 없는 하나 이상의 형식이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-709">The assembly contains one or more types that cannot be loaded.</span></span> <span data-ttu-id="84bad-710"><see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> 속성에는 로드할 수 없는 각 형식에 대한 예외가 포함되어 있으나, 이 예외의 <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> 속성에 의해 반환된 배열에는 로드된 각 형식에 대한 <see cref="T:System.Type" /> 개체 및 로드할 수 없는 각 형식에 대한 <see langword="null" /> 개체가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-710">The array returned by the <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> property of this exception contains a <see cref="T:System.Type" /> object for each type that was loaded and <see langword="null" /> for each type that could not be loaded, while the <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> property contains an exception for each type that could not be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-711">어셈블리를 전역 어셈블리 캐시에서 로드했는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-711">Gets a value indicating whether the assembly was loaded from the global assembly cache.</span></span></summary>
        <value><span data-ttu-id="84bad-712">어셈블리를 전역 어셈블리 캐시에서 로드했으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-712"><see langword="true" /> if the assembly was loaded from the global assembly cache; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-713">어셈블리를 로드하는 데 사용된 호스트 컨텍스트를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-713">Gets the host context with which the assembly was loaded.</span></span></summary>
        <value><span data-ttu-id="84bad-714">어셈블리를 로드하는 데 사용된 호스트 컨텍스트가 있을 경우 호스트 컨텍스트를 나타내는 <see cref="T:System.Int64" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-714">An <see cref="T:System.Int64" /> value that indicates the host context with which the assembly was loaded, if any.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-715">매니페스트가 포함된 파일에 저장된 CLR(공용 언어 런타임) 버전을 나타내는 문자열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-715">Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</span></span></summary>
        <value><span data-ttu-id="84bad-716">CLR 버전 폴더 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-716">The CLR version folder name.</span></span> <span data-ttu-id="84bad-717">이 값은 전체 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-717">This is not a full path.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-718">예를 들어,.NET Framework 버전 1.1에 대 한 값 v1.1.4322 것입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-718">For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</span></span> <span data-ttu-id="84bad-719">해당 버전에 대 한 이진 파일 경로 %windir%\Microsoft.NET\Framework\v1.1.4322 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-719">The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</span></span>  
  
 <span data-ttu-id="84bad-720">기본적으로 <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> 어셈블리를 빌드하는 데 사용 하는 CLR의 버전으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-720">By default, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> is set to the version of the CLR used to build the assembly.</span></span> <span data-ttu-id="84bad-721">그러나이 설정 되어 다른 값으로 컴파일할 때.</span><span class="sxs-lookup"><span data-stu-id="84bad-721">However, it might have been set to another value at compile time.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public virtual bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Reflection.Assembly.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="84bad-722">이 어셈블리에 대해 확인할 특성의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-722">The type of the attribute to be checked for this assembly.</span></span></param>
        <param name="inherit"><span data-ttu-id="84bad-723">이 인수는 이 형식의 개체에 대해 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-723">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="84bad-724">지정된 특성이 어셈블리에 적용되었는지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-724">Indicates whether or not a specified attribute has been applied to the assembly.</span></span></summary>
        <returns><span data-ttu-id="84bad-725">특성이 어셈블리에 적용되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-725"><see langword="true" /> if the attribute has been applied to the assembly; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="84bad-726">적용 하는 다음 코드 예제는 <xref:System.Reflection.AssemblyTitleAttribute> 어셈블리로 사용 하 여 다음 특성 <xref:System.Reflection.Assembly.IsDefined%2A> 정책이 적용 되었는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-726">The following code example applies the <xref:System.Reflection.AssemblyTitleAttribute> attribute to an assembly and then uses <xref:System.Reflection.Assembly.IsDefined%2A> to indicate whether it was applied.</span></span> <span data-ttu-id="84bad-727">또한 적용 되지 않은 특성을 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-727">It also tests an attribute that was not applied.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-728"><paramref name="attributeType" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-728"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-729"><paramref name="attributeType" />이 잘못된 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-729"><paramref name="attributeType" /> uses an invalid type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-730">현재 어셈블리가 현재 프로세스에서 리플렉션 내보내기를 사용하여 동적으로 생성되었는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-730">Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</span></span></summary>
        <value><span data-ttu-id="84bad-731">현재 어셈블리가 현재 프로세스에서 동적으로 생성되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-731"><see langword="true" /> if the current assembly was generated dynamically in the current process; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-732">동적 어셈블리 파생 클래스로 표현 됩니다 <xref:System.Reflection.Emit.AssemblyBuilder>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-732">Dynamic assemblies are represented by the derived class <xref:System.Reflection.Emit.AssemblyBuilder>.</span></span>  
  
 <span data-ttu-id="84bad-733">동적 어셈블리를 디스크에 저장된 된 어셈블리에 저장 될 때 동적 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-733">When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</span></span> <span data-ttu-id="84bad-734">다른 애플리케이션 도메인 또는 프로세스에 로드 되 면 저장된 된 어셈블리를 <xref:System.Reflection.Assembly.IsDynamic%2A> 속성이 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-734">If the saved assembly is loaded into another application domain or process, the <xref:System.Reflection.Assembly.IsDynamic%2A> property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-735">현재 어셈블리가 완전히 신뢰되어 로드되는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-735">Gets a value that indicates whether the current assembly is loaded with full trust.</span></span></summary>
        <value><span data-ttu-id="84bad-736">현재 어셈블리가 완전히 신뢰되어 로드되면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-736"><see langword="true" /> if the current assembly is loaded with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-737">어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-737">Loads an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="84bad-738">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-738">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-739">내보낸 어셈블리가 포함된 COFF(Common Object File Format) 기반 이미지를 사용하여 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-739">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="84bad-740">이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-740">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="84bad-741">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-741">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-742">이 메서드를 사용 하 여 로드 된 어셈블리의 신뢰 수준을 호출 어셈블리의 신뢰 수준으로 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-742">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="84bad-743">애플리케이션 도메인의 신뢰 수준 사용 하 여 바이트 배열에서 어셈블리를 로드 하려면 사용 된 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-743">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="84bad-744">오버 로드를 사용 하 여 증명 정보를 사용 하는 방법에 대 한 자세한 내용은 합니다 <xref:System.Reflection.Assembly.Load%2A> 바이트 배열을 사용 하는 메서드를 참조 합니다 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-744">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="84bad-745">C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-745">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="84bad-746">이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-746">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="84bad-747">보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.</span><span class="sxs-lookup"><span data-stu-id="84bad-747">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="84bad-748">이 메서드 오버 로드 항상 만들어집니다 새 <xref:System.Reflection.Assembly> 자체 매핑 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-748">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-749"><paramref name="rawAssembly" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-749"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-750"><paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-750"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-751">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-751">-or-</span></span> 
<span data-ttu-id="84bad-752">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-752">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="84bad-753">로드될 어셈블리를 설명하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-753">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="84bad-754">해당 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-754">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="84bad-755">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-755">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-756"><xref:System.IO.FileLoadException> 이 throw `assemblyRef` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-756"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="84bad-757">로더는 간단한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-757">The loader does not continue probing for other assemblies that match the simple name.</span></span> <span data-ttu-id="84bad-758">기본적으로 원격 어셈블리의 코드를 실행할 수 없기 때문에.NET Framework 4부터를 <xref:System.IO.FileLoadException> 경우에 throw 됩니다 `assemblyRef` 원격 어셈블리를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-758">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="84bad-759">원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-759">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>     
  
> [!NOTE]
>  <span data-ttu-id="84bad-760">사용 하지 마십시오는 <xref:System.Reflection.AssemblyName> 만 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-760">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="84bad-761">합니다 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 요소를 제공 하지 않습니다 (예: 이름 또는 버전)에서 어셈블리 id의 로드가 발생 하지 않습니다 부하-id 별 규칙에 따라에서 예상한 대로 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-761">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="84bad-762">대신, 어셈블리 로드 규칙을 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-762">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="84bad-763">로드 컨텍스트를 사용 하 여 단점에 대 한 정보를 참조 하세요. 합니다 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드 오버 로드 또는 [어셈블리를 로드 하기 위한 모범 사례](~/docs/framework/deployment/best-practices-for-assembly-loading.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-763">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="84bad-764">어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-764">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="84bad-765">어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-765">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="84bad-766">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-766">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="84bad-767">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-767">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="84bad-768">인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-768">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="84bad-769">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-769">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="84bad-770">.NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-770">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="84bad-771">.NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-771">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="84bad-772">`Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-772">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="84bad-773">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-773">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="84bad-774">호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-774">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="84bad-775">C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-775">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="84bad-776">이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-776">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="84bad-777">보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.</span><span class="sxs-lookup"><span data-stu-id="84bad-777">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-778">모두를 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 속성 및 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 어셈블리를 로드 하려는 첫 번째 시도에서는 표시 이름으로 속성 설정 (반환한 버전, 문화권 및 등을 포함 하 여는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성).</span><span class="sxs-lookup"><span data-stu-id="84bad-778">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="84bad-779">파일이 없으면 <xref:System.Reflection.AssemblyName.CodeBase%2A> 어셈블리를 검색 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-779">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="84bad-780">사용 하 여 어셈블리 있으면 <xref:System.Reflection.AssemblyName.CodeBase%2A>, 표시 이름을 어셈블리에 대해 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-780">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="84bad-781">검색이 실패 하는 경우는 <xref:System.IO.FileLoadException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-781">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-782">다음 예제에서는 <xref:System.Reflection.AssemblyName> 개체를 로드 하는 데 사용 된 `sysglobal.dll` 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-782">The following example instantiates an <xref:System.Reflection.AssemblyName> object and uses it to load the `sysglobal.dll` assembly.</span></span> <span data-ttu-id="84bad-783">어셈블리의 public 형식의 전체 이름을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-783">The example then displays the full name of the assembly's public types.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-784"><paramref name="assemblyRef" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-784"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-785"><paramref name="assemblyRef" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-785"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="84bad-786"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-786">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="84bad-787">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-787">A file that was found could not be loaded.</span></span>

<span data-ttu-id="84bad-788">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-788">-or-</span></span>

<span data-ttu-id="84bad-789"><paramref name="assemblyRef" />은 원격 어셈블리를 지정하지만 원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-789"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="84bad-790"><see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-790">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-791"><paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-791"><paramref name="assemblyRef" /> is not a valid assembly.</span></span> <span data-ttu-id="84bad-792">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-792">-or-</span></span> 
<span data-ttu-id="84bad-793">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-793">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-794">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-794">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="84bad-795">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-795">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="84bad-796">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-796">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-797">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-797">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-798">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-798">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="84bad-799">런타임에서 어셈블리를 찾는 방법</span><span class="sxs-lookup"><span data-stu-id="84bad-799">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="84bad-800">긴 형식의 어셈블리 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-800">The long form of the assembly name.</span></span></param>
        <summary><span data-ttu-id="84bad-801">긴 형식의 이름으로 지정된 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-801">Loads an assembly given the long form of its name.</span></span></summary>
        <returns><span data-ttu-id="84bad-802">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-802">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-803">긴 형식의 어셈블리 이름 (예: "System" System.dll 어셈블리에 대 한) 해당 버전, 문화권, 공개 키 토큰 및 선택적으로 해당 프로세서 아키텍처와 함께 간단한 이름은 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-803">The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</span></span> <span data-ttu-id="84bad-804">어셈블리의 해당 <xref:System.Reflection.Assembly.FullName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-804">It corresponds to the assembly's <xref:System.Reflection.Assembly.FullName%2A> property.</span></span> <span data-ttu-id="84bad-805">다음 예제에서는 System.dll.NET Framework 4 어셈블리를 로드 하는 긴 이름 사용을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-805">The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <span data-ttu-id="84bad-806"><xref:System.IO.FileLoadException> 이 throw `assemblyString` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-806"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="84bad-807">로더는 간단한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-807">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="84bad-808">어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-808">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="84bad-809">어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-809">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="84bad-810">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-810">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="84bad-811">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-811">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="84bad-812">인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-812">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="84bad-813">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-813">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="84bad-814">.NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-814">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="84bad-815">.NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-815">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="84bad-816">`Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-816">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="84bad-817">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-817">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="84bad-818">호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-818">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="84bad-819">C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-819">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="84bad-820">이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-820">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="84bad-821">보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.</span><span class="sxs-lookup"><span data-stu-id="84bad-821">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="84bad-822">.NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-822">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="84bad-823">예를 들어, "ProcessorArchitecture = msil"입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-823">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="84bad-824">하지만 어셈블리 이름을 지정 하는 방법이 권장된 만들 때를 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드로 전달 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-824">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="84bad-825"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="84bad-825">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-826">다음 예제에서는 지정 된 정규화 된 이름, 어셈블리를 로드 하 고 지정된 된 어셈블리에 포함 된 모든 형식을 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-826">The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</span></span> <span data-ttu-id="84bad-827">이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-827">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="84bad-828">참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-828">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-829"><paramref name="assemblyString" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-829"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-830"><paramref name="assemblyString" />이 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-830"><paramref name="assemblyString" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-831"><paramref name="assemblyString" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-831"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-832">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-832">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-833"><paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-833"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-834">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-834">-or-</span></span> 
<span data-ttu-id="84bad-835">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-835">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-836">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-836">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-837">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-837">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="84bad-838">런타임에서 어셈블리를 찾는 방법</span><span class="sxs-lookup"><span data-stu-id="84bad-838">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="84bad-839">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-839">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="84bad-840">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-840">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-841">생성된 어셈블리가 들어 있고 경우에 따라 어셈블리에 대한 기호도 포함하는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-841">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</span></span> <span data-ttu-id="84bad-842">이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-842">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="84bad-843">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-843">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-844">이 메서드를 사용 하 여 로드 된 어셈블리의 신뢰 수준을 호출 어셈블리의 신뢰 수준으로 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-844">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="84bad-845">애플리케이션 도메인의 신뢰 수준 사용 하 여 바이트 배열에서 어셈블리를 로드 하려면 사용 된 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-845">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="84bad-846">오버 로드를 사용 하 여 증명 정보를 사용 하는 방법에 대 한 자세한 내용은 합니다 <xref:System.Reflection.Assembly.Load%2A> 바이트 배열을 사용 하는 메서드를 참조 합니다 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-846">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="84bad-847">C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-847">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="84bad-848">이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-848">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="84bad-849">보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.</span><span class="sxs-lookup"><span data-stu-id="84bad-849">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="84bad-850">이 메서드 오버 로드 항상 만들어집니다 새 <xref:System.Reflection.Assembly> 자체 매핑 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-850">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-851"><paramref name="rawAssembly" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-851"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-852"><paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-852"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-853">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-853">-or-</span></span> 
<span data-ttu-id="84bad-854">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-854">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="84bad-855">로드될 어셈블리를 설명하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-855">The object that describes the assembly to be loaded.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="84bad-856">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-856">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-857">해당 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-857">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span> <span data-ttu-id="84bad-858">어셈블리는 제공된 증명을 사용하여 호출자의 도메인에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-858">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="84bad-859">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-859">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-860"><xref:System.IO.FileLoadException> 이 throw `assemblyRef` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-860"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="84bad-861">로더는 간단한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-861">The loader does not continue probing for other assemblies that match the simple name.</span></span>  <span data-ttu-id="84bad-862">기본적으로 원격 어셈블리의 코드를 실행할 수 없기 때문에.NET Framework 4부터를 <xref:System.IO.FileLoadException> 경우에 throw 됩니다 `assemblyRef` 원격 어셈블리를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-862">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="84bad-863">원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-863">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>   
  
> [!NOTE]
>  <span data-ttu-id="84bad-864">사용 하지 마십시오는 <xref:System.Reflection.AssemblyName> 만 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-864">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="84bad-865">합니다 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 요소를 제공 하지 않습니다 (예: 이름 또는 버전)에서 어셈블리 id의 로드가 발생 하지 않습니다 부하-id 별 규칙에 따라에서 예상한 대로 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-865">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="84bad-866">대신, 어셈블리 로드 규칙을 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-866">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="84bad-867">로드 컨텍스트를 사용 하 여 단점에 대 한 정보를 참조 하세요. 합니다 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드 오버 로드 또는 [어셈블리를 로드 하기 위한 모범 사례](~/docs/framework/deployment/best-practices-for-assembly-loading.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-867">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="84bad-868">어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-868">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="84bad-869">어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-869">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="84bad-870">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-870">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="84bad-871">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-871">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="84bad-872">인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-872">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="84bad-873">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-873">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="84bad-874">.NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-874">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="84bad-875">.NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-875">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="84bad-876">`Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-876">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="84bad-877">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-877">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="84bad-878">호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-878">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="84bad-879">C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-879">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="84bad-880">이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-880">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="84bad-881">보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.</span><span class="sxs-lookup"><span data-stu-id="84bad-881">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-882">모두를 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 속성 및 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 어셈블리를 로드 하려는 첫 번째 시도에서는 표시 이름으로 속성 설정 (반환한 버전, 문화권 및 등을 포함 하 여는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성).</span><span class="sxs-lookup"><span data-stu-id="84bad-882">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="84bad-883">파일이 없으면 <xref:System.Reflection.AssemblyName.CodeBase%2A> 어셈블리를 검색 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-883">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="84bad-884">사용 하 여 어셈블리 있으면 <xref:System.Reflection.AssemblyName.CodeBase%2A>, 표시 이름을 어셈블리에 대해 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-884">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="84bad-885">검색이 실패 하는 경우는 <xref:System.IO.FileLoadException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-885">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 <span data-ttu-id="84bad-886">호출 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 한 번 동일한 어셈블리에 있지만 지정 된 다른 증명 공용 언어 런타임에서 throw 하지 않는 보다는 <xref:System.IO.FileLoadException> 같음 및 다른 증명 사양의 무결성 수 없기 때문에 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-886">If you call the <xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="84bad-887">먼저 성공 하는 증명 정보는 사용 되는 증거입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-887">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-888"><paramref name="assemblyRef" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-888"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-889"><paramref name="assemblyRef" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-889"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-890"><paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-890"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-891">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-891">-or-</span></span> 
<span data-ttu-id="84bad-892">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-892">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-893">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-893">An assembly or module was loaded twice with two different evidences.</span></span>

<span data-ttu-id="84bad-894">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-894">-or-</span></span>

<span data-ttu-id="84bad-895"><paramref name="assemblyRef" />은 원격 어셈블리를 지정하지만 원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-895"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="84bad-896"><see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-896">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-897">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-897">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="84bad-898">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-898">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="84bad-899">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-899">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-900">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-900">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-901">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-901">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="84bad-902">런타임에서 어셈블리를 찾는 방법</span><span class="sxs-lookup"><span data-stu-id="84bad-902">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="84bad-903">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-903">The display name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="84bad-904">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-904">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-905">해당 표시 이름이 지정된 어셈블리를 로드한 다음 제공된 증명을 사용하여 이 어셈블리를 호출자의 도메인에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-905">Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="84bad-906">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-906">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-907"><xref:System.IO.FileLoadException> 이 throw `assemblyString` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-907"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="84bad-908">로더는 간단한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-908">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="84bad-909">어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-909">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="84bad-910">어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-910">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="84bad-911">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-911">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="84bad-912">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-912">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="84bad-913">인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-913">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="84bad-914">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-914">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="84bad-915">.NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-915">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="84bad-916">.NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-916">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="84bad-917">`Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-917">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="84bad-918">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-918">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="84bad-919">호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-919">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="84bad-920">C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-920">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="84bad-921">이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-921">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="84bad-922">보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.</span><span class="sxs-lookup"><span data-stu-id="84bad-922">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="84bad-923">한 번에이 메서드를 호출 하면 동일한 어셈블리에 있지만 지정 된 다른 증명, 공용 언어 런타임에서 throw 하지 않습니다는 <xref:System.IO.FileLoadException> 같음 및 다른 증명 사양의 무결성을 확인할 수 없으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-923">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="84bad-924">먼저 성공 하는 증명 정보는 사용 되는 증거입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-924">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="84bad-925">.NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-925">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="84bad-926">예를 들어, "ProcessorArchitecture = msil"입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-926">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="84bad-927">하지만 어셈블리 이름을 지정 하는 방법이 권장된 만들 때를 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드로 전달 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-927">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="84bad-928"><xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="84bad-928">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-929"><paramref name="assemblyString" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-929"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-930"><paramref name="assemblyString" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-930"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-931"><paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-931"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-932">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-932">-or-</span></span> 
<span data-ttu-id="84bad-933">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-933">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-934">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-934">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="84bad-935">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-935">-or-</span></span> 
<span data-ttu-id="84bad-936">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-936">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-937">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-937">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-938">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-938">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="84bad-939">런타임에서 어셈블리를 찾는 방법</span><span class="sxs-lookup"><span data-stu-id="84bad-939">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="84bad-940">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-940">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="84bad-941">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-941">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="84bad-942">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-942">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-943">생성된 어셈블리가 들어 있고 경우에 따라 어셈블리에 대한 기호 및 증명 정보도 포함하는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-943">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</span></span> <span data-ttu-id="84bad-944">이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-944">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="84bad-945">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-945">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-946">어셈블리는 제공된 증명을 사용하여 호출자의 도메인에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-946">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span> <span data-ttu-id="84bad-947">어셈블리에 대 한 기호를 나타내는 원시 바이트도 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-947">The raw bytes representing the symbols for the assembly are also loaded.</span></span>  
  
 <span data-ttu-id="84bad-948">어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-948">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="84bad-949">어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-949">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="84bad-950">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-950">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="84bad-951">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-951">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="84bad-952">인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-952">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="84bad-953">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-953">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="84bad-954">.NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-954">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="84bad-955">.NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-955">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="84bad-956">`Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-956">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="84bad-957">사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-957">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="84bad-958">호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-958">Evidence of the calling assembly and evidence of the COFF image are ignored.</span></span>  
  
 <span data-ttu-id="84bad-959">C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-959">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="84bad-960">이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-960">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="84bad-961">보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.</span><span class="sxs-lookup"><span data-stu-id="84bad-961">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="84bad-962">호출 하는 경우는 [\], 바이트\<xref:System.Reflection.Assembly.Load%2A > 메서드를 한 번 동일한 어셈블리에 있지만 지정 된 다른 증명 공용 언어 런타임에서 throw 하지 않는 보다는 <xref:System.IO.FileLoadException> 때문에 같음 및 다른 증명 사양의 무결성을 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-962">If you call the [\], Byte\<xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="84bad-963">먼저 성공 하는 증명 정보는 사용 되는 증거입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-963">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="84bad-964">이 메서드 오버 로드 항상 만들어집니다 새 <xref:System.Reflection.Assembly> 자체 매핑 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-964">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-965"><paramref name="rawAssembly" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-965"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-966"><paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-966"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-967">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-967">-or-</span></span> 
<span data-ttu-id="84bad-968">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-968">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-969">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-969">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="84bad-970"><paramref name="securityEvidence" />이 <see langword="null" />가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-970"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span>  <span data-ttu-id="84bad-971">기본적으로 레거시 CAS 정책은 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 사용되지 않습니다. 사용되지 않도록 설정되면 <paramref name="securityEvidence" />가 <see langword="null" />이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-971">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-972">증명 정보를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-972">for the ability to supply evidence.</span></span> <span data-ttu-id="84bad-973">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-973">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="84bad-974">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-974">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="84bad-975">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-975">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="84bad-976">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-976">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="84bad-977">보안 컨텍스트의 소스입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-977">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="84bad-978">생성된 어셈블리가 들어 있고 경우에 따라 기호도 포함하고 보안 컨텍스트의 소스도 지정하는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-978">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</span></span> <span data-ttu-id="84bad-979">이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-979">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="84bad-980">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-980">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-981">어셈블리 보안 컨텍스트에 대 한 지정된 된 소스를 사용 하 여 호출자의 애플리케이션 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-981">The assembly is loaded into the application domain of the caller using the specified source for the security context.</span></span> <span data-ttu-id="84bad-982">경우 `rawSymbolStore` 지정 어셈블리에 대 한 기호를 나타내는 원시 바이트도 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-982">If `rawSymbolStore` was specified, the raw bytes that represent the symbols for the assembly are also loaded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-983"><paramref name="rawAssembly" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-983"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-984"><paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-984"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-985">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-985">-or-</span></span> 
 <span data-ttu-id="84bad-986"><paramref name="rawAssembly" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-986"><paramref name="rawAssembly" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="84bad-987"><paramref name="securityContextSource" /> 값이 열거형 값 중 하나가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-987">The value of <paramref name="securityContextSource" /> is not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-988">어셈블리 파일의 내용을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-988">Loads the contents of an assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="84bad-989">로드할 파일의 정규화된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-989">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="84bad-990">지정된 경로에 있는 어셈블리 파일의 내용을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-990">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="84bad-991">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-991">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-992">사용 된 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드를 로드 하 고 id는 동일 하지만 서로 다른 경로에 있는 어셈블리를 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-992">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="84bad-993"><xref:System.Reflection.Assembly.LoadFile%2A> 파일에서 로드 컨텍스트에 로드 하지 않습니다 하 고으로 로드 경로 사용 하 여 종속성을 해결 되지 않으면를 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-993"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="84bad-994"><xref:System.Reflection.Assembly.LoadFile%2A> 이 제한 된 시나리오에서 유용 하기 때문에 <xref:System.Reflection.Assembly.LoadFrom%2A> 어셈블리 로드를 사용할 수는 서로 다른 경로 이지만 동일한 id를 가진; 첫 번째만 로드 됩니다 이러한 어셈블리.</span><span class="sxs-lookup"><span data-stu-id="84bad-994"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="84bad-995">경우.NET Framework 4부터 `path` 로드 하는 어셈블리는 기본적으로 사용 하지 않도록 설정, 원격 위치에서 어셈블리를 지정 하며 `LoadFile` 메서드가 throw를 <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="84bad-995">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="84bad-996">원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-996">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-997"><paramref name="path" /> 인수가 절대 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-997">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-998"><paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-998">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-999">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-999">A file that was found could not be loaded.</span></span>

<span data-ttu-id="84bad-1000">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1000">-or-</span></span>

<span data-ttu-id="84bad-1001">원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1001">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="84bad-1002"><see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1002">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-1003"><paramref name="path" /> 매개 변수가 빈 문자열("")이거나 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1003">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1004"><paramref name="path" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1004"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-1005">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1005">-or-</span></span> 
<span data-ttu-id="84bad-1006">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="path" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1006">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-1007">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1007">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="84bad-1008">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1008">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-1009">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1009">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-1010">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1010">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="84bad-1011">어셈블리 파일의 정규화된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1011">The fully qualified path of the assembly file.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="84bad-1012">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1012">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-1013">경로가 지정된 어셈블리를 로드한 다음 제공된 증명 정보를 사용하여 이 어셈블리를 호출자의 도메인에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1013">Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="84bad-1014">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1014">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1015">사용 된 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드를 로드 하 고 id는 동일 하지만 서로 다른 경로에 있는 어셈블리를 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1015">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="84bad-1016"><xref:System.Reflection.Assembly.LoadFile%2A> 파일을 로드 하지 않습니다는 <xref:System.Reflection.Assembly.LoadFrom%2A> 컨텍스트를으로 로드 경로 사용 하 여 종속성을 해결 하지 않습니다는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1016"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the <xref:System.Reflection.Assembly.LoadFrom%2A> context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="84bad-1017"><xref:System.Reflection.Assembly.LoadFile%2A> 이 제한 된 시나리오에서 유용 하기 때문에 <xref:System.Reflection.Assembly.LoadFrom%2A> 어셈블리 로드를 사용할 수는 서로 다른 경로 이지만 동일한 id를 가진; 첫 번째만 로드 됩니다 이러한 어셈블리.</span><span class="sxs-lookup"><span data-stu-id="84bad-1017"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="84bad-1018">경우.NET Framework 4부터 `path` 로드 하는 어셈블리는 기본적으로 사용 하지 않도록 설정, 원격 위치에서 어셈블리를 지정 하며 `LoadFile` 메서드가 throw를 <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="84bad-1018">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="84bad-1019">원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1019">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1020"><paramref name="path" /> 인수가 절대 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1020">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1021"><paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-1021">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-1022"><paramref name="path" /> 매개 변수가 빈 문자열("")이거나 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1022">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1023">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1023">A file that was found could not be loaded.</span></span>

<span data-ttu-id="84bad-1024">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1024">-or-</span></span>

<span data-ttu-id="84bad-1025">원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1025">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="84bad-1026"><see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1026">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1027"><paramref name="path" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1027"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-1028">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1028">-or-</span></span> 
<span data-ttu-id="84bad-1029">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="path" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1029">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="84bad-1030"><paramref name="securityEvidence" />이 <see langword="null" />가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1030"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="84bad-1031">기본적으로 레거시 CAS 정책은 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 사용되지 않습니다. 사용되지 않도록 설정되면 <paramref name="securityEvidence" />가 <see langword="null" />이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1031">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-1032">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1032">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="84bad-1033">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1033">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-1034">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1034">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-1035">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1035">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-1036">어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1036">Loads an assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

<span data-ttu-id="84bad-1037">.NET Framework 4 부터는 원격 위치에서 로드 된 어셈블리에서 코드를 실행 하는 기능은 사용 되지 기본적으로 호출 합니다 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1037">Starting with .NET Framework 4, the ability to execute code in assemblies loaded from remote locations is disabled by default, and the call to the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="84bad-1038">에 어셈블리를 로드 하 고 해당 코드를 실행 하거나 다음을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1038">To load the assembly and execute its code, you must either:</span></span>

- <span data-ttu-id="84bad-1039">어셈블리에 대 한 샌드박스를 명시적으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1039">Explicitly create a sandbox for the assembly.</span></span> <span data-ttu-id="84bad-1040">([방법: 샌드박스에서 부분적으로 신뢰할 수 있는 코드 실행](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span><span class="sxs-lookup"><span data-stu-id="84bad-1040">(See [How to: Run Partially Trusted Code in a Sandbox](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span></span>

- <span data-ttu-id="84bad-1041">완전 신뢰 수준에서 설정 하 여 어셈블리의 코드를 실행 합니다 `enabled` 특성을 [ `<loadFromRemoteSources>` 구성 요소](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 를 `true`.</span><span class="sxs-lookup"><span data-stu-id="84bad-1041">Run the assembly's code in full trust by setting the `enabled` attribute of the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) to `true`.</span></span> <span data-ttu-id="84bad-1042">자세한 내용은 참조는 [ `<loadFromRemoteSources>` 구성 요소](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 문서.</span><span class="sxs-lookup"><span data-stu-id="84bad-1042">For more information, see the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) article.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="84bad-1043">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1043">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-1044">해당 파일 이름이나 경로가 지정된 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1044">Loads an assembly given its file name or path.</span></span></summary>
        <returns><span data-ttu-id="84bad-1045">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1045">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1046">`assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1046">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="84bad-1047">이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1047">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-1048">파일 전송 프로토콜 (FTP) 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1048">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="84bad-1049">에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1049">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="84bad-1050">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1050">No exception is thrown.</span></span>  
  
 <span data-ttu-id="84bad-1051">`assemblyFile` 현재 디렉터리에 절대적 이거나 상대적 않을 어셈블리는 호출자의 도메인에 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1051">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="84bad-1052">어셈블리는 세 개의 컨텍스트 중 하나로 로드할 수 있습니다 또는 컨텍스트 없이 로드 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1052">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="84bad-1053">로드 컨텍스트를 검색 하 여 찾은 어셈블리가 포함: GAC에 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 애플리케이션 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1053">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="84bad-1054"><xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1054">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="84bad-1055">로드 컨텍스트를 검색 하 여 검색 된 디렉터리에 포함 되지 않은 경로 제공 하는 어셈블리를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1055">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="84bad-1056"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1056"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span> 

    <span data-ttu-id="84bad-1057">경우.NET Framework 4부터의 URI `assemblyFile` 원격 위치를 지정 어셈블리 로드는 기본적으로 사용 하지 않도록 설정 하며 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1057">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="84bad-1058">원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1058">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="84bad-1059">리플렉션 전용 컨텍스트에 로드 된 어셈블리를 포함 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 이러한 코드 컨텍스트를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1059">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="84bad-1060">사용자 생성 된 어셈블리를 찾을 수, 하는 경우 모든 컨텍스트에서 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1060">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="84bad-1061">이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1061">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="84bad-1062">로드 컨텍스트 검색에 포함 되지 않은 경로에서 로드 되도록 어셈블리 있으며 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1062">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="84bad-1063"><xref:System.Reflection.Assembly.LoadFrom%2A> 메서드가 다음과 같은 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1063">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="84bad-1064">대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1064">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="84bad-1065">같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1065">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="84bad-1066">어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, 로드 컨텍스트에 어셈블리 표시 이름으로 동일한 어셈블리를 로드 하려고 시도 하는 나중에 로드 하려고 하면 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1066">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="84bad-1067">어셈블리가 deserialize 될 때 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1067">This can occur when an assembly is de-serialized.</span></span>  
  
-   <span data-ttu-id="84bad-1068">어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1068">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="84bad-1069"><xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1069"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="84bad-1070">네이티브 이미지에 대 한 있으면 `assemblyFile`, 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1070">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="84bad-1071">어셈블리가는 도메인 중립적으로 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1071">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="84bad-1072">.NET Framework 버전 1.0 및 1.1에서는 정책이 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1072">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-1073">다음 예제에서는 해당 파일 이름이 나 경로가 지정 된 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1073">The following example loads an assembly given its file name or path.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1074"><paramref name="assemblyFile" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1074"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-1075"><paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 확장명을 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1075"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1076">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1076">A file that was found could not be loaded.</span></span>

<span data-ttu-id="84bad-1077">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1077">-or-</span></span>

<span data-ttu-id="84bad-1078">원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1078">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="84bad-1079"><see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1079">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1080"><paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어, 64비트 프로세스의 32비트 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1080"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="84bad-1081">자세한 정보는 예외 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1081">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="84bad-1082">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1082">-or-</span></span> 
<span data-ttu-id="84bad-1083">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1083">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="84bad-1084">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1084">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1085"><paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1085">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="84bad-1086">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1086">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-1087">"file://"로 시작 하는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1087">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="84bad-1088">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1088">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="84bad-1089">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1089">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="84bad-1090">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1090">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="84bad-1091">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1091">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-1092">해당 파일 이름이나 경로가 지정된 어셈블리를 로드하고 보안 증명을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1092">Loads an assembly given its file name or path and supplying security evidence.</span></span></summary>
        <returns><span data-ttu-id="84bad-1093">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1093">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1094">`assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1094">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="84bad-1095">이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1095">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-1096">파일 전송 프로토콜 (FTP) 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1096">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="84bad-1097">에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1097">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="84bad-1098">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1098">No exception is thrown.</span></span>  
  
 <span data-ttu-id="84bad-1099">`assemblyFile` 현재 디렉터리에 절대적 이거나 상대적 않을 어셈블리는 호출자의 도메인에 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1099">`assemblyFile` may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="84bad-1100">어셈블리는 세 개의 컨텍스트 중 하나로 로드할 수 있습니다 또는 컨텍스트 없이 로드 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1100">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="84bad-1101">로드 컨텍스트를 검색 하 여 찾은 어셈블리가 포함: GAC에 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 애플리케이션 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1101">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="84bad-1102"><xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1102">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="84bad-1103">로드 컨텍스트를 검색 하 여 검색 된 디렉터리에 포함 되지 않은 경로 제공 하는 어셈블리를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1103">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="84bad-1104"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1104"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>

    <span data-ttu-id="84bad-1105">경우.NET Framework 4부터의 URI `assemblyFile` 원격 위치를 지정 어셈블리 로드는 기본적으로 사용 하지 않도록 설정 하며 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1105">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="84bad-1106">원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1106">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="84bad-1107">리플렉션 전용 컨텍스트에 로드 된 어셈블리를 포함 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 이러한 코드 컨텍스트를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1107">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="84bad-1108">사용자 생성 된 어셈블리를 찾을 수, 하는 경우 모든 컨텍스트에서 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1108">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="84bad-1109">이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1109">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="84bad-1110">로드 컨텍스트 검색에 포함 되지 않은 경로에서 로드 되도록 어셈블리 있으며 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1110">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="84bad-1111"><xref:System.Reflection.Assembly.LoadFrom%2A> 메서드가 다음과 같은 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1111">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="84bad-1112">대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1112">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="84bad-1113">같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1113">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="84bad-1114">어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, 로드 컨텍스트에 어셈블리 표시 이름으로 동일한 어셈블리를 로드 하려고 시도 하는 나중에 로드 하려고 하면 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1114">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="84bad-1115">어셈블리가 deserialize되면 이 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1115">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="84bad-1116">어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1116">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="84bad-1117"><xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1117"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="84bad-1118">네이티브 이미지에 대 한 있으면 `assemblyFile`, 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1118">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="84bad-1119">어셈블리가는 도메인 중립적으로 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1119">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="84bad-1120">.NET Framework 버전 1.0 및 1.1에서는 정책이 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1120">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="84bad-1121">어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1121">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="84bad-1122">어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1122">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="84bad-1123">사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1123">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="84bad-1124">사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1124">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="84bad-1125">인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1125">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="84bad-1126">한 번에이 메서드를 호출 하면 동일한 어셈블리에 있지만 지정 된 다른 증명, 공용 언어 런타임에서 throw 하지 않습니다는 <xref:System.IO.FileLoadException> 같음 및 다른 증명 사양의 무결성을 확인할 수 없으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1126">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="84bad-1127">먼저 성공 하는 증명 정보는 사용 되는 증거입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1127">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="84bad-1128">사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수 결합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1128">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="84bad-1129">`Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1129">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="84bad-1130">사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1130">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="84bad-1131">호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1131">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1132"><paramref name="assemblyFile" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1132"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-1133"><paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 확장명을 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1133"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1134">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1134">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="84bad-1135">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1135">-or-</span></span> 
<span data-ttu-id="84bad-1136"><paramref name="securityEvidence" />가 모호하며 올바르지 않은 것으로 확인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1136">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="84bad-1137">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1137">-or-</span></span>

<span data-ttu-id="84bad-1138">원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1138">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="84bad-1139"><see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1139">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1140"><paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어, 64비트 프로세스의 32비트 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1140"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="84bad-1141">자세한 정보는 예외 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1141">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="84bad-1142">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1142">-or-</span></span> 
<span data-ttu-id="84bad-1143">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1143">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="84bad-1144">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1144">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1145"><paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1145">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="84bad-1146">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1146">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-1147">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1147">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-1148">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1148">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-1149">"file://"로 시작 하는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1149">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="84bad-1150">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1150">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="84bad-1151">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1151">for reading a URI that does not begin with "file://".</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="84bad-1152">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1152">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="84bad-1153">계산된 해시 코드의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1153">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="84bad-1154">파일을 해시하고 강력한 이름을 생성하는 데 사용된 해시 알고리즘입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1154">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="84bad-1155">해당 파일 이름이나 경로가 지정된 어셈블리, 해시 값 및 해시 알고리즘을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1155">Loads an assembly given its file name or path, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="84bad-1156">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1156">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1157">`assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1157">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="84bad-1158">이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1158">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-1159">파일 전송 프로토콜 (FTP) 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1159">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="84bad-1160">에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1160">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="84bad-1161">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1161">No exception is thrown.</span></span>  
  
 <span data-ttu-id="84bad-1162">`assemblyFile` 현재 디렉터리에 절대적 이거나 상대적 않을 어셈블리는 호출자의 도메인에 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1162">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="84bad-1163">어셈블리는 세 개의 컨텍스트 중 하나로 로드할 수 있습니다 또는 컨텍스트 없이 로드 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1163">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="84bad-1164">로드 컨텍스트를 검색 하 여 찾은 어셈블리가 포함: 전역 어셈블리 캐시에 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 애플리케이션 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1164">The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="84bad-1165"><xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1165">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="84bad-1166">로드 컨텍스트는 사용자 검색에 포함 되지 않은 경로 제공 하는 어셈블리를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1166">The load-from context contains assemblies for which the user provided a path that is not included in probing.</span></span> <span data-ttu-id="84bad-1167"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1167"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="84bad-1168">경우.NET Framework 4부터의 URI `assemblyFile` 원격 위치를 지정 어셈블리 로드는 기본적으로 사용 하지 않도록 설정 하며 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1168">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="84bad-1169">원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1169">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="84bad-1170">리플렉션 전용 컨텍스트에 로드 된 어셈블리를 포함 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 이러한 코드 컨텍스트를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1170">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="84bad-1171">사용자 생성 된 어셈블리를 찾을 수, 하는 경우 모든 컨텍스트에서 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1171">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="84bad-1172">이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1172">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="84bad-1173">로드 컨텍스트 검색에 포함 되지 않은 경로에서 로드 되도록 어셈블리 있으며 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1173">The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="84bad-1174"><xref:System.Reflection.Assembly.LoadFrom%2A> 메서드가 다음과 같은 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1174">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="84bad-1175">대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1175">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="84bad-1176">같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1176">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="84bad-1177">어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, 로드 컨텍스트에 어셈블리 표시 이름으로 동일한 어셈블리를 로드 하려고 시도 하는 나중에 로드 하려고 하면 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1177">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="84bad-1178">어셈블리가 deserialize되면 이 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1178">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="84bad-1179">어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1179">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="84bad-1180"><xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1180"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="84bad-1181">네이티브 이미지에 대 한 있으면 `assemblyFile`, 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1181">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="84bad-1182">어셈블리는 도메인 중립적으로 로드될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1182">The assembly cannot be loaded as domain-neutral.</span></span>  
  
 <span data-ttu-id="84bad-1183">어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1183">The assembly is loaded with the evidence that the loader supplies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1184"><paramref name="assemblyFile" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1184"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-1185"><paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 이름 확장명을 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1185"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1186">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1186">A file that was found could not be loaded.</span></span>

<span data-ttu-id="84bad-1187">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1187">-or-</span></span>

<span data-ttu-id="84bad-1188">원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1188">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="84bad-1189"><see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1189">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1190"><paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어, 64비트 프로세스의 32비트 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1190"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="84bad-1191">자세한 정보는 예외 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1191">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="84bad-1192">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1192">-or-</span></span> 
 <span data-ttu-id="84bad-1193"><paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1193"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="84bad-1194">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1194">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1195"><paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1195">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="84bad-1196">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1196">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-1197">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1197">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-1198">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1198">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-1199">"file://"로 시작 하는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1199">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="84bad-1200">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1200">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="84bad-1201">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1201">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="84bad-1202">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1202">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="84bad-1203">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1203">Evidence for loading the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="84bad-1204">계산된 해시 코드의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1204">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="84bad-1205">파일을 해시하고 강력한 이름을 생성하는 데 사용된 해시 알고리즘입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1205">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="84bad-1206">해당 파일 이름이나 경로가 지정된 어셈블리, 보안 증명 정보, 해시 값 및 해시 알고리즘을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1206">Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="84bad-1207">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1207">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1208">`assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1208">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="84bad-1209">이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1209">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-1210">파일 전송 프로토콜 (FTP) 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1210">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="84bad-1211">에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1211">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="84bad-1212">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1212">No exception is thrown.</span></span>  
  
 <span data-ttu-id="84bad-1213">`assemblyFile` 현재 디렉터리에 절대적 이거나 상대적 않을 어셈블리는 호출자의 도메인에 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1213">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="84bad-1214">어셈블리는 세 개의 컨텍스트 중 하나로 로드할 수 있습니다 또는 컨텍스트 없이 로드 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1214">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="84bad-1215">로드 컨텍스트를 검색 하 여 찾은 어셈블리가 포함: GAC에 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 애플리케이션 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1215">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="84bad-1216"><xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1216">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="84bad-1217">로드 컨텍스트를 검색 하 여 검색 된 디렉터리에 포함 되지 않은 경로 제공 하는 어셈블리를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1217">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="84bad-1218"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1218"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="84bad-1219">경우.NET Framework 4부터의 URI `assemblyFile` 원격 위치를 지정 어셈블리 로드는 기본적으로 사용 하지 않도록 설정 하며 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1219">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="84bad-1220">원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1220">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="84bad-1221">리플렉션 전용 컨텍스트에 로드 된 어셈블리를 포함 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 이러한 코드 컨텍스트를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1221">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="84bad-1222">사용자 생성 된 어셈블리를 찾을 수, 하는 경우 모든 컨텍스트에서 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1222">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="84bad-1223">이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1223">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="84bad-1224">로드 컨텍스트 검색에 포함 되지 않은 경로에서 로드 되도록 어셈블리 있으며 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1224">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="84bad-1225"><xref:System.Reflection.Assembly.LoadFrom%2A> 메서드가 다음과 같은 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1225">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="84bad-1226">대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1226">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="84bad-1227">같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1227">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="84bad-1228">어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, 로드 컨텍스트에 어셈블리 표시 이름으로 동일한 어셈블리를 로드 하려고 시도 하는 나중에 로드 하려고 하면 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1228">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="84bad-1229">어셈블리가 deserialize되면 이 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1229">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="84bad-1230">어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1230">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="84bad-1231"><xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1231"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="84bad-1232">네이티브 이미지에 대 한 있으면 `assemblyFile`, 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1232">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="84bad-1233">어셈블리가는 도메인 중립적으로 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1233">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="84bad-1234">.NET Framework 버전 1.0 및 1.1에서는 정책이 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1234">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="84bad-1235">어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1235">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="84bad-1236">어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1236">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="84bad-1237">사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1237">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="84bad-1238">사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1238">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="84bad-1239">인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1239">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="84bad-1240">한 번에이 메서드를 호출 하면 동일한 어셈블리에 있지만 지정 된 다른 증명, 공용 언어 런타임에서 throw 하지 않습니다는 <xref:System.IO.FileLoadException> 같음 및 다른 증명 사양의 무결성을 확인할 수 없으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1240">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="84bad-1241">먼저 성공 하는 증명 정보는 사용 되는 증거입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1241">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="84bad-1242">사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수 결합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1242">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="84bad-1243">`Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1243">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="84bad-1244">사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1244">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="84bad-1245">호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1245">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1246"><paramref name="assemblyFile" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1246"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-1247"><paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 확장명을 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1247"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1248">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1248">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="84bad-1249">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1249">-or-</span></span> 
<span data-ttu-id="84bad-1250"><paramref name="securityEvidence" />가 모호하며 올바르지 않은 것으로 확인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1250">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="84bad-1251">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1251">-or-</span></span>

<span data-ttu-id="84bad-1252">원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1252">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="84bad-1253"><see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1253">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1254"><paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어, 64비트 프로세스의 32비트 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1254"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="84bad-1255">자세한 정보는 예외 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1255">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="84bad-1256">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1256">-or-</span></span> 
<span data-ttu-id="84bad-1257">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1257">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="84bad-1258">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1258">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1259"><paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1259">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="84bad-1260">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1260">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-1261">증명 정보를 사용 하 여 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1261">to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-1262">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1262">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-1263">"file://"로 시작 하는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1263">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="84bad-1264">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1264">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="84bad-1265">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1265">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-1266">이 어셈블리의 내부 모듈을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1266">Loads the module internal to this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="84bad-1267">모듈의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1267">The name of the module.</span></span> <span data-ttu-id="84bad-1268">이 문자열은 어셈블리 매니페스트에 있는 파일 이름과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1268">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="84bad-1269">내보낸 모듈 또는 리소스가 포함된 COFF 기반 이미지인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1269">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <summary><span data-ttu-id="84bad-1270">내보낸 모듈인 리소스 파일이 포함된 COFF(Common Object File Format) 기반 이미지가 포함된 이 어셈블리의 내부 모듈을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1270">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span></summary>
        <returns><span data-ttu-id="84bad-1271">로드된 모듈입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1271">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1272"><paramref name="moduleName" /> 또는 <paramref name="rawModule" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-1272"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1273"><paramref name="moduleName" />과 일치하는 파일 항목이 이 어셈블리의 매니페스트에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1273"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1274"><paramref name="rawModule" />은 유효한 모듈이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1274"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1275">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1275">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-1276">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1276">to provide evidence.</span></span> <span data-ttu-id="84bad-1277">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1277">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="84bad-1278">모듈의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1278">The name of the module.</span></span> <span data-ttu-id="84bad-1279">이 문자열은 어셈블리 매니페스트에 있는 파일 이름과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1279">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="84bad-1280">내보낸 모듈 또는 리소스가 포함된 COFF 기반 이미지인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1280">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="84bad-1281">모듈의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1281">A byte array containing the raw bytes representing the symbols for the module.</span></span> <span data-ttu-id="84bad-1282">이 배열이 리소스 파일이면 <see langword="null" />이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1282">Must be <see langword="null" /> if this is a resource file.</span></span></param>
        <summary><span data-ttu-id="84bad-1283">내보낸 모듈인 리소스 파일이 포함된 COFF(Common Object File Format) 기반 이미지가 포함된 이 어셈블리의 내부 모듈을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1283">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span> <span data-ttu-id="84bad-1284">모듈의 기호를 나타내는 원시 바이트도 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1284">The raw bytes representing the symbols for the module are also loaded.</span></span></summary>
        <returns><span data-ttu-id="84bad-1285">로드된 모듈입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1285">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1286"><paramref name="moduleName" /> 또는 <paramref name="rawModule" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-1286"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1287"><paramref name="moduleName" />과 일치하는 파일 항목이 이 어셈블리의 매니페스트에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1287"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1288"><paramref name="rawModule" />은 유효한 모듈이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1288"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1289">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1289">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-1290">증명 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1290">to provide evidence.</span></span> <span data-ttu-id="84bad-1291">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1291">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-1292">부분 이름을 사용하여 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에서 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1292">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="84bad-1293">오버 로드는 <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> 메서드는 사용 되지 않으며 이전 버전과 호환성을 위해 보존 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1293">The overloads of the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method are obsolete and have been retained for backward compatibility.</span></span> <span data-ttu-id="84bad-1294">사용되는 대체 항목은 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1294">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="84bad-1295">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1295">The display name of the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-1296">부분 이름을 사용하여 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에서 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1296">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <returns><span data-ttu-id="84bad-1297">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1297">The loaded assembly.</span></span> <span data-ttu-id="84bad-1298"><paramref name="partialName" />이 없으면 이 메서드에서 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1298">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="84bad-1299"><xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> 메서드는 사용 되지 않으며 이전 버전과 호환성을 위해 유지 되었습니다 했습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1299">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="84bad-1300">사용되는 대체 항목은 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1300">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="84bad-1301">이 메서드를 사용 하 여 어셈블리를 로드 하는 애플리케이션 업그레이드 이러한 어셈블리의 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1301">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="84bad-1302">따라서이 메서드를 사용 하지 마세요 사용 하도록 애플리케이션을 다시 디자인 된 <xref:System.Reflection.Assembly.Load%28System.String%29> 메서드 오버 로드 또는 <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1302">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%28System.String%29> method overload or the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 <span data-ttu-id="84bad-1303">이 메서드는 먼저 호출 <xref:System.Reflection.Assembly.Load%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1303">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="84bad-1304">어셈블리가 없으면이 메서드는 같은 간단한 이름 및 가장 높은 버전 번호를 포함 하는 전역 어셈블리 캐시에서 어셈블리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1304">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1305"><paramref name="partialName" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-1305">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1306"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1306"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-1307">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1307">-or-</span></span> 
<span data-ttu-id="84bad-1308">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="partialName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1308">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="84bad-1309">어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1309">The display name of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="84bad-1310">어셈블리 로드에 사용할 증명 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1310">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-1311">부분 이름을 사용하여 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에서 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1311">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span> <span data-ttu-id="84bad-1312">어셈블리는 제공된 증명을 사용하여 호출자의 도메인에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1312">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="84bad-1313">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1313">The loaded assembly.</span></span> <span data-ttu-id="84bad-1314"><paramref name="partialName" />이 없으면 이 메서드에서 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1314">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="84bad-1315"><xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> 메서드는 사용 되지 않으며 이전 버전과 호환성을 위해 유지 되었습니다 했습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1315">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="84bad-1316">사용되는 대체 항목은 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1316">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="84bad-1317">증명 정보는 코드에 부여할 수 있는 권한 같이 보안 정책을 결정하기 위해 입력하는 정보 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1317">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 <span data-ttu-id="84bad-1318">이 메서드를 사용 하 여 어셈블리를 로드 하는 애플리케이션 업그레이드 이러한 어셈블리의 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1318">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="84bad-1319">따라서이 메서드를 사용 하지 마세요 사용 하도록 애플리케이션을 다시 디자인 된 <xref:System.Reflection.Assembly.Load%2A> 메서드 또는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-1319">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%2A> method or the <xref:System.Reflection.Assembly.LoadFrom%2A> method.</span></span>  
  
 <span data-ttu-id="84bad-1320">이 메서드는 먼저 호출 <xref:System.Reflection.Assembly.Load%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1320">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="84bad-1321">어셈블리가 없으면이 메서드는 같은 간단한 이름 및 가장 높은 버전 번호를 포함 하는 전역 어셈블리 캐시에서 어셈블리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1321">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1322">어셈블리 또는 모듈이 서로 다른 두 증명 정보 집합으로 두 번 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1322">An assembly or module was loaded twice with two different sets of evidence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1323"><paramref name="partialName" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-1323">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1324"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1324"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-1325">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1325">-or-</span></span> 
<span data-ttu-id="84bad-1326">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="partialName" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1326">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="84bad-1327">비관리 코드 호출에 대 한 증명 정보를 사용 하 여 어셈블리를 로드 하려면.</span><span class="sxs-lookup"><span data-stu-id="84bad-1327">for calling unmanaged code and to load an assembly with evidence.</span></span> <span data-ttu-id="84bad-1328">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1328">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-1329">매니페스트가 포함된 로드된 파일의 전체 경로나 UNC 위치를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1329">Gets the full path or UNC location of the loaded file that contains the manifest.</span></span></summary>
        <value><span data-ttu-id="84bad-1330">매니페스트가 포함된 로드된 파일의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1330">The location of the loaded file that contains the manifest.</span></span> <span data-ttu-id="84bad-1331">로드된 파일이 섀도 복사된 경우 위치는 해당 파일이 섀도 복사된 후의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1331">If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</span></span> <span data-ttu-id="84bad-1332"><see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> 메서드 오버로드를 사용한 경우처럼 어셈블리가 바이트 배열에서 로드되면 빈 문자열("")이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1332">If the assembly is loaded from a byte array, such as when using the <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> method overload, the value returned is an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1333">위치를 가져오려면 파일이 섀도 복사 되기 전에 <xref:System.Reflection.Assembly.CodeBase%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1333">To get the location before the file has been shadow-copied, use the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84bad-1334">다음 예제에서는 매니페스트를 포함 하는 로드 된 파일의 위치를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1334">The following example displays the location of the loaded file that contains the manifest.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="84bad-1335">현재 어셈블리가 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 개체로 표현되는 동적 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1335">The current assembly is a dynamic assembly, represented by an <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> object.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-1336">경로에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1336">for access to the path.</span></span> <span data-ttu-id="84bad-1337">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1337">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="84bad-1338">어셈블리 섀도 복사</span><span class="sxs-lookup"><span data-stu-id="84bad-1338">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-1339">현재 어셈블리의 매니페스트가 포함된 모듈을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1339">Gets the module that contains the manifest for the current assembly.</span></span></summary>
        <value><span data-ttu-id="84bad-1340">어셈블리의 매니페스트가 포함된 모듈입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1340">The module that contains the manifest for the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-1341">공용 언어 런타임 클래스 로더가 일반적인 방법으로 어셈블리의 내부 모듈에 대한 참조를 확인할 수 없는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1341">Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1342">이 이벤트는 콜백 검색 모듈 자체를 로드 하 고 반환할 수를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1342">This event gives the callback a chance to find and load the module itself and return it.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="84bad-1343">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1343">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="84bad-1344">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1344">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-1345">이 어셈블리의 모듈을 포함하는 컬렉션을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1345">Gets a collection that contains the modules in this assembly.</span></span></summary>
        <value><span data-ttu-id="84bad-1346">이 어셈블리의 모듈을 포함하는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1346">A collection that contains the modules in this assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="84bad-1347"><paramref name="right" />와 비교할 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1347">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="84bad-1348"><paramref name="left" />와 비교할 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1348">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="84bad-1349">두 <see cref="T:System.Reflection.Assembly" /> 개체가 같은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1349">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="84bad-1350"><see langword="true" />이 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1350"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="84bad-1351"><paramref name="right" />와 비교할 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1351">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="84bad-1352"><paramref name="left" />와 비교할 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1352">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="84bad-1353">두 <see cref="T:System.Reflection.Assembly" /> 개체가 같지 않은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1353">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="84bad-1354"><see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1354"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-1355">현재 어셈블리의 권한 부여 집합을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1355">Gets the grant set of the current assembly.</span></span></summary>
        <value><span data-ttu-id="84bad-1356">현재 어셈블리의 권한 부여 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1356">The grant set of the current assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1357"><xref:System.Security.PermissionSet> 개체는 경로 같은 중요 한 정보를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1357"><xref:System.Security.PermissionSet> objects can contain sensitive information such as paths.</span></span> <span data-ttu-id="84bad-1358">따라서 이러한 개체에 액세스 하려면 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1358">Therefore, full trust is required to access these objects.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="84bad-1359">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1359">requires full trust for the immediate caller.</span></span> <span data-ttu-id="84bad-1360">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1360">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-1361">이 어셈블리가 리플렉션 전용 컨텍스트에 로드되었는지를 나타내는 <see cref="T:System.Boolean" /> 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1361">Gets a <see cref="T:System.Boolean" /> value indicating whether this assembly was loaded into the reflection-only context.</span></span></summary>
        <value><span data-ttu-id="84bad-1362">어셈블리가 실행 컨텍스트가 아니라 리플렉션 전용 컨텍스트에 로드되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1362"><see langword="true" /> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1363">사용 하 여 어셈블리를 리플렉션 전용 컨텍스트에 로드 되었으면를 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 메서드를 어셈블리에서 코드를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1363">If an assembly has been loaded into the reflection-only context, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, you cannot execute code in the assembly.</span></span> <span data-ttu-id="84bad-1364">어셈블리 코드를 실행 하려면 실행 컨텍스트에 로드 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1364">To execute code, the assembly must be loaded into the execution context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="84bad-1365">어셈블리를 검사할 수 있지만 실행할 수는 없는 리플렉션 전용 컨텍스트에 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1365">Loads an assembly into the reflection-only context, where it can be examined but not executed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="84bad-1366">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1366">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-1367">내보낸 어셈블리가 포함된 COFF(Common Object File Format) 기반 이미지에서 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1367">Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="84bad-1368">어셈블리는 호출자 응용 프로그램 도메인의 리플렉션 전용 컨텍스트에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1368">The assembly is loaded into the reflection-only context of the caller's application domain.</span></span></summary>
        <returns><span data-ttu-id="84bad-1369">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1369">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1370">리플렉션 전용 컨텍스트에 로드 된 어셈블리에서 코드를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1370">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="84bad-1371">코드를 실행 하려면 어셈블리에 로드 해야만 실행 컨텍스트를 사용 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-1371">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="84bad-1372">리플렉션 전용 컨텍스트에 다른 컨텍스트에서 다르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1372">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="84bad-1373">컨텍스트에 로드 된 어셈블리를 애플리케이션 도메인을 언로드하는 유일한 언로드될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1373">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1374"><paramref name="rawAssembly" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1374"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1375"><paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1375"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-1376">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1376">-or-</span></span> 
<span data-ttu-id="84bad-1377">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1377">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1378"><paramref name="rawAssembly" />를 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1378"><paramref name="rawAssembly" /> cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="84bad-1379"><see cref="P:System.Reflection.AssemblyName.FullName" /> 속성에서 반환된 어셈블리의 표시 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1379">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="84bad-1380">지정된 표시 이름을 사용하여 어셈블리를 리플렉션 전용 컨텍스트에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1380">Loads an assembly into the reflection-only context, given its display name.</span></span></summary>
        <returns><span data-ttu-id="84bad-1381">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1381">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1382">종속성은 리플렉션 전용 컨텍스트에 자동으로 로드 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1382">Dependencies are not automatically loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="84bad-1383">리플렉션 전용 컨텍스트에 로드 된 어셈블리에서 코드를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1383">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="84bad-1384">코드를 실행 하려면 어셈블리에 로드 해야만 실행 컨텍스트를 사용 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-1384">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="84bad-1385">어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1385">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="84bad-1386">어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1386">The rules for assembly and security evidence merging are as follows:</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84bad-1387">C + +에서 컴파일된 실행 파일에 반영를 throw 할 수는 <xref:System.IO.FileLoadException>합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1387">Reflecting on executable files compiled in C++ might throw a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="84bad-1388">C + + 컴파일러가 실행 파일에서.reloc 섹션 이나 재배치 주소 원인인 것 같습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1388">This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</span></span> <span data-ttu-id="84bad-1389">.Reloc 주소를 유지 하려면 지정 `/fixed:no` 링크할 때.</span><span class="sxs-lookup"><span data-stu-id="84bad-1389">To preserve the .reloc address, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="84bad-1390">리플렉션 전용 컨텍스트에 다른 컨텍스트에서 다르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1390">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="84bad-1391">컨텍스트에 로드 된 어셈블리를 애플리케이션 도메인을 언로드하는 유일한 언로드될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1391">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1392"><paramref name="assemblyString" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1392"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1393"><paramref name="assemblyString" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-1393"><paramref name="assemblyString" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-1394"><paramref name="assemblyString" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-1394"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1395"><paramref name="assemblyString" />을 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1395"><paramref name="assemblyString" /> is found, but cannot be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1396"><paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1396"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-1397">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1397">-or-</span></span> 
<span data-ttu-id="84bad-1398">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1398">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="84bad-1399">어셈블리 매니페스트가 포함된 파일의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1399">The path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-1400">지정된 경로를 사용하여 어셈블리를 리플렉션 전용 컨텍스트에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1400">Loads an assembly into the reflection-only context, given its path.</span></span></summary>
        <returns><span data-ttu-id="84bad-1401">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1401">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1402">종속성은 리플렉션 전용 컨텍스트에 자동으로 로드 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1402">Dependencies are not automatically loaded into the reflection-only context.</span></span> <span data-ttu-id="84bad-1403">종속성을 자동으로 로드 하려면 처리는 <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> 이벤트 및 이벤트 처리기에 종속성을 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1403">To automatically load dependencies, handle the <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> event and load the dependency in the event handler.</span></span>  
  
 <span data-ttu-id="84bad-1404">리플렉션 전용 컨텍스트에 로드 된 어셈블리에서 코드를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1404">You cannot execute code from an assembly that has been loaded into the reflection-only context.</span></span> <span data-ttu-id="84bad-1405">코드를 실행 하려면 사용 하 여 어셈블리를 로드 합니다 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="84bad-1405">To execute the code, load the assembly with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="84bad-1406">`assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1406">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="84bad-1407">이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1407">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
 <span data-ttu-id="84bad-1408">지정 된 경로 `assemblyFile` 현재 디렉터리에 상대적입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1408">The path specified for `assemblyFile` is relative to the current directory.</span></span> <span data-ttu-id="84bad-1409">어셈블리는 호출자의 도메인에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1409">The assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="84bad-1410">리플렉션 전용 컨텍스트에 다른 컨텍스트에서 다르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1410">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="84bad-1411">컨텍스트에 로드 된 어셈블리를 애플리케이션 도메인을 언로드하는 유일한 언로드될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1411">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1412"><paramref name="assemblyFile" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1412"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-1413"><paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 이름 확장명을 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1413"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1414"><paramref name="assemblyFile" />을 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1414"><paramref name="assemblyFile" /> is found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1415"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1415"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-1416">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1416">-or-</span></span> 
<span data-ttu-id="84bad-1417">버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1417">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="84bad-1418">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1418">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="84bad-1419">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1419">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1420"><paramref name="assemblyFile" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="84bad-1420"><paramref name="assemblyFile" /> is an empty string ("").</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="84bad-1421">"file://"로 시작 하는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1421">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="84bad-1422">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="84bad-1422">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="84bad-1423">"file://"로 시작 하지 않는 URI를 읽는 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1423">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="84bad-1424">CLR(공용 언어 런타임)가 이 어셈블리에 대해 적용해야 하는 보안 규칙 집합을 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1424">Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</span></span></summary>
        <value><span data-ttu-id="84bad-1425">CLR가 이 어셈블리에 대해 적용하는 보안 규칙 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1425">The security rule set that the CLR enforces for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1426">기본적으로 사용 하 여 컴파일하는 어셈블리는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 대신에 명시적으로 만들 수 있지만 투명성을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1426">By default, assemblies that you compile with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] have  transparency, although you can explicitly make them  instead.</span></span> <span data-ttu-id="84bad-1427">이전 버전의.NET Framework를 사용 하 여 컴파일된 어셈블리에는 수준 1 투명도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1427">Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</span></span>  
  
 <span data-ttu-id="84bad-1428">[보안 변경 내용](~/docs/framework/security/security-changes.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84bad-1428">See [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md"><span data-ttu-id="84bad-1429">보안 투명 코드</span><span class="sxs-lookup"><span data-stu-id="84bad-1429">Security-Transparent Code</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="84bad-1430">.NET Framework 4의에서 보안 변경 내용</span><span class="sxs-lookup"><span data-stu-id="84bad-1430">Security Changes in the .NET Framework 4</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-1431">현재 인스턴스의 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1431">Returns the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="84bad-1432"><see cref="T:System.Reflection.Assembly" /> 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1432">An object that represents the <see cref="T:System.Reflection.Assembly" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="84bad-1433">표시 이름이라고도 하는 어셈블리의 전체 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1433">Returns the full name of the assembly, also known as the display name.</span></span></summary>
        <returns><span data-ttu-id="84bad-1434">어셈블리의 전체 이름입니다. 어셈블리의 전체 이름을 확인할 수 없는 경우에는 클래스 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1434">The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="84bad-1435">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1435">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="84bad-1436">일부 보안 검사를 무시하고 로드 소스 컨텍스트로 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1436">Loads an assembly into the load-from context, bypassing some security checks.</span></span></summary>
        <returns><span data-ttu-id="84bad-1437">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1437">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84bad-1438">이 메서드를 사용 하 여 운영 체제 (예를 들어, 임시 파일 인터넷 이나 인트라넷에서 다운로드) 웹에서 로드 되었음을 표시에 로컬 어셈블리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1438">Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</span></span> <span data-ttu-id="84bad-1439">전에 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 이러한 어셈블리는 샌드박스 애플리케이션 도메인에 자동으로 로드 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1439">Before the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], such assemblies were automatically loaded into a sandboxed application domain.</span></span> <span data-ttu-id="84bad-1440">부터 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 완전 신뢰를 사용 하 여 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1440">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], they are loaded with full trust.</span></span>  
  
 <span data-ttu-id="84bad-1441">이 메서드를 사용 하는 대신에 적용할 수 있습니다 합니다 [&lt;NetFx40_LegacySecurityPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) 애플리케이션 구성 파일에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1441">As an alternative to using this method, you can apply the [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) in your application configuration file.</span></span> <span data-ttu-id="84bad-1442">이렇게 하면 공용 언어 런타임에서의 보안 정책으로 되돌리려면는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1442">This causes the common language runtime to revert to the security policy of the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="84bad-1443">이러한 솔루션 중 하나를 사용 하는 경우 확인 해야 로드 해도 안전 하다 `assemblyFile` 완전 신뢰를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1443">If you use either of these solutions, you must be certain that it is safe to load `assemblyFile` with full trust.</span></span>  
  
 <span data-ttu-id="84bad-1444">로드 컨텍스트를 포함 하 여 로드 컨텍스트의 참조는 <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1444">For a discussion of load contexts, including the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="84bad-1445"><paramref name="assemblyFile" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1445"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="84bad-1446"><paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 확장명을 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1446"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="84bad-1447">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1447">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="84bad-1448"><paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1448"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="84bad-1449">또는</span><span class="sxs-lookup"><span data-stu-id="84bad-1449">-or-</span></span> 
 <span data-ttu-id="84bad-1450"><paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1450"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="84bad-1451">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1451">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="84bad-1452"><paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1452">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="84bad-1453">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1453">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="84bad-1454">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1454">requires full trust for the immediate caller.</span></span> <span data-ttu-id="84bad-1455">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="84bad-1455">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>