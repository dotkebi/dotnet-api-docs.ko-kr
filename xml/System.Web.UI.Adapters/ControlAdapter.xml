<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0f6fed664b044da1885a7b85efbbbf8911c7ce56" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58875569" /></Metadata><TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="8bbc1-101">어댑터가 연결될 파생 컨트롤의 렌더링을 사용자 지정하여 특정 브라우저의 기본 태그나 동작을 수정합니다. 모든 컨트롤 어댑터가 상속하는 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-101">Customizes rendering for the derived control to which the adapter is attached, to modify the default markup or behavior for specific browsers, and is the base class from which all control adapters inherit.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-102">컨트롤 어댑터 특정 재정의 하는 구성 요소는 <xref:System.Web.UI.Control> 브라우저 또는 태그 관련 처리를 허용 하도록 실행 주기에서 메서드 및 이벤트 클래스.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-102">Control adapters are components that override certain <xref:System.Web.UI.Control> class methods and events in its execution lifecycle to allow browser or markup-specific handling.</span></span> <span data-ttu-id="8bbc1-103">단일 파생된 컨트롤 어댑터를.NET Framework에서 매핑되는 <xref:System.Web.UI.Control> 각 클라이언트 요청에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-103">The .NET Framework maps a single derived control adapter to a <xref:System.Web.UI.Control> object for each client request.</span></span>  
  
 <span data-ttu-id="8bbc1-104">어댑터는 특정 브라우저 또는 브라우저의 클래스에 대 한 컨트롤을 수정 하거나 특정 기능에는 임의의 필터 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-104">An adapter modifies a control for a specific browser or class of browsers or acts as an arbitrary filter on some capability.</span></span> <span data-ttu-id="8bbc1-105">일반적으로 어댑터는 브라우저 (예: XHTML 또는 HTML 3.2)를 사용 하는 태그 언어에서 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-105">Typically the adapter is defined by the markup language that the browser uses (for example, XHTML or HTML 3.2).</span></span> <span data-ttu-id="8bbc1-106">파생 되는 특수 클래스에 캡슐화 할 수 있습니다의 렌더링 동작에서을 <xref:System.Web.UI.HtmlTextWriter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-106">Much of the adaptability in rendering behavior can be encapsulated in the specialized classes that derive from the <xref:System.Web.UI.HtmlTextWriter> class.</span></span> <span data-ttu-id="8bbc1-107">따라서 것 브라우저 클래스 동작 또는에 어댑터 기능이 포함 되는 수에 대 한 단일 어댑터를 사용할 수 있도록 합니다 <xref:System.Web.UI.HtmlTextWriter> 클래스 불필요 한 컨트롤 어댑터 사용을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-107">Therefore, it is likely that a single adapter can be used for a number of browser class behaviors or that inclusion of the adaptability in the <xref:System.Web.UI.HtmlTextWriter> classes could make the use of a control adapter unnecessary.</span></span>  
  
 <span data-ttu-id="8bbc1-108">컨트롤 클래스에 대 한 어댑터 보다 특수 한 어댑터가 존재 하지 않는 클래스에서 상속 되는 모든 컨트롤에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-108">An adapter for a control class applies to all controls that inherit from that class, unless more specialized adapters are present.</span></span> <span data-ttu-id="8bbc1-109">예를 들어 어댑터가 합니다 <xref:System.Web.UI.WebControls.BaseValidator> 모든 클래스를 사용할 수 있습니다 `Validator` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-109">For example, an adapter for the <xref:System.Web.UI.WebControls.BaseValidator> class can be used for all `Validator` objects.</span></span>  
  
 <span data-ttu-id="8bbc1-110">어댑터 일반적으로에서 직접 상속 하지 않습니다는 <xref:System.Web.UI.Adapters.ControlAdapter> 클래스 대상별 어댑터 중 하나에서 하지만 기본 컨트롤 형식 및 대상 브라우저에 관련 된 추가 기능을 제공 하는 클래스 또는 필요한 특정 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-110">Adapters typically do not inherit directly from the <xref:System.Web.UI.Adapters.ControlAdapter> class, but from one of the target-specific adapter base classes that provide additional functionality specific to the control type and target browser or the particular rendering required.</span></span>  
  
 <span data-ttu-id="8bbc1-111">컨트롤 자체는 어댑터를 반드시 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-111">Controls themselves do not necessarily require an adapter.</span></span> <span data-ttu-id="8bbc1-112">컨트롤은 컴퍼지션을 확장 하는 경우 일반적으로 자식 컨트롤 어댑터는 충분 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-112">If controls are extended through composition, generally the child control adapters are sufficient.</span></span>  
  
 <span data-ttu-id="8bbc1-113">각 컨트롤에.browser 정의 파일을 통해 어댑터에 대 한 명시적인 매핑이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-113">Each control has explicit mappings to adapters through the .browser definition files.</span></span> <span data-ttu-id="8bbc1-114">따라서 액세스 하는 모든 합니다 <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> 속성에서 사용 하는 <xref:System.Web.HttpBrowserCapabilities> 컨트롤 어댑터의 매핑에 대 한 조회를 수행 하는 브라우저 정의 파일에서 추출 된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-114">Thus, any access to the <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> property uses the <xref:System.Web.HttpBrowserCapabilities> object extracted from the browser definition files to perform the lookup for the mapping of the adapter to control.</span></span>  
  
 <span data-ttu-id="8bbc1-115">처리 하는 동안.NET Framework 대상에 관련 될 수 있는 컨트롤의 재정의 가능한 메서드를 호출을 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-115">During processing, the .NET Framework intercepts calls to the overridable methods of a control that could be target-specific.</span></span> <span data-ttu-id="8bbc1-116">컨트롤 어댑터가 연결 되 면.NET Framework는 연결 된 어댑터 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-116">If a control adapter is attached, the .NET Framework calls the associated adapter methods.</span></span>  
  
 <span data-ttu-id="8bbc1-117">어댑터를 통해 해당 컨트롤에 대 한 렌더링을 수행 합니다 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-117">The adapter performs rendering for the control through the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method.</span></span> <span data-ttu-id="8bbc1-118">재정의 된 경우 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 있으므로 다시 호출을 수행 하는 기본 클래스 구현을 호출 하지 않아야 잠재적으로 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-118">If overridden, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potentially should not call the base class implementation because that performs a call back on the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8bbc1-119">어댑터가 한 번 및 컨트롤에서 한 번을 두 번 발생 하도록 렌더링을 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-119">This might cause the rendering to occur twice, once by the adapter and once by the control.</span></span>  
  
 <span data-ttu-id="8bbc1-120">합니다 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 메서드 호출을 다시 기준의 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 컨트롤의 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-120">The <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> base method calls back on the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method of the control.</span></span> <span data-ttu-id="8bbc1-121">따라서 재정의 하는 경우 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>를 구현 하는 렌더링에서 제공 하는 그 외에 하지 않는 한 기본 클래스 구현을 호출 하지 않아야 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-121">Thus, if you override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, you should not call the base class implementation unless the rendering you implement is in addition to that provided by <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> of the control.</span></span>  
  
 <span data-ttu-id="8bbc1-122">.NET Framework 자식 컨트롤의 어댑터에 대 한 인터 셉 션을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-122">You must ensure that the .NET Framework performs interception for adapters of the child controls.</span></span> <span data-ttu-id="8bbc1-123">호출 하 여이 수행할 수 있습니다는 <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> 기본 메서드를 호출 하는 합니다 <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> 컨트롤의 메서드에서 프로그램 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-123">You can do this by calling the <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> base method, which calls the <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> method of the control, from your <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> override.</span></span>  
  
 <span data-ttu-id="8bbc1-124"><xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> 하 고 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 직전과 직후 컨트롤 호출 (각각) 컨트롤에서 메서드 호출 됩니다는 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-124">The <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> methods are called by the control immediately before and after (respectively) the control calls the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method.</span></span> <span data-ttu-id="8bbc1-125">사전 및 사후 렌더링 하는 경우만 브라우저 전용 처리 하는 작업을 사용 하 여 필요한 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> 하 고 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 를 재정의 하지 않아도 쓰이지 않을 수 있습니다 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-125">If pre- and post-rendering are the only browser-specific processing tasks required, using <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> might make it unnecessary to override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>.</span></span> <span data-ttu-id="8bbc1-126">기본 동작을 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> 및 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 의 해당 메서드를 호출 하는 메서드는 <xref:System.Web.UI.HtmlTextWriter>합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-126">The default behavior of the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> methods is to call the corresponding methods of the <xref:System.Web.UI.HtmlTextWriter>.</span></span>  
  
 <span data-ttu-id="8bbc1-127">상태 정보를 유지 하려면 컨트롤 어댑터를 재정의할 수는 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, 및 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-127">To maintain its own state information, a control adapter can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> methods.</span></span> <span data-ttu-id="8bbc1-128"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>를 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, 및 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> 개인 컨트롤과 뷰 상태가 저장 되 고 로드를 각각 때 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-128"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> are called when the private control and view states are saved and loaded, respectively.</span></span>  
  
 <span data-ttu-id="8bbc1-129">합니다 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>를 <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, 및 <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> 기준 메서드를 호출 다시 해당 <xref:System.Web.UI.Control> 클래스 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-129">The <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> base methods call back on the corresponding <xref:System.Web.UI.Control> class methods.</span></span> <span data-ttu-id="8bbc1-130">따라서 이러한 항목 중 하나 <xref:System.Web.UI.Adapters.ControlAdapter> 연결 된 이벤트가 고, 그렇지 않으면 재정의 된 메서드는 기본 메서드를 호출 합니다 <xref:System.Web.UI.Control> 클래스 메서드를 발생 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-130">Thus, any of these <xref:System.Web.UI.Adapters.ControlAdapter> methods that are overridden must call their base methods; otherwise, the event associated with the <xref:System.Web.UI.Control> class method will not be raised.</span></span>  
  
 <span data-ttu-id="8bbc1-131">컨트롤 및 어댑터는 필요에 따라 구현 된 <xref:System.Web.UI.IPostBackDataHandler> 및 <xref:System.Web.UI.IPostBackEventHandler> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-131">Controls and adapters optionally implement the <xref:System.Web.UI.IPostBackDataHandler> and <xref:System.Web.UI.IPostBackEventHandler> interfaces.</span></span> <span data-ttu-id="8bbc1-132">.NET Framework는 어댑터의 존재 여부 및 어댑터에서 이러한 인터페이스를 구현 하는 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-132">The .NET Framework determines whether an adapter exists and whether the adapter implements these interfaces.</span></span> <span data-ttu-id="8bbc1-133">이 경우 어댑터를 재정의 해야 합니다 <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, 및 <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> 필요에 따라 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-133">If it does, the adapter should override the <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, and <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> methods, as necessary.</span></span> <span data-ttu-id="8bbc1-134">어댑터에서 다시 게시 데이터가 인식 되지 않으면,이 처리 하는 컨트롤에 다시 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-134">If the postback data is not recognized in the adapter, it must call back on the control to process it.</span></span> <span data-ttu-id="8bbc1-135">후속 이벤트 처리기도 호출 해야 다시 컨트롤에 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-135">Subsequent event handlers also must call back on the control.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-136">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스를 일반 어댑터 기능을 필요로 하는 컨트롤을 해당 어댑터 클래스가 패턴에서 기본 있어야 <paramref name="ControlType" /> <see langword="Adapter" /> (예를 들어 <see langword="TextBoxAdapter" />).</span><span class="sxs-lookup"><span data-stu-id="8bbc1-136">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, a control that requires general adapter functionality should have a corresponding adapter base class, named in the pattern <paramref name="ControlType" /><see langword="Adapter" /> (for example, <see langword="TextBoxAdapter" />).</span></span> <span data-ttu-id="8bbc1-137">어댑터에는 최소한 반환할지를 통해 해당 컨트롤의 강력한 형식의 인스턴스를 해당 <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-137">The adapter should at a minimum return a strongly-typed instance of the control through its <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> property.</span></span>  
  
<span data-ttu-id="8bbc1-138">1.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-138">1.</span></span>  <span data-ttu-id="8bbc1-139">컨트롤 패턴에 지정 된 컨트롤 형식 및 태그 언어 이름을 지정 해야에 대 한 어댑터 <paramref name="MarkupControlType" /> <see langword="Adapter" /> (예를 들어 <see langword="XhtmlTextBoxAdapter" />).</span><span class="sxs-lookup"><span data-stu-id="8bbc1-139">Control adapters for a given control type and markup language should be named in the pattern <paramref name="MarkupControlType" /><see langword="Adapter" /> (for example, <see langword="XhtmlTextBoxAdapter" />).</span></span> <span data-ttu-id="8bbc1-140">컨트롤 어댑터에서 구현 하는 <see langword="Adapters" /> 하위 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-140">Adapters for a control should be implemented in an <see langword="Adapters" /> subnamespace.</span></span>  
  
<span data-ttu-id="8bbc1-141">컨트롤 어댑터 적절 한 기본 클래스에서 상속 하며 컨트롤로 동일한 상속 모델을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-141">Control adapters should inherit from the appropriate base class and follow the same inheritance model as the control.</span></span> <span data-ttu-id="8bbc1-142">상속 하는 컨트롤의 예를 들어, 어댑터는 <see cref="T:System.Web.UI.Control" /> 기본 클래스에서 상속 해야 합니다 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스나 관련 <paramref name="ControlType" /> <see langword="Adapter" /> 클래스.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-142">For example, an adapter for a control inheriting from the <see cref="T:System.Web.UI.Control" /> base class should inherit from either the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class or the relevant <paramref name="ControlType" /><see langword="Adapter" /> class.</span></span>  
  
<span data-ttu-id="8bbc1-143">특수화 된 어댑터는 모든 장치 노드의 구성.browser 파일에 있는 특수 한 컨트롤에 대해 정의 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-143">Any specialized adapters should be defined for the specialized control under all of the device nodes in configuration .browser files.</span></span>  
  
<span data-ttu-id="8bbc1-144">어댑터가 연결 되어 있는지 또는 연결 된 어댑터 특정 인터페이스를 구현 하는 제대로 구현 된 컨트롤을 가정 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-144">A properly implemented control should not assume that an adapter is attached, or that the attached adapter implements a specific interface.</span></span> <span data-ttu-id="8bbc1-145">대신 호출 하기 전에 이러한 항목에 대해 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-145">Instead, it should check for these before calling.</span></span>  
  
<span data-ttu-id="8bbc1-146">시뮬레이션 같은 컨트롤에서 protected 이벤트 메서드를 재정의 하는 것이 가능 합니다 <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> 메서드의 <see cref="T:System.Web.UI.WebControls.LinkButton" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-146">It is possible to simulate overriding protected event methods in the control, such as the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method of the <see cref="T:System.Web.UI.WebControls.LinkButton" />.</span></span> <span data-ttu-id="8bbc1-147">어댑터 클래스를 먼저 만듭니다는 <c>OnClick</c> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-147">First, create an adapter class with an <c>OnClick</c> method.</span></span> <span data-ttu-id="8bbc1-148">다음에서 파생 된 새 컨트롤을 만듭니다 <see cref="T:System.Web.UI.WebControls.LinkButton" /> 재정의 <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-148">Then create a new control derived from <see cref="T:System.Web.UI.WebControls.LinkButton" /> and override the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method.</span></span> <span data-ttu-id="8bbc1-149">재정의 된 <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> 메서드 호출을 <c>OnClick</c> 어댑터의 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-149">The overridden <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method calls the <c>OnClick</c> method of the adapter.</span></span> <span data-ttu-id="8bbc1-150">어댑터 개체는 보호를 통해 사용할 수 있습니다 <see cref="P:System.Web.UI.Control.Adapter" /> 의 속성을 <see cref="T:System.Web.UI.Control" /> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-150">The adapter object is available through the protected <see cref="P:System.Web.UI.Control.Adapter" /> property of the <see cref="T:System.Web.UI.Control" /> class.</span></span> <span data-ttu-id="8bbc1-151">합니다 <see cref="P:System.Web.UI.Control.Adapter" /> 컨트롤의 속성이 <see langword="null" /> 연결 된 어댑터가 있으면 되므로 코드 확인 해야 해당 조건에 대 한 어댑터의 메서드를 호출 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-151">The <see cref="P:System.Web.UI.Control.Adapter" /> property of the control is <see langword="null" /> when there is no associated adapter, so any code should check for that condition before calling methods of the adapter.</span></span></para></block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8bbc1-152"><see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-152">Initializes a new instance of the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-153">.NET Framework는 내부적으로이 어댑터를 생성 해당를 만들 때 <xref:System.Web.UI.Control> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-153">The .NET Framework internally constructs this adapter when it creates the corresponding <xref:System.Web.UI.Control> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="8bbc1-154">대상별 출력을 렌더링하는 메서드가 포함된 <see cref="T:System.Web.UI.HtmlTextWriter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-154">The <see cref="T:System.Web.UI.HtmlTextWriter" /> containing methods to render the target-specific output.</span></span></param>
        <summary><span data-ttu-id="8bbc1-155">컨트롤의 렌더링 전에 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-155">Called prior to the rendering of a control.</span></span> <span data-ttu-id="8bbc1-156">파생 어댑터 클래스에서 특정 대상에는 필요하지만 HTML 브라우저에는 필요하지 않은 여는 태그를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-156">In a derived adapter class, generates opening tags that are required by a specific target but not needed by HTML browsers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-157"><xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> 메서드 직전에 호출 되는 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 메서드를 대상 특정 컨트롤의 렌더링 하기 전에 전처리 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-157">The <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method is called just before the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method, and is used to perform target-specific preprocessing before the rendering of the control.</span></span>  
  
 <span data-ttu-id="8bbc1-158">사용 된 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> 함께에서 메서드는 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 열기 및 닫기 태그 일관성을 확인 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-158">Use the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method in combination with the <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method to ensure opening and closing tag consistency.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-159">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스를 <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> 메서드 호출을 기본는 <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-159">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method.</span></span> <span data-ttu-id="8bbc1-160">따라서의 재정의 <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> 메서드를 호출 해야 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> 외에, 대신 대신 해당 처리 하는 경우에 기본 메서드를 <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-160">Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method.</span></span></para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8bbc1-161">현재 HTTP 요청을 하는 클라이언트의 브라우저 기능에 대한 참조를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-161">Gets a reference to the browser capabilities of the client making the current HTTP request.</span></span></summary>
        <value><span data-ttu-id="8bbc1-162">클라이언트 브라우저와 태그 기능을 지정하는 <see cref="T:System.Web.HttpBrowserCapabilities" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-162">An <see cref="T:System.Web.HttpBrowserCapabilities" /> specifying client browser and markup capabilities.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-163">A <xref:System.Web.UI.Adapters.ControlAdapter> 에서 클라이언트 브라우저 기능을 확인 하는 개체를 <xref:System.Web.HttpBrowserCapabilities> 에서 반환 되는 개체는 <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-163">A <xref:System.Web.UI.Adapters.ControlAdapter> object determines the client browser capabilities from the <xref:System.Web.HttpBrowserCapabilities> object that is returned by the <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> property.</span></span> <span data-ttu-id="8bbc1-164">그러면 합니다 <xref:System.Web.UI.Adapters.ControlAdapter> 브라우저 전용 태그를 렌더링 하거나 그렇지 않은 경우의 동작을 수정 하는 개체는 <xref:System.Web.UI.Control>합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-164">This enables the <xref:System.Web.UI.Adapters.ControlAdapter> object to render browser-specific markup or otherwise modify the behavior of the <xref:System.Web.UI.Control>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8bbc1-165">다음 코드 예제를 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> 속성을 요청 하는 브라우저의 세부 정보에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-165">The following code example shows how to use the <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> property to access the details of the requesting browser.</span></span> <span data-ttu-id="8bbc1-166">이 예제에서는 확인 코드 브라우저 JavaScript를 사용 하 여 호환 되는 경우에 사용자 지정 된 출력을 렌더링 하는 개발자를 허용 합니다 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-166">In this example, the code checks to determine whether the browser is compatible with JavaScript, and then allows the developer to render customized output in that case.</span></span>  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8bbc1-167">이 컨트롤 어댑터가 결합된 컨트롤에 대한 참조를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-167">Gets a reference to the control to which this control adapter is attached.</span></span></summary>
        <value><span data-ttu-id="8bbc1-168">이 <see cref="T:System.Web.UI.Control" />가 연결된 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-168">The <see cref="T:System.Web.UI.Control" /> to which this <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> is attached.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-169">파생된 컨트롤 어댑터를 컨트롤에 연결 되 면.NET Framework 컨트롤 멤버 대신 특정 어댑터 멤버를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-169">When a derived control adapter is attached to a control, the .NET Framework calls certain adapter members instead of the control members.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8bbc1-170">다음 코드 예제에서 사용자 지정 컨트롤을 파생 하는 방법을 보여 줍니다 합니다 <xref:System.Web.UI.Control> 클래스를 만든 다음에서 상속 되는 해당 어댑터는 <xref:System.Web.UI.Adapters.ControlAdapter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-170">The following code example shows how to derive a custom control from the <xref:System.Web.UI.Control> class, and then create a corresponding adapter that inherits from the <xref:System.Web.UI.Adapters.ControlAdapter> class.</span></span> <span data-ttu-id="8bbc1-171">어댑터 재정의 <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> 속성 및 컨트롤에 대 한 강력한 참조를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-171">The adapter overrides the <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> property and returns a strongly-typed reference to the control.</span></span>  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-172">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스를 구현 해야 최소한를 <see langword="Control" /> 예제 단원에 나와 있는 것 처럼 컨트롤의 강력한 형식의 인스턴스를 반환 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-172">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, at a minimum, you should implement a <see langword="Control" /> property to return a strongly-typed instance of the control, as shown in the Example section.</span></span></para></block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8bbc1-173">합성 컨트롤의 대상별 자식 컨트롤을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-173">Creates the target-specific child controls for a composite control.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-174">파생된 컨트롤 어댑터를 연결할 경우는 <xref:System.Web.UI.Control> 개체 및 <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> 메서드가 재정의 되는 재정의 대신 호출 되는 <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-174">If there is a derived control adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> method is overridden, the override is called instead of the <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8bbc1-175">따라서 <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> 대상별 자식 컨트롤 집합을 만드는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-175">Thus, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> can be used to create a target-specific child control set.</span></span>  
  
 <span data-ttu-id="8bbc1-176">새 컨트롤을 만드는 컨트롤을 결합 하는 방법에 대 한 자세한 내용은 참조 하세요. [복합 컨트롤](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-176">For more information about combining controls to create a new control, see [Composite Controls](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-177">상속 클래스를 만들고 재정의 <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> 메서드인 기본 메서드에 의해 생성 된 컨트롤을 추가 하려는 경우가 아니면 기본 메서드를 호출 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-177">If you create an inheriting class and override the <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> method, do not call the base method unless you want to add controls to those created by the base method.</span></span> <span data-ttu-id="8bbc1-178">그렇지 않으면 두 자식 컨트롤 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-178">Otherwise you could create two sets of child controls.</span></span></para></block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="8bbc1-179">대상별 출력을 렌더링하는 메서드가 포함된 <see cref="T:System.Web.UI.HtmlTextWriter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-179">The <see cref="T:System.Web.UI.HtmlTextWriter" /> containing methods to render the target-specific output.</span></span></param>
        <summary><span data-ttu-id="8bbc1-180">컨트롤의 렌더링 후에 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-180">Called after the rendering of a control.</span></span> <span data-ttu-id="8bbc1-181">파생 어댑터 클래스에서 특정 대상에는 필요하지만 HTML 브라우저에는 필요하지 않은 닫는 태그를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-181">In a derived adapter class, generates closing tags that are required by a specific target but not needed by HTML browsers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-182">합니다 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 직후 호출 됩니다는 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 메서드는 컨트롤의 렌더링 후 대상별 후 처리를 수행 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-182">The <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method is called just after the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method, and is used to perform target-specific postprocessing after the rendering of the control.</span></span>  
  
 <span data-ttu-id="8bbc1-183">사용 된 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> 함께에서 메서드는 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> 열기 및 닫기 태그 일관성을 확인 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-183">Use the <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method in combination with the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method to ensure opening and closing tag consistency.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-184">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스를 <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> 메서드 호출을 기본는 <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-184">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method.</span></span> <span data-ttu-id="8bbc1-185">따라서의 재정의 <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> 메서드를 호출 해야 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> 외에, 대신 대신 해당 처리 하는 경우에 기본 메서드를 <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-185">Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method.</span></span></para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="8bbc1-186">어댑터의 컨트롤 상태 정보를 <see cref="T:System.Object" />으로 포함하는 <see cref="T:System.Web.UI.StateBag" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-186">An <see cref="T:System.Object" /> that contains the adapter's control state information as a <see cref="T:System.Web.UI.StateBag" />.</span></span></param>
        <summary><span data-ttu-id="8bbc1-187">이 컨트롤 어댑터와 연결된 컨트롤이 있는 페이지에 대한 이전의 요청 중 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />에서 저장한 어댑터 컨트롤 상태 정보를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-187">Loads adapter control state information that was saved by <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> during a previous request to the page where the control associated with this control adapter resides.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-188">컨트롤 상태가 필요한 뷰 상태를 사용 하지 않도록 설정 하는 경우에 필수 상태 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-188">Control state is the essential state information needed even if view state is disabled.</span></span> <span data-ttu-id="8bbc1-189">어댑터를 자체 컨트롤 상태 정보를 유지 해야 하는 경우 재정의할 수는 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> 고 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-189">When an adapter needs to maintain its own control state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> methods.</span></span>  
  
 <span data-ttu-id="8bbc1-190">어댑터는 상태와 연결된 된 컨트롤의 상태에서에 관계 없이 요청 간에 유지 해야 하는 기능이 있을 때 컨트롤 상태 정보를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-190">An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</span></span> <span data-ttu-id="8bbc1-191">큰 텍스트 표시 및의 그룹으로 구성 된 복합 컨트롤 예를 들어 <xref:System.Web.UI.WebControls.RadioButton> 컨트롤 데스크톱 컴퓨터 브라우저의 단일 뷰를 렌더링 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-191">For example, a composite control consisting of a large textual display and a group of <xref:System.Web.UI.WebControls.RadioButton> controls might render as a single view on desktop computer browsers.</span></span> <span data-ttu-id="8bbc1-192">다른 브라우저 렌더링-텍스트 표시 및 다른 라디오 단추 그룹에 대해 하나의 뷰에서 분할 될 수 있습니다 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-192">On other browsers, it might split its rendering - one view for the textual display and the other for the radio button group.</span></span> <span data-ttu-id="8bbc1-193">어댑터는 현재 활성 보기에 대 한 고유한 대상 관련 정보를 유지 관리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-193">The adapter would need to maintain its own target-specific information about the currently active view.</span></span>  
  
 <span data-ttu-id="8bbc1-194"><xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> 직후 호출 됩니다 합니다 <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> 메서드는 `LoadState` 수명 주기 단계.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-194">The <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> method is called immediately after the <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> method, in the `LoadState` lifecycle stage.</span></span> <span data-ttu-id="8bbc1-195">어댑터 컨트롤 상태는 별도 되며 컨트롤의 컨트롤 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-195">The adapter control state is separate and in addition to the control state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="8bbc1-196">어댑터 뷰 상태 정보를 <see cref="T:System.Object" />으로 포함하는 <see cref="T:System.Web.UI.StateBag" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-196">An <see cref="T:System.Object" /> that contains the adapter view state information as a <see cref="T:System.Web.UI.StateBag" />.</span></span></param>
        <summary><span data-ttu-id="8bbc1-197">이 컨트롤 어댑터와 연결된 컨트롤이 있는 페이지에 대한 이전 요청 중 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />에서 저장한 어댑터 뷰 상태 정보를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-197">Loads adapter view state information that was saved by <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> during a previous request to the page where the control associated with this control adapter resides.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-198">어댑터를 자신의 뷰 상태 정보를 유지 해야 하는 경우 재정의할 수는 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> 고 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-198">When an adapter needs to maintain its own view state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> methods.</span></span>  
  
 <span data-ttu-id="8bbc1-199">어댑터는 데이터와 연결된 된 컨트롤의 뷰 상태 관계 없이 요청 간에 유지 해야 하는 경우 뷰 상태 정보를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-199">An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the view state of the associated control.</span></span> <span data-ttu-id="8bbc1-200">예를 들어, 데스크톱 컴퓨터 브라우저에서 표 형태 컨트롤 값의 열 및 행의 단일 뷰를 렌더링 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-200">For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</span></span> <span data-ttu-id="8bbc1-201">다른 브라우저에서는 행 및 단일 행의 세부 정보 목록 같은 별도 여러 뷰를 렌더링을 분할 될 수 있습니다 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-201">On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</span></span> <span data-ttu-id="8bbc1-202">어댑터 뷰 상태에서 현재 활성화 되지 않은 보기에 대 한 데이터를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-202">The adapter would need to maintain the data for the views that are not currently active in view state.</span></span>  
  
 <span data-ttu-id="8bbc1-203"><xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> 바로 전에 메서드가 호출 되는 <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> 에서 메서드를 `LoadState` 수명 주기 단계.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-203">The <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> method is called immediately before the <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> method in the `LoadState` lifecycle stage.</span></span> <span data-ttu-id="8bbc1-204">어댑터 뷰 상태는 별도 되며 컨트롤의 뷰 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-204">The adapter view state is separate and in addition to the view state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="8bbc1-205">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-205">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="8bbc1-206">연결된 컨트롤의 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-206">Overrides the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method for the associated control.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-207">어댑터에 연결 된 경우는 <xref:System.Web.UI.Control> 개체 및 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> 메서드를 재정의 대신 재정의 메서드를 호출 합니다 <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-207">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8bbc1-208">재정의 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> 대상별 처리를 수행 하는 `Initialize` 컨트롤 수명 주기의 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-208">Override <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> to perform target-specific processing in the `Initialize` stage of the control lifecycle.</span></span> <span data-ttu-id="8bbc1-209">일반적으로이 컨트롤을 만들 때 수행 되는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-209">Typically, these are functions that are performed when a control is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8bbc1-210">다음 코드 샘플을 사용자 지정 컨트롤 어댑터에서 파생 되는 <xref:System.Web.UI.Adapters.ControlAdapter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-210">The following code sample derives a custom control adapter from the <xref:System.Web.UI.Adapters.ControlAdapter> class.</span></span> <span data-ttu-id="8bbc1-211">다음 재정의 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> 메서드를 연결된 된 컨트롤의 속성을 설정 하 고 컨트롤 초기화를 완료 하려면 기본 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-211">It then overrides the <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> method to set a property on the associated control and call the base method to complete the control initialization.</span></span>  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-212">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스 및 어댑터 재정의 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> 메서드를 어댑터를 호출 하는 해당 기본 클래스 메서드를 호출 해야 합니다는 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-212">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method.</span></span> <span data-ttu-id="8bbc1-213">경우는 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 메서드를 호출 하지 않으면는 <see cref="E:System.Web.UI.Control.Init" /> 이벤트 발생 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-213">If the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.Init" /> event will not be raised.</span></span></para></block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="8bbc1-214">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-214">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="8bbc1-215">연결된 컨트롤의 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-215">Overrides the <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> method for the associated control.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-216">어댑터에 연결 된 경우는 <xref:System.Web.UI.Control> 개체 및 <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> 메서드를 재정의 대신 재정의 메서드를 호출 합니다 <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-216">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8bbc1-217">재정의 <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> 대상별 처리를 수행 하는 방법의 `Load` 컨트롤 수명 주기의 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-217">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> method to perform target-specific processing in the `Load` stage of the control lifecycle.</span></span> <span data-ttu-id="8bbc1-218">일반적으로이 각 클라이언트 요청에 대해 수행 해야 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-218">Typically, these are functions that should be performed for each client request.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-219">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스 및 어댑터 재정의 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> 메서드를 어댑터를 호출 하는 해당 기본 클래스 메서드를 호출 해야 합니다는 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-219">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> method.</span></span> <span data-ttu-id="8bbc1-220">하는 경우 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 가 호출 되지 않습니다는 <see cref="E:System.Web.UI.Control.Load" /> 이벤트 발생 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-220">If <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Load" /> event will not be raised.</span></span></para></block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="8bbc1-221">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-221">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="8bbc1-222">연결된 컨트롤의 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-222">Overrides the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method for the associated control.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-223">어댑터에 연결 된 경우는 <xref:System.Web.UI.Control> 개체 및 <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> 메서드를 재정의 대신 재정의 메서드를 호출 합니다 <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-223">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8bbc1-224">재정의 <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> 대상별 처리를 수행 하는 방법의 `PreRender` 컨트롤 수명 주기의 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-224">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> method to perform target-specific processing in the `PreRender` stage of the control lifecycle.</span></span> <span data-ttu-id="8bbc1-225">일반적으로이 바로 앞에 컨트롤 출력을 렌더링 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-225">Typically, these are functions that immediately precede rendering of the control output.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-226">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스 및 어댑터 재정의 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> 메서드를 어댑터를 호출 하는 해당 기본 클래스 메서드를 호출 해야 합니다는 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-226">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method.</span></span> <span data-ttu-id="8bbc1-227">경우는 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 메서드를 호출 하지 않으면는 <see cref="E:System.Web.UI.Control.PreRender" /> 이벤트 발생 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-227">If the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.PreRender" /> event will not be raised.</span></span></para></block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="8bbc1-228">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-228">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="8bbc1-229">연결된 컨트롤의 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-229">Overrides the <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> method for the associated control.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-230">어댑터에 연결 된 경우는 <xref:System.Web.UI.Control> 개체 및 <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> 메서드를 재정의 대신 재정의 메서드를 호출 합니다 <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-230">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8bbc1-231">재정의 <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> 대상별 처리를 위해 메서드를 `Unload` 컨트롤 수명 주기의 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-231">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> method to do target-specific processing in the `Unload` stage of the control lifecycle.</span></span> <span data-ttu-id="8bbc1-232">일반적으로 이것은 정리 함수 앞에 컨트롤의 처리입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-232">Typically, these are cleanup functions that precede disposition of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-233">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스 및 어댑터 재정의 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> 메서드를 어댑터를 호출 하는 해당 기본 클래스 메서드를 호출 해야 합니다는 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-233">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> method.</span></span> <span data-ttu-id="8bbc1-234">하는 경우 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 가 호출 되지 않습니다는 <see cref="E:System.Web.UI.Control.Unload" /> 이벤트 발생 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-234">If <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Unload" /> event will not be raised.</span></span></para></block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8bbc1-235">이 어댑터와 연결된 컨트롤이 있는 페이지에 대한 참조를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-235">Gets a reference to the page where the control associated with this adapter resides.</span></span></summary>
        <value><span data-ttu-id="8bbc1-236">연결된 컨트롤이 있는 페이지 인스턴스에 대한 액세스를 제공하는 <see cref="T:System.Web.UI.Page" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-236">A <see cref="T:System.Web.UI.Page" /> that provides access to the page instance where the associated control is situated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-237">합니다 <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> 속성에 대 한 액세스를 제공 합니다 <xref:System.Web.UI.Page?displayProperty=nameWithType> 여기서은 컨트롤이 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-237">The <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> property provides access to the <xref:System.Web.UI.Page?displayProperty=nameWithType> object where the control is situated.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8bbc1-238">연결된 컨트롤이 있는 페이지의 페이지 어댑터에 대한 참조를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-238">Gets a reference to the page adapter for the page where the associated control resides.</span></span></summary>
        <value><span data-ttu-id="8bbc1-239">현재 <see cref="T:System.Web.UI.Adapters.PageAdapter" />와 연결된 컨트롤이 있는 페이지의 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-239">A <see cref="T:System.Web.UI.Adapters.PageAdapter" /> for the page where the control associated with the current <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> is situated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-240"><xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> 속성에 대 한 액세스를 제공 합니다 <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> 개체에 대 한는 <xref:System.Web.UI.Page> 개체 위치를 <xref:System.Web.UI.Control> 현재 연관 된 개체 <xref:System.Web.UI.Adapters.ControlAdapter> 개체는에.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-240">The <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> property provides access to the <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> object for the <xref:System.Web.UI.Page> object where the <xref:System.Web.UI.Control> object associated with the current <xref:System.Web.UI.Adapters.ControlAdapter> object is situated.</span></span>  
  
 <span data-ttu-id="8bbc1-241"><xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> 속성 페이지에서 여러 컨트롤 형식에 적용할 수 있는 일반적인 대상별 함수와 같은 페이지 어댑터 수준에서 다른 항목에 액세스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-241">The <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> property can be used to access other items at the page adapter level, such as common target-specific functions that could apply to several control types on the page.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="8bbc1-242">대상별 출력을 렌더링하는 데 사용하는 <see cref="T:System.Web.UI.HtmlTextWriter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-242">The <see cref="T:System.Web.UI.HtmlTextWriter" /> to use to render the target-specific output.</span></span></param>
        <summary><span data-ttu-id="8bbc1-243">컨트롤 어댑터가 연결된 컨트롤에 대한 대상별 태그를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-243">Generates the target-specific markup for the control to which the control adapter is attached.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-244">재정의 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 클라이언트 브라우저로 보낼 대상별 태그를 생성 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-244">Override the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method to generate target-specific markup to send to the client browser.</span></span> <span data-ttu-id="8bbc1-245"><xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> 메서드는 대신를 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 메서드 경우를 <xref:System.Web.UI.Adapters.ControlAdapter> 개체에 연결 되어를 <xref:System.Web.UI.Control> 개체.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-245">The <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method is called in place of the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method if a <xref:System.Web.UI.Adapters.ControlAdapter> object is attached to a <xref:System.Web.UI.Control> object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-246">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 클래스를 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 메서드 호출을 기본는 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-246">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method.</span></span> <span data-ttu-id="8bbc1-247">따라서의 재정의 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 메서드를 호출 해야 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 외에, 대신 대신 해당 처리 하는 경우에 기본 메서드를 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-247">Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method.</span></span>  
  
<span data-ttu-id="8bbc1-248">복합 컨트롤의 경우 어댑터 개발자는 자식 컨트롤이 렌더링 되는 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-248">For a composite control, the adapter developer must ensure that the child controls are rendered.</span></span> <span data-ttu-id="8bbc1-249">경우는 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 메서드를 사용 하면 자식 컨트롤을 렌더링할 수 있지만 태그를 생성 하지 않습니다는 것이 적합 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 기본 메서드를 호출 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-249">If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method.</span></span> <span data-ttu-id="8bbc1-250">자식 컨트롤의 대상별 렌더링 필요한 경우, 어댑터가 구현 해야 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 메서드를 호출 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 메서드에서 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-250">If target-specific rendering of the child controls is necessary, the adapter should implement the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method and call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.</span></span></para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="8bbc1-251">대상별 출력을 렌더링하는 데 사용하는 <see cref="T:System.Web.UI.HtmlTextWriter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-251">The <see cref="T:System.Web.UI.HtmlTextWriter" /> to use to render the target-specific output.</span></span></param>
        <summary><span data-ttu-id="8bbc1-252">컨트롤 어댑터가 결합되는 합성 컨트롤의 자식 컨트롤에 대한 대상별 태그를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-252">Generates the target-specific markup for the child controls in a composite control to which the control adapter is attached.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-253">재정의 <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> 메서드 또한 개별 자식 컨트롤의 태그에 복합 컨트롤의 자식 컨트롤 집합에 대 한 대상별 태그를 생성 하는 데 필요한 경우.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-253">Override the <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> method when it is necessary to generate target-specific markup for the child control set of a composite control, in addition to the markup for the individual child controls.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8bbc1-254">상속 하는 경우는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 어댑터 개발자는 복합 컨트롤에 대 한 클래스는 자식 컨트롤 렌더링 되도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-254">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, for a composite control, the adapter developer must ensure that the child controls are rendered.</span></span> <span data-ttu-id="8bbc1-255">어댑터를 재정의 하는 경우는 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 호출 메서드를 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 재정의 메서드에서 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-255">If the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method, it should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from an override of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.</span></span>  
  
<span data-ttu-id="8bbc1-256">경우는 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 메서드를 사용 하면 자식 컨트롤을 렌더링할 수 있지만 자체 태그를 생성 하지 않습니다는 것이 적합 합니다 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 메서드를 호출 하는 기본 메서드를 호출는 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 대 한 재정의 구현 하는 대신 메서드를 <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-256">If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but itself does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method, which calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method, instead of implementing an override for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method.</span></span></para></block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8bbc1-257">컨트롤 어댑터의 컨트롤 상태 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-257">Saves control state information for the control adapter.</span></span></summary>
        <returns><span data-ttu-id="8bbc1-258">어댑터의 컨트롤 상태 정보를 <see cref="T:System.Object" />으로 포함하는 <see cref="T:System.Web.UI.StateBag" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-258">An <see cref="T:System.Object" /> that contains the adapter's control state information as a <see cref="T:System.Web.UI.StateBag" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-259">컨트롤 상태가 필요한 뷰 상태를 사용 하지 않도록 설정 하는 경우에 필수 상태 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-259">Control state is the essential state information needed even if view state is disabled.</span></span> <span data-ttu-id="8bbc1-260">어댑터를 자체 컨트롤 상태 정보를 유지 해야 하는 경우 재정의할 수는 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> 고 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-260">When an adapter needs to maintain its own control state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> methods.</span></span>  
  
 <span data-ttu-id="8bbc1-261">어댑터는 상태와 연결된 된 컨트롤의 상태에서에 관계 없이 요청 간에 유지 해야 하는 기능이 있을 때 컨트롤 상태 정보를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-261">An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</span></span> <span data-ttu-id="8bbc1-262">큰 텍스트 표시 및의 그룹으로 구성 된 복합 컨트롤 예를 들어 <xref:System.Web.UI.WebControls.RadioButton> 컨트롤 데스크톱 컴퓨터 브라우저의 단일 뷰를 렌더링 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-262">For example, a composite control consisting of a large textual display and a group of <xref:System.Web.UI.WebControls.RadioButton> controls might render as a single view on desktop computer browsers.</span></span> <span data-ttu-id="8bbc1-263">다른 브라우저 렌더링-텍스트 표시 및 다른 라디오 단추 그룹에 대해 하나의 뷰에서 분할 될 수 있습니다 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-263">On other browsers, it might split its rendering - one view for the textual display and the other for the radio button group.</span></span> <span data-ttu-id="8bbc1-264">어댑터는 현재 활성 보기에 대 한 고유한 대상 관련 정보를 유지 관리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-264">The adapter would need to maintain its own target-specific information about the currently active view.</span></span>  
  
 <span data-ttu-id="8bbc1-265">합니다 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> 직후 호출 됩니다 합니다 <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> 에서 메서드는 `SaveState` 수명 주기 단계.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-265">The <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> method is called immediately after the <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> method in the `SaveState` lifecycle stage.</span></span> <span data-ttu-id="8bbc1-266">어댑터 컨트롤 상태는 별도 되며 컨트롤의 컨트롤 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-266">The adapter control state is separate and in addition to the control state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8bbc1-267">컨트롤 어댑터의 뷰 상태 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-267">Saves view state information for the control adapter.</span></span></summary>
        <returns><span data-ttu-id="8bbc1-268">어댑터 뷰 상태 정보를 <see cref="T:System.Object" />으로 포함하는 <see cref="T:System.Web.UI.StateBag" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-268">An <see cref="T:System.Object" /> that contains the adapter view state information as a <see cref="T:System.Web.UI.StateBag" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8bbc1-269">어댑터를 자신의 뷰 상태 정보를 유지 해야 하는 경우 재정의할 수는 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> 고 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-269">When an adapter needs to maintain its own view state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> methods.</span></span>  
  
 <span data-ttu-id="8bbc1-270">어댑터는 데이터 컨트롤의 연결 된 뷰 상태 관계 없이 요청 간에 유지 해야 하는 경우 뷰 상태 정보를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-270">An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the associated view state of the control.</span></span> <span data-ttu-id="8bbc1-271">예를 들어, 데스크톱 컴퓨터 브라우저에서 표 형태 컨트롤 값의 열 및 행의 단일 뷰를 렌더링 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-271">For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</span></span> <span data-ttu-id="8bbc1-272">다른 브라우저에서는 행 및 단일 행의 세부 정보 목록 같은 별도 여러 뷰를 렌더링을 분할 될 수 있습니다 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-272">On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</span></span> <span data-ttu-id="8bbc1-273">어댑터 뷰 상태에서 현재 활성화 되지 않은 보기에 대 한 데이터를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-273">The adapter would need to maintain the data for the views that are not currently active in view state.</span></span>  
  
 <span data-ttu-id="8bbc1-274"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> 바로 전에 메서드가 호출 되는 <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> 에서 메서드를 `SaveState` 수명 주기 단계.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-274">The <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> method is called immediately before the <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> method in the `SaveState` lifecycle stage.</span></span> <span data-ttu-id="8bbc1-275">어댑터 뷰 상태는 별도 되며 컨트롤의 뷰 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="8bbc1-275">The adapter view state is separate and in addition to the view state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>