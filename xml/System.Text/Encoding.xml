<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="76d4d835f6dce4521d61c90bd9496531e320c717" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58701886" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="892d9-101">문자 인코딩을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-101">Represents a character encoding.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-102">인코딩은 유니코드 문자 집합을 바이트 시퀀스로 변환하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="892d9-103">반면, 디코딩은 유니코드 문자 집합으로 인코딩된 바이트 시퀀스로 변환 하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-103">In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span> <span data-ttu-id="892d9-104">유니코드 변환 형식 (Utf) 및에서 지 원하는 다른 인코딩에 대 한 내용은 <xref:System.Text.Encoding>를 참조 하세요 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-104">For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="892d9-105"><xref:System.Text.Encoding> 바이트 배열과 같은 임의의 이진 데이터 대신 유니코드 문자에 대해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-105">Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="892d9-106">텍스트로 임의의 이진 데이터를 인코딩해야 하는 경우에와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-106">If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="892d9-107">.NET의 다음 구현을 제공 합니다 <xref:System.Text.Encoding> 현재 유니코드 인코딩 및 다른 인코딩을 지원 하기 위해 클래스:</span><span class="sxs-lookup"><span data-stu-id="892d9-107">.NET provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:</span></span>  
  
-   <span data-ttu-id="892d9-108"><xref:System.Text.ASCIIEncoding> 단일 7 비트 ASCII 문자를 유니코드 문자를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-108"><xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters.</span></span> <span data-ttu-id="892d9-109">이 인코딩 U + 사이의 문자 값만 지원 0000 및 U + 007F 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-109">This encoding only supports character values between U+0000 and U+007F.</span></span> <span data-ttu-id="892d9-110">코드 페이지 20127입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-110">Code page 20127.</span></span> <span data-ttu-id="892d9-111">통해 사용 가능한는 <xref:System.Text.Encoding.ASCII%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-111">Also available through the <xref:System.Text.Encoding.ASCII%2A> property.</span></span>  
  
-   <span data-ttu-id="892d9-112"><xref:System.Text.UTF7Encoding> utf-7 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-112"><xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding.</span></span> <span data-ttu-id="892d9-113">이 인코딩은 모든 유니코드 문자 값을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-113">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="892d9-114">코드 페이지 65000입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-114">Code page 65000.</span></span> <span data-ttu-id="892d9-115">통해 사용 가능한는 <xref:System.Text.Encoding.UTF7%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-115">Also available through the <xref:System.Text.Encoding.UTF7%2A> property.</span></span>  
  
-   <span data-ttu-id="892d9-116"><xref:System.Text.UTF8Encoding> utf-8 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-116"><xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding.</span></span> <span data-ttu-id="892d9-117">이 인코딩은 모든 유니코드 문자 값을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-117">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="892d9-118">코드 페이지 65001입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-118">Code page 65001.</span></span> <span data-ttu-id="892d9-119">통해 사용 가능한는 <xref:System.Text.Encoding.UTF8%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-119">Also available through the <xref:System.Text.Encoding.UTF8%2A> property.</span></span>  
  
-   <span data-ttu-id="892d9-120"><xref:System.Text.UnicodeEncoding> utf-16 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-120"><xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding.</span></span> <span data-ttu-id="892d9-121">Little endian 및 big endian 바이트 순서가 둘 다 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-121">Both little endian and big endian byte orders are supported.</span></span> <span data-ttu-id="892d9-122">통해 사용 가능한 합니다 <xref:System.Text.Encoding.Unicode%2A> 속성 및 <xref:System.Text.Encoding.BigEndianUnicode%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-122">Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.</span></span>  
  
-   <span data-ttu-id="892d9-123"><xref:System.Text.UTF32Encoding> UTF-32 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-123"><xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding.</span></span> <span data-ttu-id="892d9-124">Little endian (코드 페이지 12000) 및 big endian (코드 페이지 12001) 바이트 순서가 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-124">Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.</span></span> <span data-ttu-id="892d9-125">통해 사용 가능한는 <xref:System.Text.Encoding.UTF32%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-125">Also available through the <xref:System.Text.Encoding.UTF32%2A> property.</span></span>  
  
 <span data-ttu-id="892d9-126"><xref:System.Text.Encoding> 클래스는 주로 다른 인코딩과 유니코드 간 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-126">The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode.</span></span> <span data-ttu-id="892d9-127">앱에 적합 한 경우가 파생 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-127">Often one of the derived Unicode classes is the correct choice for your app.</span></span>  
  
 <span data-ttu-id="892d9-128">사용 하 여는 <xref:System.Text.Encoding.GetEncoding%2A> 다른 인코딩을 얻는 메서드를 호출는 <xref:System.Text.Encoding.GetEncodings%2A> 모든 인코딩 목록을 가져오기 위한 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-128">Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.</span></span>  
  
 <span data-ttu-id="892d9-129">다음 표에서.NET Framework 및.NET Core에서 지 원하는 인코딩은 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-129">The following table lists the encodings supported by .NET Framework and .NET Core.</span></span> <span data-ttu-id="892d9-130">각 인코딩의 코드 페이지 번호 및 인코딩의 값 나열 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 고 <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-130">It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="892d9-131">에 확인 표시가 합니다 **.NET Framework 지원** 하 고 **.NET Core 지원** 열 코드 페이지는 기본 플랫폼에 관계 없이 해당.NET 구현에서 지원 고유 하 게 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-131">A check mark in the **.NET Framework support** and **.NET Core support** columns indicates that the code page is natively supported by that .NET implementation, regardless of the underlying platform.</span></span> <span data-ttu-id="892d9-132">.NET Framework에 대 한 테이블에 나열 된 다른 인코딩을 가용성 운영 체제에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-132">For .NET Framework, the availability of other encodings listed in the table depends on the operating system.</span></span> <span data-ttu-id="892d9-133">.NET Core에 대 한 다른 인코딩을 통해 이용할 수는 <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> 나 클래스에서 파생 하는 <xref:System.Text.EncodingProvider?displayProperty=nameWithType> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-133">For .NET Core, other encodings are available by using the <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> class or by deriving from the <xref:System.Text.EncodingProvider?displayProperty=nameWithType> class.</span></span>  

> [!NOTE]
> <span data-ttu-id="892d9-134">해당 코드 페이지 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 국제 표준에 해당 하는 속성 전체 해당 표준을 준수 하지 않는 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-134">Code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> property corresponds to an international standard do not necessarily comply in full with that standard.</span></span> 

|<span data-ttu-id="892d9-135">코드 페이지</span><span class="sxs-lookup"><span data-stu-id="892d9-135">Code page</span></span>|<span data-ttu-id="892d9-136">name</span><span class="sxs-lookup"><span data-stu-id="892d9-136">Name</span></span>|<span data-ttu-id="892d9-137">표시 이름</span><span class="sxs-lookup"><span data-stu-id="892d9-137">Display name</span></span>|<span data-ttu-id="892d9-138">.NET framework 지원</span><span class="sxs-lookup"><span data-stu-id="892d9-138">.NET Framework support</span></span>| <span data-ttu-id="892d9-139">.NET Core 지원</span><span class="sxs-lookup"><span data-stu-id="892d9-139">.NET Core support</span></span> | 
|---------|----|------------|----------------------|-------------------|    
|<span data-ttu-id="892d9-140">37</span><span class="sxs-lookup"><span data-stu-id="892d9-140">37</span></span>|<span data-ttu-id="892d9-141">IBM037</span><span class="sxs-lookup"><span data-stu-id="892d9-141">IBM037</span></span>|<span data-ttu-id="892d9-142">IBM EBCDIC (미국-캐나다)</span><span class="sxs-lookup"><span data-stu-id="892d9-142">IBM EBCDIC (US-Canada)</span></span>|||  
|<span data-ttu-id="892d9-143">437</span><span class="sxs-lookup"><span data-stu-id="892d9-143">437</span></span>|<span data-ttu-id="892d9-144">IBM437</span><span class="sxs-lookup"><span data-stu-id="892d9-144">IBM437</span></span>|<span data-ttu-id="892d9-145">OEM United States</span><span class="sxs-lookup"><span data-stu-id="892d9-145">OEM United States</span></span>|||  
|<span data-ttu-id="892d9-146">500</span><span class="sxs-lookup"><span data-stu-id="892d9-146">500</span></span>|<span data-ttu-id="892d9-147">IBM500</span><span class="sxs-lookup"><span data-stu-id="892d9-147">IBM500</span></span>|<span data-ttu-id="892d9-148">IBM EBCDIC (국제)</span><span class="sxs-lookup"><span data-stu-id="892d9-148">IBM EBCDIC (International)</span></span>|||  
|<span data-ttu-id="892d9-149">708</span><span class="sxs-lookup"><span data-stu-id="892d9-149">708</span></span>|<span data-ttu-id="892d9-150">ASMO-708</span><span class="sxs-lookup"><span data-stu-id="892d9-150">ASMO-708</span></span>|<span data-ttu-id="892d9-151">아랍어 (ASMO 708)</span><span class="sxs-lookup"><span data-stu-id="892d9-151">Arabic (ASMO 708)</span></span>|||  
|<span data-ttu-id="892d9-152">720</span><span class="sxs-lookup"><span data-stu-id="892d9-152">720</span></span>|<span data-ttu-id="892d9-153">DOS-720</span><span class="sxs-lookup"><span data-stu-id="892d9-153">DOS-720</span></span>|<span data-ttu-id="892d9-154">아랍어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-154">Arabic (DOS)</span></span>|||  
|<span data-ttu-id="892d9-155">737</span><span class="sxs-lookup"><span data-stu-id="892d9-155">737</span></span>|<span data-ttu-id="892d9-156">ibm737</span><span class="sxs-lookup"><span data-stu-id="892d9-156">ibm737</span></span>|<span data-ttu-id="892d9-157">그리스어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-157">Greek (DOS)</span></span>|||  
|<span data-ttu-id="892d9-158">775</span><span class="sxs-lookup"><span data-stu-id="892d9-158">775</span></span>|<span data-ttu-id="892d9-159">ibm775</span><span class="sxs-lookup"><span data-stu-id="892d9-159">ibm775</span></span>|<span data-ttu-id="892d9-160">발트어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-160">Baltic (DOS)</span></span>|||  
|<span data-ttu-id="892d9-161">850</span><span class="sxs-lookup"><span data-stu-id="892d9-161">850</span></span>|<span data-ttu-id="892d9-162">ibm850</span><span class="sxs-lookup"><span data-stu-id="892d9-162">ibm850</span></span>|<span data-ttu-id="892d9-163">서유럽어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-163">Western European (DOS)</span></span>|||  
|<span data-ttu-id="892d9-164">852</span><span class="sxs-lookup"><span data-stu-id="892d9-164">852</span></span>|<span data-ttu-id="892d9-165">ibm852</span><span class="sxs-lookup"><span data-stu-id="892d9-165">ibm852</span></span>|<span data-ttu-id="892d9-166">중앙 유럽어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-166">Central European (DOS)</span></span>|||  
|<span data-ttu-id="892d9-167">855</span><span class="sxs-lookup"><span data-stu-id="892d9-167">855</span></span>|<span data-ttu-id="892d9-168">IBM855</span><span class="sxs-lookup"><span data-stu-id="892d9-168">IBM855</span></span>|<span data-ttu-id="892d9-169">OEM 키릴 자모</span><span class="sxs-lookup"><span data-stu-id="892d9-169">OEM Cyrillic</span></span>|||  
|<span data-ttu-id="892d9-170">857</span><span class="sxs-lookup"><span data-stu-id="892d9-170">857</span></span>|<span data-ttu-id="892d9-171">ibm857</span><span class="sxs-lookup"><span data-stu-id="892d9-171">ibm857</span></span>|<span data-ttu-id="892d9-172">터키어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-172">Turkish (DOS)</span></span>|||  
|<span data-ttu-id="892d9-173">858</span><span class="sxs-lookup"><span data-stu-id="892d9-173">858</span></span>|<span data-ttu-id="892d9-174">IBM00858</span><span class="sxs-lookup"><span data-stu-id="892d9-174">IBM00858</span></span>|<span data-ttu-id="892d9-175">OEM 다국 라틴 문자 I</span><span class="sxs-lookup"><span data-stu-id="892d9-175">OEM Multilingual Latin I</span></span>|||  
|<span data-ttu-id="892d9-176">860</span><span class="sxs-lookup"><span data-stu-id="892d9-176">860</span></span>|<span data-ttu-id="892d9-177">IBM860</span><span class="sxs-lookup"><span data-stu-id="892d9-177">IBM860</span></span>|<span data-ttu-id="892d9-178">포르투갈어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-178">Portuguese (DOS)</span></span>|||  
|<span data-ttu-id="892d9-179">861</span><span class="sxs-lookup"><span data-stu-id="892d9-179">861</span></span>|<span data-ttu-id="892d9-180">ibm861</span><span class="sxs-lookup"><span data-stu-id="892d9-180">ibm861</span></span>|<span data-ttu-id="892d9-181">아이슬란드어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-181">Icelandic (DOS)</span></span>|||  
|<span data-ttu-id="892d9-182">862</span><span class="sxs-lookup"><span data-stu-id="892d9-182">862</span></span>|<span data-ttu-id="892d9-183">DOS-862</span><span class="sxs-lookup"><span data-stu-id="892d9-183">DOS-862</span></span>|<span data-ttu-id="892d9-184">히브리어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-184">Hebrew (DOS)</span></span>|||  
|<span data-ttu-id="892d9-185">863</span><span class="sxs-lookup"><span data-stu-id="892d9-185">863</span></span>|<span data-ttu-id="892d9-186">IBM863</span><span class="sxs-lookup"><span data-stu-id="892d9-186">IBM863</span></span>|<span data-ttu-id="892d9-187">프랑스어 (캐나다) (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-187">French Canadian (DOS)</span></span>|||  
|<span data-ttu-id="892d9-188">864</span><span class="sxs-lookup"><span data-stu-id="892d9-188">864</span></span>|<span data-ttu-id="892d9-189">IBM864</span><span class="sxs-lookup"><span data-stu-id="892d9-189">IBM864</span></span>|<span data-ttu-id="892d9-190">아랍어 (864)</span><span class="sxs-lookup"><span data-stu-id="892d9-190">Arabic (864)</span></span>|||  
|<span data-ttu-id="892d9-191">865</span><span class="sxs-lookup"><span data-stu-id="892d9-191">865</span></span>|<span data-ttu-id="892d9-192">IBM865</span><span class="sxs-lookup"><span data-stu-id="892d9-192">IBM865</span></span>|<span data-ttu-id="892d9-193">북유럽어 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-193">Nordic (DOS)</span></span>|||  
|<span data-ttu-id="892d9-194">866</span><span class="sxs-lookup"><span data-stu-id="892d9-194">866</span></span>|<span data-ttu-id="892d9-195">cp866</span><span class="sxs-lookup"><span data-stu-id="892d9-195">cp866</span></span>|<span data-ttu-id="892d9-196">키릴 자모 (DOS)</span><span class="sxs-lookup"><span data-stu-id="892d9-196">Cyrillic (DOS)</span></span>|||  
|<span data-ttu-id="892d9-197">869</span><span class="sxs-lookup"><span data-stu-id="892d9-197">869</span></span>|<span data-ttu-id="892d9-198">ibm869</span><span class="sxs-lookup"><span data-stu-id="892d9-198">ibm869</span></span>|<span data-ttu-id="892d9-199">(DOS) 현대 그리스어</span><span class="sxs-lookup"><span data-stu-id="892d9-199">Greek, Modern (DOS)</span></span>|||  
|<span data-ttu-id="892d9-200">870</span><span class="sxs-lookup"><span data-stu-id="892d9-200">870</span></span>|<span data-ttu-id="892d9-201">IBM870</span><span class="sxs-lookup"><span data-stu-id="892d9-201">IBM870</span></span>|<span data-ttu-id="892d9-202">IBM EBCDIC (다국어 라틴어-2)</span><span class="sxs-lookup"><span data-stu-id="892d9-202">IBM EBCDIC (Multilingual Latin-2)</span></span>|||  
|<span data-ttu-id="892d9-203">874</span><span class="sxs-lookup"><span data-stu-id="892d9-203">874</span></span>|<span data-ttu-id="892d9-204">windows-874</span><span class="sxs-lookup"><span data-stu-id="892d9-204">windows-874</span></span>|<span data-ttu-id="892d9-205">태국어 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-205">Thai (Windows)</span></span>|||  
|<span data-ttu-id="892d9-206">875</span><span class="sxs-lookup"><span data-stu-id="892d9-206">875</span></span>|<span data-ttu-id="892d9-207">cp875</span><span class="sxs-lookup"><span data-stu-id="892d9-207">cp875</span></span>|<span data-ttu-id="892d9-208">IBM EBCDIC (현대 그리스어)</span><span class="sxs-lookup"><span data-stu-id="892d9-208">IBM EBCDIC (Greek Modern)</span></span>|||  
|<span data-ttu-id="892d9-209">932</span><span class="sxs-lookup"><span data-stu-id="892d9-209">932</span></span>|<span data-ttu-id="892d9-210">shift_jis</span><span class="sxs-lookup"><span data-stu-id="892d9-210">shift_jis</span></span>|<span data-ttu-id="892d9-211">일본어 (SHIFT-JIS)</span><span class="sxs-lookup"><span data-stu-id="892d9-211">Japanese (Shift-JIS)</span></span>|||  
|<span data-ttu-id="892d9-212">936</span><span class="sxs-lookup"><span data-stu-id="892d9-212">936</span></span>|<span data-ttu-id="892d9-213">gb2312</span><span class="sxs-lookup"><span data-stu-id="892d9-213">gb2312</span></span>|<span data-ttu-id="892d9-214">중국어 간체 (GB2312)</span><span class="sxs-lookup"><span data-stu-id="892d9-214">Chinese Simplified (GB2312)</span></span>|<span data-ttu-id="892d9-215">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-215">✓</span></span>||  
|<span data-ttu-id="892d9-216">949</span><span class="sxs-lookup"><span data-stu-id="892d9-216">949</span></span>|<span data-ttu-id="892d9-217">ks_c_5601-1987</span><span class="sxs-lookup"><span data-stu-id="892d9-217">ks_c_5601-1987</span></span>|<span data-ttu-id="892d9-218">한국어</span><span class="sxs-lookup"><span data-stu-id="892d9-218">Korean</span></span>|||  
|<span data-ttu-id="892d9-219">950</span><span class="sxs-lookup"><span data-stu-id="892d9-219">950</span></span>|<span data-ttu-id="892d9-220">big5</span><span class="sxs-lookup"><span data-stu-id="892d9-220">big5</span></span>|<span data-ttu-id="892d9-221">중국어 번체 (Big5)</span><span class="sxs-lookup"><span data-stu-id="892d9-221">Chinese Traditional (Big5)</span></span>|||  
|<span data-ttu-id="892d9-222">1026</span><span class="sxs-lookup"><span data-stu-id="892d9-222">1026</span></span>|<span data-ttu-id="892d9-223">IBM1026</span><span class="sxs-lookup"><span data-stu-id="892d9-223">IBM1026</span></span>|<span data-ttu-id="892d9-224">IBM EBCDIC (터키어 라틴어-5)</span><span class="sxs-lookup"><span data-stu-id="892d9-224">IBM EBCDIC (Turkish Latin-5)</span></span>|||  
|<span data-ttu-id="892d9-225">1047</span><span class="sxs-lookup"><span data-stu-id="892d9-225">1047</span></span>|<span data-ttu-id="892d9-226">IBM01047</span><span class="sxs-lookup"><span data-stu-id="892d9-226">IBM01047</span></span>|<span data-ttu-id="892d9-227">IBM Latin 1</span><span class="sxs-lookup"><span data-stu-id="892d9-227">IBM Latin-1</span></span>|||  
|<span data-ttu-id="892d9-228">1140</span><span class="sxs-lookup"><span data-stu-id="892d9-228">1140</span></span>|<span data-ttu-id="892d9-229">IBM01140</span><span class="sxs-lookup"><span data-stu-id="892d9-229">IBM01140</span></span>|<span data-ttu-id="892d9-230">IBM EBCDIC (미국-캐나다-유럽)</span><span class="sxs-lookup"><span data-stu-id="892d9-230">IBM EBCDIC (US-Canada-Euro)</span></span>|||  
|<span data-ttu-id="892d9-231">1141</span><span class="sxs-lookup"><span data-stu-id="892d9-231">1141</span></span>|<span data-ttu-id="892d9-232">IBM01141</span><span class="sxs-lookup"><span data-stu-id="892d9-232">IBM01141</span></span>|<span data-ttu-id="892d9-233">IBM EBCDIC (독일-Euro)</span><span class="sxs-lookup"><span data-stu-id="892d9-233">IBM EBCDIC (Germany-Euro)</span></span>|||  
|<span data-ttu-id="892d9-234">1142</span><span class="sxs-lookup"><span data-stu-id="892d9-234">1142</span></span>|<span data-ttu-id="892d9-235">IBM01142</span><span class="sxs-lookup"><span data-stu-id="892d9-235">IBM01142</span></span>|<span data-ttu-id="892d9-236">IBM EBCDIC (덴마크-노르웨이-유럽)</span><span class="sxs-lookup"><span data-stu-id="892d9-236">IBM EBCDIC (Denmark-Norway-Euro)</span></span>|||  
|<span data-ttu-id="892d9-237">1143</span><span class="sxs-lookup"><span data-stu-id="892d9-237">1143</span></span>|<span data-ttu-id="892d9-238">IBM01143</span><span class="sxs-lookup"><span data-stu-id="892d9-238">IBM01143</span></span>|<span data-ttu-id="892d9-239">IBM EBCDIC (핀란드-스웨덴-유럽)</span><span class="sxs-lookup"><span data-stu-id="892d9-239">IBM EBCDIC (Finland-Sweden-Euro)</span></span>|||  
|<span data-ttu-id="892d9-240">1144</span><span class="sxs-lookup"><span data-stu-id="892d9-240">1144</span></span>|<span data-ttu-id="892d9-241">IBM01144</span><span class="sxs-lookup"><span data-stu-id="892d9-241">IBM01144</span></span>|<span data-ttu-id="892d9-242">IBM EBCDIC (이탈리아-유럽)</span><span class="sxs-lookup"><span data-stu-id="892d9-242">IBM EBCDIC (Italy-Euro)</span></span>|||  
|<span data-ttu-id="892d9-243">1145</span><span class="sxs-lookup"><span data-stu-id="892d9-243">1145</span></span>|<span data-ttu-id="892d9-244">IBM01145</span><span class="sxs-lookup"><span data-stu-id="892d9-244">IBM01145</span></span>|<span data-ttu-id="892d9-245">IBM EBCDIC (스페인-Euro)</span><span class="sxs-lookup"><span data-stu-id="892d9-245">IBM EBCDIC (Spain-Euro)</span></span>|||  
|<span data-ttu-id="892d9-246">1146</span><span class="sxs-lookup"><span data-stu-id="892d9-246">1146</span></span>|<span data-ttu-id="892d9-247">IBM01146</span><span class="sxs-lookup"><span data-stu-id="892d9-247">IBM01146</span></span>|<span data-ttu-id="892d9-248">IBM EBCDIC (영국-유럽)</span><span class="sxs-lookup"><span data-stu-id="892d9-248">IBM EBCDIC (UK-Euro)</span></span>|||  
|<span data-ttu-id="892d9-249">1147</span><span class="sxs-lookup"><span data-stu-id="892d9-249">1147</span></span>|<span data-ttu-id="892d9-250">IBM01147</span><span class="sxs-lookup"><span data-stu-id="892d9-250">IBM01147</span></span>|<span data-ttu-id="892d9-251">IBM EBCDIC (프랑스-Euro)</span><span class="sxs-lookup"><span data-stu-id="892d9-251">IBM EBCDIC (France-Euro)</span></span>|||  
|<span data-ttu-id="892d9-252">1148</span><span class="sxs-lookup"><span data-stu-id="892d9-252">1148</span></span>|<span data-ttu-id="892d9-253">IBM01148</span><span class="sxs-lookup"><span data-stu-id="892d9-253">IBM01148</span></span>|<span data-ttu-id="892d9-254">IBM EBCDIC (국제-유럽)</span><span class="sxs-lookup"><span data-stu-id="892d9-254">IBM EBCDIC (International-Euro)</span></span>|||  
|<span data-ttu-id="892d9-255">1149</span><span class="sxs-lookup"><span data-stu-id="892d9-255">1149</span></span>|<span data-ttu-id="892d9-256">IBM01149</span><span class="sxs-lookup"><span data-stu-id="892d9-256">IBM01149</span></span>|<span data-ttu-id="892d9-257">IBM EBCDIC (아이슬란드어-Euro)</span><span class="sxs-lookup"><span data-stu-id="892d9-257">IBM EBCDIC (Icelandic-Euro)</span></span>|||  
|<span data-ttu-id="892d9-258">1200</span><span class="sxs-lookup"><span data-stu-id="892d9-258">1200</span></span>|<span data-ttu-id="892d9-259">utf-16</span><span class="sxs-lookup"><span data-stu-id="892d9-259">utf-16</span></span>|<span data-ttu-id="892d9-260">유니코드(Unicode)</span><span class="sxs-lookup"><span data-stu-id="892d9-260">Unicode</span></span>|<span data-ttu-id="892d9-261">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-261">✓</span></span>|<span data-ttu-id="892d9-262">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-262">✓</span></span>|  
|<span data-ttu-id="892d9-263">1201</span><span class="sxs-lookup"><span data-stu-id="892d9-263">1201</span></span>|<span data-ttu-id="892d9-264">unicodeFFFE</span><span class="sxs-lookup"><span data-stu-id="892d9-264">unicodeFFFE</span></span>|<span data-ttu-id="892d9-265">Unicode (Big endian)</span><span class="sxs-lookup"><span data-stu-id="892d9-265">Unicode (Big endian)</span></span>|<span data-ttu-id="892d9-266">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-266">✓</span></span>|<span data-ttu-id="892d9-267">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-267">✓</span></span>|  
|<span data-ttu-id="892d9-268">1250</span><span class="sxs-lookup"><span data-stu-id="892d9-268">1250</span></span>|<span data-ttu-id="892d9-269">windows-1250</span><span class="sxs-lookup"><span data-stu-id="892d9-269">windows-1250</span></span>|<span data-ttu-id="892d9-270">중앙 유럽어 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-270">Central European (Windows)</span></span>|||  
|<span data-ttu-id="892d9-271">1251</span><span class="sxs-lookup"><span data-stu-id="892d9-271">1251</span></span>|<span data-ttu-id="892d9-272">windows-1251</span><span class="sxs-lookup"><span data-stu-id="892d9-272">windows-1251</span></span>|<span data-ttu-id="892d9-273">키릴 자모 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-273">Cyrillic (Windows)</span></span>|||  
|<span data-ttu-id="892d9-274">1252</span><span class="sxs-lookup"><span data-stu-id="892d9-274">1252</span></span>|<span data-ttu-id="892d9-275">Windows-1252</span><span class="sxs-lookup"><span data-stu-id="892d9-275">Windows-1252</span></span>|<span data-ttu-id="892d9-276">서유럽어 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-276">Western European (Windows)</span></span>|<span data-ttu-id="892d9-277">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-277">✓</span></span>||  
|<span data-ttu-id="892d9-278">1253</span><span class="sxs-lookup"><span data-stu-id="892d9-278">1253</span></span>|<span data-ttu-id="892d9-279">windows-1253</span><span class="sxs-lookup"><span data-stu-id="892d9-279">windows-1253</span></span>|<span data-ttu-id="892d9-280">그리스어 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-280">Greek (Windows)</span></span>|||  
|<span data-ttu-id="892d9-281">1254</span><span class="sxs-lookup"><span data-stu-id="892d9-281">1254</span></span>|<span data-ttu-id="892d9-282">windows-1254</span><span class="sxs-lookup"><span data-stu-id="892d9-282">windows-1254</span></span>|<span data-ttu-id="892d9-283">터키어 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-283">Turkish (Windows)</span></span>|||  
|<span data-ttu-id="892d9-284">1255</span><span class="sxs-lookup"><span data-stu-id="892d9-284">1255</span></span>|<span data-ttu-id="892d9-285">windows-1255</span><span class="sxs-lookup"><span data-stu-id="892d9-285">windows-1255</span></span>|<span data-ttu-id="892d9-286">히브리어 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-286">Hebrew (Windows)</span></span>|||  
|<span data-ttu-id="892d9-287">1256</span><span class="sxs-lookup"><span data-stu-id="892d9-287">1256</span></span>|<span data-ttu-id="892d9-288">windows-1256</span><span class="sxs-lookup"><span data-stu-id="892d9-288">windows-1256</span></span>|<span data-ttu-id="892d9-289">아랍어 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-289">Arabic (Windows)</span></span>|||  
|<span data-ttu-id="892d9-290">1257</span><span class="sxs-lookup"><span data-stu-id="892d9-290">1257</span></span>|<span data-ttu-id="892d9-291">windows-1257</span><span class="sxs-lookup"><span data-stu-id="892d9-291">windows-1257</span></span>|<span data-ttu-id="892d9-292">발트어 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-292">Baltic (Windows)</span></span>|||  
|<span data-ttu-id="892d9-293">1258</span><span class="sxs-lookup"><span data-stu-id="892d9-293">1258</span></span>|<span data-ttu-id="892d9-294">windows-1258</span><span class="sxs-lookup"><span data-stu-id="892d9-294">windows-1258</span></span>|<span data-ttu-id="892d9-295">베트남어 (Windows)</span><span class="sxs-lookup"><span data-stu-id="892d9-295">Vietnamese (Windows)</span></span>|||  
|<span data-ttu-id="892d9-296">1361</span><span class="sxs-lookup"><span data-stu-id="892d9-296">1361</span></span>|<span data-ttu-id="892d9-297">조합</span><span class="sxs-lookup"><span data-stu-id="892d9-297">Johab</span></span>|<span data-ttu-id="892d9-298">한국어 (Johab)</span><span class="sxs-lookup"><span data-stu-id="892d9-298">Korean (Johab)</span></span>|||  
|<span data-ttu-id="892d9-299">10000</span><span class="sxs-lookup"><span data-stu-id="892d9-299">10000</span></span>|<span data-ttu-id="892d9-300">macintosh</span><span class="sxs-lookup"><span data-stu-id="892d9-300">macintosh</span></span>|<span data-ttu-id="892d9-301">서유럽어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-301">Western European (Mac)</span></span>|||  
|<span data-ttu-id="892d9-302">10001</span><span class="sxs-lookup"><span data-stu-id="892d9-302">10001</span></span>|<span data-ttu-id="892d9-303">x-mac-일본어</span><span class="sxs-lookup"><span data-stu-id="892d9-303">x-mac-japanese</span></span>|<span data-ttu-id="892d9-304">일본어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-304">Japanese (Mac)</span></span>|||  
|<span data-ttu-id="892d9-305">10002</span><span class="sxs-lookup"><span data-stu-id="892d9-305">10002</span></span>|<span data-ttu-id="892d9-306">중국어--번체 mac x</span><span class="sxs-lookup"><span data-stu-id="892d9-306">x-mac-chinesetrad</span></span>|<span data-ttu-id="892d9-307">중국어 번체 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-307">Chinese Traditional (Mac)</span></span>|||  
|<span data-ttu-id="892d9-308">10003</span><span class="sxs-lookup"><span data-stu-id="892d9-308">10003</span></span>|<span data-ttu-id="892d9-309">x-mac-한국어</span><span class="sxs-lookup"><span data-stu-id="892d9-309">x-mac-korean</span></span>|<span data-ttu-id="892d9-310">한국어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-310">Korean (Mac)</span></span>|<span data-ttu-id="892d9-311">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-311">✓</span></span>||  
|<span data-ttu-id="892d9-312">10004</span><span class="sxs-lookup"><span data-stu-id="892d9-312">10004</span></span>|<span data-ttu-id="892d9-313">x-mac-아랍어</span><span class="sxs-lookup"><span data-stu-id="892d9-313">x-mac-arabic</span></span>|<span data-ttu-id="892d9-314">아랍어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-314">Arabic (Mac)</span></span>|||  
|<span data-ttu-id="892d9-315">10005</span><span class="sxs-lookup"><span data-stu-id="892d9-315">10005</span></span>|<span data-ttu-id="892d9-316">x-mac-히브리어</span><span class="sxs-lookup"><span data-stu-id="892d9-316">x-mac-hebrew</span></span>|<span data-ttu-id="892d9-317">히브리어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-317">Hebrew (Mac)</span></span>|||  
|<span data-ttu-id="892d9-318">10006</span><span class="sxs-lookup"><span data-stu-id="892d9-318">10006</span></span>|<span data-ttu-id="892d9-319">x-mac-그리스어</span><span class="sxs-lookup"><span data-stu-id="892d9-319">x-mac-greek</span></span>|<span data-ttu-id="892d9-320">그리스어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-320">Greek (Mac)</span></span>|||  
|<span data-ttu-id="892d9-321">10007</span><span class="sxs-lookup"><span data-stu-id="892d9-321">10007</span></span>|<span data-ttu-id="892d9-322">x-mac-cyrillic</span><span class="sxs-lookup"><span data-stu-id="892d9-322">x-mac-cyrillic</span></span>|<span data-ttu-id="892d9-323">키릴 자모 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-323">Cyrillic (Mac)</span></span>|||  
|<span data-ttu-id="892d9-324">10008</span><span class="sxs-lookup"><span data-stu-id="892d9-324">10008</span></span>|<span data-ttu-id="892d9-325">x-mac-chinesesimp</span><span class="sxs-lookup"><span data-stu-id="892d9-325">x-mac-chinesesimp</span></span>|<span data-ttu-id="892d9-326">중국어 간체 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-326">Chinese Simplified (Mac)</span></span>|<span data-ttu-id="892d9-327">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-327">✓</span></span>||  
|<span data-ttu-id="892d9-328">10010</span><span class="sxs-lookup"><span data-stu-id="892d9-328">10010</span></span>|<span data-ttu-id="892d9-329">x-mac-루마니아어</span><span class="sxs-lookup"><span data-stu-id="892d9-329">x-mac-romanian</span></span>|<span data-ttu-id="892d9-330">루마니아어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-330">Romanian (Mac)</span></span>|||  
|<span data-ttu-id="892d9-331">10017</span><span class="sxs-lookup"><span data-stu-id="892d9-331">10017</span></span>|<span data-ttu-id="892d9-332">ukrainian-x-mac</span><span class="sxs-lookup"><span data-stu-id="892d9-332">x-mac-ukrainian</span></span>|<span data-ttu-id="892d9-333">우크라이나어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-333">Ukrainian (Mac)</span></span>|||  
|<span data-ttu-id="892d9-334">10021</span><span class="sxs-lookup"><span data-stu-id="892d9-334">10021</span></span>|<span data-ttu-id="892d9-335">x-mac-태국어</span><span class="sxs-lookup"><span data-stu-id="892d9-335">x-mac-thai</span></span>|<span data-ttu-id="892d9-336">태국어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-336">Thai (Mac)</span></span>|||  
|<span data-ttu-id="892d9-337">10029</span><span class="sxs-lookup"><span data-stu-id="892d9-337">10029</span></span>|<span data-ttu-id="892d9-338">x-mac-ce</span><span class="sxs-lookup"><span data-stu-id="892d9-338">x-mac-ce</span></span>|<span data-ttu-id="892d9-339">중앙 유럽어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-339">Central European (Mac)</span></span>|||  
|<span data-ttu-id="892d9-340">10079</span><span class="sxs-lookup"><span data-stu-id="892d9-340">10079</span></span>|<span data-ttu-id="892d9-341">icelandic-x-mac</span><span class="sxs-lookup"><span data-stu-id="892d9-341">x-mac-icelandic</span></span>|<span data-ttu-id="892d9-342">아이슬란드어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-342">Icelandic (Mac)</span></span>|||  
|<span data-ttu-id="892d9-343">10081</span><span class="sxs-lookup"><span data-stu-id="892d9-343">10081</span></span>|<span data-ttu-id="892d9-344">x-mac-터키어</span><span class="sxs-lookup"><span data-stu-id="892d9-344">x-mac-turkish</span></span>|<span data-ttu-id="892d9-345">터키어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-345">Turkish (Mac)</span></span>|||  
|<span data-ttu-id="892d9-346">10082</span><span class="sxs-lookup"><span data-stu-id="892d9-346">10082</span></span>|<span data-ttu-id="892d9-347">croatian-x-mac</span><span class="sxs-lookup"><span data-stu-id="892d9-347">x-mac-croatian</span></span>|<span data-ttu-id="892d9-348">크로아티아어 (Mac)</span><span class="sxs-lookup"><span data-stu-id="892d9-348">Croatian (Mac)</span></span>|||  
|<span data-ttu-id="892d9-349">12000</span><span class="sxs-lookup"><span data-stu-id="892d9-349">12000</span></span>|<span data-ttu-id="892d9-350">utf-32</span><span class="sxs-lookup"><span data-stu-id="892d9-350">utf-32</span></span>|<span data-ttu-id="892d9-351">유니코드 (UTF-32)</span><span class="sxs-lookup"><span data-stu-id="892d9-351">Unicode (UTF-32)</span></span>|<span data-ttu-id="892d9-352">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-352">✓</span></span>|<span data-ttu-id="892d9-353">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-353">✓</span></span>|  
|<span data-ttu-id="892d9-354">12001</span><span class="sxs-lookup"><span data-stu-id="892d9-354">12001</span></span>|<span data-ttu-id="892d9-355">utf-32BE</span><span class="sxs-lookup"><span data-stu-id="892d9-355">utf-32BE</span></span>|<span data-ttu-id="892d9-356">유니코드 (UTF-32 Big endian)</span><span class="sxs-lookup"><span data-stu-id="892d9-356">Unicode (UTF-32 Big endian)</span></span>|<span data-ttu-id="892d9-357">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-357">✓</span></span>|<span data-ttu-id="892d9-358">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-358">✓</span></span>|  
|<span data-ttu-id="892d9-359">20000</span><span class="sxs-lookup"><span data-stu-id="892d9-359">20000</span></span>|<span data-ttu-id="892d9-360">x-중국어-CN</span><span class="sxs-lookup"><span data-stu-id="892d9-360">x-Chinese-CNS</span></span>|<span data-ttu-id="892d9-361">중국어 번체 (CNS)</span><span class="sxs-lookup"><span data-stu-id="892d9-361">Chinese Traditional (CNS)</span></span>|||  
|<span data-ttu-id="892d9-362">20001</span><span class="sxs-lookup"><span data-stu-id="892d9-362">20001</span></span>|<span data-ttu-id="892d9-363">x-cp20001</span><span class="sxs-lookup"><span data-stu-id="892d9-363">x-cp20001</span></span>|<span data-ttu-id="892d9-364">Tca</span><span class="sxs-lookup"><span data-stu-id="892d9-364">TCA Taiwan</span></span>|||  
|<span data-ttu-id="892d9-365">20002</span><span class="sxs-lookup"><span data-stu-id="892d9-365">20002</span></span>|<span data-ttu-id="892d9-366">x-중국어-Eten</span><span class="sxs-lookup"><span data-stu-id="892d9-366">x-Chinese-Eten</span></span>|<span data-ttu-id="892d9-367">중국어 번체 (Eten)</span><span class="sxs-lookup"><span data-stu-id="892d9-367">Chinese Traditional (Eten)</span></span>|||  
|<span data-ttu-id="892d9-368">20003</span><span class="sxs-lookup"><span data-stu-id="892d9-368">20003</span></span>|<span data-ttu-id="892d9-369">x-cp20003</span><span class="sxs-lookup"><span data-stu-id="892d9-369">x-cp20003</span></span>|<span data-ttu-id="892d9-370">Ibm5550</span><span class="sxs-lookup"><span data-stu-id="892d9-370">IBM5550 Taiwan</span></span>|||  
|<span data-ttu-id="892d9-371">20004</span><span class="sxs-lookup"><span data-stu-id="892d9-371">20004</span></span>|<span data-ttu-id="892d9-372">x-cp20004</span><span class="sxs-lookup"><span data-stu-id="892d9-372">x-cp20004</span></span>|<span data-ttu-id="892d9-373">Teletext</span><span class="sxs-lookup"><span data-stu-id="892d9-373">TeleText Taiwan</span></span>|||  
|<span data-ttu-id="892d9-374">20005</span><span class="sxs-lookup"><span data-stu-id="892d9-374">20005</span></span>|<span data-ttu-id="892d9-375">x-cp20005</span><span class="sxs-lookup"><span data-stu-id="892d9-375">x-cp20005</span></span>|<span data-ttu-id="892d9-376">Wang 대만</span><span class="sxs-lookup"><span data-stu-id="892d9-376">Wang Taiwan</span></span>|||  
|<span data-ttu-id="892d9-377">20105</span><span class="sxs-lookup"><span data-stu-id="892d9-377">20105</span></span>|<span data-ttu-id="892d9-378">x-IA5</span><span class="sxs-lookup"><span data-stu-id="892d9-378">x-IA5</span></span>|<span data-ttu-id="892d9-379">서유럽어 (IA5)</span><span class="sxs-lookup"><span data-stu-id="892d9-379">Western European (IA5)</span></span>|||  
|<span data-ttu-id="892d9-380">20106</span><span class="sxs-lookup"><span data-stu-id="892d9-380">20106</span></span>|<span data-ttu-id="892d9-381">x-IA5-독일어</span><span class="sxs-lookup"><span data-stu-id="892d9-381">x-IA5-German</span></span>|<span data-ttu-id="892d9-382">독일어 (IA5)</span><span class="sxs-lookup"><span data-stu-id="892d9-382">German (IA5)</span></span>|||  
|<span data-ttu-id="892d9-383">20107</span><span class="sxs-lookup"><span data-stu-id="892d9-383">20107</span></span>|<span data-ttu-id="892d9-384">x-IA5-Swedish</span><span class="sxs-lookup"><span data-stu-id="892d9-384">x-IA5-Swedish</span></span>|<span data-ttu-id="892d9-385">스웨덴어 (IA5)</span><span class="sxs-lookup"><span data-stu-id="892d9-385">Swedish (IA5)</span></span>|||  
|<span data-ttu-id="892d9-386">20108</span><span class="sxs-lookup"><span data-stu-id="892d9-386">20108</span></span>|<span data-ttu-id="892d9-387">--노르웨이어 IA5 x</span><span class="sxs-lookup"><span data-stu-id="892d9-387">x-IA5-Norwegian</span></span>|<span data-ttu-id="892d9-388">노르웨이어 (IA5)</span><span class="sxs-lookup"><span data-stu-id="892d9-388">Norwegian (IA5)</span></span>|||  
|<span data-ttu-id="892d9-389">20127</span><span class="sxs-lookup"><span data-stu-id="892d9-389">20127</span></span>|<span data-ttu-id="892d9-390">us-ascii</span><span class="sxs-lookup"><span data-stu-id="892d9-390">us-ascii</span></span>|<span data-ttu-id="892d9-391">US-ASCII</span><span class="sxs-lookup"><span data-stu-id="892d9-391">US-ASCII</span></span>|<span data-ttu-id="892d9-392">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-392">✓</span></span>|<span data-ttu-id="892d9-393">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-393">✓</span></span>|  
|<span data-ttu-id="892d9-394">20261</span><span class="sxs-lookup"><span data-stu-id="892d9-394">20261</span></span>|<span data-ttu-id="892d9-395">x-cp20261</span><span class="sxs-lookup"><span data-stu-id="892d9-395">x-cp20261</span></span>|<span data-ttu-id="892d9-396">T.61</span><span class="sxs-lookup"><span data-stu-id="892d9-396">T.61</span></span>|||  
|<span data-ttu-id="892d9-397">20269</span><span class="sxs-lookup"><span data-stu-id="892d9-397">20269</span></span>|<span data-ttu-id="892d9-398">x-cp20269</span><span class="sxs-lookup"><span data-stu-id="892d9-398">x-cp20269</span></span>|<span data-ttu-id="892d9-399">ISO-6937</span><span class="sxs-lookup"><span data-stu-id="892d9-399">ISO-6937</span></span>|||  
|<span data-ttu-id="892d9-400">20273</span><span class="sxs-lookup"><span data-stu-id="892d9-400">20273</span></span>|<span data-ttu-id="892d9-401">IBM273</span><span class="sxs-lookup"><span data-stu-id="892d9-401">IBM273</span></span>|<span data-ttu-id="892d9-402">IBM EBCDIC (독일)</span><span class="sxs-lookup"><span data-stu-id="892d9-402">IBM EBCDIC (Germany)</span></span>|||  
|<span data-ttu-id="892d9-403">20277</span><span class="sxs-lookup"><span data-stu-id="892d9-403">20277</span></span>|<span data-ttu-id="892d9-404">IBM277</span><span class="sxs-lookup"><span data-stu-id="892d9-404">IBM277</span></span>|<span data-ttu-id="892d9-405">IBM EBCDIC (덴마크-노르웨이)</span><span class="sxs-lookup"><span data-stu-id="892d9-405">IBM EBCDIC (Denmark-Norway)</span></span>|||  
|<span data-ttu-id="892d9-406">20278</span><span class="sxs-lookup"><span data-stu-id="892d9-406">20278</span></span>|<span data-ttu-id="892d9-407">IBM278</span><span class="sxs-lookup"><span data-stu-id="892d9-407">IBM278</span></span>|<span data-ttu-id="892d9-408">IBM EBCDIC (핀란드-스웨덴)</span><span class="sxs-lookup"><span data-stu-id="892d9-408">IBM EBCDIC (Finland-Sweden)</span></span>|||  
|<span data-ttu-id="892d9-409">20280</span><span class="sxs-lookup"><span data-stu-id="892d9-409">20280</span></span>|<span data-ttu-id="892d9-410">IBM280</span><span class="sxs-lookup"><span data-stu-id="892d9-410">IBM280</span></span>|<span data-ttu-id="892d9-411">IBM EBCDIC (이탈리아)</span><span class="sxs-lookup"><span data-stu-id="892d9-411">IBM EBCDIC (Italy)</span></span>|||  
|<span data-ttu-id="892d9-412">20284</span><span class="sxs-lookup"><span data-stu-id="892d9-412">20284</span></span>|<span data-ttu-id="892d9-413">IBM284</span><span class="sxs-lookup"><span data-stu-id="892d9-413">IBM284</span></span>|<span data-ttu-id="892d9-414">IBM EBCDIC (스페인)</span><span class="sxs-lookup"><span data-stu-id="892d9-414">IBM EBCDIC (Spain)</span></span>|||  
|<span data-ttu-id="892d9-415">20285</span><span class="sxs-lookup"><span data-stu-id="892d9-415">20285</span></span>|<span data-ttu-id="892d9-416">IBM285</span><span class="sxs-lookup"><span data-stu-id="892d9-416">IBM285</span></span>|<span data-ttu-id="892d9-417">IBM EBCDIC (영국)</span><span class="sxs-lookup"><span data-stu-id="892d9-417">IBM EBCDIC (UK)</span></span>|||  
|<span data-ttu-id="892d9-418">20290</span><span class="sxs-lookup"><span data-stu-id="892d9-418">20290</span></span>|<span data-ttu-id="892d9-419">IBM290</span><span class="sxs-lookup"><span data-stu-id="892d9-419">IBM290</span></span>|<span data-ttu-id="892d9-420">IBM EBCDIC (일본어 가타카나)</span><span class="sxs-lookup"><span data-stu-id="892d9-420">IBM EBCDIC (Japanese katakana)</span></span>|||  
|<span data-ttu-id="892d9-421">20297</span><span class="sxs-lookup"><span data-stu-id="892d9-421">20297</span></span>|<span data-ttu-id="892d9-422">IBM297</span><span class="sxs-lookup"><span data-stu-id="892d9-422">IBM297</span></span>|<span data-ttu-id="892d9-423">IBM EBCDIC (프랑스)</span><span class="sxs-lookup"><span data-stu-id="892d9-423">IBM EBCDIC (France)</span></span>|||  
|<span data-ttu-id="892d9-424">20420</span><span class="sxs-lookup"><span data-stu-id="892d9-424">20420</span></span>|<span data-ttu-id="892d9-425">IBM420</span><span class="sxs-lookup"><span data-stu-id="892d9-425">IBM420</span></span>|<span data-ttu-id="892d9-426">IBM EBCDIC (아랍어)</span><span class="sxs-lookup"><span data-stu-id="892d9-426">IBM EBCDIC (Arabic)</span></span>|||  
|<span data-ttu-id="892d9-427">20423</span><span class="sxs-lookup"><span data-stu-id="892d9-427">20423</span></span>|<span data-ttu-id="892d9-428">IBM423</span><span class="sxs-lookup"><span data-stu-id="892d9-428">IBM423</span></span>|<span data-ttu-id="892d9-429">IBM EBCDIC (그리스어)</span><span class="sxs-lookup"><span data-stu-id="892d9-429">IBM EBCDIC (Greek)</span></span>|||  
|<span data-ttu-id="892d9-430">20424</span><span class="sxs-lookup"><span data-stu-id="892d9-430">20424</span></span>|<span data-ttu-id="892d9-431">IBM424</span><span class="sxs-lookup"><span data-stu-id="892d9-431">IBM424</span></span>|<span data-ttu-id="892d9-432">IBM EBCDIC (히브리어)</span><span class="sxs-lookup"><span data-stu-id="892d9-432">IBM EBCDIC (Hebrew)</span></span>|||  
|<span data-ttu-id="892d9-433">20833</span><span class="sxs-lookup"><span data-stu-id="892d9-433">20833</span></span>|<span data-ttu-id="892d9-434">x-EBCDIC-KoreanExtended</span><span class="sxs-lookup"><span data-stu-id="892d9-434">x-EBCDIC-KoreanExtended</span></span>|<span data-ttu-id="892d9-435">IBM EBCDIC (한국어 확장)</span><span class="sxs-lookup"><span data-stu-id="892d9-435">IBM EBCDIC (Korean Extended)</span></span>|||  
|<span data-ttu-id="892d9-436">20838</span><span class="sxs-lookup"><span data-stu-id="892d9-436">20838</span></span>|<span data-ttu-id="892d9-437">IBM-태국어</span><span class="sxs-lookup"><span data-stu-id="892d9-437">IBM-Thai</span></span>|<span data-ttu-id="892d9-438">IBM EBCDIC (태국어)</span><span class="sxs-lookup"><span data-stu-id="892d9-438">IBM EBCDIC (Thai)</span></span>|||  
|<span data-ttu-id="892d9-439">20866</span><span class="sxs-lookup"><span data-stu-id="892d9-439">20866</span></span>|<span data-ttu-id="892d9-440">koi8-r</span><span class="sxs-lookup"><span data-stu-id="892d9-440">koi8-r</span></span>|<span data-ttu-id="892d9-441">키릴 자모 (KOI8-R)</span><span class="sxs-lookup"><span data-stu-id="892d9-441">Cyrillic (KOI8-R)</span></span>|||  
|<span data-ttu-id="892d9-442">20871</span><span class="sxs-lookup"><span data-stu-id="892d9-442">20871</span></span>|<span data-ttu-id="892d9-443">IBM871</span><span class="sxs-lookup"><span data-stu-id="892d9-443">IBM871</span></span>|<span data-ttu-id="892d9-444">IBM EBCDIC (아이슬란드어)</span><span class="sxs-lookup"><span data-stu-id="892d9-444">IBM EBCDIC (Icelandic)</span></span>|||  
|<span data-ttu-id="892d9-445">20880</span><span class="sxs-lookup"><span data-stu-id="892d9-445">20880</span></span>|<span data-ttu-id="892d9-446">IBM880</span><span class="sxs-lookup"><span data-stu-id="892d9-446">IBM880</span></span>|<span data-ttu-id="892d9-447">IBM EBCDIC (키릴 자모 러시아어)</span><span class="sxs-lookup"><span data-stu-id="892d9-447">IBM EBCDIC (Cyrillic Russian)</span></span>|||  
|<span data-ttu-id="892d9-448">20905</span><span class="sxs-lookup"><span data-stu-id="892d9-448">20905</span></span>|<span data-ttu-id="892d9-449">IBM905</span><span class="sxs-lookup"><span data-stu-id="892d9-449">IBM905</span></span>|<span data-ttu-id="892d9-450">IBM EBCDIC (터키어)</span><span class="sxs-lookup"><span data-stu-id="892d9-450">IBM EBCDIC (Turkish)</span></span>|||  
|<span data-ttu-id="892d9-451">20924</span><span class="sxs-lookup"><span data-stu-id="892d9-451">20924</span></span>|<span data-ttu-id="892d9-452">IBM00924</span><span class="sxs-lookup"><span data-stu-id="892d9-452">IBM00924</span></span>|<span data-ttu-id="892d9-453">IBM Latin 1</span><span class="sxs-lookup"><span data-stu-id="892d9-453">IBM Latin-1</span></span>|||  
|<span data-ttu-id="892d9-454">20932</span><span class="sxs-lookup"><span data-stu-id="892d9-454">20932</span></span>|<span data-ttu-id="892d9-455">EUC-JP</span><span class="sxs-lookup"><span data-stu-id="892d9-455">EUC-JP</span></span>|<span data-ttu-id="892d9-456">일본어 (JIS 0208 1990 및 0212 1990)</span><span class="sxs-lookup"><span data-stu-id="892d9-456">Japanese (JIS 0208-1990 and 0212-1990)</span></span>|||  
|<span data-ttu-id="892d9-457">20936</span><span class="sxs-lookup"><span data-stu-id="892d9-457">20936</span></span>|<span data-ttu-id="892d9-458">x-cp20936</span><span class="sxs-lookup"><span data-stu-id="892d9-458">x-cp20936</span></span>|<span data-ttu-id="892d9-459">중국어 간체 (GB2312-80)</span><span class="sxs-lookup"><span data-stu-id="892d9-459">Chinese Simplified (GB2312-80)</span></span>|<span data-ttu-id="892d9-460">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-460">✓</span></span>||  
|<span data-ttu-id="892d9-461">20949</span><span class="sxs-lookup"><span data-stu-id="892d9-461">20949</span></span>|<span data-ttu-id="892d9-462">x-cp20949</span><span class="sxs-lookup"><span data-stu-id="892d9-462">x-cp20949</span></span>|<span data-ttu-id="892d9-463">한국어 (완성)</span><span class="sxs-lookup"><span data-stu-id="892d9-463">Korean Wansung</span></span>|<span data-ttu-id="892d9-464">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-464">✓</span></span>||  
|<span data-ttu-id="892d9-465">21025</span><span class="sxs-lookup"><span data-stu-id="892d9-465">21025</span></span>|<span data-ttu-id="892d9-466">cp1025</span><span class="sxs-lookup"><span data-stu-id="892d9-466">cp1025</span></span>|<span data-ttu-id="892d9-467">IBM EBCDIC (키릴 자모 세르비아어-불가리아어)</span><span class="sxs-lookup"><span data-stu-id="892d9-467">IBM EBCDIC (Cyrillic Serbian-Bulgarian)</span></span>|||  
|<span data-ttu-id="892d9-468">21866</span><span class="sxs-lookup"><span data-stu-id="892d9-468">21866</span></span>|<span data-ttu-id="892d9-469">koi8-u</span><span class="sxs-lookup"><span data-stu-id="892d9-469">koi8-u</span></span>|<span data-ttu-id="892d9-470">키릴 자모 (KOI8-U)</span><span class="sxs-lookup"><span data-stu-id="892d9-470">Cyrillic (KOI8-U)</span></span>|||  
|<span data-ttu-id="892d9-471">28591</span><span class="sxs-lookup"><span data-stu-id="892d9-471">28591</span></span>|<span data-ttu-id="892d9-472">iso-8859-1</span><span class="sxs-lookup"><span data-stu-id="892d9-472">iso-8859-1</span></span>|<span data-ttu-id="892d9-473">서유럽어 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-473">Western European (ISO)</span></span>|<span data-ttu-id="892d9-474">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-474">✓</span></span>|<span data-ttu-id="892d9-475">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-475">✓</span></span>|  
|<span data-ttu-id="892d9-476">28592</span><span class="sxs-lookup"><span data-stu-id="892d9-476">28592</span></span>|<span data-ttu-id="892d9-477">iso-8859-2</span><span class="sxs-lookup"><span data-stu-id="892d9-477">iso-8859-2</span></span>|<span data-ttu-id="892d9-478">중앙 유럽어 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-478">Central European (ISO)</span></span>|||  
|<span data-ttu-id="892d9-479">28593</span><span class="sxs-lookup"><span data-stu-id="892d9-479">28593</span></span>|<span data-ttu-id="892d9-480">iso-8859-3</span><span class="sxs-lookup"><span data-stu-id="892d9-480">iso-8859-3</span></span>|<span data-ttu-id="892d9-481">라틴어 3 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-481">Latin 3 (ISO)</span></span>|||  
|<span data-ttu-id="892d9-482">28594</span><span class="sxs-lookup"><span data-stu-id="892d9-482">28594</span></span>|<span data-ttu-id="892d9-483">iso-8859-4</span><span class="sxs-lookup"><span data-stu-id="892d9-483">iso-8859-4</span></span>|<span data-ttu-id="892d9-484">발트어 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-484">Baltic (ISO)</span></span>|||  
|<span data-ttu-id="892d9-485">28595</span><span class="sxs-lookup"><span data-stu-id="892d9-485">28595</span></span>|<span data-ttu-id="892d9-486">iso-8859-5</span><span class="sxs-lookup"><span data-stu-id="892d9-486">iso-8859-5</span></span>|<span data-ttu-id="892d9-487">키릴 자모 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-487">Cyrillic (ISO)</span></span>|||  
|<span data-ttu-id="892d9-488">28596</span><span class="sxs-lookup"><span data-stu-id="892d9-488">28596</span></span>|<span data-ttu-id="892d9-489">iso-8859-6</span><span class="sxs-lookup"><span data-stu-id="892d9-489">iso-8859-6</span></span>|<span data-ttu-id="892d9-490">아랍어 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-490">Arabic (ISO)</span></span>|||  
|<span data-ttu-id="892d9-491">28597</span><span class="sxs-lookup"><span data-stu-id="892d9-491">28597</span></span>|<span data-ttu-id="892d9-492">iso-8859-7</span><span class="sxs-lookup"><span data-stu-id="892d9-492">iso-8859-7</span></span>|<span data-ttu-id="892d9-493">그리스어 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-493">Greek (ISO)</span></span>|||  
|<span data-ttu-id="892d9-494">28598</span><span class="sxs-lookup"><span data-stu-id="892d9-494">28598</span></span>|<span data-ttu-id="892d9-495">iso-8859-8</span><span class="sxs-lookup"><span data-stu-id="892d9-495">iso-8859-8</span></span>|<span data-ttu-id="892d9-496">히브리어 (Iso-visual)</span><span class="sxs-lookup"><span data-stu-id="892d9-496">Hebrew (ISO-Visual)</span></span>|<span data-ttu-id="892d9-497">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-497">✓</span></span>||  
|<span data-ttu-id="892d9-498">28599</span><span class="sxs-lookup"><span data-stu-id="892d9-498">28599</span></span>|<span data-ttu-id="892d9-499">iso-8859-9</span><span class="sxs-lookup"><span data-stu-id="892d9-499">iso-8859-9</span></span>|<span data-ttu-id="892d9-500">터키어 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-500">Turkish (ISO)</span></span>|||  
|<span data-ttu-id="892d9-501">28603</span><span class="sxs-lookup"><span data-stu-id="892d9-501">28603</span></span>|<span data-ttu-id="892d9-502">iso-8859-13</span><span class="sxs-lookup"><span data-stu-id="892d9-502">iso-8859-13</span></span>|<span data-ttu-id="892d9-503">에스토니아어 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-503">Estonian (ISO)</span></span>|||  
|<span data-ttu-id="892d9-504">28605</span><span class="sxs-lookup"><span data-stu-id="892d9-504">28605</span></span>|<span data-ttu-id="892d9-505">iso-8859-15</span><span class="sxs-lookup"><span data-stu-id="892d9-505">iso-8859-15</span></span>|<span data-ttu-id="892d9-506">라틴어 9 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-506">Latin 9 (ISO)</span></span>|||  
|<span data-ttu-id="892d9-507">29001</span><span class="sxs-lookup"><span data-stu-id="892d9-507">29001</span></span>|<span data-ttu-id="892d9-508">x-유럽어</span><span class="sxs-lookup"><span data-stu-id="892d9-508">x-Europa</span></span>|<span data-ttu-id="892d9-509">유럽어</span><span class="sxs-lookup"><span data-stu-id="892d9-509">Europa</span></span>|||  
|<span data-ttu-id="892d9-510">38598</span><span class="sxs-lookup"><span data-stu-id="892d9-510">38598</span></span>|<span data-ttu-id="892d9-511">iso-8859-8-i</span><span class="sxs-lookup"><span data-stu-id="892d9-511">iso-8859-8-i</span></span>|<span data-ttu-id="892d9-512">히브리어 (Iso-logical)</span><span class="sxs-lookup"><span data-stu-id="892d9-512">Hebrew (ISO-Logical)</span></span>|<span data-ttu-id="892d9-513">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-513">✓</span></span>||  
|<span data-ttu-id="892d9-514">50220</span><span class="sxs-lookup"><span data-stu-id="892d9-514">50220</span></span>|<span data-ttu-id="892d9-515">iso-2022-jp</span><span class="sxs-lookup"><span data-stu-id="892d9-515">iso-2022-jp</span></span>|<span data-ttu-id="892d9-516">일본어 (JIS)</span><span class="sxs-lookup"><span data-stu-id="892d9-516">Japanese (JIS)</span></span>|<span data-ttu-id="892d9-517">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-517">✓</span></span>||  
|<span data-ttu-id="892d9-518">50221</span><span class="sxs-lookup"><span data-stu-id="892d9-518">50221</span></span>|<span data-ttu-id="892d9-519">csISO2022JP</span><span class="sxs-lookup"><span data-stu-id="892d9-519">csISO2022JP</span></span>|<span data-ttu-id="892d9-520">일본어 (JIS-허용 1 바이트 일본어가 나 구분)</span><span class="sxs-lookup"><span data-stu-id="892d9-520">Japanese (JIS-Allow 1 byte Kana)</span></span>|<span data-ttu-id="892d9-521">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-521">✓</span></span>||  
|<span data-ttu-id="892d9-522">50222</span><span class="sxs-lookup"><span data-stu-id="892d9-522">50222</span></span>|<span data-ttu-id="892d9-523">iso-2022-jp</span><span class="sxs-lookup"><span data-stu-id="892d9-523">iso-2022-jp</span></span>|<span data-ttu-id="892d9-524">일본어 (JIS-허용 1 바이트 Kana-따라서 / SI)</span><span class="sxs-lookup"><span data-stu-id="892d9-524">Japanese (JIS-Allow 1 byte Kana - SO/SI)</span></span>|<span data-ttu-id="892d9-525">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-525">✓</span></span>||  
|<span data-ttu-id="892d9-526">50225</span><span class="sxs-lookup"><span data-stu-id="892d9-526">50225</span></span>|<span data-ttu-id="892d9-527">iso-2022-한국</span><span class="sxs-lookup"><span data-stu-id="892d9-527">iso-2022-kr</span></span>|<span data-ttu-id="892d9-528">한국어 (ISO)</span><span class="sxs-lookup"><span data-stu-id="892d9-528">Korean (ISO)</span></span>|<span data-ttu-id="892d9-529">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-529">✓</span></span>||  
|<span data-ttu-id="892d9-530">50227</span><span class="sxs-lookup"><span data-stu-id="892d9-530">50227</span></span>|<span data-ttu-id="892d9-531">x-cp50227</span><span class="sxs-lookup"><span data-stu-id="892d9-531">x-cp50227</span></span>|<span data-ttu-id="892d9-532">중국어 간체 (ISO-2022)</span><span class="sxs-lookup"><span data-stu-id="892d9-532">Chinese Simplified (ISO-2022)</span></span>|<span data-ttu-id="892d9-533">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-533">✓</span></span>||  
|<span data-ttu-id="892d9-534">51932</span><span class="sxs-lookup"><span data-stu-id="892d9-534">51932</span></span>|<span data-ttu-id="892d9-535">euc-jp</span><span class="sxs-lookup"><span data-stu-id="892d9-535">euc-jp</span></span>|<span data-ttu-id="892d9-536">일본어 (EUC)</span><span class="sxs-lookup"><span data-stu-id="892d9-536">Japanese (EUC)</span></span>|<span data-ttu-id="892d9-537">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-537">✓</span></span>||  
|<span data-ttu-id="892d9-538">51936</span><span class="sxs-lookup"><span data-stu-id="892d9-538">51936</span></span>|<span data-ttu-id="892d9-539">EUC-CN</span><span class="sxs-lookup"><span data-stu-id="892d9-539">EUC-CN</span></span>|<span data-ttu-id="892d9-540">중국어 간체 (EUC)</span><span class="sxs-lookup"><span data-stu-id="892d9-540">Chinese Simplified (EUC)</span></span>|<span data-ttu-id="892d9-541">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-541">✓</span></span>||  
|<span data-ttu-id="892d9-542">51949</span><span class="sxs-lookup"><span data-stu-id="892d9-542">51949</span></span>|<span data-ttu-id="892d9-543">euc kr</span><span class="sxs-lookup"><span data-stu-id="892d9-543">euc-kr</span></span>|<span data-ttu-id="892d9-544">한국어 (EUC)</span><span class="sxs-lookup"><span data-stu-id="892d9-544">Korean (EUC)</span></span>|<span data-ttu-id="892d9-545">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-545">✓</span></span>||  
|<span data-ttu-id="892d9-546">52936</span><span class="sxs-lookup"><span data-stu-id="892d9-546">52936</span></span>|<span data-ttu-id="892d9-547">hz-gb-2312</span><span class="sxs-lookup"><span data-stu-id="892d9-547">hz-gb-2312</span></span>|<span data-ttu-id="892d9-548">중국어 간체 (HZ)</span><span class="sxs-lookup"><span data-stu-id="892d9-548">Chinese Simplified (HZ)</span></span>|<span data-ttu-id="892d9-549">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-549">✓</span></span>||  
|<span data-ttu-id="892d9-550">54936</span><span class="sxs-lookup"><span data-stu-id="892d9-550">54936</span></span>|<span data-ttu-id="892d9-551">GB18030</span><span class="sxs-lookup"><span data-stu-id="892d9-551">GB18030</span></span>|<span data-ttu-id="892d9-552">중국어 간체 (GB18030)</span><span class="sxs-lookup"><span data-stu-id="892d9-552">Chinese Simplified (GB18030)</span></span>|<span data-ttu-id="892d9-553">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-553">✓</span></span>||  
|<span data-ttu-id="892d9-554">57002</span><span class="sxs-lookup"><span data-stu-id="892d9-554">57002</span></span>|<span data-ttu-id="892d9-555">x-iscii-de</span><span class="sxs-lookup"><span data-stu-id="892d9-555">x-iscii-de</span></span>|<span data-ttu-id="892d9-556">ISCII 데바나가리어</span><span class="sxs-lookup"><span data-stu-id="892d9-556">ISCII Devanagari</span></span>|<span data-ttu-id="892d9-557">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-557">✓</span></span>||  
|<span data-ttu-id="892d9-558">57003</span><span class="sxs-lookup"><span data-stu-id="892d9-558">57003</span></span>|<span data-ttu-id="892d9-559">iscii-수 x</span><span class="sxs-lookup"><span data-stu-id="892d9-559">x-iscii-be</span></span>|<span data-ttu-id="892d9-560">ISCII 벵골어</span><span class="sxs-lookup"><span data-stu-id="892d9-560">ISCII Bengali</span></span>|<span data-ttu-id="892d9-561">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-561">✓</span></span>||  
|<span data-ttu-id="892d9-562">57004</span><span class="sxs-lookup"><span data-stu-id="892d9-562">57004</span></span>|<span data-ttu-id="892d9-563">x-iscii-ta</span><span class="sxs-lookup"><span data-stu-id="892d9-563">x-iscii-ta</span></span>|<span data-ttu-id="892d9-564">Iscii-타밀어</span><span class="sxs-lookup"><span data-stu-id="892d9-564">ISCII Tamil</span></span>|<span data-ttu-id="892d9-565">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-565">✓</span></span>||  
|<span data-ttu-id="892d9-566">57005</span><span class="sxs-lookup"><span data-stu-id="892d9-566">57005</span></span>|<span data-ttu-id="892d9-567">x-iscii-te</span><span class="sxs-lookup"><span data-stu-id="892d9-567">x-iscii-te</span></span>|<span data-ttu-id="892d9-568">Iscii-텔루구어</span><span class="sxs-lookup"><span data-stu-id="892d9-568">ISCII Telugu</span></span>|<span data-ttu-id="892d9-569">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-569">✓</span></span>||  
|<span data-ttu-id="892d9-570">57006</span><span class="sxs-lookup"><span data-stu-id="892d9-570">57006</span></span>|<span data-ttu-id="892d9-571">x-iscii-으로</span><span class="sxs-lookup"><span data-stu-id="892d9-571">x-iscii-as</span></span>|<span data-ttu-id="892d9-572">ISCII 아삼 어</span><span class="sxs-lookup"><span data-stu-id="892d9-572">ISCII Assamese</span></span>|<span data-ttu-id="892d9-573">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-573">✓</span></span>||  
|<span data-ttu-id="892d9-574">57007</span><span class="sxs-lookup"><span data-stu-id="892d9-574">57007</span></span>|<span data-ttu-id="892d9-575">x-iscii 또는</span><span class="sxs-lookup"><span data-stu-id="892d9-575">x-iscii-or</span></span>|<span data-ttu-id="892d9-576">Iscii-오리야어</span><span class="sxs-lookup"><span data-stu-id="892d9-576">ISCII Oriya</span></span>|<span data-ttu-id="892d9-577">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-577">✓</span></span>||  
|<span data-ttu-id="892d9-578">57008</span><span class="sxs-lookup"><span data-stu-id="892d9-578">57008</span></span>|<span data-ttu-id="892d9-579">x-iscii-ka</span><span class="sxs-lookup"><span data-stu-id="892d9-579">x-iscii-ka</span></span>|<span data-ttu-id="892d9-580">Iscii-카나다어</span><span class="sxs-lookup"><span data-stu-id="892d9-580">ISCII Kannada</span></span>|<span data-ttu-id="892d9-581">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-581">✓</span></span>||  
|<span data-ttu-id="892d9-582">57009</span><span class="sxs-lookup"><span data-stu-id="892d9-582">57009</span></span>|<span data-ttu-id="892d9-583">--ma iscii x</span><span class="sxs-lookup"><span data-stu-id="892d9-583">x-iscii-ma</span></span>|<span data-ttu-id="892d9-584">ISCII 말라얄람어</span><span class="sxs-lookup"><span data-stu-id="892d9-584">ISCII Malayalam</span></span>|<span data-ttu-id="892d9-585">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-585">✓</span></span>||  
|<span data-ttu-id="892d9-586">57010</span><span class="sxs-lookup"><span data-stu-id="892d9-586">57010</span></span>|<span data-ttu-id="892d9-587">x-iscii-gu</span><span class="sxs-lookup"><span data-stu-id="892d9-587">x-iscii-gu</span></span>|<span data-ttu-id="892d9-588">ISCII 구자라트어</span><span class="sxs-lookup"><span data-stu-id="892d9-588">ISCII Gujarati</span></span>|<span data-ttu-id="892d9-589">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-589">✓</span></span>||  
|<span data-ttu-id="892d9-590">57011</span><span class="sxs-lookup"><span data-stu-id="892d9-590">57011</span></span>|<span data-ttu-id="892d9-591">x-iscii-pa</span><span class="sxs-lookup"><span data-stu-id="892d9-591">x-iscii-pa</span></span>|<span data-ttu-id="892d9-592">ISCII 펀잡어</span><span class="sxs-lookup"><span data-stu-id="892d9-592">ISCII Punjabi</span></span>|<span data-ttu-id="892d9-593">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-593">✓</span></span>||  
|<span data-ttu-id="892d9-594">65000</span><span class="sxs-lookup"><span data-stu-id="892d9-594">65000</span></span>|<span data-ttu-id="892d9-595">utf-7</span><span class="sxs-lookup"><span data-stu-id="892d9-595">utf-7</span></span>|<span data-ttu-id="892d9-596">유니코드 (utf-7)</span><span class="sxs-lookup"><span data-stu-id="892d9-596">Unicode (UTF-7)</span></span>|<span data-ttu-id="892d9-597">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-597">✓</span></span>|<span data-ttu-id="892d9-598">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-598">✓</span></span>|  
|<span data-ttu-id="892d9-599">65001</span><span class="sxs-lookup"><span data-stu-id="892d9-599">65001</span></span>|<span data-ttu-id="892d9-600">utf-8</span><span class="sxs-lookup"><span data-stu-id="892d9-600">utf-8</span></span>|<span data-ttu-id="892d9-601">유니코드(UTF-8)</span><span class="sxs-lookup"><span data-stu-id="892d9-601">Unicode (UTF-8)</span></span>|<span data-ttu-id="892d9-602">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-602">✓</span></span>|<span data-ttu-id="892d9-603">✓</span><span class="sxs-lookup"><span data-stu-id="892d9-603">✓</span></span>|  
  
 <span data-ttu-id="892d9-604">다음 예제에서는 합니다 <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> 고 <xref:System.Text.Encoding.GetEncoding%28System.String%29> 그리스어 (Windows)를 가져오는 메서드를 코드 페이지 인코딩.</span><span class="sxs-lookup"><span data-stu-id="892d9-604">The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding.</span></span> <span data-ttu-id="892d9-605">비교는 <xref:System.Text.Encoding> 를 표시 하 고, 동일 맵 그리스어 알파벳의 유니코드 코드 포인트 및 각 문자에 대해 해당 코드 페이지 값을을 표시 한 다음 메서드 호출에서 반환 된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-605">It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.</span></span>  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 <span data-ttu-id="892d9-606">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-606">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-607">Utf-16 및 UTF-32 인코더 big endian 바이트 순서를 사용할 수 있습니다 (최상위 바이트 첫 번째) 또는 little endian 바이트 순서 (최하위 바이트 먼저).</span><span class="sxs-lookup"><span data-stu-id="892d9-607">The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).</span></span> <span data-ttu-id="892d9-608">예를 들어, 영문 대문자를 (u+0041)으로 serialize 됩니다 (16 진수)에서 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-608">For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="892d9-609">Utf-16 big endian 바이트 순서: 00 41</span><span class="sxs-lookup"><span data-stu-id="892d9-609">UTF-16 big endian byte order: 00 41</span></span>  
  
-   <span data-ttu-id="892d9-610">Utf-16 little endian 바이트 순서: 41 00</span><span class="sxs-lookup"><span data-stu-id="892d9-610">UTF-16 little endian byte order: 41 00</span></span>  
  
-   <span data-ttu-id="892d9-611">UTF-32 big endian 바이트 순서: 00 00 00 41</span><span class="sxs-lookup"><span data-stu-id="892d9-611">UTF-32 big endian byte order: 00 00 00 41</span></span>  
  
-   <span data-ttu-id="892d9-612">UTF-32 little endian 바이트 순서: 41 00 00 00</span><span class="sxs-lookup"><span data-stu-id="892d9-612">UTF-32 little endian byte order: 41 00 00 00</span></span>  
  
 <span data-ttu-id="892d9-613">이 기본 바이트 순서를 사용 하 여 유니코드 문자를 저장 하려면 일반적으로 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-613">It is generally more efficient to store Unicode characters using the native byte order.</span></span> <span data-ttu-id="892d9-614">예를 들어 Intel 컴퓨터 같은 little endian 플랫폼에서 little endian 바이트 순서를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-614">For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</span></span>  
  
 <span data-ttu-id="892d9-615"><xref:System.Text.Encoding.GetPreamble%2A> 메서드는 바이트 순서 표시 (BOM)를 포함 하는 바이트의 배열을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-615">The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM).</span></span> <span data-ttu-id="892d9-616">이 바이트 배열은 인코딩된 스트림으로 접두사가 사용 된 인코딩 형식을 식별 하는 디코더 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-616">If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</span></span>  
  
 <span data-ttu-id="892d9-617">바이트 순서에서 바이트 순서 표시에 대 한 자세한 내용은 유니코드 표준을 참조 합니다 [유니코드 홈페이지](https://go.microsoft.com/fwlink/?LinkId=37123)합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-617">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>  
  
 <span data-ttu-id="892d9-618">인코딩 클래스 오류를 허용 하는 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-618">Note that the encoding classes allow errors to:</span></span>  
  
-   <span data-ttu-id="892d9-619">자동으로 변경 하는 "?" 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-619">Silently change to a "?" character.</span></span>  
  
-   <span data-ttu-id="892d9-620">"최적" 문자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-620">Use a "best fit" character.</span></span>  
  
-   <span data-ttu-id="892d9-621">사용 하 여 응용 프로그램별 동작을 변경 합니다 <xref:System.Text.EncoderFallback> 및 <xref:System.Text.DecoderFallback> U + FFFD 유니코드 대체 문자로 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-621">Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character.</span></span>  
  
 <span data-ttu-id="892d9-622">모든 데이터 스트림 오류에서 예외를 throw 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-622">You should throw an exception on any data stream error.</span></span> <span data-ttu-id="892d9-623">앱을 해당 하는 경우 "throwonerror" 플래그를 사용 하거나 사용 합니다 <xref:System.Text.EncoderExceptionFallback> 고 <xref:System.Text.DecoderExceptionFallback> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-623">An app either uses a "throwonerror" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes.</span></span> <span data-ttu-id="892d9-624">데이터 손실 또는 혼동 될 수 있습니다 하 고 단순한 문자 대체 보다 느린 있기 때문에 최상의 대체 (fallback) 것이 좋습니다 없는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-624">Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.</span></span> <span data-ttu-id="892d9-625">ANSI 인코딩을 자동 맞춤된 동작이 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-625">For ANSI encodings, the best fit behavior is the default.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-626">다음 예제에서는 한 인코딩에서 다른 문자열로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-626">The following example converts a string from one encoding to another.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="892d9-627">Byte 배열 유형만 인코딩된 데이터를 포함 하는이 예제의 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-627">The byte[] array is the only type in this example that contains the encoded data.</span></span> <span data-ttu-id="892d9-628">.NET 문자 및 문자열 형식은 유니코드 자체 이므로 <xref:System.Text.Encoding.GetChars%2A> 호출 유니코드 데이터를 다시 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-628">The .NET Char and String types are themselves Unicode, so the <xref:System.Text.Encoding.GetChars%2A> call decodes the data back to Unicode.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-629">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-629">Understanding Encodings</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="892d9-630"><see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-630">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="892d9-631"><see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-631">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-632">파생된 클래스는이 생성자를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-632">Derived classes override this constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="892d9-633">기본 설정 인코딩의 코드 페이지 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-633">The code page identifier of the preferred encoding.</span></span>  
  
<span data-ttu-id="892d9-634">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-634">-or-</span></span> 
<span data-ttu-id="892d9-635">기본 인코딩을 사용하려면 0을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-635">0, to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="892d9-636">지정한 코드 페이지에 해당하는 <see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-636">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-637">파생된 클래스는이 생성자를 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-637">Derived classes override this constructor.</span></span>  
  
 <span data-ttu-id="892d9-638">파생된 클래스에서이 생성자를 호출 만들기는 <xref:System.Text.Encoding> 인코딩 및 디코딩 작업 모두에 대 한 최적된 대체 (fallback)를 사용 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-638">Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations.</span></span> <span data-ttu-id="892d9-639">모두를 <xref:System.Text.Encoding.DecoderFallback%2A> 고 <xref:System.Text.Encoding.EncoderFallback%2A> 속성 읽기 전용 이며 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-639">Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified.</span></span> <span data-ttu-id="892d9-640">파생 된 클래스에 대 한 대체 (fallback) 전략을 제어 하려면 <xref:System.Text.Encoding>를 호출 합니다 <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-640">To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-641"><paramref name="codePage" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-641"><paramref name="codePage" /> is less than zero.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="892d9-642">인코딩 코드 페이지 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-642">The encoding code page identifier.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="892d9-643">현재 인코딩으로 문자를 인코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-643">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="892d9-644">현재 인코딩으로 바이트 시퀀스를 디코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-644">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="892d9-645">지정된 인코더 및 디코더 대체 전략을 사용하여 지정된 코드 페이지에 해당하는 <see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-645">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-646">이 생성자는 `protected`; 파생 클래스에서 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-646">This constructor is `protected`; derived classes override it.</span></span>  
  
 <span data-ttu-id="892d9-647">인코딩 및 디코딩 전략 대체를 제어 하는 파생된 클래스에서이 생성자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-647">You call this constructor from a derived class to control the fallback encoding and decoding strategies.</span></span> <span data-ttu-id="892d9-648"><xref:System.Text.Encoding> 클래스 생성자 인코더 또는 디코더가 대체 (fallback) 개체를 만든 후에 설정할 수를 허용 하지 않는 읽기 전용으로 인코딩 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-648">The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.</span></span>  
  
 <span data-ttu-id="892d9-649">이면 `encoderFallback` 또는 `decoderFallback` 이 null 이면 최적된 대체 (fallback) 해당 대체 (fallback) 전략으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-649">If either `encoderFallback` or `decoderFallback` is null, best-fit fallback is used as the corresponding fallback strategy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-650"><paramref name="codePage" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-650"><paramref name="codePage" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-651">ASCII(7비트) 문자 집합에 대한 인코딩을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-651">Gets an encoding for the ASCII (7-bit) character set.</span></span></summary>
        <value><span data-ttu-id="892d9-652">ASCII(7비트) 문자 집합에 대한 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-652">An  encoding for the ASCII (7-bit) character set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-653">ASCII 문자 u+0000 ~ U + 007F에서에서 가장 낮은 128 유니코드 문자로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-653">ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</span></span>  
  
 <span data-ttu-id="892d9-654">앱에 대 한 ASCII 인코딩을 선택할 때 다음 사항을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-654">When selecting the ASCII encoding for your app, consider the following:</span></span>  
  
-   <span data-ttu-id="892d9-655">ASCII 인코딩 ASCII를 필요로 하는 프로토콜에 대 한 일반적으로 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-655">The ASCII encoding is usually appropriate for protocols that require ASCII.</span></span>  
  
-   <span data-ttu-id="892d9-656">8 비트 인코딩 (라고 하는 경우에 따라 올바르게 하지에 "ASCII")에 필요한 경우 u t F-8 인코딩 것이 좋습니다 ascii 인코딩.</span><span class="sxs-lookup"><span data-stu-id="892d9-656">If you requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding.</span></span> <span data-ttu-id="892d9-657">문자 0-7F에 대 한 결과 동일 하지만 u t F-8을 사용 하 여 표현한 것으로 표현할 수 있는 모든 유니코드 문자를 허용 하 여 데이터 손실을 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-657">For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.</span></span> <span data-ttu-id="892d9-658">ASCII 인코딩 8 번째에 비트 악의적인 사용을 허용할 수 있는 모호성 하지만 u t F-8 인코딩 8 번째 비트에 대 한 모호성을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-658">Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</span></span>  
  
-   <span data-ttu-id="892d9-659">.NET Framework 버전 2.0 이전의.NET Framework 8 번째 비트를 무시 하 여 스푸핑 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-659">Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.</span></span> <span data-ttu-id="892d9-660">.NET Framework 2.0 부터는 ASCII가 아닌 코드 포인트 대체 디코딩하는 동안.</span><span class="sxs-lookup"><span data-stu-id="892d9-660">Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</span></span>  
  
 <span data-ttu-id="892d9-661"><xref:System.Text.ASCIIEncoding> 이 속성에 의해 반환 되는 개체는 앱에 대 한 적절 한 동작 있을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-661">The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span> <span data-ttu-id="892d9-662">교체 대체 (fallback)를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트는 물음표를 바꿉니다 ("?") 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-662">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="892d9-663">대신 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 인스턴스화하기 위한 메서드를 <xref:System.Text.ASCIIEncoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-663">Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="892d9-664">다음 예에서는 ASCII 문자를 ASCII 범위를 벗어나는에 인코딩의 효과 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-664">The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.</span></span>  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-665">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-665">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-666">big endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-666">Gets an encoding for the UTF-16 format that uses the big endian byte order.</span></span></summary>
        <value><span data-ttu-id="892d9-667">Big-Endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-667">An encoding object for the UTF-16 format that uses the big endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-668"><xref:System.Text.UnicodeEncoding> 이 속성에 의해 반환 된 개체를 앱에 대 한 적절 한 동작에 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-668">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="892d9-669">교체 대체 (fallback)를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트는 물음표를 바꿉니다 ("?") 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-669">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="892d9-670">대신, 호출할 수 있습니다는 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> big endian를 인스턴스화하는 생성자 <xref:System.Text.UnicodeEncoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-670">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 <span data-ttu-id="892d9-671">반환 된 <xref:System.Text.UnicodeEncoding> 개체에 <xref:System.Text.Encoding.BodyName%2A>를 <xref:System.Text.Encoding.HeaderName%2A>, 및 <xref:System.Text.Encoding.WebName%2A> unicodeFFFE"이름"을 생성 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-671">The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name "unicodeFFFE".</span></span> <span data-ttu-id="892d9-672">Utf-16 big endian 바이트 순서 표시를 16 진수 FEFF 경우에 "이름"unicodeFFFE 바이트 순서 표시가 little endian Windows 컴퓨터에서 16 진수 FFFE로 표시 되기 때문에 선택 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-672">Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-673">다음 예에서는 u t F-16으로 인코딩된 big endian 바이트 순서를 사용 하 여 텍스트 파일을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-673">The following example reads a text file with a UTF-16 encoding using the big endian byte order.</span></span>  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 <span data-ttu-id="892d9-674">다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-674">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-675">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-675">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-676">파생 클래스에서 재정의되면 메일 에이전트 본문 태그에 사용할 수 있는 현재 인코딩의 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-676">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</span></span></summary>
        <value><span data-ttu-id="892d9-677">메일 에이전트 본문 태그에 사용할 수 있는 현재 <see cref="T:System.Text.Encoding" />의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-677">A name for the current <see cref="T:System.Text.Encoding" /> that can be used with mail agent body tags.</span></span>  
  
<span data-ttu-id="892d9-678">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-678">-or-</span></span> 
<span data-ttu-id="892d9-679">현재 <see cref="T:System.Text.Encoding" />을 사용할 수 없으면 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-679">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-680">본문 이름에 대 한 인코딩을 해야 하는 경우 호출 해야 <xref:System.Text.Encoding.GetEncoding%2A> 사용 하 여는 <xref:System.Text.Encoding.BodyName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-680">If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property.</span></span> <span data-ttu-id="892d9-681">종종 메서드 호출에 제공 된 인코딩을 테스트에서 다른 인코딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-681">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="892d9-682">일반적으로 전자 메일 응용 프로그램만 그러한 인코딩을; 검색 해야 인코딩을 설명 해야 하는 다른 대부분의 응용 프로그램을 사용할지는 <xref:System.Text.Encoding.WebName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-682">Generally only email applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.</span></span>  
  
 <span data-ttu-id="892d9-683">경우에 따라 값을 <xref:System.Text.Encoding.BodyName%2A> 속성은 해당 인코딩을 정의 하는 국제 표준에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-683">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="892d9-684">구현 표준에 사용 하 여 전체에서 준수는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-684">This doesn't mean that the implementation complies in full with that standard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-685">다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-685">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="892d9-686">표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-686">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="892d9-687">파생 클래스에서 재정의되면 현재 <see cref="T:System.Text.Encoding" /> 개체의 부분 복사본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-687">When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <returns><span data-ttu-id="892d9-688">현재 <see cref="T:System.Text.Encoding" /> 개체의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-688">A copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-689">복제본은 쓰기 가능한 경우에 원래 <xref:System.Text.Encoding> 개체가 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-689">The clone is writable even if the original <xref:System.Text.Encoding> object is read-only.</span></span> <span data-ttu-id="892d9-690">따라서 복제본의 속성을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-690">Therefore, the properties of the clone can be modified.</span></span>  
  
 <span data-ttu-id="892d9-691">개체의 단순 복사본에만 개체의 복사본이입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-691">A shallow copy of an object is a copy of the object only.</span></span> <span data-ttu-id="892d9-692">개체가 다른 개체에 대 한 참조를 포함 하는 경우 단순 복사를 참조 된 개체의 복사본을 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-692">If the object contains references to other objects, the shallow copy does not create copies of the referred objects.</span></span> <span data-ttu-id="892d9-693">참조 된 원래 개체 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-693">It refers to the original objects instead.</span></span> <span data-ttu-id="892d9-694">반면, 개체의 전체 복사본을 만들고 개체의 복사본 개체에서 직접 또는 간접적으로 참조 하는 모든 대상을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-694">In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-695">파생 클래스에서 재정의되면 현재 <see cref="T:System.Text.Encoding" />의 코드 페이지 식별자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-695">When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></summary>
        <value><span data-ttu-id="892d9-696">현재 <see cref="T:System.Text.Encoding" />의 코드 페이지 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-696">The code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="892d9-697">다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-697">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="892d9-698">표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-698">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="892d9-699">바이트 배열을 한 인코딩에서 다른 인코딩으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-699">Converts a byte array from one encoding to another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="892d9-700"><paramref name="bytes" />의 인코딩 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-700">The encoding format of <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="892d9-701">대상 인코딩 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-701">The target encoding format.</span></span></param>
        <param name="bytes"><span data-ttu-id="892d9-702">변환할 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-702">The bytes to convert.</span></span></param>
        <summary><span data-ttu-id="892d9-703">전체 바이트 배열의 인코딩을 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-703">Converts an entire byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="892d9-704"><see cref="T:System.Byte" />를 <paramref name="bytes" />에서 <paramref name="srcEncoding" />으로 변환한 결과를 포함하는 <paramref name="dstEncoding" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-704">An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="892d9-705">다음 예제에서는 ASCII로 인코드된 문자열을 유니코드로 인코딩된 문자열로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-705">The following example converts a Unicode-encoded string to an ASCII-encoded string.</span></span> <span data-ttu-id="892d9-706">ASCII 인코딩 개체를 반환 하므로 <xref:System.Text.Encoding.ASCII%2A> 교체 대체 (fallback)를 사용 하는 속성 및 Pi 문자는 ASCII 문자 집합의 일부가 아닌, Pi 문자는 출력은 예제에서 물음표를 사용 하 여 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-706">Because the ASCII encoding object returned by the <xref:System.Text.Encoding.ASCII%2A> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-707"><paramref name="srcEncoding" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-707"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="892d9-708">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-708">-or-</span></span> 
 <span data-ttu-id="892d9-709"><paramref name="dstEncoding" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-709"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="892d9-710">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-710">-or-</span></span> 
 <span data-ttu-id="892d9-711"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-711"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-712">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-712">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-713">및</span><span class="sxs-lookup"><span data-stu-id="892d9-713">-and-</span></span> 
 <span data-ttu-id="892d9-714">**srcEncoding.**</span><span class="sxs-lookup"><span data-stu-id="892d9-714">**srcEncoding.**</span></span> <span data-ttu-id="892d9-715"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-715"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-716">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-716">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-717">및</span><span class="sxs-lookup"><span data-stu-id="892d9-717">-and-</span></span> 
 <span data-ttu-id="892d9-718">**dstEncoding.**</span><span class="sxs-lookup"><span data-stu-id="892d9-718">**dstEncoding.**</span></span> <span data-ttu-id="892d9-719"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-719"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="892d9-720">소스 배열 <paramref name="bytes" />의 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-720">The encoding of the source array, <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="892d9-721">출력 배열의 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-721">The encoding of the output array.</span></span></param>
        <param name="bytes"><span data-ttu-id="892d9-722">변환할 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-722">The array of bytes to convert.</span></span></param>
        <param name="index"><span data-ttu-id="892d9-723">변환할 <paramref name="bytes" />에 있는 첫 번째 요소의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-723">The index of the first element of <paramref name="bytes" /> to convert.</span></span></param>
        <param name="count"><span data-ttu-id="892d9-724">변환할 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-724">The number of bytes to convert.</span></span></param>
        <summary><span data-ttu-id="892d9-725">바이트 배열의 바이트 범위를 한 인코딩에서 다른 인코딩으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-725">Converts a range of bytes in a byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="892d9-726"><see cref="T:System.Byte" />의 바이트 범위를 <paramref name="bytes" />에서 <paramref name="srcEncoding" />으로 변환한 결과를 포함하는 <paramref name="dstEncoding" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-726">An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-727"><paramref name="srcEncoding" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-727"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="892d9-728">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-728">-or-</span></span> 
 <span data-ttu-id="892d9-729"><paramref name="dstEncoding" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-729"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="892d9-730">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-730">-or-</span></span> 
 <span data-ttu-id="892d9-731"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-731"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-732"><paramref name="index" /> 및 <paramref name="count" />가 바이트 배열의 유효한 범위를 지정하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-732"><paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the byte array.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-733">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-733">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-734">및</span><span class="sxs-lookup"><span data-stu-id="892d9-734">-and-</span></span> 
 <span data-ttu-id="892d9-735">**srcEncoding.**</span><span class="sxs-lookup"><span data-stu-id="892d9-735">**srcEncoding.**</span></span> <span data-ttu-id="892d9-736"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-736"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-737">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-737">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-738">및</span><span class="sxs-lookup"><span data-stu-id="892d9-738">-and-</span></span> 
 <span data-ttu-id="892d9-739">**dstEncoding.**</span><span class="sxs-lookup"><span data-stu-id="892d9-739">**dstEncoding.**</span></span> <span data-ttu-id="892d9-740"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-740"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-741">현재 <see cref="T:System.Text.DecoderFallback" /> 개체에 대한 <see cref="T:System.Text.Encoding" /> 개체를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-741">Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="892d9-742">현재 <see cref="T:System.Text.Encoding" /> 개체에 대한 디코더 대체 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-742">The decoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-743"><xref:System.Text.DecoderFallback> 개체 문자를 인코딩된 바이트 시퀀스를 디코딩할 수 없는 경우 호출 되는 오류 처리기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-743">The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.</span></span> <span data-ttu-id="892d9-744">다음 처리기 형식 중 하나로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-744">Any one of the following handler types is supported:</span></span>  
  
-   <span data-ttu-id="892d9-745">최적된 대체 (fallback) 처리기를 몇 가지 적절 한 대체 문자를 사용 하 여 디코딩할 수 없는 바이트를 대체 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-745">A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</span></span>  
  
-   <span data-ttu-id="892d9-746">교체 대체 (fallback) 처리기를 일부 임의의 대체 문자를 사용 하 여 디코딩할 수 없는 바이트를 대체 하는입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-746">A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.</span></span> <span data-ttu-id="892d9-747">.NET 포함 한 교체 대체 (fallback) 처리기를 <xref:System.Text.DecoderFallback>를 디코딩할 수 없는 바이트 물음표로 대체 하는 기본적으로는 ("?") 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-747">.NET includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</span></span>  
  
-   <span data-ttu-id="892d9-748">예외 대체 (fallback) 처리기 바이트를 디코딩할 수 없는 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-748">An exception fallback handler, which throws an exception when bytes cannot be decoded.</span></span> <span data-ttu-id="892d9-749">.NET 포함 한 예외 대체 (fallback) 처리기 <xref:System.Text.DecoderExceptionFallback>를 throw 하는 <xref:System.Text.DecoderFallbackException> 바이트를 디코딩할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="892d9-749">.NET includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-750">집합 작업의 값이 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-750">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="892d9-751">현재 <see cref="T:System.Text.Encoding" /> 개체가 읽기 전용이기 때문에 set 작업에 값을 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-751">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-752">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-752">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-753">이 .NET 구현을 위한 기본 인코딩을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-753">Gets the default encoding for this .NET implementation.</span></span></summary>
        <value><span data-ttu-id="892d9-754">이.NET 구현에 대 한 인코딩 기본입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-754">The default encoding for this .NET implementation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  <span data-ttu-id="892d9-755">서로 다른 컴퓨터는 기본적으로 다른 인코딩을 사용할 수 및 기본 인코딩을 단일 컴퓨터에서 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-755">Different computers can use different encodings as the default, and the default encoding can change on a single computer.</span></span> <span data-ttu-id="892d9-756">사용 하는 경우는 <xref:System.Text.Encoding.Default%2A> 인코딩을 인코딩 및 디코딩 스트리밍할 컴퓨터 간에 또는 동일한 컴퓨터에서 서로 다른 시간에 검색 데이터를 변환할 수도 있습니다 하지 해당 데이터 올바르게 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-756">If you use the <xref:System.Text.Encoding.Default%2A> encoding to encode and decode data streamed between computers or retrieved at different times on the same computer, it may translate that data incorrectly.</span></span> <span data-ttu-id="892d9-757">또한 인코딩을 반환한는 <xref:System.Text.Encoding.Default%2A> 속성 최적된 대체 (fallback)를 사용 하 여 지원 되지 않는 문자 코드 페이지에서 지 원하는 문자에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-757">In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page.</span></span> <span data-ttu-id="892d9-758">이러한 이유로, 기본 인코딩을 사용 하 여 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-758">For these reasons, using the default encoding is not recommended.</span></span> <span data-ttu-id="892d9-759">인코딩된 바이트 디코딩되는 유니코드 인코딩 등을 사용 해야 되도록 하려면 <xref:System.Text.UTF8Encoding> 또는 <xref:System.Text.UnicodeEncoding>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-759">To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>.</span></span> <span data-ttu-id="892d9-760">또한 동일한 형식을 인코딩 및 디코딩을 위한 사용 되는지 확인 하는 상위 수준 프로토콜을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-760">You could also use a higher-level protocol to ensure that the same format is used for encoding and decoding.</span></span>  

### <a name="the-default-property-in-the-net-framework"></a><span data-ttu-id="892d9-761">.NET Framework의 기본 속성</span><span class="sxs-lookup"><span data-stu-id="892d9-761">The Default property in the .NET Framework</span></span>

<span data-ttu-id="892d9-762">Windows 바탕 화면에서.NET framework에서는 <xref:System.Text.Encoding.Default%2A> 속성 항상 시스템의 활성 코드 페이지를 가져오고 만듭니다는 <xref:System.Text.Encoding> 것에 해당 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-762">In the .NET Framework on the Windows desktop, the <xref:System.Text.Encoding.Default%2A> property always gets the system's active code page and creates a <xref:System.Text.Encoding> object that corresponds to it.</span></span> <span data-ttu-id="892d9-763">현재 코드 페이지에는 ASCII 문자 코드 페이지에서 함께 달라 지는 추가 문자 집합을 포함 하는 ANSI 코드 페이지를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-763">The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page.</span></span> <span data-ttu-id="892d9-764">때문에 모든 <xref:System.Text.Encoding.Default%2A> 인코딩은 ANSI 코드 페이지에 따라 데이터가 손실, 사용 하는 것이 좋습니다는 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 대신 인코딩.</span><span class="sxs-lookup"><span data-stu-id="892d9-764">Because all <xref:System.Text.Encoding.Default%2A> encodings based on ANSI code pages lose data, consider using the <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> encoding instead.</span></span> <span data-ttu-id="892d9-765">U t F-8에서 U + 00에서 U + 7F 범위와 동일 하지만 손실 없이 ASCII 범위 밖의 문자를 인코딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-765">UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.</span></span>

## <a name="the-default-property-on-net-core"></a><span data-ttu-id="892d9-766">.NET Core의 기본 속성</span><span class="sxs-lookup"><span data-stu-id="892d9-766">The Default property on .NET Core</span></span>

<span data-ttu-id="892d9-767">.NET Core에서의 <xref:System.Text.Encoding.Default%2A> 속성은 항상 반환 된 <xref:System.Text.UTF8Encoding>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-767">On .NET Core, the <xref:System.Text.Encoding.Default%2A> property always returns the <xref:System.Text.UTF8Encoding>.</span></span> <span data-ttu-id="892d9-768">U t F-8은 모든 운영 체제 (Windows, Linux 및 OS X 최대) 실행 하는.NET Core 응용 프로그램에서 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-768">UTF-8 is supported on all the operating systems (Windows, Linux, and Max OS X) on which .NET Core applications run.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-769">현재 <see cref="T:System.Text.EncoderFallback" /> 개체에 대한 <see cref="T:System.Text.Encoding" /> 개체를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-769">Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="892d9-770">현재 <see cref="T:System.Text.Encoding" /> 개체에 대한 인코더 대체 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-770">The encoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-771"><xref:System.Text.EncoderFallback> 개체 문자를 인코딩된 바이트 시퀀스로 변환할 수 없을 때 호출 되는 오류 처리기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-771">The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</span></span> <span data-ttu-id="892d9-772">다음 처리기 형식 중 하나로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-772">Any one of the following handler types is supported:</span></span>  
  
-   <span data-ttu-id="892d9-773">최적된 대체 (fallback) 처리기를 몇 가지 적절 한 대체 문자를 사용 하 여 인코딩할 수 없는 문자를 대체 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-773">A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</span></span>  
  
-   <span data-ttu-id="892d9-774">교체 대체 (fallback) 처리기를 일부 임의의 대체 문자를 사용 하 여 인코딩할 수 없는 문자를 대체 하는입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-774">A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.</span></span> <span data-ttu-id="892d9-775">.NET 포함 한 교체 대체 (fallback) 처리기를 <xref:System.Text.EncoderFallback>를 인코딩할 수 없는 문자는 물음표를 사용 하 여 대체 하는 기본적으로는 ("?") 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-775">.NET includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark ("?") character.</span></span>  
  
-   <span data-ttu-id="892d9-776">예외 대체 (fallback) 처리기 문자를 인코딩할 수 없는 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-776">An exception fallback handler, which throws an exception when characters cannot be encoded.</span></span> <span data-ttu-id="892d9-777">.NET 포함 한 예외 대체 (fallback) 처리기 <xref:System.Text.EncoderExceptionFallback>를 throw 하는 <xref:System.Text.EncoderFallbackException> 문자를 디코딩할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="892d9-777">.NET includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-778">집합 작업의 값이 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-778">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="892d9-779">현재 <see cref="T:System.Text.Encoding" /> 개체가 읽기 전용이기 때문에 set 작업에 값을 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-779">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-780">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-780">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-781">파생 클래스에서 재정의되면 현재 인코딩에 대해 사람이 읽을 수 있는 설명을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-781">When overridden in a derived class, gets the human-readable description of the current encoding.</span></span></summary>
        <value><span data-ttu-id="892d9-782">현재 <see cref="T:System.Text.Encoding" />에 대해 사람이 읽을 수 있는 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-782">The human-readable description of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-783"><xref:System.Text.Encoding.EncodingName%2A> 속성을 표시 하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-783">The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display.</span></span> <span data-ttu-id="892d9-784">에 전달 될 수 있는 이름을 찾으려면 합니다 <xref:System.Text.Encoding.GetEncoding%2A> 메서드를 사용 하 여는 <xref:System.Text.Encoding.WebName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-784">To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-785">다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-785">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="892d9-786">표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-786">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="892d9-787">현재 인스턴스와 비교할 <see cref="T:System.Object" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-787">The <see cref="T:System.Object" /> to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="892d9-788">지정한 <see cref="T:System.Object" />가 현재 인스턴스와 같은지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-788">Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</span></span></summary>
        <returns><span data-ttu-id="892d9-789"><see langword="true" />가 <paramref name="value" />의 인스턴스이고 현재 인스턴스와 같으면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-789"><see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-790">두 인스턴스 <xref:System.Text.Encoding> 동일한 코드 페이지에 해당 하는 경우 같은 것으로 간주 됩니다 및 해당 `EncoderFallback` 및 `DecoderFallback` 개체는 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-790">Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal.</span></span> <span data-ttu-id="892d9-791">특히 모든 파생 된 코드 페이지에는 0의 코드 페이지가 하 고 해당 대체는 일반적으로 `null` (`Nothing` Visual Basic.net에서).</span><span class="sxs-lookup"><span data-stu-id="892d9-791">In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET).</span></span> <span data-ttu-id="892d9-792">따라서 이러한 모든 것으로 간주 됩니다 서로 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-792">Thus they are all considered equal to one another.</span></span> <span data-ttu-id="892d9-793">결과 때 <xref:System.Text.Encoding.Equals%2A> 해시 테이블을 채우는 데 사용 됩니다 하 고 모든 파생 인코딩이 같으며 동일한 해시 테이블 슬롯에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-793">One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-794">다음 예제에서는 두 인스턴스가 동일한 인코딩 (각각 하나) 및 다른 이름으로,와 서로 같은지 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-794">The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="892d9-795">파생 클래스에서 재정의되면 문자 집합을 인코딩하여 생성되는 바이트 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-795">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="892d9-796">인코딩할 문자가 포함된 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-796">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="892d9-797">파생 클래스에서 재정의되면 지정한 문자 배열의 모든 문자를 인코딩하여 생성되는 바이트 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-797">When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</span></span></summary>
        <returns><span data-ttu-id="892d9-798">지정한 문자 배열의 모든 문자를 인코딩하여 생성되는 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-798">The number of bytes produced by encoding all the characters in the specified character array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-799">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하려면 호출을 <xref:System.Text.Encoding.GetByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-799">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="892d9-800">최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-800">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="892d9-801">합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-801">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-802"><xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-802">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-803"><xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-803">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-804">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-804">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-805">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-805">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-806">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-806">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-807">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-807">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="892d9-808">문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우는 <xref:System.Text.Encoding.GetBytes%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-808">If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>  
  
-   <span data-ttu-id="892d9-809">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-809">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-810">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-810">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-811">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-811">If your app must convert a large amount of data, you should reuse the output buffer.</span></span> <span data-ttu-id="892d9-812">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-812">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-813">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-813">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-814">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-814">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-815">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-815">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-816">다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-816">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-817"><paramref name="chars" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-817"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-818">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-818">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-819">및</span><span class="sxs-lookup"><span data-stu-id="892d9-819">-and-</span></span> 
 <span data-ttu-id="892d9-820"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-820"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="892d9-821">인코딩할 문자 집합이 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-821">The string containing the set of characters to encode.</span></span></param>
        <summary><span data-ttu-id="892d9-822">파생 클래스에서 재정의되면 지정된 문자열의 문자를 인코딩하여 생성되는 바이트 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-822">When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</span></span></summary>
        <returns><span data-ttu-id="892d9-823">지정한 문자를 인코딩할 경우 생성되는 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-823">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-824">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하려면 호출을 <xref:System.Text.Encoding.GetByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-824">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="892d9-825">최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-825">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="892d9-826">합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-826">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-827"><xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-827">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-828"><xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-828">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-829">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-829">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-830">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-830">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-831">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-831">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-832">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-832">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="892d9-833">앱이 사용자 입력 문자열의 문자열 버전을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A> 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-833">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>  
  
-   <span data-ttu-id="892d9-834">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-834">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-835">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-835">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-836">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-836">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-837">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-837">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-838">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-838">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-839">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-839">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-840">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-840">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-841">다음 예제에서는 문자열 또는 문자열의 범위를 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-841">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-842"><paramref name="s" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-842"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-843">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-843">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-844">및</span><span class="sxs-lookup"><span data-stu-id="892d9-844">-and-</span></span> 
 <span data-ttu-id="892d9-845"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-845"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="892d9-846">인코딩할 첫 번째 문자를 가리키는 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-846">A pointer to the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="892d9-847">인코딩할 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-847">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="892d9-848">파생 클래스에서 재정의되면 지정한 문자 포인터에서 시작하는 문자 집합을 인코딩하여 생성되는 바이트 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-848">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="892d9-849">지정한 문자를 인코딩할 경우 생성되는 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-849">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-850">정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 필요한 결과 바이트를 저장 하려면 호출 해야 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-850">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="892d9-851">최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-851">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="892d9-852">합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-852">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-853"><xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-853">The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-854"><xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-854">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-855">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-855">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-856">다음은 이러한 메서드를 사용 하는 것에 대 한 몇 가지 고려 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-856">The following are some considerations for using these methods:</span></span>  
  
-   <span data-ttu-id="892d9-857">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-857">Your app may need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-858">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-858">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="892d9-859">문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우는 <xref:System.Text.Encoding.GetBytes%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-859">If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>  
  
-   <span data-ttu-id="892d9-860">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%2A> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-860">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-861">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-861">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-862">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-862">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-863">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-863">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-864">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-864">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-865">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-865">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-866">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-866">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-867"><paramref name="chars" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-867"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-868"><paramref name="count" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-868"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-869">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-869">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-870">및</span><span class="sxs-lookup"><span data-stu-id="892d9-870">-and-</span></span> 
 <span data-ttu-id="892d9-871"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-871"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="892d9-872">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-872">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="892d9-873">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-873">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="892d9-874">인코딩할 문자 집합이 포함된 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-874">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="892d9-875">인코딩할 첫 번째 문자의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-875">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="892d9-876">인코딩할 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-876">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="892d9-877">파생 클래스에서 재정의되면 지정한 문자 배열의 문자 집합을 인코딩하여 생성되는 바이트 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-877">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</span></span></summary>
        <returns><span data-ttu-id="892d9-878">지정한 문자를 인코딩할 경우 생성되는 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-878">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-879">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하려면 호출을 <xref:System.Text.Encoding.GetByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-879">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="892d9-880">최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-880">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="892d9-881">합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-881">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-882"><xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-882">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-883"><xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-883">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-884">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-884">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-885">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-885">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-886">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-886">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-887">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-887">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="892d9-888">앱이 사용자 입력 문자열의 문자열 버전을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A> 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-888">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>  
  
-   <span data-ttu-id="892d9-889">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-889">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-890">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-890">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-891">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-891">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-892">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-892">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-893">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-893">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-894">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-894">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-895">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-895">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-896">다음 예제에서는 세 문자는 문자 배열에서 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-896">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-897"><paramref name="chars" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-897"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-898"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-898"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="892d9-899">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-899">-or-</span></span> 
 <span data-ttu-id="892d9-900"><paramref name="index" /> 및 <paramref name="count" />가 <paramref name="chars" />에서 올바른 범위를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-900"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-901">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-901">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-902">및</span><span class="sxs-lookup"><span data-stu-id="892d9-902">-and-</span></span> 
 <span data-ttu-id="892d9-903"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-903"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="892d9-904">파생 클래스에서 재정의되면 문자 집합을 바이트 시퀀스로 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-904">When overridden in a derived class, encodes a set of characters into a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="892d9-905">인코딩할 문자가 포함된 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-905">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="892d9-906">파생 클래스에서 재정의되면 지정한 문자 배열의 모든 문자를 바이트 시퀀스로 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-906">When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="892d9-907">지정한 문자 집합을 인코딩한 결과가 포함된 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-907">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-908">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-908">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-909"><xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-909">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-910"><xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-910">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-911">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-911">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-912">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-912">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-913">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-913">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-914">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-914">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="892d9-915">(예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함.</span><span class="sxs-lookup"><span data-stu-id="892d9-915">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="892d9-916"><xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-916">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="892d9-917"><xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="892d9-917"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="892d9-918">문자열 버전을 호출 해야 앱 문자열 입력을 처리 하는 경우는 <xref:System.Text.Encoding.GetBytes%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-918">If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>  
  
-   <span data-ttu-id="892d9-919">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-919">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-920">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-920">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-921">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-921">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-922">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-922">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-923">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-923">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-924">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-924">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-925">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-925">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-926">다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-926">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-927"><paramref name="chars" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-927"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-928">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-928">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-929">및</span><span class="sxs-lookup"><span data-stu-id="892d9-929">-and-</span></span> 
 <span data-ttu-id="892d9-930"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-930"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="892d9-931">인코딩할 문자가 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-931">The string containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="892d9-932">파생 클래스에서 재정의되면 지정한 문자열의 모든 문자를 바이트 시퀀스로 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-932">When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="892d9-933">지정한 문자 집합을 인코딩한 결과가 포함된 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-933">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-934">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-934">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-935"><xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-935">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-936"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-936">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-937">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-937">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-938">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-938">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-939">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-939">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-940">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-940">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="892d9-941">(예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함.</span><span class="sxs-lookup"><span data-stu-id="892d9-941">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="892d9-942"><xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-942">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="892d9-943"><xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="892d9-943"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="892d9-944">문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-944">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="892d9-945">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-945">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-946">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-946">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-947">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-947">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-948">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-948">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-949">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-949">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-950">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-950">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-951">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-951">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-952">다음 예제에서는 문자열 또는 문자열의 범위를 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-952">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-953"><paramref name="s" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-953"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-954">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-954">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-955">및</span><span class="sxs-lookup"><span data-stu-id="892d9-955">-and-</span></span> 
 <span data-ttu-id="892d9-956"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-956"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="892d9-957">인코딩할 문자 집합이 포함된 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-957">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="892d9-958">인코딩할 첫 번째 문자의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-958">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="892d9-959">인코딩할 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-959">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="892d9-960">파생 클래스에서 재정의되면 지정한 문자 배열의 문자 집합을 바이트 시퀀스로 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-960">When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="892d9-961">지정한 문자 집합을 인코딩한 결과가 포함된 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-961">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-962">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-962">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-963"><xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-963">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-964"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-964">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-965">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-965">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-966">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-966">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-967">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-967">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-968">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-968">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="892d9-969">(예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함.</span><span class="sxs-lookup"><span data-stu-id="892d9-969">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="892d9-970"><xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-970">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="892d9-971"><xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="892d9-971"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="892d9-972">문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-972">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="892d9-973">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-973">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-974">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-974">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-975">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-975">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-976">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-976">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-977">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-977">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-978">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-978">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-979">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-979">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-980">다음 예제에서는 세 문자는 문자 배열에서 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-980">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-981"><paramref name="chars" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-981"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-982"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-982"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="892d9-983">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-983">-or-</span></span> 
 <span data-ttu-id="892d9-984"><paramref name="index" /> 및 <paramref name="count" />가 <paramref name="chars" />에서 올바른 범위를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-984"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-985">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-985">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-986">및</span><span class="sxs-lookup"><span data-stu-id="892d9-986">-and-</span></span> 
 <span data-ttu-id="892d9-987"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-987"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="892d9-988">인코딩할 첫 번째 문자를 가리키는 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-988">A pointer to the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="892d9-989">인코딩할 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-989">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="892d9-990">결과 바이트 시퀀스를 쓰기 시작할 위치를 가리키는 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-990">A pointer to the location at which to start writing the resulting sequence of bytes.</span></span></param>
        <param name="byteCount"><span data-ttu-id="892d9-991">쓸 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-991">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="892d9-992">파생 클래스에서 재정의되면 지정한 문자 포인터에서 시작하는 문자 집합을 지정한 바이트 포인터에서 시작하여 저장되는 바이트 시퀀스로 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-992">When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="892d9-993"><paramref name="bytes" /> 매개 변수가 가리키는 위치에 쓴 실제 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-993">The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-994">정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 필요한 결과 바이트를 저장 하려면 호출을 <xref:System.Text.Encoding.GetByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-994">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="892d9-995">최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-995">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="892d9-996">합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-996">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-997">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 는 에서제공하는개체<xref:System.Text.Encoding.GetDecoder%2A> 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-997">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-998"><xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-998">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-999"><xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-999">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1000">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1000">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-1001">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1001">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1002">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1002">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-1003">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1003">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="892d9-1004">(예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함.</span><span class="sxs-lookup"><span data-stu-id="892d9-1004">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="892d9-1005"><xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1005">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="892d9-1006"><xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="892d9-1006"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="892d9-1007">문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1007">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="892d9-1008">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1008">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-1009">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1009">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1010">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1010">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1011">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1011">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1012">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1012">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-1013">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1013">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1014">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1014">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1015"><paramref name="chars" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1015"><paramref name="chars" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="892d9-1016">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1016">-or-</span></span> 
 <span data-ttu-id="892d9-1017"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1017"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1018"><paramref name="charCount" /> 또는 <paramref name="byteCount" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1018"><paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1019"><paramref name="byteCount" />가 결과 바이트 수보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1019"><paramref name="byteCount" /> is less than the resulting number of bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-1020">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1020">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1021">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1021">-and-</span></span> 
 <span data-ttu-id="892d9-1022"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1022"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="892d9-1023">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1023">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="892d9-1024">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1024">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="892d9-1025">인코딩할 문자 집합이 포함된 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1025">The character array containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="892d9-1026">인코딩할 첫 번째 문자의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1026">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="892d9-1027">인코딩할 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1027">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="892d9-1028">결과 바이트 시퀀스를 포함할 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1028">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="892d9-1029">결과 바이트 시퀀스를 쓰기 시작할 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1029">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="892d9-1030">파생 클래스에서 재정의되면 지정한 문자 배열의 문자 집합을 지정한 바이트 배열로 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1030">When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="892d9-1031"><paramref name="bytes" />에 쓴 실제 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1031">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1032">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 바이트를 저장 하는 결과 호출 해야 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1032">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="892d9-1033">최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1033">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="892d9-1034">합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1034">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-1035">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1035">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-1036"><xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1036">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-1037"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1037">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1038">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1038">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-1039">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1039">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1040">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1040">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-1041">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1041">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="892d9-1042">(예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함.</span><span class="sxs-lookup"><span data-stu-id="892d9-1042">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="892d9-1043"><xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1043">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="892d9-1044"><xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="892d9-1044"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="892d9-1045">문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1045">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="892d9-1046">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1046">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-1047">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1047">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1048">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1048">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1049">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1049">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1050">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1050">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-1051">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1051">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1052">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1052">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1053">다음 예제에서는 세 문자는 문자 배열에서 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1053">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1054"><paramref name="chars" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1054"><paramref name="chars" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="892d9-1055">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1055">-or-</span></span> 
 <span data-ttu-id="892d9-1056"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1056"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1057"><paramref name="charIndex" />, <paramref name="charCount" /> 또는 <paramref name="byteIndex" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1057"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="892d9-1058">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1058">-or-</span></span> 
 <span data-ttu-id="892d9-1059"><paramref name="charIndex" /> 및 <paramref name="charCount" />가 <paramref name="chars" />에서 올바른 범위를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1059"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>  
  
<span data-ttu-id="892d9-1060">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1060">-or-</span></span> 
 <span data-ttu-id="892d9-1061"><paramref name="byteIndex" />가 <paramref name="bytes" />의 유효한 인덱스가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1061"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1062"><paramref name="bytes" />의 용량(<paramref name="byteIndex" /> ~ 배열 끝)이 부족해서 결과 바이트를 수용할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1062"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-1063">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1063">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1064">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1064">-and-</span></span> 
 <span data-ttu-id="892d9-1065"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1065"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="892d9-1066">인코딩할 문자 집합이 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1066">The string containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="892d9-1067">인코딩할 첫 번째 문자의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1067">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="892d9-1068">인코딩할 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1068">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="892d9-1069">결과 바이트 시퀀스를 포함할 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1069">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="892d9-1070">결과 바이트 시퀀스를 쓰기 시작할 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1070">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="892d9-1071">파생 클래스에서 재정의되면 지정한 문자열의 문자 집합을 지정한 바이트 배열로 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1071">When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="892d9-1072"><paramref name="bytes" />에 쓴 실제 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1072">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1073">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 바이트를 저장 하는 결과 호출 해야 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1073">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="892d9-1074">최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1074">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="892d9-1075">합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1075">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-1076">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1076">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-1077"><xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1077">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="892d9-1078"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1078">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1079">여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1079">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="892d9-1080">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1080">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1081">앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1081">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="892d9-1082">이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1082">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="892d9-1083">(예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함.</span><span class="sxs-lookup"><span data-stu-id="892d9-1083">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="892d9-1084"><xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1084">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="892d9-1085"><xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="892d9-1085"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="892d9-1086">문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1086">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="892d9-1087">유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1087">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="892d9-1088">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1088">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1089">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1089">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1090">이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1090">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1091">사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1091">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="892d9-1092">최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1092">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1093">연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1093">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1094">다음 예제에서는 문자열 또는 문자열의 범위를 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1094">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1095"><paramref name="s" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1095"><paramref name="s" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="892d9-1096">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1096">-or-</span></span> 
 <span data-ttu-id="892d9-1097"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1097"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1098"><paramref name="charIndex" />, <paramref name="charCount" /> 또는 <paramref name="byteIndex" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1098"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="892d9-1099">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1099">-or-</span></span> 
 <span data-ttu-id="892d9-1100"><paramref name="charIndex" /> 및 <paramref name="charCount" />가 <paramref name="chars" />에서 올바른 범위를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1100"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>  
  
<span data-ttu-id="892d9-1101">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1101">-or-</span></span> 
 <span data-ttu-id="892d9-1102"><paramref name="byteIndex" />가 <paramref name="bytes" />의 유효한 인덱스가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1102"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1103"><paramref name="bytes" />의 용량(<paramref name="byteIndex" /> ~ 배열 끝)이 부족해서 결과 바이트를 수용할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1103"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-1104">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1104">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1105">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1105">-and-</span></span> 
 <span data-ttu-id="892d9-1106"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1106"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="892d9-1107">파생 클래스에서 재정의되면 바이트 시퀀스를 디코딩하여 생성되는 문자 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1107">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1108">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1108">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="892d9-1109">파생 클래스에서 재정의되면 지정한 바이트 배열의 모든 바이트를 디코딩하여 생성되는 문자 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1109">When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="892d9-1110">지정한 바이트 시퀀스를 디코딩할 경우 생성되는 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1110">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1111">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1111">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method.</span></span> <span data-ttu-id="892d9-1112">최대 배열 크기를 계산 하려면 사용 해야는 <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1112">To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method.</span></span> <span data-ttu-id="892d9-1113">합니다 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1113">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-1114">합니다 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 메서드는 실제 디코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1114">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding.</span></span> <span data-ttu-id="892d9-1115"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1115">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1116">여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1116">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="892d9-1117">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1117">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1118">앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1118">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="892d9-1119">이 경우 아마도 해야 호출 간에 상태를 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1119">In this case, you probably need to maintain state between calls.</span></span>  
  
-   <span data-ttu-id="892d9-1120">앱에서 문자열 출력을 처리 하는 경우 사용 해야는 <xref:System.Text.Encoding.GetString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1120">If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="892d9-1121">이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1121">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="892d9-1122">바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1122">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="892d9-1123">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1123">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1124">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1124">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1125">이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1125">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1126">사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1126">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="892d9-1127">변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1127">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1128">연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1128">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1129">다음 예제에서는 문자열 바이트 배열로 인코딩하고 바이트 문자 배열로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1129">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1130"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1130"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1131">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1131">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1132">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1132">-and-</span></span> 
 <span data-ttu-id="892d9-1133"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1133"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1134">디코딩할 첫 번째 바이트를 가리키는 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1134">A pointer to the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="892d9-1135">디코딩할 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1135">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="892d9-1136">파생 클래스에서 재정의되면 지정한 바이트 포인터에서 시작하는 바이트 시퀀스를 디코딩하여 생성되는 문자 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1136">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="892d9-1137">지정한 바이트 시퀀스를 디코딩할 경우 생성되는 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1137">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1138">정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 필요한 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1138">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1139">최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1139">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1140">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1140">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-1141">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1141">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="892d9-1142"><xref:System.Text.Encoding.GetChars%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1142">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1143">여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1143">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="892d9-1144">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1144">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1145">앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1145">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="892d9-1146">이 경우 아마도 해야 호출 간에 상태를 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1146">In this case, you probably need to maintain state between calls.</span></span>  
  
-   <span data-ttu-id="892d9-1147">사용 하도록 권장 되는 앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1147">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="892d9-1148">이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1148">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="892d9-1149">바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1149">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="892d9-1150">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1150">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1151">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1151">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1152">이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1152">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1153">사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1153">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="892d9-1154">변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1154">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1155">연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1155">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1156"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1156"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1157"><paramref name="count" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1157"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1158">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1158">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1159">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1159">-and-</span></span> 
 <span data-ttu-id="892d9-1160"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1160"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="892d9-1161">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1161">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="892d9-1162">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1162">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1163">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1163">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="892d9-1164">디코딩할 첫 번째 바이트의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1164">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="892d9-1165">디코딩할 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1165">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="892d9-1166">파생 클래스에서 재정의되면 지정한 바이트 배열의 바이트 시퀀스를 디코딩하여 생성되는 문자 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1166">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="892d9-1167">지정한 바이트 시퀀스를 디코딩할 경우 생성되는 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1167">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1168">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1168">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1169">최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1169">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1170">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1170">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-1171">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1171">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="892d9-1172"><xref:System.Text.Encoding.GetChars%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1172">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1173">여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1173">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="892d9-1174">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1174">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1175">앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1175">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="892d9-1176">이 경우 아마도 해야 호출 간에 상태를 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1176">In this case, you probably need to maintain state between calls.</span></span>  
  
-   <span data-ttu-id="892d9-1177">사용 하도록 권장 되는 앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1177">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="892d9-1178">이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1178">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="892d9-1179">바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1179">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="892d9-1180">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1180">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1181">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1181">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1182">이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1182">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1183">사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1183">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="892d9-1184">변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1184">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1185">연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1185">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1186">다음 예제에서는 한 인코딩에서 다른 문자열로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1186">The following example converts a string from one encoding to another.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 <span data-ttu-id="892d9-1187">다음 예제에서는 문자열을 바이트 배열로 인코딩합니다 및 다음 문자 배열로 바이트의 범위를 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1187">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1188"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1188"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1189"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1189"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="892d9-1190">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1190">-or-</span></span> 
 <span data-ttu-id="892d9-1191"><paramref name="index" /> 및 <paramref name="count" />가 <paramref name="bytes" />에서 올바른 범위를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1191"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1192">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1192">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1193">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1193">-and-</span></span> 
 <span data-ttu-id="892d9-1194"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1194"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="892d9-1195">파생 클래스에서 재정의되면 바이트 시퀀스를 문자 집합으로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1195">When overridden in a derived class, decodes a sequence of bytes into a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1196">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1196">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="892d9-1197">파생 클래스에서 재정의되면 지정한 바이트 배열의 모든 바이트를 문자 집합으로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1197">When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="892d9-1198">지정한 바이트 시퀀스의 디코딩 결과가 포함된 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1198">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1199"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 입력된 바이트 시퀀스에서 문자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1199"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="892d9-1200"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 다릅니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 하므로 <xref:System.Text.Encoding> 분리 된 변환이 필요 하는 동안 <xref:System.Text.Decoder> 단일 입력 스트림에 대 한 패스가 여러 개에 대 한 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1200"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1201">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1201">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-1202">**참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1202">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="892d9-1203">와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩할 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1203">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="892d9-1204">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1204">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="892d9-1205"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1205">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1206">여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1206">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="892d9-1207">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1207">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1208">앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1208">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="892d9-1209">이 경우 시켜야 호출 간에 상태를 유지 하므로 일괄 처리 하는 경우에 바이트 시퀀스를 중단 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1209">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="892d9-1210">(예를 들어 ISO-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 <xref:System.Text.Encoding.GetChars%2A> 호출 하 고 다음의 시작 부분에 계속 <xref:System.Text.Encoding.GetChars%2A> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1210">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="892d9-1211"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 이러한 불완전 한 시퀀스에 대 한 대체는 호출 되지만 <xref:System.Text.Decoder> 다음 호출에 대 한 해당 시퀀스에 저장 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="892d9-1211"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="892d9-1212">사용 하도록 권장 되는 앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1212">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="892d9-1213">이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1213">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="892d9-1214">바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1214">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="892d9-1215">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1215">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1216">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1216">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1217">이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1217">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1218">사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1218">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="892d9-1219">변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1219">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1220">연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1220">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1221">다음 예제에서는 문자열 바이트 배열로 인코딩하고 바이트 문자 배열로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1221">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1222"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1222"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1223">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1223">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1224">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1224">-and-</span></span> 
 <span data-ttu-id="892d9-1225"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1225"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1226">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1226">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="892d9-1227">디코딩할 첫 번째 바이트의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1227">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="892d9-1228">디코딩할 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1228">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="892d9-1229">파생 클래스에서 재정의되면 지정한 바이트 배열의 바이트 시퀀스를 문자 집합으로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1229">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="892d9-1230">지정한 바이트 시퀀스의 디코딩 결과가 포함된 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1230">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1231"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 입력된 바이트 시퀀스에서 문자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1231"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="892d9-1232"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 다릅니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 하므로 <xref:System.Text.Encoding> 분리 된 변환이 필요 하는 동안 <xref:System.Text.Decoder> 단일 입력 스트림에 대 한 패스가 여러 개에 대 한 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1232"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1233">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1233">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-1234">**참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1234">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="892d9-1235">와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩할 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1235">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="892d9-1236">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1236">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="892d9-1237"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1237">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1238">여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1238">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="892d9-1239">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1239">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1240">앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1240">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="892d9-1241">이 경우 시켜야 호출 간에 상태를 유지 하므로 일괄 처리 하는 경우에 바이트 시퀀스를 중단 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1241">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="892d9-1242">(예를 들어 ISO-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 <xref:System.Text.Encoding.GetChars%2A> 호출 하 고 다음의 시작 부분에 계속 <xref:System.Text.Encoding.GetChars%2A> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1242">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="892d9-1243"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 이러한 불완전 한 시퀀스에 대 한 대체는 호출 되지만 <xref:System.Text.Decoder> 다음 호출에 대 한 해당 시퀀스에 저장 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="892d9-1243"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="892d9-1244">사용 하도록 권장 되는 앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1244">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="892d9-1245">이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1245">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="892d9-1246">바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1246">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="892d9-1247">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1247">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1248">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1248">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1249">이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1249">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1250">사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1250">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="892d9-1251">변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1251">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1252">연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1252">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1253">다음 예제에서는 문자열을 바이트 배열로 인코딩합니다 및 다음 문자 배열로 바이트의 범위를 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1253">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1254"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1254"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1255"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1255"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="892d9-1256">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1256">-or-</span></span> 
 <span data-ttu-id="892d9-1257"><paramref name="index" /> 및 <paramref name="count" />가 <paramref name="bytes" />에서 올바른 범위를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1257"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1258">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1258">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1259">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1259">-and-</span></span> 
 <span data-ttu-id="892d9-1260"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1260"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1261">디코딩할 첫 번째 바이트를 가리키는 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1261">A pointer to the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="892d9-1262">디코딩할 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1262">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="892d9-1263">결과 문자 집합을 쓰기 시작할 위치를 가리키는 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1263">A pointer to the location at which to start writing the resulting set of characters.</span></span></param>
        <param name="charCount"><span data-ttu-id="892d9-1264">쓸 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1264">The maximum number of characters to write.</span></span></param>
        <summary><span data-ttu-id="892d9-1265">파생 클래스에서 재정의되면 지정한 바이트 포인터에서 시작하는 바이트 시퀀스를 지정한 문자 포인터에서 시작하여 저장되는 문자 집합으로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1265">When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="892d9-1266"><paramref name="chars" /> 매개 변수가 가리키는 위치에 쓴 실제 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1266">The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1267">정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 필요한 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1267">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1268">최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1268">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1269">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1269">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-1270"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 입력된 바이트 시퀀스에서 문자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1270"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="892d9-1271"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 다릅니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 하므로 <xref:System.Text.Encoding> 분리 된 변환이 필요 하는 동안 <xref:System.Text.Decoder> 단일 입력 스트림에 대 한 패스가 여러 개에 대 한 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1271"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1272">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 는 에서제공하는개체<xref:System.Text.Encoding.GetDecoder%2A> 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1272">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-1273">**참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1273">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="892d9-1274">와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩할 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1274">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="892d9-1275">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1275">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="892d9-1276"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1276">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1277">여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1277">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="892d9-1278">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1278">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1279">앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1279">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="892d9-1280">이 경우 시켜야 호출 간에 상태를 유지 하므로 일괄 처리 하는 경우에 바이트 시퀀스를 중단 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1280">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="892d9-1281">(예를 들어 ISO-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 <xref:System.Text.Encoding.GetChars%2A> 호출 하 고 다음의 시작 부분에 계속 <xref:System.Text.Encoding.GetChars%2A> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1281">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="892d9-1282"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 이러한 불완전 한 시퀀스에 대 한 대체는 호출 되지만 <xref:System.Text.Decoder> 다음 호출에 대 한 해당 시퀀스에 저장 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="892d9-1282"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="892d9-1283">앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1283">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="892d9-1284">이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1284">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="892d9-1285">바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1285">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="892d9-1286">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1286">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1287">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1287">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1288">이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1288">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1289">사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1289">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="892d9-1290">변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1290">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1291">연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1291">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1292"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1292"><paramref name="bytes" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="892d9-1293">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1293">-or-</span></span> 
 <span data-ttu-id="892d9-1294"><paramref name="chars" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1294"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1295"><paramref name="byteCount" /> 또는 <paramref name="charCount" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1295"><paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1296"><paramref name="charCount" />가 결과 문자 수보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1296"><paramref name="charCount" /> is less than the resulting number of characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1297">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1297">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1298">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1298">-and-</span></span> 
 <span data-ttu-id="892d9-1299"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1299"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="892d9-1300">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1300">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="892d9-1301">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1301">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1302">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1302">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="892d9-1303">디코딩할 첫 번째 바이트의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1303">The index of the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="892d9-1304">디코딩할 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1304">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="892d9-1305">결과 문자 집합을 포함할 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1305">The character array to contain the resulting set of characters.</span></span></param>
        <param name="charIndex"><span data-ttu-id="892d9-1306">결과 문자 집합을 쓰기 시작할 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1306">The index at which to start writing the resulting set of characters.</span></span></param>
        <summary><span data-ttu-id="892d9-1307">파생 클래스에서 재정의되면 지정한 바이트 배열의 바이트 시퀀스를 지정한 문자 배열로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1307">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</span></span></summary>
        <returns><span data-ttu-id="892d9-1308"><paramref name="chars" />에 쓴 실제 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1308">The actual number of characters written into <paramref name="chars" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1309">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1309">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1310">최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1310">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1311">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1311">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-1312">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 입력된 바이트 시퀀스에서 문자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1312">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="892d9-1313">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 다릅니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 하므로 <xref:System.Text.Encoding> 불연속 변환이 필요 하는 동안 <xref:System.Text.Decoder> 용인지 여러 단일 입력된 스트림을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1313">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1314">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1314">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-1315">**참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1315">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="892d9-1316">와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩할 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1316">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="892d9-1317">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1317">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="892d9-1318"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1318">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="892d9-1319">여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1319">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="892d9-1320">다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1320">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="892d9-1321">앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1321">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="892d9-1322">이 경우 시켜야 호출 간에 상태를 유지 하므로 일괄 처리 하는 경우에 바이트 시퀀스를 중단 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1322">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="892d9-1323">(예를 들어 ISO-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > 호출 하 고 다음의 시작 부분에 계속 [\], Int32, Int32, Char\<xref : System.Text.Encoding.GetChars%2A > 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1323">(For example, part of an ISO-2022 shift sequence may end one [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="892d9-1324">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 이러한 불완전 한 시퀀스에 대 한 대체는 호출 되지만 <xref:System.Text.Decoder> 다음 호출에 대 한 해당 시퀀스에 저장 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="892d9-1324">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="892d9-1325">앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1325">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="892d9-1326">이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1326">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="892d9-1327">바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1327">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="892d9-1328">그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1328">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="892d9-1329">앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1329">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="892d9-1330">이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1330">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="892d9-1331">사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1331">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="892d9-1332">변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1332">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="892d9-1333">연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1333">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1334">다음 예제에서는 한 인코딩에서 다른 문자열로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1334">The following example converts a string from one encoding to another.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 <span data-ttu-id="892d9-1335">다음 예제에서는 문자열을 바이트 배열로 인코딩합니다 및 다음 문자 배열로 바이트의 범위를 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1335">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1336"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1336"><paramref name="bytes" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="892d9-1337">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1337">-or-</span></span> 
 <span data-ttu-id="892d9-1338"><paramref name="chars" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1338"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1339"><paramref name="byteIndex" />, <paramref name="byteCount" /> 또는 <paramref name="charIndex" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1339"><paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="892d9-1340">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1340">-or-</span></span> 
 <span data-ttu-id="892d9-1341"><paramref name="byteindex" /> 및 <paramref name="byteCount" />가 <paramref name="bytes" />에서 올바른 범위를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1341"><paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span></span>  
  
<span data-ttu-id="892d9-1342">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1342">-or-</span></span> 
 <span data-ttu-id="892d9-1343"><paramref name="charIndex" />가 <paramref name="chars" />의 유효한 인덱스가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1343"><paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1344"><paramref name="chars" />의 용량(<paramref name="charIndex" /> ~ 배열 끝)이 부족해서 결과 문자를 수용할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1344"><paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1345">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1345">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1346">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1346">-and-</span></span> 
 <span data-ttu-id="892d9-1347"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1347"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="892d9-1348">파생 클래스에서 재정의되면 인코딩된 바이트 시퀀스를 문자 시퀀스로 변환하는 디코더를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1348">When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</span></span></summary>
        <returns><span data-ttu-id="892d9-1349">인코딩된 바이트 시퀀스를 문자 시퀀스로 변환하는 <see cref="T:System.Text.Decoder" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1349">A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1350"><xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 메서드를 비슷한 방식으로 문자의 순차 블록 순차 블록 바이트 변환 된 <xref:System.Text.Encoding.GetChars%2A> 이 클래스의 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1350">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class.</span></span> <span data-ttu-id="892d9-1351">그러나는 <xref:System.Text.Decoder> 블록으로 확장 되는 바이트 시퀀스를 디코딩하고 올바르게 있도록 호출 간의 상태 정보를 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1351">However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks.</span></span> <span data-ttu-id="892d9-1352"><xref:System.Text.Decoder> 도 데이터 블록의 끝에 후행 바이트를 유지 하 고 디코딩 작업은 다음에 후행 바이트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1352">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="892d9-1353">따라서 <xref:System.Text.Encoding.GetDecoder%2A> 고 <xref:System.Text.Encoding.GetEncoder%2A> 있으므로 아주 유용 네트워크 전송 및 파일 작업에 대 한 전체 데이터 스트림 대신 데이터 블록을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1353">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="892d9-1354">기본 구현은 반환을 <see cref="T:System.Text.Decoder" /> 를 호출 하는 합니다 <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> 및 <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> 현재 메서드 <see cref="T:System.Text.Encoding" />합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1354">The default implementation returns a <see cref="T:System.Text.Decoder" /> that calls the <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="892d9-1355">반환 하려면이 메서드를 재정의 해야 합니다는 <see cref="T:System.Text.Decoder" /> 호출 간에 상태를 유지 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1355">You must override this method to return a <see cref="T:System.Text.Decoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1356">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1356">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="892d9-1357">파생 클래스에서 재정의되면 유니코드 문자 시퀀스를 인코딩된 바이트 시퀀스로 변환하는 인코더를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1357">When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="892d9-1358">유니코드 문자 시퀀스를 인코딩된 바이트 시퀀스로 변환하는 <see cref="T:System.Text.Encoder" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1358">A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1359">합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 비슷한 방식으로 바이트 순차 블록 문자의 순차 블록 변환는 <xref:System.Text.Encoding.GetBytes%2A> 이 클래스의 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1359">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class.</span></span> <span data-ttu-id="892d9-1360">그러나는 <xref:System.Text.Encoder> 블록으로 확장 되는 문자 시퀀스 올바르게 인코딩하기 호출 간의 상태 정보를 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1360">However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks.</span></span> <span data-ttu-id="892d9-1361"><xref:System.Text.Encoder> 또한 후행 유지 되는 데이터 블록의 끝 문자 하 고 다음 인코딩 작업에서 후행 문자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1361">The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="892d9-1362">예를 들어 데이터 블록 수는 일치 하지 않는 상위 서로게이트를 사용 하 여 종료 및 다음 데이터 블록에 일치 하는 하위 서로게이트 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1362">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="892d9-1363">따라서 <xref:System.Text.Encoding.GetDecoder%2A> 고 <xref:System.Text.Encoding.GetEncoder%2A> 있으므로 아주 유용 네트워크 전송 및 파일 작업에 대 한 전체 데이터 스트림 대신 데이터 블록을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1363">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="892d9-1364">기본 구현은 반환을 <see cref="T:System.Text.Encoder" /> 를 호출 하는 합니다 <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> 및 <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> 현재 메서드 <see cref="T:System.Text.Encoding" />합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1364">The default implementation returns a <see cref="T:System.Text.Encoder" /> that calls the <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="892d9-1365">반환 하려면이 메서드를 재정의 해야 합니다는 <see cref="T:System.Text.Encoder" /> 호출 간에 상태를 유지 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1365">You must override this method to return a <see cref="T:System.Text.Encoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1366">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1366">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="892d9-1367">지정한 코드 페이지에 대한 인코딩을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1367">Returns an encoding for the specified code page.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="892d9-1368">기본 설정 인코딩의 코드 페이지 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1368">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="892d9-1369">가능한 값은 <see cref="T:System.Text.Encoding" /> 클래스 항목에 나타나는 테이블의 코드 페이지 열에 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1369">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>  
  
<span data-ttu-id="892d9-1370">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1370">-or-</span></span> 
<span data-ttu-id="892d9-1371">기본 인코딩을 사용하려면 0을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1371">0 (zero), to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="892d9-1372">지정한 코드 페이지 식별자와 관련된 인코딩을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1372">Returns the encoding associated with the specified code page identifier.</span></span></summary>
        <returns><span data-ttu-id="892d9-1373">지정한 코드 페이지와 관련된 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1373">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1374">대체 (fallback) 처리기의 인코딩 형식을 종속 `codepage`합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1374">The fallback handler depends on the encoding type of `codepage`.</span></span> <span data-ttu-id="892d9-1375">경우 `codepage` 코드 페이지 또는 더블 바이트 문자 집합 (DBCS) 인코딩을 최적된 대체 (fallback) 처리기 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1375">If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="892d9-1376">그렇지 않은 경우 교체 대체 (fallback) 처리기가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1376">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="892d9-1377">이러한 대체 (fallback) 처리기는 앱에 대 한 적합 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1377">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="892d9-1378">으로 지정 된 인코딩을 사용 하 여 대체 (fallback) 처리기를 지정 `codepage`를 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1378">To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>  
  
 <span data-ttu-id="892d9-1379">.NET framework에서 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하려면 기본 플랫폼에 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1379">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="892d9-1380">그러나.NET Framework에는 기본적으로 일부 인코딩은 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1380">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="892d9-1381">코드 페이지 목록을 보려면 참조는 <xref:System.Text.Encoding> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1381">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="892d9-1382">.NET core에서는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 기본적으로.NET Core에서 지 원하는 인코딩을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1382">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="892d9-1383">두.NET 구현에서 호출할 수 있습니다 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져오는 방법 <xref:System.Text.EncodingInfo> 사용할 수 있는 모든 인코딩에 대 한 정보를 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1383">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="892d9-1384">.NET Core에서 고유 하 게 사용할 수 있는 또는.NET Framework의 특정 플랫폼 버전에서 기본적으로 지원 되는 인코딩은 외에도 <xref:System.Text.Encoding.GetEncoding%2A> 를등록하여사용할수있는모든추가인코딩을메서드<xref:System.Text.EncodingProvider> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1384">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="892d9-1385">인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체를이 메서드가 반환 개가 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1385">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  

<span data-ttu-id="892d9-1386">0 값을 제공할 수도 있습니다는 `codepage` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1386">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="892d9-1387">정확한 동작은 해당 여부 모든 인코딩을 사용할 수 있게 된 등록 하 여 종속는 <xref:System.Text.EncodingProvider> 개체:</span><span class="sxs-lookup"><span data-stu-id="892d9-1387">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="892d9-1388">하나 이상의 인코딩 공급자를 등록 한 경우 마지막으로 때 인코딩을 반환할 하기로 등록 된 공급자의 인코딩을 반환 합니다 <xref:System.Text.Encoding.GetEncoding%2A> 메서드에 전달 됩니다는 `codepage` 0 인수.</span><span class="sxs-lookup"><span data-stu-id="892d9-1388">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>     

- <span data-ttu-id="892d9-1389">.NET Framework에서 인코딩 없이 공급자가 등록을 하는 경우는 <xref:System.Text.CodePagesEncodingProvider> 등록 된 인코딩 공급자에는 등록 된 인코딩 공급자가 없습니다 처리 하는 경우 또는 `codepage` 값 운영 체제의 활성 코드 페이지 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1389">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the operating system's active code page.</span></span> <span data-ttu-id="892d9-1390">Windows 시스템에서 활성 코드 페이지를 확인 하는 Windows를 호출 [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Windows 바탕 화면에서.NET Framework에서 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1390">To determine the active code page on Windows systems, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>

- <span data-ttu-id="892d9-1391">.NET Core, 인코딩 공급자가 등록 또는 등록 된 인코딩 공급자가 없습니다를 처리 하는 경우에 없는 경우에 `codepage` 값 0을 반환 합니다는 <xref:System.Text.UTF8Encoding>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1391">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding>.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="892d9-1392">일부 지원 되지 않는 코드 페이지 원인을 <xref:System.ArgumentException> 다른 반면 throw 되는 <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1392">Some unsupported code pages cause an <xref:System.ArgumentException> to be thrown, whereas others cause a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="892d9-1393">따라서 코드 모든 catch 해야 예외 섹션에 표시 된 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1393">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="892d9-1394">ANSI 코드 페이지가 서로 다른 컴퓨터에 다른 수 있으며 데이터가 손상, 단일 컴퓨터에서 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1394">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="892d9-1395">이러한 이유로 현재 코드 페이지는 ANSI 코드 페이지를 사용 하는 경우 인코딩 및 기본 코드 페이지를 사용 하 여 데이터를 디코딩 반환한 `Encoding.GetEncoding(0)` 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1395">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="892d9-1396">가장 일관 된 결과 유니코드 인코딩인 u t F-8 (코드 페이지 65001) 또는 u t F-16이 고 같은 특정 코드 페이지를 대신 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1396">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>  
  
 <span data-ttu-id="892d9-1397"><xref:System.Text.Encoding.GetEncoding%2A> 기본 설정 사용 하 여 캐시 된 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1397"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="892d9-1398">인스턴스를 가져오는 다른 설정을 사용 하 여 파생된 클래스의 생성자를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1398">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="892d9-1399">예를 들어를 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1399">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  

   
  
## Examples  
 <span data-ttu-id="892d9-1400">다음 예제에서는 같은 인코딩 (코드 페이지에서 하나) 및 다른 이름으로, 두 인스턴스와 서로 같은지 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1400">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1401"><paramref name="codepage" />가 0보다 작거나 65535보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1401"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1402"><paramref name="codepage" />가 내부 플랫폼에서 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1402"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="892d9-1403"><paramref name="codepage" />가 내부 플랫폼에서 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1403"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1404">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1404">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="892d9-1405">기본 설정 인코딩의 코드 페이지 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1405">The code page name of the preferred encoding.</span></span> <span data-ttu-id="892d9-1406"><see cref="P:System.Text.Encoding.WebName" /> 속성에서 반환된 값이 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1406">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="892d9-1407">가능한 값은 <see cref="T:System.Text.Encoding" /> 클래스 항목에 나타나는 테이블의 이름 열에 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1407">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <summary><span data-ttu-id="892d9-1408">지정한 코드 페이지 이름과 관련된 인코딩을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1408">Returns the encoding associated with the specified code page name.</span></span></summary>
        <returns><span data-ttu-id="892d9-1409">지정한 코드 페이지와 관련된 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1409">The encoding  associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1410">대체 (fallback) 처리기의 인코딩 형식을 종속 `name`합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1410">The fallback handler depends on the encoding type of `name`.</span></span> <span data-ttu-id="892d9-1411">경우 `name` 코드 페이지 또는 더블 바이트 문자 집합 (DBCS) 인코딩을 최적된 대체 (fallback) 처리기 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1411">If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="892d9-1412">그렇지 않은 경우 교체 대체 (fallback) 처리기가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1412">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="892d9-1413">이러한 대체 (fallback) 처리기는 앱에 대 한 적합 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1413">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="892d9-1414">으로 지정 된 인코딩을 사용 하 여 대체 (fallback) 처리기를 지정 `name`를 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1414">To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>  

<span data-ttu-id="892d9-1415">.NET framework에서 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하려면 기본 플랫폼에 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1415">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="892d9-1416">그러나.NET Framework에는 기본적으로 일부 인코딩은 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1416">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="892d9-1417">코드 페이지 목록을 보려면 참조는 <xref:System.Text.Encoding> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1417">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="892d9-1418">.NET core에서는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 기본적으로.NET Core에서 지 원하는 인코딩을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1418">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="892d9-1419">두.NET 구현에서 호출할 수 있습니다 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져오는 방법 <xref:System.Text.EncodingInfo> 사용할 수 있는 모든 인코딩에 대 한 정보를 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1419">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="892d9-1420">.NET Core에서 고유 하 게 사용할 수 있는 또는.NET Framework의 특정 플랫폼 버전에서 기본적으로 지원 되는 인코딩은 외에도 <xref:System.Text.Encoding.GetEncoding%2A> 를등록하여사용할수있는모든추가인코딩을메서드<xref:System.Text.EncodingProvider> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1420">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="892d9-1421">인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체를이 메서드가 반환 개가 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1421">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  
   
> [!NOTE]
>  <span data-ttu-id="892d9-1422">ANSI 코드 페이지를 다른 컴퓨터에 다른 수 또는 단일 컴퓨터의 경우 데이터가 손상에 대 한 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1422">The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</span></span> <span data-ttu-id="892d9-1423">가장 일관 된 결과 특정 코드 페이지 대신 유니코드 u t F-16이 고 u t F-8 (코드 페이지 65001) 등을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1423">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>  
 
  
 <span data-ttu-id="892d9-1424"><xref:System.Text.Encoding.GetEncoding%2A> 기본 설정 사용 하 여 캐시 된 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1424"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="892d9-1425">인스턴스를 가져오는 다른 설정을 사용 하 여 파생된 클래스의 생성자를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1425">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="892d9-1426">예를 들어를 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1426">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  
  
## Examples  
 <span data-ttu-id="892d9-1427">다음 예제에서는 같은 인코딩 (코드 페이지에서 하나) 및 다른 이름으로, 두 인스턴스와 서로 같은지 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1427">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1428"><paramref name="name" />이 올바른 코드 페이지 이름이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1428"><paramref name="name" /> is not a valid code page name.</span></span>  
  
<span data-ttu-id="892d9-1429">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1429">-or-</span></span> 
<span data-ttu-id="892d9-1430"><paramref name="name" />으로 표시된 코드 페이지가 내부 플랫폼에서 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1430">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1431">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1431">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="892d9-1432">기본 설정 인코딩의 코드 페이지 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1432">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="892d9-1433">가능한 값은 <see cref="T:System.Text.Encoding" /> 클래스 항목에 나타나는 테이블의 코드 페이지 열에 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1433">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>  
  
<span data-ttu-id="892d9-1434">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1434">-or-</span></span> 
<span data-ttu-id="892d9-1435">기본 인코딩을 사용하려면 0을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1435">0 (zero), to use the default encoding.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="892d9-1436">현재 인코딩으로 문자를 인코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1436">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="892d9-1437">현재 인코딩으로 바이트 시퀀스를 디코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1437">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="892d9-1438">지정한 코드 페이지 식별자와 관련된 인코딩을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1438">Returns the encoding associated with the specified code page identifier.</span></span> <span data-ttu-id="892d9-1439">매개 변수는 인코딩할 수 없는 문자 및 디코딩할 수 없는 바이트 시퀀스에 대한 오류 처리기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1439">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="892d9-1440">지정한 코드 페이지와 관련된 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1440">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="892d9-1441">일부 지원 되지 않는 코드 페이지는 예외를 발생 시킬 <xref:System.ArgumentException> throw 될 다른 반면 <xref:System.NotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1441">Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="892d9-1442">따라서 코드 모든 catch 해야 예외 섹션에 표시 된 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1442">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>  

<span data-ttu-id="892d9-1443">.NET framework에서 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하려면 기본 플랫폼에 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1443">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="892d9-1444">그러나.NET Framework에는 기본적으로 일부 인코딩은 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1444">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="892d9-1445">코드 페이지 목록을 보려면 참조는 <xref:System.Text.Encoding> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1445">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="892d9-1446">.NET core에서는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 기본적으로.NET Core에서 지 원하는 인코딩을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1446">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="892d9-1447">두.NET 구현에서 호출할 수 있습니다 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져오는 방법 <xref:System.Text.EncodingInfo> 사용할 수 있는 모든 인코딩에 대 한 정보를 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1447">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="892d9-1448">.NET Core에서 고유 하 게 사용할 수 있는 또는.NET Framework의 특정 플랫폼 버전에서 기본적으로 지원 되는 인코딩은 외에도 <xref:System.Text.Encoding.GetEncoding%2A> 를등록하여사용할수있는모든추가인코딩을메서드<xref:System.Text.EncodingProvider> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1448">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="892d9-1449">인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체를이 메서드가 반환 개가 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1449">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  

<span data-ttu-id="892d9-1450">0 값을 제공할 수도 있습니다는 `codepage` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1450">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="892d9-1451">정확한 동작은 해당 여부 모든 인코딩을 사용할 수 있게 된 등록 하 여 종속는 <xref:System.Text.EncodingProvider> 개체:</span><span class="sxs-lookup"><span data-stu-id="892d9-1451">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="892d9-1452">하나 이상의 인코딩 공급자를 등록 한 경우 마지막으로 때 인코딩을 반환할 하기로 등록 된 공급자의 인코딩을 반환 합니다 <xref:System.Text.Encoding.GetEncoding%2A> 메서드에 전달 됩니다는 `codepage` 0 인수.</span><span class="sxs-lookup"><span data-stu-id="892d9-1452">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>     

- <span data-ttu-id="892d9-1453">.NET Framework에서 인코딩 없이 공급자가 등록을 하는 경우는 <xref:System.Text.CodePagesEncodingProvider> 등록 된 인코딩 공급자에는 등록 된 인코딩 공급자가 없습니다 처리 하는 경우 또는 `codepage` 값 활성 코드 페이지 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1453">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the active code page.</span></span>

- <span data-ttu-id="892d9-1454">.NET Core, 인코딩 공급자가 등록 또는 등록 된 인코딩 공급자가 없습니다를 처리 하는 경우에 없는 경우에 `codepage` 값 0을 반환 합니다는 <xref:System.Text.UTF8Encoding> 인코딩.</span><span class="sxs-lookup"><span data-stu-id="892d9-1454">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding> encoding.</span></span>

> [!NOTE]
>  <span data-ttu-id="892d9-1455">ANSI 코드 페이지가 서로 다른 컴퓨터에 다른 수 있으며 데이터가 손상, 단일 컴퓨터에서 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1455">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="892d9-1456">이러한 이유로 현재 코드 페이지는 ANSI 코드 페이지를 사용 하는 경우 인코딩 및 기본 코드 페이지를 사용 하 여 데이터를 디코딩 반환한 `Encoding.GetEncoding(0)` 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1456">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="892d9-1457">가장 일관 된 결과 특정 코드 페이지 대신 유니코드 u t F-16이 고 u t F-8 (코드 페이지 65001) 등을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1457">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span> 
  
 <span data-ttu-id="892d9-1458">활성 코드 페이지와 관련 된 인코딩을 가져오려면 제공할 수 있습니다 하거나 값 0에 대 한 합니다 `codepage` 인수 또는 Windows 바탕 화면에서.NET Framework에서 코드를 실행 하는 경우의 값을 검색 합니다 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1458">To get the encoding associated with the active code page, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="892d9-1459">현재 활성 코드 페이지를 확인 하는 Windows를 호출 [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Windows 바탕 화면에서.NET Framework에서 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1459">To determine the current active code page, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>  
  
 <span data-ttu-id="892d9-1460"><xref:System.Text.Encoding.GetEncoding%2A> 기본 설정 사용 하 여 캐시 된 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1460"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="892d9-1461">인스턴스를 가져오는 다른 설정을 사용 하 여 파생된 클래스의 생성자를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1461">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="892d9-1462">예를 들어를 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1462">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1463">다음 예제는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1463">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1464"><paramref name="codepage" />가 0보다 작거나 65535보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1464"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1465"><paramref name="codepage" />가 내부 플랫폼에서 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1465"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="892d9-1466"><paramref name="codepage" />가 내부 플랫폼에서 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1466"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1467">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1467">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="892d9-1468">기본 설정 인코딩의 코드 페이지 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1468">The code page name of the preferred encoding.</span></span> <span data-ttu-id="892d9-1469"><see cref="P:System.Text.Encoding.WebName" /> 속성에서 반환된 값이 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1469">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="892d9-1470">가능한 값은 <see cref="T:System.Text.Encoding" /> 클래스 항목에 나타나는 테이블의 이름 열에 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1470">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="892d9-1471">현재 인코딩으로 문자를 인코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1471">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="892d9-1472">현재 인코딩으로 바이트 시퀀스를 디코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1472">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="892d9-1473">지정한 코드 페이지 이름과 관련된 인코딩을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1473">Returns the encoding associated with the specified code page name.</span></span> <span data-ttu-id="892d9-1474">매개 변수는 인코딩할 수 없는 문자 및 디코딩할 수 없는 바이트 시퀀스에 대한 오류 처리기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1474">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="892d9-1475">지정한 코드 페이지와 관련된 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1475">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="892d9-1476">.NET framework에서 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하려면 기본 플랫폼에 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1476">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="892d9-1477">그러나.NET Framework에는 기본적으로 일부 인코딩은 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1477">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="892d9-1478">코드 페이지 목록을 보려면 참조는 <xref:System.Text.Encoding> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1478">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="892d9-1479">.NET core에서는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 기본적으로.NET Core에서 지 원하는 인코딩을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1479">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="892d9-1480">두.NET 구현에서 호출할 수 있습니다 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져오는 방법 <xref:System.Text.EncodingInfo> 사용할 수 있는 모든 인코딩에 대 한 정보를 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1480">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="892d9-1481">.NET Core에서 고유 하 게 사용할 수 있는 또는.NET Framework의 특정 플랫폼 버전에서 기본적으로 지원 되는 인코딩은 외에도 <xref:System.Text.Encoding.GetEncoding%2A> 를등록하여사용할수있는모든추가인코딩을메서드<xref:System.Text.EncodingProvider> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1481">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="892d9-1482">인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체를이 메서드가 반환 개가 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1482">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="892d9-1483">ANSI 코드 페이지가 서로 다른 컴퓨터에 다른 수 있으며 데이터가 손상, 단일 컴퓨터에서 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1483">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="892d9-1484">가장 일관 된 결과 유니코드 인코딩인 u t F-8 (코드 페이지 65001) 또는 u t F-16이 고 같은 특정 코드 페이지를 대신 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1484">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>  
  
 <span data-ttu-id="892d9-1485"><xref:System.Text.Encoding.GetEncoding%2A> 기본 설정 사용 하 여 캐시 된 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1485"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="892d9-1486">인스턴스를 가져오는 다른 설정을 사용 하 여 파생된 클래스의 생성자를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1486">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="892d9-1487">예를 들어를 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1487">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1488">다음 예제는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1488">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1489"><paramref name="name" />이 올바른 코드 페이지 이름이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1489"><paramref name="name" /> is not a valid code page name.</span></span>  
  
<span data-ttu-id="892d9-1490">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1490">-or-</span></span> 
<span data-ttu-id="892d9-1491"><paramref name="name" />으로 표시된 코드 페이지가 내부 플랫폼에서 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1491">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1492">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1492">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="892d9-1493">모든 인코딩을 포함하는 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1493">Returns an array that contains all encodings.</span></span></summary>
        <returns><span data-ttu-id="892d9-1494">모든 인코딩을 포함하는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1494">An array that contains all encodings.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1495">이 메서드는 코드 페이지에서 고유 하 게 구분 하는 지원 되는 인코딩 목록을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1495">This method returns a list of supported encodings, uniquely distinguished by code page.</span></span> <span data-ttu-id="892d9-1496">지원 되는 인코딩을 나열 하는 테이블에 대 한 참조를 <xref:System.Text.Encoding> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1496">For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="892d9-1497">반환한 지원 되는 인코딩 목록은 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 메서드는 제공 된 모든 추가 인코딩을 포함 하지 <xref:System.Text.EncodingProvider> 구현을 호출 하 여 등록 된는 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1497">The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method.</span></span>  
  
 <span data-ttu-id="892d9-1498">.NET Framework에서 50220 및 50222 인코딩은 둘 다 이름과 연결 된 "iso-2022-jp" 있지만 같지는있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1498">On the .NET Framework, encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical.</span></span> <span data-ttu-id="892d9-1499">인코딩 50220 반자 가타카나 반자 가타카나 문자를 변환, 인코딩 50222 반면 반자 가타카나 문자를 인코딩할 shift-/ 시프트 아웃 시퀀스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1499">Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.</span></span> <span data-ttu-id="892d9-1500">50222 인코딩에 대 한 표시 이름은 "일본어 (JIS-1 바이트 Kana-허용 하므로 / SI)" 인코딩에서 구분 하기 위해 표시 된 50220 이름을 "일본어 (JIS)".</span><span class="sxs-lookup"><span data-stu-id="892d9-1500">The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</span></span>  
  
 <span data-ttu-id="892d9-1501">요청 된 인코딩 이름 "iso-2022-jp",.NET Framework는 50220 인코딩.</span><span class="sxs-lookup"><span data-stu-id="892d9-1501">If you request the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220.</span></span> <span data-ttu-id="892d9-1502">그러나 앱에 대 한 적합 한 인코딩을 종속 반자 가타카나 문자가 기본 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1502">However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.</span></span>  
  
 <span data-ttu-id="892d9-1503">특정 인코딩의 가져오려면 사용할지는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1503">To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method.</span></span>  
  
 <span data-ttu-id="892d9-1504"><xref:System.Text.Encoding.GetEncodings%2A> 사용자 파일의 인코딩 목록으로 제공할 수 사용 되기도 **다른 이름으로 저장** 대화 상자.</span><span class="sxs-lookup"><span data-stu-id="892d9-1504"><xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box.</span></span> <span data-ttu-id="892d9-1505">그러나 여러 비유니코드 인코딩을은 불완전 한 많은 문자를 및 "?", 또는 다른 플랫폼에서 동작이 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1505">However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms.</span></span> <span data-ttu-id="892d9-1506">기본적으로 utf-8 또는 u t F-16을 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1506">Consider using UTF-8 or UTF-16 as the default.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1507">다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1507">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1508">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1508">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="892d9-1509">현재 인스턴스의 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1509">Returns the hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="892d9-1510">현재 인스턴스에 대한 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1510">The hash code for the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount"><span data-ttu-id="892d9-1511">인코딩할 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1511">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="892d9-1512">파생 클래스에서 재정의되면 지정한 문자 수의 문자를 인코딩하여 만들 바이트 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1512">When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</span></span></summary>
        <returns><span data-ttu-id="892d9-1513">지정한 수의 문자를 인코딩할 경우 생성되는 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1513">The maximum number of bytes produced by encoding the specified number of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1514">합니다 `charCount` 매개 변수 개수를 실제로 지정 <xref:System.Char> .NET 유니코드 문자를 나타내기 위해 내부적으로 u t F-16을 사용 하기 때문에, 인코딩할 유니코드 문자를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1514">The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because .NET internally uses UTF-16 to represent Unicode characters.</span></span> <span data-ttu-id="892d9-1515">따라서 씩 대부분의 유니코드 문자를 표현할 수 있습니다 <xref:System.Char> 개체가 아니라 예를 들어, 서로게이트 쌍을 나타내는 유니코드 문자는 두 개가 필요 <xref:System.Char> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1515">Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects.</span></span>  
  
 <span data-ttu-id="892d9-1516">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 바이트를 저장 하는 결과 사용할지를 <xref:System.Text.Encoding.GetByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1516">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="892d9-1517">최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1517">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="892d9-1518">합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1518">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-1519"><xref:System.Text.Encoding.GetMaxByteCount%2A> 현재 선택 된 최악의 경우를 비롯 한 최악의 숫자 검색 <xref:System.Text.EncoderFallback>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1519"><xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="892d9-1520">잠재적으로 큰 문자열을 사용 하 여 대체를 선택한 경우 <xref:System.Text.Encoding.GetMaxByteCount%2A> 여기서 인코딩에 최악의 경우 전환 해야 하는 모든 문자에 대 한 모드의 경우에 특히 큰 값을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1520">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.</span></span> <span data-ttu-id="892d9-1521">예를 들어이 값은 ISO-2022-JP에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1521">For example, this can happen for ISO-2022-JP.</span></span> <span data-ttu-id="892d9-1522">자세한 내용은 블로그 항목을 참조 하세요. "[Encoding.GetMaxByteCount()와 Encoding.GetMaxCharCount() 란?](https://go.microsoft.com/fwlink/?LinkId=153702)"</span><span class="sxs-lookup"><span data-stu-id="892d9-1522">For more information, see the blog entry "[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](https://go.microsoft.com/fwlink/?LinkId=153702)"</span></span> <span data-ttu-id="892d9-1523">(http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).</span><span class="sxs-lookup"><span data-stu-id="892d9-1523">(http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).</span></span>  
  
 <span data-ttu-id="892d9-1524">대부분의 경우이 메서드는 작은 문자열에 대 한 적절 한 값을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1524">In most cases, this method retrieves reasonable values for small strings.</span></span> <span data-ttu-id="892d9-1525">큰 문자열에 대 한 매우 큰 버퍼를 사용 하 여 및 보다 적절 한 크기 버퍼가 너무 작은 경우 드문 경우에서 오류를 catch 하는 중 하나를 선택 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1525">For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.</span></span> <span data-ttu-id="892d9-1526">사용 하는 다른 방법을 고려해 야 할 수도 있습니다 <xref:System.Text.Encoding.GetByteCount%2A> 또는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1526">You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="892d9-1527">사용 하는 경우 <xref:System.Text.Encoding.GetMaxByteCount%2A>, 입력된 버퍼의 최대 크기를 기준으로 출력 버퍼를 할당 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1527">When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="892d9-1528">출력 버퍼 크기에 제한 되는 경우 사용할 수 있습니다는 <xref:System.Text.Encoding.Convert%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1528">If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.</span></span>  
  
 <span data-ttu-id="892d9-1529"><xref:System.Text.Encoding.GetMaxByteCount%2A> 이전 디코더 작업에서 잠재적인 남겨진 서로게이트를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1529">Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation.</span></span> <span data-ttu-id="892d9-1530">디코더를 인해 인코딩에 싱글바이트 ASCII와 같은 2를 검색 방법 1의 값을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1530">Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.</span></span> <span data-ttu-id="892d9-1531">기능을 사용할지는 <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> 이 정보가 필요한 경우 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1531">You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="892d9-1532">`GetMaxByteCount(N)` 동일한 값은 반드시 `N* GetMaxByteCount(1)`입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1532">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1533">다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1533">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1534"><paramref name="charCount" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1534"><paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="892d9-1535">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1535">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1536">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1536">-and-</span></span> 
 <span data-ttu-id="892d9-1537"><see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1537"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="892d9-1538">모든 <see cref="T:System.Text.Encoding" /> 구현에서 버퍼 오버플로 예외가 발생 하지 않는지 버퍼는이 메서드의 계산의 결과 따라 크기가 결정 하는 경우를 보장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1538">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount"><span data-ttu-id="892d9-1539">디코딩할 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1539">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="892d9-1540">파생 클래스에서 재정의되면 지정한 수의 바이트를 디코딩하여 생성되는 최대 문자 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1540">When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="892d9-1541">지정한 수의 바이트를 디코딩할 경우 생성되는 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1541">The maximum number of characters produced by decoding the specified number of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1542">에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1542">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1543">최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1543">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="892d9-1544">합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1544">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="892d9-1545"><xref:System.Text.Encoding.GetMaxCharCount%2A> 현재 선택 된 최악의 경우를 비롯 한 최악의 숫자 검색 <xref:System.Text.DecoderFallback>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1545"><xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="892d9-1546">잠재적으로 큰 문자열을 사용 하 여 대체를 선택한 경우 <xref:System.Text.Encoding.GetMaxCharCount%2A> 큰 값을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1546">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.</span></span>  
  
 <span data-ttu-id="892d9-1547">대부분의 경우이 메서드는 작은 문자열에 대해 적합 한 숫자를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1547">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="892d9-1548">큰 문자열에 대 한 매우 큰 버퍼를 사용 하 여 및 보다 적절 한 크기의 버퍼가 너무 작아서 드문 경우에서 오류를 catch 하는 중 하나를 선택 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1548">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.</span></span> <span data-ttu-id="892d9-1549">사용 하는 다른 방법을 고려해 야 할 수도 있습니다 <xref:System.Text.Encoding.GetCharCount%2A> 또는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1549">You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="892d9-1550"><xref:System.Text.Encoding.GetMaxCharCount%2A> 관계가 없으며 <xref:System.Text.Encoding.GetBytes%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1550"><xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>.</span></span> <span data-ttu-id="892d9-1551">비슷한 기능을 사용 해야 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>를 사용 해야 <xref:System.Text.Encoding.GetMaxByteCount%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1551">If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span></span>  
  
 <span data-ttu-id="892d9-1552">사용 하는 경우 <xref:System.Text.Encoding.GetMaxCharCount%2A>, 입력된 버퍼의 최대 크기를 기준으로 출력 버퍼를 할당 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1552">When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="892d9-1553">출력 버퍼 크기에 제한 되는 경우 사용할 수 있습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="892d9-1553">If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="892d9-1554"><xref:System.Text.Encoding.GetMaxCharCount%2A> 이전 인코더 작업에서 남아 있는 바이트에 대 한 최악의 경우를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1554">Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation.</span></span> <span data-ttu-id="892d9-1555">대부분의 코드 페이지에 대 한 값을 1 보다 크거나 검색 값이 0이 메서드에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1555">For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="892d9-1556">`GetMaxCharCount(N)` 동일한 값은 반드시 `N* GetMaxCharCount(1)`입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1556">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1557">다음 예제에서는 문자열 바이트 배열로 인코딩하고 바이트 문자 배열로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1557">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1558"><paramref name="byteCount" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1558"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1559">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1559">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1560">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1560">-and-</span></span> 
 <span data-ttu-id="892d9-1561"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1561"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="892d9-1562">모든 <see cref="T:System.Text.Encoding" /> 구현에서 버퍼 오버플로 예외가 발생 하지 않는지 버퍼는이 메서드의 계산의 결과 따라 크기가 결정 하는 경우를 보장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1562">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="892d9-1563">파생 클래스에서 재정의되면 사용되는 인코딩을 지정하는 바이트 시퀀스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1563">When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</span></span></summary>
        <returns><span data-ttu-id="892d9-1564">사용되는 인코딩을 지정하는 바이트 시퀀스가 포함된 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1564">A byte array containing a sequence of bytes that specifies the encoding used.</span></span>  
  
<span data-ttu-id="892d9-1565">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1565">-or-</span></span> 
<span data-ttu-id="892d9-1566">프리앰블이 필요하지 않으면 길이가 0인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1566">A byte array of length zero, if a preamble is not required.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1567">필요에 따라는 <xref:System.Text.Encoding> 개체는 인코딩 프로세스에서 발생 하는 바이트 시퀀스를 붙일 수 있습니다 하는 바이트 배열이 프리앰블을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1567">Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="892d9-1568">머리말 (유니코드 코드 포인트 U + FEFF)에서 바이트 순서 표시가 들어 디코더에서 바이트 순서와 변환 형식 또는 u t F를 결정 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1568">If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>  
  
 <span data-ttu-id="892d9-1569">유니코드 바이트 순서 표시 (BOM) (16 진수)에서 다음과 같이 serialize 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1569">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="892d9-1570">UTF-8: EF BB BF</span><span class="sxs-lookup"><span data-stu-id="892d9-1570">UTF-8: EF BB BF</span></span>  
  
-   <span data-ttu-id="892d9-1571">Utf-16 big endian 바이트 순서: FE FF</span><span class="sxs-lookup"><span data-stu-id="892d9-1571">UTF-16 big endian byte order: FE FF</span></span>  
  
-   <span data-ttu-id="892d9-1572">Utf-16 little endian 바이트 순서: FF FE</span><span class="sxs-lookup"><span data-stu-id="892d9-1572">UTF-16 little endian byte order: FF FE</span></span>  
  
-   <span data-ttu-id="892d9-1573">UTF-32 big endian 바이트 순서: 00 00 FE FF</span><span class="sxs-lookup"><span data-stu-id="892d9-1573">UTF-32 big endian byte order: 00 00 FE FF</span></span>  
  
-   <span data-ttu-id="892d9-1574">UTF-32 little endian 바이트 순서: FF FE 00 00</span><span class="sxs-lookup"><span data-stu-id="892d9-1574">UTF-32 little endian byte order: FF FE 00 00</span></span>  
  
 <span data-ttu-id="892d9-1575">거의 손실에 대 한 참조는 파일에 대 한 인코딩 특정 식별을 제공 하기 때문에 BOM을 사용 해야는 <xref:System.Text.Encoding> 않았을 때 비즈니스를 저장 하는 임의 텍스트 파일 또는 개체, 예를 들어 부적절 하 게 웹 데이터를 태그가 있거나 없는 가 국제 문제 또는 기타 데이터.</span><span class="sxs-lookup"><span data-stu-id="892d9-1575">You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</span></span> <span data-ttu-id="892d9-1576">데이터는 일관 되 게 제대로 태그 지정, 가급적 utf-8 또는 u t F-16에서 종종 사용자 문제를 방지할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1576">Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</span></span>  
  
 <span data-ttu-id="892d9-1577">인코딩 형식을 제공 하는 표준에 대 한 BOM 다소 중복 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1577">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="892d9-1578">그러나 올바른 인코딩 헤더를 보내도록 서버를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1578">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="892d9-1579">또는 사용할 수 있습니다 대체 방법으로 인코딩을 분실할 그렇지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="892d9-1579">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>  
  
 <span data-ttu-id="892d9-1580">BOM을 사용 하 여 몇 가지 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1580">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="892d9-1581">예를 들어 BOM을 사용 하는 데이터베이스 필드를 제한 하는 방법을 알면 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1581">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="892d9-1582">파일의 연결 문제가 될 수 또한 예를 들어, 파일 등에서 병합 될 때는 데이터 중간에 불필요 한 문자가 포함 될 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1582">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="892d9-1583">몇 가지 단점에도 불구 하 고 있지만 bom을 사용 하 여 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1583">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>  
  
 <span data-ttu-id="892d9-1584">바이트 순서에서 바이트 순서 표시에 대 한 자세한 내용은 유니코드 표준을 참조 합니다 [유니코드 홈페이지](https://go.microsoft.com/fwlink/?LinkId=37123)합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1584">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="892d9-1585">인코딩된 바이트 제대로 디코딩 하도록 인코딩된 바이트 프리앰블 붙여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1585">To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</span></span> <span data-ttu-id="892d9-1586">그러나 대부분의 인코딩 프리앰블을 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1586">However, most encodings do not provide a preamble.</span></span> <span data-ttu-id="892d9-1587">인코딩된 바이트 디코딩되을 사용할지는 유니코드 인코딩을, 되도록 <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, 또는 <xref:System.Text.UTF32Encoding>, 프리앰블을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1587">To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1588">다음 예제에서는 머리말 기반 인코딩의 바이트 순서를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1588">The following example determines the byte order of the encoding based on the preamble.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="892d9-1589">파생 클래스에서 재정의되면 바이트 시퀀스를 문자열로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1589">When overridden in a derived class, decodes a sequence of bytes into a string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1590">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1590">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="892d9-1591">파생 클래스에서 재정의되면 지정한 바이트 배열의 모든 바이트를 문자열로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1591">When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="892d9-1592">지정된 바이트 시퀀스에 대한 디코딩 결과가 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1592">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1593">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 에서 반환 된 개체는 <xref:System.Text.Encoding.GetDecoder%2A> 를 파생 메서드 ved 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1593">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-1594">설명 섹션을 참조 합니다 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 디코딩 기술 및 고려 사항에 대 한 설명은 대 한 참조 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1594">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>  
  
 <span data-ttu-id="892d9-1595">정확 하 게 동작 합니다 <xref:System.Text.Encoding.GetString%2A> 특정 메서드 <xref:System.Text.Encoding> 구현에 대 한 정의 대체 (fallback) 전략에 따라 달라 집니다 <xref:System.Text.Encoding> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1595">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="892d9-1596">자세한 내용은 "대체 (fallback) 전략 선택" 섹션을 참조 합니다 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1596">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1597">다음 예제에서는 나타내는 이진 파일을 u t F-8로 인코딩된 문자열을 읽습니다.는 <xref:System.IO.FileStream> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1597">The following example reads a UTF-8 encoded string from a binary file represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="892d9-1598">2,048 바이트 보다 작은 파일에 대 한 호출 하는 바이트 배열에 전체 파일의 내용을 읽고는 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> 디코딩을 수행 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1598">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> method to perform the decoding.</span></span> <span data-ttu-id="892d9-1599">더 큰 파일에 대 한 바이트를 읽습니다 2,048 동시 호출을 바이트 배열로 합니다 <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 문자 개수를 결정 하는 방법 배열에 포함 되어 있으며 다음 호출을 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 디코딩을 수행 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="892d9-1599">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 <span data-ttu-id="892d9-1600">이 예제에서는 라는 Utf8Example.txt u t F-8로 인코딩된 파일에 저장 해야 하는 다음 텍스트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1600">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1601">바이트 배열에 잘못된 유니코드 코드 포인트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1601">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1602"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1602"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1603">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1603">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1604">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1604">-and-</span></span> 
 <span data-ttu-id="892d9-1605"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1605"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1606">바이트 배열에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1606">A pointer to a byte array.</span></span></param>
        <param name="byteCount"><span data-ttu-id="892d9-1607">디코딩할 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1607">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="892d9-1608">파생 클래스에서 재정의할 때 지정된 주소에서 시작하는 지정된 바이트 수를 문자열로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1608">When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</span></span></summary>
        <returns><span data-ttu-id="892d9-1609">지정된 바이트 시퀀스에 대한 디코딩 결과가 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1609">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1610"><xref:System.Text.Encoding.GetString%2A> 메서드는 바이트 배열에 대 한 네이티브 포인터를 해야 하는 경우 성능을 최적화 하도록 디자인 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1610">The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array.</span></span> <span data-ttu-id="892d9-1611">관리 되는 바이트 배열을 만들고 다음이 디코딩하는 대신 중간 개체를 작성 하지 않고 대신이 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1611">Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</span></span>  
  
 <span data-ttu-id="892d9-1612">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 에서 반환 된 개체는 <xref:System.Text.Encoding.GetDecoder%2A> 를 파생 메서드 ved 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1612">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-1613">설명 섹션을 참조 합니다 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 디코딩 기술 및 고려 사항에 대 한 설명은 대 한 참조 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1613">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>  
  
 <span data-ttu-id="892d9-1614">정확 하 게 동작 합니다 <xref:System.Text.Encoding.GetString%2A> 특정 메서드 <xref:System.Text.Encoding> 구현에 대 한 정의 대체 (fallback) 전략에 따라 달라 집니다 <xref:System.Text.Encoding> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1614">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="892d9-1615">자세한 내용은 "대체 (fallback) 전략 선택" 섹션을 참조 합니다 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1615">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1616"><paramref name="bytes" />이(가) null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1616"><paramref name="bytes" /> is a null pointer.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1617"><paramref name="byteCount" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="892d9-1617"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1618">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1618">A   fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for a complete explanation)</span></span> 
<span data-ttu-id="892d9-1619">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1619">-and-</span></span> 
 <span data-ttu-id="892d9-1620"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1620"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="892d9-1621">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1621">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="892d9-1622">디코딩할 첫 번째 바이트의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1622">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="892d9-1623">디코딩할 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1623">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="892d9-1624">파생 클래스에서 재정의되면 지정한 바이트 배열의 바이트 시퀀스를 문자열로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1624">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="892d9-1625">지정된 바이트 시퀀스에 대한 디코딩 결과가 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1625">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1626">변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1626">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="892d9-1627">설명 섹션을 참조 합니다 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 디코딩 기술 및 고려 사항에 대 한 설명은 대 한 참조 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1627">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1628">다음 예제에서는 나타내는 이진 파일을 u t F-8로 인코딩된 문자열을 읽습니다.는 <xref:System.IO.FileStream> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1628">The following example reads a UTF-8 encoded string from a binary file that is represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="892d9-1629">2,048 바이트 보다 작은 파일에 대 한 호출 하는 바이트 배열에 전체 파일의 내용을 읽고는 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 디코딩을 수행 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1629">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to perform the decoding.</span></span> <span data-ttu-id="892d9-1630">더 큰 파일에 대 한 바이트를 읽습니다 2,048 동시 호출을 바이트 배열로 합니다 <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 문자 개수를 결정 하는 방법 배열에 포함 되어 있으며 다음 호출을 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 디코딩을 수행 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="892d9-1630">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 <span data-ttu-id="892d9-1631">이 예제에서는 라는 Utf8Example.txt u t F-8로 인코딩된 파일에 저장 해야 하는 다음 텍스트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1631">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="892d9-1632">바이트 배열에 잘못된 유니코드 코드 포인트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1632">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1633"><paramref name="bytes" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1633"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="892d9-1634"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1634"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="892d9-1635">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1635">-or-</span></span> 
 <span data-ttu-id="892d9-1636"><paramref name="index" /> 및 <paramref name="count" />가 <paramref name="bytes" />에서 올바른 범위를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1636"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="892d9-1637">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="892d9-1637">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="892d9-1638">및</span><span class="sxs-lookup"><span data-stu-id="892d9-1638">-and-</span></span> 
 <span data-ttu-id="892d9-1639"><see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1639"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1640">파생 클래스에서 재정의되면 메일 에이전트 헤더 태그에 사용할 수 있는 현재 인코딩의 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1640">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</span></span></summary>
        <value><span data-ttu-id="892d9-1641">메일 에이전트 헤더 태그에 사용할 현재 <see cref="T:System.Text.Encoding" />의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1641">A name for the current <see cref="T:System.Text.Encoding" /> to use with mail agent header tags.</span></span>  
  
<span data-ttu-id="892d9-1642">또는</span><span class="sxs-lookup"><span data-stu-id="892d9-1642">-or-</span></span> 
<span data-ttu-id="892d9-1643">현재 <see cref="T:System.Text.Encoding" />을 사용할 수 없으면 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1643">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1644">헤더 이름에 대 한 인코딩을 해야 하는 경우 호출 해야 합니다 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 <xref:System.Text.Encoding.HeaderName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1644">If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property.</span></span> <span data-ttu-id="892d9-1645">종종 메서드 호출에 제공 된 인코딩을 테스트에서 다른 인코딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1645">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="892d9-1646">일반적으로 전자 메일 응용 프로그램만 그러한 인코딩을 검색 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1646">Generally only email applications need to retrieve such an encoding.</span></span>  
  
 <span data-ttu-id="892d9-1647">경우에 따라 값을 <xref:System.Text.Encoding.BodyName%2A> 속성은 해당 인코딩을 정의 하는 국제 표준에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1647">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="892d9-1648">구현 표준에 사용 하 여 전체에서 준수는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1648">This doesn't mean that the implementation complies in full with that standard.</span></span>  
  
 <span data-ttu-id="892d9-1649"><xref:System.Text.Encoding.WebName%2A> 을 사용 하는 인코딩을 설명 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1649">Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding.</span></span> <span data-ttu-id="892d9-1650"><xref:System.Text.Encoding.HeaderName%2A> 속성 더 적합할 수 있는 전자 메일 응용 프로그램에 대 한 예를 들어 다른 인코딩을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1650">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an email application, for example.</span></span> <span data-ttu-id="892d9-1651">그러나 인코딩을 정의 하는 속성의 사용은 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1651">However, use of the property to define the encoding is not recommended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1652">다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1652">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="892d9-1653">표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1653">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="892d9-1654">현재 인코딩이 항상 정규화되는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1654">Gets a value indicating whether the current encoding is always normalized.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="892d9-1655">기본 정규화 형식을 사용하여 현재 인코딩이 항상 정규화되는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1655">Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</span></span></summary>
        <returns><span data-ttu-id="892d9-1656">현재 <see cref="T:System.Text.Encoding" />이 항상 정규화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1656"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="892d9-1657">기본값은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1657">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1658">기본 정규화는 <xref:System.Text.NormalizationForm.FormC>, 완전 한 정식 분해를 해당 기본 복합으로 시퀀스를 대체 하 여 가능한 경우 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1658">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="form"><span data-ttu-id="892d9-1659"><see cref="T:System.Text.NormalizationForm" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1659">One of the <see cref="T:System.Text.NormalizationForm" /> values.</span></span></param>
        <summary><span data-ttu-id="892d9-1660">파생 클래스에서 재정의되면 지정한 정규화 형식을 사용하여 현재 인코딩이 항상 정규화되는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1660">When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</span></span></summary>
        <returns><span data-ttu-id="892d9-1661">현재 <see langword="true" /> 개체가 항상 지정한 <see cref="T:System.Text.Encoding" /> 값을 사용하여 정규화되면 <see cref="T:System.Text.NormalizationForm" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1661"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="892d9-1662">기본값은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1662">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1663">기본 정규화는 <xref:System.Text.NormalizationForm.FormC>, 완전 한 정식 분해를 해당 기본 복합으로 시퀀스를 대체 하 여 가능한 경우 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1663">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1664">파생 클래스에서 재정의되면 현재 인코딩을 브라우저 클라이언트가 내용을 표시하는 데 사용할 수 있는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1664">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="892d9-1665">현재 <see cref="T:System.Text.Encoding" />을 브라우저 클라이언트가 내용을 표시하는 데 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1665"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="892d9-1666">다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1666">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1667">파생 클래스에서 재정의되면 현재 인코딩을 브라우저 클라이언트가 내용을 저장하는 데 사용할 수 있는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1667">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</span></span></summary>
        <value><span data-ttu-id="892d9-1668">현재 <see cref="T:System.Text.Encoding" />을 브라우저 클라이언트가 내용을 저장하는 데 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1668"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="892d9-1669">다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1669">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1670">파생 클래스에서 재정의되면 현재 인코딩을 메일 및 뉴스 클라이언트가 내용을 표시하는 데 사용할 수 있는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1670">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="892d9-1671">현재 <see cref="T:System.Text.Encoding" />을 메일 및 뉴스 클라이언트가 내용을 표시하는 데 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1671"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="892d9-1672">다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1672">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1673">파생 클래스에서 재정의되면 현재 인코딩을 메일 및 뉴스 클라이언트가 내용을 저장하는 데 사용할 수 있는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1673">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</span></span></summary>
        <value><span data-ttu-id="892d9-1674">현재 <see langword="true" />을 메일 및 뉴스 클라이언트가 내용을 저장하는 데 사용할 수 있으면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1674"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="892d9-1675">다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1675">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1676">파생 클래스에서 재정의되면 현재 인코딩이 읽기 전용인지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1676">When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</span></span></summary>
        <value><span data-ttu-id="892d9-1677">현재 <see langword="true" />가 읽기 전용이면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1677"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is read-only; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="892d9-1678">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1678">The default is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1679">파생 클래스에서 재정의되면 현재 인코딩이 단일 바이트 코드 포인트를 사용하는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1679">When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</span></span></summary>
        <value><span data-ttu-id="892d9-1680">현재 <see langword="true" />이 단일 바이트 코드 포인트를 사용하면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1680"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> uses single-byte code points; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1681">싱글바이트 인코딩, 예를 들어 <xref:System.Text.ASCIIEncoding>,이 속성을 검색 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1681">For a single-byte encoding, for example, <xref:System.Text.ASCIIEncoding>, this property retrieves `true`.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="892d9-1682">에 대 한 값을 사용 하 여 응용 프로그램은 주의 해 서 해야 <xref:System.Text.Encoding.IsSingleByte%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1682">You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>.</span></span> <span data-ttu-id="892d9-1683">인코딩 진행 하는 방법의 가정은 잘못 된 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1683">An assumption of how an Encoding will proceed may still be wrong.</span></span> <span data-ttu-id="892d9-1684">예를 들어 Windows-1252에 값 `true` 에 대 한 <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, 하지만 Encoding.GetMaxByteCount(1) 2를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1684">For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, but Encoding.GetMaxByteCount(1) returns 2.</span></span> <span data-ttu-id="892d9-1685">이 메서드는 이전 decoder 작업에서 잠재적인 남겨진 서로게이트를 고려 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1685">This is because the method considers potential leftover surrogates from a previous decoder operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1686">다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1686">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="892d9-1687">추가 문자 인코딩에 대한 액세스를 제공하는 <see cref="T:System.Text.EncodingProvider" />의 하위 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1687">A subclass of <see cref="T:System.Text.EncodingProvider" /> that provides access to additional character encodings.</span></span></param>
        <summary><span data-ttu-id="892d9-1688">인코딩 공급자를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1688">Registers an encoding provider.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1689">합니다 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드를 사용 하면에서 파생 된 클래스를 등록할 수 있습니다 <xref:System.Text.EncodingProvider> 는 그렇지 않은 경우 지원 하지 않는 플랫폼에서 사용할 수 있는 인코딩 문자는 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1689">The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them.</span></span> <span data-ttu-id="892d9-1690">지원 되는 인코딩은 인코딩 공급자 등록 되 면 하나를 호출 하 여 검색할 수 있습니다 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1690">Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> overload.</span></span> <span data-ttu-id="892d9-1691">여러 인코딩 공급자에 있는 경우는 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 메서드 가장 최근에 등록 된 것으로 시작 하는 각 공급자에서 지정 된 인코딩을 검색 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1691">If there are multiple encoding providers, the <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> method attempts to retrieve a specified encoding from each provider starting with the one most recently registered.</span></span>

<span data-ttu-id="892d9-1692">인코딩 공급자를 사용 하 여 등록 합니다 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드는 또한의 동작을 수정 합니다 [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) 및 [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) 메서드는 인수를 전달 하는 경우 `0`:</span><span class="sxs-lookup"><span data-stu-id="892d9-1692">Registering an encoding provider by using the <xref:System.Text.Encoding.RegisterProvider%2A> method also modifies the behavior of the [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) and [EncodingProvider.GetEncoding(Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) methods when passed an argument of `0`:</span></span>

- <span data-ttu-id="892d9-1693">등록 된 공급자가는 <xref:System.Text.CodePagesEncodingProvider>, 메서드는 Windows 운영 체제를 실행 하는 경우 시스템 활성 코드 페이지와 일치 하는 인코딩을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1693">If the registered provider is the <xref:System.Text.CodePagesEncodingProvider>, the method returns the encoding that matches the system active code page when running on the Windows operating system.</span></span>

- <span data-ttu-id="892d9-1694">사용자 지정 인코딩 공급자를 반환할 때 인코딩을 선택할 수 있습니다 이러한 <xref:System.Text.Encoding.GetEncoding%2A> 메서드 오버 로드의 인수로 전달 됩니다 `0`합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1694">A custom encoding provider can choose which encoding to return when either of these <xref:System.Text.Encoding.GetEncoding%2A> method overloads is passed an argument of `0`.</span></span> <span data-ttu-id="892d9-1695">공급자 함으로써 인코딩을 반환 하지 하도록 선택할 수도 있습니다는 <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> 메서드가 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1695">The provider can also choose to not return an encoding by having the <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> method return `null`.</span></span> 
  
<span data-ttu-id="892d9-1696">.NET Framework 4.6 부터는.NET Framework에 하나의 인코딩 공급자 <xref:System.Text.CodePagesEncodingProvider>, 전체.NET Framework에는 유니버설 Windows 플랫폼에서 사용할 수 없는 인코딩을 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1696">Starting with the .NET Framework 4.6, the .NET Framework includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in the Universal Windows Platform.</span></span> <span data-ttu-id="892d9-1697">유니버설 Windows 플랫폼을 기본적으로 유니코드, ASCII 인코딩과 코드 페이지 28591만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1697">By default, the Universal Windows Platform only supports the Unicode encodings, ASCII, and code page 28591.</span></span>  
  
 <span data-ttu-id="892d9-1698">동일한 인코딩 공급자에 대 한 여러 호출에 사용 되 면는 <xref:System.Text.Encoding.RegisterProvider%2A> 공급자를 등록 하는 메서드를 첫 번째 메서드 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1698">If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider.</span></span> <span data-ttu-id="892d9-1699">후속 호출은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1699">Subsequent calls are ignored.</span></span>  
  
 <span data-ttu-id="892d9-1700">경우는 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드 같은 인코딩을 처리 하는 여러 공급자를 등록 하는, 마지막으로 등록 된 공급자가 모든 인코딩 및 디코딩 작업에 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1700">If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.</span></span> <span data-ttu-id="892d9-1701">이전에 등록 된 모든 공급자는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1701">Any previously registered providers are ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="892d9-1702"><paramref name="provider" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1702"><paramref name="provider" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1703">little endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1703">Gets an encoding for the UTF-16 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="892d9-1704">little-endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1704">An encoding for the UTF-16 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1705">.NET 및 인코딩을 사용 하는 유니코드에 대 한 설명은에서 지 원하는 인코딩에 대 한 내용은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1705">For information about the encodings supported by the .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="892d9-1706"><xref:System.Text.UnicodeEncoding> 이 속성에 의해 반환 된 개체를 앱에 대 한 적절 한 동작에 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1706">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="892d9-1707">교체 대체 (fallback)를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트는 물음표를 바꿉니다 ("?") 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1707">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="892d9-1708">대신 호출할 수 있습니다는 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 생성자를 인스턴스화하는 little endian의 약자 <xref:System.Text.UnicodeEncoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1708">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1709">다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1709">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1710">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1710">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1711">little endian 바이트 순서를 사용하는 UTF-32 형식에 대한 인코딩을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1711">Gets an encoding for the UTF-32 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="892d9-1712">little-endian 바이트 순서를 사용하는 UTF-32 형식에 대한 인코딩 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1712">An  encoding object for the UTF-32 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1713"><xref:System.Text.UTF32Encoding> 이 속성에 의해 반환 된 개체를 앱에 대 한 적절 한 동작에 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1713">The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="892d9-1714">교체 대체 (fallback)를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트 유니코드 REPLACEMENT CHARACTER (U + FFFE)으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1714">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).</span></span> <span data-ttu-id="892d9-1715">대신, 호출할 수 있습니다는 <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 인스턴스화하는 생성자를 <xref:System.Text.UTF32Encoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1715">Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 <span data-ttu-id="892d9-1716">Little endian 바이트 순서 내용은 참조는 <xref:System.Text.Encoding> 클래스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1716">For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic.</span></span>  
  
 <span data-ttu-id="892d9-1717">.NET 및 인코딩을 사용 하는 유니코드에 대 한 설명은에서 지 원하는 인코딩에 대 한 내용은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1717">For information about the encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1718">다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1718">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1719">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1719">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1720">UTF-7 형식에 대한 인코딩을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1720">Gets an encoding for the UTF-7 format.</span></span></summary>
        <value><span data-ttu-id="892d9-1721">UTF-7 형식에 대한 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1721">An encoding for the UTF-7 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1722">Utf-7 인코딩이 지금까지 7 비트, NNTP 등 일부 전자 메일 응용 프로그램을 제한 된 된 환경에서 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1722">UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.</span></span> <span data-ttu-id="892d9-1723">견고성 및 보안 문제로 인해 사용 하지 않아야 UTF7 8 비트 환경에서 인코딩 u t F-8 인코딩을 사용할 수 있는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1723">Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1724">다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1724">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1725">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1725">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1726">UTF-8 형식에 대한 인코딩을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1726">Gets an encoding for the UTF-8 format.</span></span></summary>
        <value><span data-ttu-id="892d9-1727">UTF-8 형식에 대한 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1727">An encoding for the UTF-8 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1728">이 속성은 반환을 <xref:System.Text.UTF8Encoding> 문자당 1 ~ 4 바이트 시퀀스를 유니코드 (u t F-16으로 인코딩된) 문자를 인코딩하는 유니코드 (u t F-16으로 인코딩된) 문자는 u t F-8로 인코딩된 바이트 배열 디코드 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1728">This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.</span></span> <span data-ttu-id="892d9-1729">.NET 및 인코딩을 사용 하는 유니코드에 대 한 설명은에서 지 원하는 문자 인코딩에 대 한 내용은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1729">For information about the character encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="892d9-1730"><xref:System.Text.UTF8Encoding> 이 속성에 의해 반환 되는 개체는 앱에 대 한 적절 한 동작 있을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1730">The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span>  
  
-   <span data-ttu-id="892d9-1731">반환 된 <xref:System.Text.UTF8Encoding> 유니코드 바이트 순서 표시 (BOM)를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1731">It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM).</span></span> <span data-ttu-id="892d9-1732">BOM을 제공 하지 않는 한 UTF8 인코딩을 인스턴스화 호출의 오버 로드는 <xref:System.Text.UTF8Encoding.%23ctor%2A> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1732">To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.</span></span>  
  
-   <span data-ttu-id="892d9-1733">반환 된 <xref:System.Text.UTF8Encoding> 물음표를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트를 바꾸려면 교체 대체 (fallback)를 사용 하는 개체 ("?") 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1733">It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark ("?") character.</span></span> <span data-ttu-id="892d9-1734">대신, 호출할 수 있습니다는 <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 인스턴스화하는 생성자를 <xref:System.Text.UTF8Encoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1734">Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1735">다음 예제에서는 다음 문자로 구성 된 배열을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1735">The following example defines an array that consists of the following characters:</span></span>  
  
-   <span data-ttu-id="892d9-1736">라틴어 소문자 Z (U + 007A)</span><span class="sxs-lookup"><span data-stu-id="892d9-1736">LATIN SMALL LETTER Z (U+007A)</span></span>  
  
-   <span data-ttu-id="892d9-1737">라틴어 작은 문자는 (단어로)</span><span class="sxs-lookup"><span data-stu-id="892d9-1737">LATIN SMALL LETTER A (U+0061)</span></span>  
  
-   <span data-ttu-id="892d9-1738">결합 에스프레소 (U + 0306)</span><span class="sxs-lookup"><span data-stu-id="892d9-1738">COMBINING BREVE (U+0306)</span></span>  
  
-   <span data-ttu-id="892d9-1739">예 (U + 01FD)를 사용 하 여 영문 소문자 AE</span><span class="sxs-lookup"><span data-stu-id="892d9-1739">LATIN SMALL LETTER AE WITH ACUTE (U+01FD)</span></span>  
  
-   <span data-ttu-id="892d9-1740">그리스어 소문자 베타 (U + 03B2)</span><span class="sxs-lookup"><span data-stu-id="892d9-1740">GREEK SMALL LETTER BETA (U+03B2)</span></span>  
  
-   <span data-ttu-id="892d9-1741">서로게이트 쌍 (u+d800부터 U + DD54) 그리스어 ACROPHONIC ATTIC 하나 천 STATERS (U + 10154)를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1741">A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154).</span></span>  
  
 <span data-ttu-id="892d9-1742">각 문자의 utf-16 코드 단위를 표시 하 고 문자 배열을 인코딩하는 데는 utf-8 인코더에 필요한 바이트 수를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1742">It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array.</span></span> <span data-ttu-id="892d9-1743">다음 문자를 인코딩하고 결과 u t F-8로 인코딩된 바이트 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1743">It then encodes the characters and displays the resulting UTF-8-encoded bytes.</span></span>  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="892d9-1744">인코딩 이해</span><span class="sxs-lookup"><span data-stu-id="892d9-1744">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1745">파생 클래스에서 재정의되면 현재 인코딩에 대해 IANA(Internet Assigned Numbers Authority)에 등록된 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1745">When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</span></span></summary>
        <value><span data-ttu-id="892d9-1746">현재 <see cref="T:System.Text.Encoding" />에 대한 IANA 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1746">The IANA name for the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1747">합니다 <xref:System.Text.Encoding.WebName%2A> 속성은 동일 합니다 <xref:System.Text.EncodingInfo.Name%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1747">The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property.</span></span>  
  
 <span data-ttu-id="892d9-1748"><xref:System.Text.Encoding.WebName%2A> 인코딩에 대해 IANA에 등록 된 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1748">Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding.</span></span> <span data-ttu-id="892d9-1749">해당 값은 표준의 이름, 인코딩 구현 표준에 전체에서 따르지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1749">When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.</span></span> <span data-ttu-id="892d9-1750"><xref:System.Text.Encoding.HeaderName%2A> 속성은 전자 메일 헤더에 더 적합할 수 있는 다른 인코딩을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1750">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for email headers.</span></span> <span data-ttu-id="892d9-1751">그러나 대부분의 앱을 사용 해야 <xref:System.Text.Encoding.WebName%2A> 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1751">However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.</span></span>  
  
 <span data-ttu-id="892d9-1752">IANA에 대 한 자세한 내용은 이동 [www.iana.org](https://www.iana.org/)합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1752">For more information on the IANA, go to [www.iana.org](https://www.iana.org/).</span></span>  
  
 <span data-ttu-id="892d9-1753">합니다 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> 동일 합니다 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 반환한 <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1753">The <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="892d9-1754">웹 이름 중 일부는 중복 되었습니다. 에 대 한 설명을 참조 <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1754">Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> for more information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1755">다음 예제를 포함 합니다 <xref:System.Text.Encoding.WebName%2A> HTML 헤더에서입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1755">The following example includes the <xref:System.Text.Encoding.WebName%2A> in an HTML header.</span></span>  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 <span data-ttu-id="892d9-1756">다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1756">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="892d9-1757">표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1757">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="892d9-1758">파생 클래스에서 재정의되면 현재 인코딩과 가장 비슷한 Windows 운영 체제 코드 페이지를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1758">When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</span></span></summary>
        <value><span data-ttu-id="892d9-1759">현재 <see cref="T:System.Text.Encoding" />과 가장 비슷한 Windows 운영 체제 코드 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1759">The Windows operating system code page that most closely corresponds to the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="892d9-1760">이 속성은 글꼴 패밀리를 결정 하는 데 예를 들어 Windows 다국어 (MLang) Api 사용 하 여 호환성을 위해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1760">This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.</span></span> <span data-ttu-id="892d9-1761">세계화를 위한 유니코드 인코딩 중 하나를 사용 하는 것이 좋습니다 대신.</span><span class="sxs-lookup"><span data-stu-id="892d9-1761">For globalization, using one of the Unicode encodings is recommended instead.</span></span> <span data-ttu-id="892d9-1762">사용 하는 것은 권장 수도 <xref:System.Text.Encoding.WebName%2A> 대신 <xref:System.Text.Encoding.WindowsCodePage%2A> 코드 페이지를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1762">It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="892d9-1763">다음 예제에서는 각 인코딩에 해당 하는 가장 근접 하 게는 Windows 코드 페이지를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="892d9-1763">The following example determines the Windows code page that most closely corresponds to each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>