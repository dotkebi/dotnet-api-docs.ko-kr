<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f09ba51049b785b441b3abb25f341ac68edc837a" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58736394" /></Metadata><TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="7e0e0-101">리소스 또는 리소스 풀에 동시에 액세스할 수 있는 스레드 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-102">사용 된 <xref:System.Threading.Semaphore> 리소스 풀에 대 한 액세스를 제어 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="7e0e0-103">스레드가 세마포를 호출 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A> 에서 상속 된 메서드를 <xref:System.Threading.WaitHandle> 클래스를 호출 하 여 세마포를 해제 합니다 <xref:System.Threading.Semaphore.Release%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="7e0e0-104">도달한 세마포에 대해 개수가 스레드가 세마포를 입력 하 고는 스레드가 세마포를 해제할 때 증가 될 때마다 감소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="7e0e0-105">횟수가 0 일 경우 후속 요청에 다른 스레드가 세마포를 해제할 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="7e0e0-106">모든 스레드가 세마포를 해제 한 경우 개수는 최 댓 값에 만들어질 때 지정 된 세마포 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="7e0e0-107">FIFO 등 LIFO, 차단 된 스레드가 세마포를 입력할 수 있는 보장 된 순서 없이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-108">스레드가 세마포에 들어갈 수를 여러 번 호출 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드 반복적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="7e0e0-109">이러한 항목 중 일부나 전부를 해제 하려면 스레드 매개 변수가 없는 호출 수 <xref:System.Threading.Semaphore.Release> 메서드 오버 로드를 여러 번 하거나 호출할 수는 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 해제할 항목 수를 지정 하는 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="7e0e0-110">합니다 <xref:System.Threading.Semaphore> 클래스에 대 한 호출에서 스레드 id를 적용 하지 않습니다 <xref:System.Threading.WaitHandle.WaitOne%2A> 또는 <xref:System.Threading.Semaphore.Release%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="7e0e0-111">프로그래머는 스레드는 해제 하지 않아 세마포를 너무 여러 번 확인 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="7e0e0-112">예를 들어 세마포의 최대 개수가 2개인데 스레드 A와 스레드 B가 모두 세마포를 입력한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="7e0e0-113">스레드 B에서에서 프로그래밍 오류를 호출 하면 <xref:System.Threading.Semaphore.Release%2A> 을 두 번 두 호출은 모두 성공 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="7e0e0-114">그러면 세마포 개수가 다 차서 스레드 A가 <xref:System.Threading.Semaphore.Release%2A>를 호출하면 <xref:System.Threading.SemaphoreFullException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="7e0e0-115">세마포는 두 가지 유형입니다: 로컬 세마포 및 명명 된 시스템 세마포 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="7e0e0-116">만드는 경우는 <xref:System.Threading.Semaphore> 이름을 허용 하는 생성자를 사용 하 여 해당 이름의 운영 체제 세마포를 사용 하 여 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="7e0e0-117">명명 된 시스템 세마포 전체 운영 체제에 표시 되 고 사용 하 여 프로세스 작업을 동기화 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="7e0e0-118">여러 개 만들 수 있습니다 <xref:System.Threading.Semaphore> 동일한 나타내는 개체를 명명 된 시스템 세마포를 및 사용할 수는 <xref:System.Threading.Semaphore.OpenExisting%2A> 명명 된 시스템 세마포가 기존 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-119">로컬 세마포가 프로세스 내에 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="7e0e0-120">로컬 <xref:System.Threading.Semaphore> 개체에 대한 참조가 있는 프로세스의 모든 스레드에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="7e0e0-121">각 <xref:System.Threading.Semaphore> 개체는 별도 로컬 세마포입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-122">다음 코드 예제에서는 세 개의 최대 개수를 및 0에 대 한 초기 카운트를 사용 하 여 세마포를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="7e0e0-123">이 예제에서는 세마포를 기다리는 동안 차단 하는 5 개의 스레드를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="7e0e0-124">주 스레드에서 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 세마포를 입력 하려면 3 개의 스레드를 허용 합니다. 최대값으로 세마포 수를 늘리려면 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="7e0e0-125">각 스레드가 사용 하는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 1 초 동안 기다린 후 작업을 시뮬레이션 한 다음 호출 하는 방법의 <xref:System.Threading.Semaphore.Release> 세마포를 해제 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="7e0e0-126">세마포를 해제 될 때마다 이전 세마포 카운트가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="7e0e0-127">콘솔 메시지 세마포 사용을 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-127">Console messages track semaphore use.</span></span> <span data-ttu-id="7e0e0-128">시뮬레이션 된 작업 간격 출력을 쉽게 읽을 수 있도록 각 스레드에 대해 약간 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="7e0e0-129">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-129">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-130">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-130">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-131">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-131">Semaphore</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7e0e0-132"><see cref="T:System.Threading.Semaphore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-132">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="7e0e0-133">세마포에 동시에 부여할 수 있는 초기 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-133">The initial number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="7e0e0-134">세마포에 동시에 부여할 수 있는 최대 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-134">The maximum number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <summary><span data-ttu-id="7e0e0-135">초기 항목 수와 최대 동시 항목 수를 지정하여 <see cref="T:System.Threading.Semaphore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-135">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-136">이 생성자는 명명 되지 않은 세마포를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-136">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="7e0e0-137">이러한 세마포의 인스턴스를 사용 하는 모든 스레드는 인스턴스에 대 한 참조가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-137">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="7e0e0-138">하는 경우 `initialCount` 는 보다 작은 `maximumCount`, 현재 스레드의 호출 하는 것 처럼 효과 동일 <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` 빼기 `initialCount`) 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-138">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="7e0e0-139">세마포를 만드는 스레드는 엔트리를 예약 하지 않을 경우 같은 값을 사용 하 여 `maximumCount` 고 `initialCount`입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-139">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-140">다음 예제에서는 최대 개수 3 및 0에 대 한 초기 카운트를 사용 하 여 세마포를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-140">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="7e0e0-141">이 예제에서는 세마포를 기다리는 동안 차단 하는 5 개의 스레드를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-141">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="7e0e0-142">주 스레드에서 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 세마포를 입력 하려면 3 개의 스레드를 허용 합니다. 최대값으로 세마포 수를 늘리려면 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-142">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="7e0e0-143">각 스레드가 사용 하는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 1 초 동안 기다린 후 작업을 시뮬레이션 한 다음 호출 하는 방법의 <xref:System.Threading.Semaphore.Release> 세마포를 해제 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-143">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="7e0e0-144">세마포를 해제 될 때마다 이전 세마포 카운트가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-144">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="7e0e0-145">콘솔 메시지 세마포 사용을 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-145">Console messages track semaphore use.</span></span> <span data-ttu-id="7e0e0-146">시뮬레이션 된 작업 간격 출력을 쉽게 읽을 수 있도록 각 스레드에 대해 약간 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-146">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e0e0-147"><paramref name="initialCount" />가 <paramref name="maximumCount" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-147"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e0e0-148"><paramref name="maximumCount" />가 1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-148"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="7e0e0-149">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-149">-or-</span></span> 
 <span data-ttu-id="7e0e0-150"><paramref name="initialCount" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-150"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-151">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-151">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-152">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-152">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="7e0e0-153">세마포에 동시에 부여할 수 있는 초기 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-153">The initial number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="7e0e0-154">세마포에 동시에 부여할 수 있는 최대 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-154">The maximum number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="7e0e0-155">명명된 시스템 세마포 개체의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-155">The name of a named system semaphore object.</span></span></param>
        <summary><span data-ttu-id="7e0e0-156">초기 항목 수와 최대 동시 항목 수를 지정하고, 시스템 세마포 개체 이름을 선택적으로 지정하여 <see cref="T:System.Threading.Semaphore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-156">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-157">이 생성자는 <xref:System.Threading.Semaphore> 명명된 된 시스템 세마포를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-157">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="7e0e0-158">여러 개 만들 수 있습니다 <xref:System.Threading.Semaphore> 명명 된 시스템 세마포가 동일한를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-158">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-159">명명 된 시스템 세마포가 존재 하지 않는 경우 초기 개수 및 지정 된 최대 수를 사용 하 여 생성 됩니다 `initialCount` 고 `maximumCount`입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-159">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="7e0e0-160">명명 된 시스템 세마포가 이미 있는 경우 `initialCount` 고 `maximumCount` 잘못 된 값에는 예외가 발생 하더라도 있지만 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-160">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="7e0e0-161">결정 해야 하는 경우 명명된 된 시스템 세마포를 만들지 여부, 사용 된 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> 생성자 오버 로드를 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-161">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="7e0e0-162">권장 되는 방식은 같은 값을 지정 하려면이 생성자 오버 로드를 사용 하면 `initialCount` 고 `maximumCount`입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-162">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="7e0e0-163">하는 경우 `initialCount` 는 보다 작은 `maximumCount`, 및 명명된 된 시스템 세마포를 현재 스레드에서 호출 하는 것 처럼 효과 동일 <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` 빼기 `initialCount`) 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-163">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="7e0e0-164">그러나이 생성자 오버 로드를 사용 하 여 있습니다 명명 된 시스템 세마포가 만들어졌는지 여부를 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-164">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="7e0e0-165">지정 하는 경우 `null` 또는 빈 문자열로 `name`를 호출한 것 처럼 로컬 세마포가 만들어진는 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> 생성자 오버 로드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-165">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="7e0e0-166">명명 된 세마포 운영 체제 전체에 표시 되므로, 프로세스 경계를 넘어 리소스 사용을 조정 하기 위해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-166">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="7e0e0-167">명명된 된 시스템 세마포가 존재 하는지 여부 확인을 사용 하려는 경우는 <xref:System.Threading.Semaphore.OpenExisting%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-167">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="7e0e0-168"><xref:System.Threading.Semaphore.OpenExisting%2A> 메서드는 기존 명명 된 세마포를 열려고 시도 하 고 시스템 세마포가 존재 하지 않는 경우 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-168">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-169">다음 코드 예제에서는 명명 된 세마포 프로세스 간 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-169">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="7e0e0-170">이 예제에서는 명명된 된 세마포의 최대 개수가 5와 5 명에 대 한 초기 카운트</span><span class="sxs-lookup"><span data-stu-id="7e0e0-170">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="7e0e0-171">프로그램을 세 번 호출 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-171">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="7e0e0-172">두 번째 복사본의 세 번째 호출에서 차단 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우에 따라서 <xref:System.Threading.WaitHandle.WaitOne%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-172">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="7e0e0-173">두 번째 차단을 해제 하려면 프로그램의 첫 번째 복사본에 있는 하나 이상의 항목을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-173">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e0e0-174"><paramref name="initialCount" />가 <paramref name="maximumCount" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-174"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="7e0e0-175">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-175">-or-</span></span> 
 <span data-ttu-id="7e0e0-176"><paramref name="name" />이 260자 보다 긴 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-176"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e0e0-177"><paramref name="maximumCount" />가 1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-177"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="7e0e0-178">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-178">-or-</span></span> 
 <span data-ttu-id="7e0e0-179"><paramref name="initialCount" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-179"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e0e0-180">Win32 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-180">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-181">명명된 세마포가 존재하고 이 세마포에 액세스 제어 보안이 있고 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-181">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e0e0-182">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 세마포를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-182">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e0e0-183">명명 된 시스템 세마포를 만들지 비관리 코드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-183">for calling unmanaged code to create a named system semaphore.</span></span> <span data-ttu-id="7e0e0-184">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="7e0e0-184">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span>  
  
<span data-ttu-id="7e0e0-185">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-185">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-186">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-186">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-187">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-187">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="7e0e0-188">동시에 충족될 수 있는 세마포의 초기 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-188">The initial number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="7e0e0-189">동시에 충족될 수 있는 세마포의 최대 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-189">The maximum number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="7e0e0-190">명명된 시스템 세마포 개체의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-190">The name of a named system semaphore object.</span></span></param>
        <param name="createdNew"><span data-ttu-id="7e0e0-191">이 메서드가 반환될 때 로컬 세마포가 만들어진 경우(즉, <paramref name="name" />이 <see langword="null" />이거나 빈 문자열인 경우) 또는 지정한 명명된 시스템 세마포가 만들어진 경우에는 <see langword="true" />가 포함되고, 지정한 명명된 시스템 세마포가 이미 있는 경우에는 <see langword="false" />가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-191">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span></span> <span data-ttu-id="7e0e0-192">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-192">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="7e0e0-193">초기 항목 수 및 최대 동시 항목 수를 지정하고, 선택적으로 시스템 세마포 개체의 이름을 지정하고, 새 시스템 세마포가 만들어졌는지 여부를 나타내는 값을 받을 변수를 지정하여 <see cref="T:System.Threading.Semaphore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-193">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-194">이 생성자는 <xref:System.Threading.Semaphore> 명명된 된 시스템 세마포를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-194">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="7e0e0-195">여러 개 만들 수 있습니다 <xref:System.Threading.Semaphore> 명명 된 시스템 세마포가 동일한를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-195">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-196">명명 된 시스템 세마포가 존재 하지 않는 경우 초기 개수 및 지정 된 최대 수를 사용 하 여 생성 됩니다 `initialCount` 고 `maximumCount`입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-196">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="7e0e0-197">명명 된 시스템 세마포가 이미 있는 경우 `initialCount` 고 `maximumCount` 잘못 된 값에는 예외가 발생 하더라도 있지만 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-197">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="7e0e0-198">사용 하 여 `createdNew` 시스템 세마포가 만들어졌는지 여부를 확인 하려면.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-198">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="7e0e0-199">경우 `initialCount` 는 보다 작은 `maximumCount`, 및 `createdNew` 는 `true`를 현재 스레드에서 호출 하는 것 처럼 효과 동일 <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` 빼기 `initialCount`) 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-199">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="7e0e0-200">지정 하는 경우 `null` 또는 빈 문자열로 `name`를 호출한 것 처럼 로컬 세마포가 만들어진는 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> 생성자 오버 로드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-200">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="7e0e0-201">이 예에서 `createdNew` 항상 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-201">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="7e0e0-202">명명 된 세마포 운영 체제 전체에 표시 되므로, 프로세스 경계를 넘어 리소스 사용을 조정 하기 위해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-202">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-203">다음 코드 예제에서는 명명 된 세마포 프로세스 간 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-203">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="7e0e0-204">이 예제에서는 명명된 된 세마포의 최대 개수가 5 및 2의 초기 수를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="7e0e0-204">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="7e0e0-205">즉, 세 가지 생성자를 호출 하는 스레드에 엔트리를 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-205">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="7e0e0-206">경우 `createNew` 됩니다 `false`, 프로그램을 세 번 호출 하는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-206">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="7e0e0-207">두 번째 복사본의 세 번째 호출에서 차단 됩니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우에 따라서 <xref:System.Threading.WaitHandle.WaitOne%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-207">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="7e0e0-208">두 번째 차단을 해제 하려면 프로그램의 첫 번째 복사본에 있는 하나 이상의 항목을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-208">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e0e0-209"><paramref name="initialCount" />가 <paramref name="maximumCount" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-209"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="7e0e0-210">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-210">-or-</span></span> 
 <span data-ttu-id="7e0e0-211"><paramref name="name" />이 260자 보다 긴 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-211"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e0e0-212"><paramref name="maximumCount" />가 1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-212"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="7e0e0-213">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-213">-or-</span></span> 
 <span data-ttu-id="7e0e0-214"><paramref name="initialCount" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-214"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e0e0-215">Win32 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-215">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-216">명명된 세마포가 존재하고 이 세마포에 액세스 제어 보안이 있고 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-216">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e0e0-217">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 세마포를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-217">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e0e0-218">명명 된 시스템 세마포를 만들지 비관리 코드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-218">for calling unmanaged code to create a named system semaphore.</span></span> <span data-ttu-id="7e0e0-219">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="7e0e0-219">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span>  
  
<span data-ttu-id="7e0e0-220">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-220">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-221">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-221">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-222">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-222">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maximumCount" Type="System.Int32" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="7e0e0-223">동시에 충족될 수 있는 세마포의 초기 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-223">The initial number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="7e0e0-224">동시에 충족될 수 있는 세마포의 최대 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-224">The maximum number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="7e0e0-225">명명된 시스템 세마포 개체의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-225">The name of a named system semaphore object.</span></span></param>
        <param name="createdNew"><span data-ttu-id="7e0e0-226">이 메서드가 반환될 때 로컬 세마포가 만들어진 경우(즉, <paramref name="name" />이 <see langword="null" />이거나 빈 문자열인 경우) 또는 지정한 명명된 시스템 세마포가 만들어진 경우에는 <see langword="true" />가 포함되고, 지정한 명명된 시스템 세마포가 이미 있는 경우에는 <see langword="false" />가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-226">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span></span> <span data-ttu-id="7e0e0-227">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-227">This parameter is passed uninitialized.</span></span></param>
        <param name="semaphoreSecurity"><span data-ttu-id="7e0e0-228">명명된 시스템 세마포에 적용할 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-228">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span></span></param>
        <summary><span data-ttu-id="7e0e0-229">초기 항목 수 및 최대 동시 항목 수를 지정하고, 선택적으로 시스템 세마포 개체의 이름을 지정하고, 새 시스템 세마포가 만들어졌는지 여부를 나타내는 값을 받을 변수를 지정하고, 시스템 세마포에 대한 액세스 제어 보안을 지정하여 <see cref="T:System.Threading.Semaphore" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-229">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-230">세마포 제어 인해 다른 코드를 만들 때 명명 된 시스템 세마포에 액세스 제어 보안을 적용 하려면이 생성자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-230">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-231">이 생성자는 <xref:System.Threading.Semaphore> 명명된 된 시스템 세마포를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-231">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="7e0e0-232">여러 개 만들 수 있습니다 <xref:System.Threading.Semaphore> 명명 된 시스템 세마포가 동일한를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-232">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-233">명명 된 시스템 세마포가 존재 하지 않는 경우 지정 된 액세스 제어 보안을 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-233">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="7e0e0-234">명명 된 세마포가 존재 하는 경우 지정 된 액세스 제어 보안 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-234">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7e0e0-235">호출자에 게 완전히 제어할 새로 만든된 <xref:System.Threading.Semaphore> 경우에도 개체 `semaphoreSecurity` 거부 하거나 현재 사용자에 게 일부 액세스 권한을 부여 하지 못했습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-235">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="7e0e0-236">그러나 현재 사용자가 다른 <xref:System.Threading.Semaphore> 개체를 나타내는 동일한 명명 된 세마포를 사용 하 여 생성자 또는 <xref:System.Threading.Semaphore.OpenExisting%2A> 메서드를 Windows 액세스 제어 보안이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-236">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="7e0e0-237">명명 된 시스템 세마포가 존재 하지 않는 경우 초기 개수 및 지정 된 최대 수를 사용 하 여 생성 됩니다 `initialCount` 고 `maximumCount`입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-237">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="7e0e0-238">명명 된 시스템 세마포가 이미 있는 경우 `initialCount` 고 `maximumCount` 잘못 된 값에는 예외가 발생 하더라도 있지만 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-238">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="7e0e0-239">사용 된 `createdNew` 매개 변수를이 생성자에 의해 시스템 세마포가 만들어졌는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-239">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="7e0e0-240">경우 `initialCount` 는 보다 작은 `maximumCount`, 및 `createdNew` 는 `true`를 현재 스레드에서 호출 하는 것 처럼 효과 동일 <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` 빼기 `initialCount`) 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-240">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="7e0e0-241">지정 하는 경우 `null` 또는 빈 문자열로 `name`를 호출한 것 처럼 로컬 세마포가 만들어진는 <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> 생성자 오버 로드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-241">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="7e0e0-242">이 예에서 `createdNew` 항상 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-242">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="7e0e0-243">명명 된 세마포 운영 체제 전체에 표시 되므로, 프로세스 경계를 넘어 리소스 사용을 조정 하기 위해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-243">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-244">다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 세마포 프로세스 간 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-244">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e0e0-245">이 예제에서는 사용은 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드 오버 로드는 명명 된 세마포의 존재 여부를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-245">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="7e0e0-246">세마포가 존재 하지 않는 경우 두 개의 최대 개수와 세마포를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 세마포에 대 한 권한이 변경 권한 부여는 액세스 제어 보안을 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-246">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="7e0e0-247">두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-247">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="7e0e0-248">예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 세마포를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-248">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7e0e0-249">권한이 변경 되 면 세마포를 입력 하 고 해제 하는 데 필요한 권한으로 열려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-249">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="7e0e0-250">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-250">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e0e0-251"><paramref name="initialCount" />가 <paramref name="maximumCount" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-251"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="7e0e0-252">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-252">-or-</span></span> 
 <span data-ttu-id="7e0e0-253"><paramref name="name" />이 260자 보다 긴 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-253"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e0e0-254"><paramref name="maximumCount" />가 1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-254"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="7e0e0-255">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-255">-or-</span></span> 
 <span data-ttu-id="7e0e0-256"><paramref name="initialCount" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-256"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-257">명명된 세마포가 존재하고 이 세마포에 액세스 제어 보안이 있고 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-257">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e0e0-258">Win32 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-258">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e0e0-259">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 세마포를 만들 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-259">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e0e0-260">명명 된 시스템 세마포를 만들지 비관리 코드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-260">for calling unmanaged code to create a named system semaphore.</span></span> <span data-ttu-id="7e0e0-261">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="7e0e0-261">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span> <span data-ttu-id="7e0e0-262">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-262">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-263">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-263">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-264">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-264">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7e0e0-265">명명된 시스템 세마포에 대한 액세스 제어 보안을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-265">Gets the access control security for a named system semaphore.</span></span></summary>
        <returns><span data-ttu-id="7e0e0-266">명명된 시스템 세마포에 대한 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-266">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-267"><xref:System.Threading.Semaphore.GetAccessControl%2A> 메서드는 다음과 같은 조합을 플래그 (비트 OR 연산을 사용 하 여 결합)를 사용 하 여 사용 권한을 검색할: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, 및 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-267">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="7e0e0-268">사용자에 게 <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> 세마포 및이 메서드를 호출 하는 권한을 사용 하 여 열려 있어야 <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> 권한.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-268">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="7e0e0-269">로컬 세마포가에서 액세스 제어 보안은 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-269">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="7e0e0-270">경우는 <xref:System.Threading.Semaphore> 개체가 명명된 된 시스템 세마포를 나타내지 않는,이 메서드는 반환을 <xref:System.Security.AccessControl.SemaphoreSecurity> 모든 사용자에 게 모든 권한을 부여 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-270">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-271">다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 세마포 프로세스 간 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-271">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e0e0-272">이 예제에서는 사용은 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드 오버 로드는 명명 된 세마포의 존재 여부를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-272">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-273">세마포가 존재 하지 않는 경우 두 개의 최대 개수와 세마포를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 세마포에 대 한 권한이 변경 권한 부여는 액세스 제어 보안을 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-273">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-274">두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-274">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="7e0e0-275">예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 세마포를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-275">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="7e0e0-276">사용 하 여 가져온 시스템 세마포에 대 한 액세스 제어 보안을 <xref:System.Threading.Semaphore.GetAccessControl%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-276">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="7e0e0-277">권한이 변경 되 면 세마포를 입력 하 고 해제 하는 데 필요한 권한으로 열려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-277">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="7e0e0-278">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-278">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-279">현재 <see cref="T:System.Threading.Semaphore" /> 개체가 명명된 시스템 세마포를 나타내며 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-279">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span></span>  
  
<span data-ttu-id="7e0e0-280">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-280">-or-</span></span> 
<span data-ttu-id="7e0e0-281">현재 <see cref="T:System.Threading.Semaphore" /> 개체가 명명된 시스템 세마포를 나타내며 <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> 권한으로 열리지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-281">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7e0e0-282">Windows 98 또는 Windows Millennium Edition에서 지원되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-282">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-283">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-283">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-284">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-284">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7e0e0-285">이미 있는 경우 지정한 명명된 세마포를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-285">Opens a specified named semaphore, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7e0e0-286">열려는 시스템 세마포의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-286">The name of the system semaphore to open.</span></span></param>
        <summary><span data-ttu-id="7e0e0-287">이미 있는 경우 지정한 명명된 세마포를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-287">Opens the specified named semaphore, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="7e0e0-288">명명된 시스템 세마포를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-288">An object that represents the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-289"><xref:System.Threading.Semaphore.OpenExisting%2A> 메서드는 지정 된 명명 된 세마포를 열려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-289">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="7e0e0-290">시스템 세마포가 존재 하지 않는 경우이 메서드는 시스템 세마포를 만들지 않고 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-290">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="7e0e0-291">시스템 세마포를 만들려면 이미 존재 하지 않을 경우 중 하나를 사용 합니다 <xref:System.Threading.Semaphore.%23ctor%2A> 에 생성자를 `name` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-291">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7e0e0-292">에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Semaphore> 개체를 나타내는 반환 되는 개체가 동일한 명명 된 시스템 세마포가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-292">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-293">이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.Semaphore.OpenExisting%2A> 메서드 오버 로드 하 고 지정 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-293">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="7e0e0-294">지정 하는 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 플래그는 스레드가 세마포를 입력 될 수 있습니다 지정 하는 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 플래그는 스레드가 호출 될 수 있습니다는 <xref:System.Threading.Semaphore.Release%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-294">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-295">다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 세마포 프로세스 간 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-295">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e0e0-296">이 예제에서는 사용은 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드 오버 로드는 명명 된 세마포의 존재 여부를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-296">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-297">세마포가 존재 하지 않는 경우 두 개의 최대 개수와 세마포를 사용할 수 있는 권한이 현재 사용자 거부는 하지만 읽기 및 세마포에 대 한 권한이 변경 권한 부여는 액세스 제어 보안을 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-297">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-298">두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-298">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="7e0e0-299">예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 세마포를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-299">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7e0e0-300">권한이 변경 되 면 세마포를 입력 하 고 해제 하는 데 필요한 권한으로 열려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-300">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="7e0e0-301">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-301">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e0e0-302"><paramref name="name" />이 빈 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-302"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="7e0e0-303">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-303">-or-</span></span> 
 <span data-ttu-id="7e0e0-304"><paramref name="name" />이 260자 보다 긴 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-304"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e0e0-305"><paramref name="name" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-305"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e0e0-306">명명된 세마포가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-306">The named semaphore does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e0e0-307">Win32 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-307">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-308">명명된 세마포가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-308">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e0e0-309">명명된 된 시스템 세마포를 열려고 비관리 코드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-309">for calling unmanaged code to open a named system semaphore.</span></span> <span data-ttu-id="7e0e0-310">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="7e0e0-310">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span>  
  
<span data-ttu-id="7e0e0-311">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-311">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-312">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-312">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-313">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-313">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7e0e0-314">열려는 시스템 세마포의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-314">The name of the system semaphore to open.</span></span></param>
        <param name="rights"><span data-ttu-id="7e0e0-315">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-315">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="7e0e0-316">이미 있는 경우 지정한 명명된 세마포를 원하는 보안 액세스로 엽니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-316">Opens the specified named semaphore, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="7e0e0-317">명명된 시스템 세마포를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-317">An object that represents the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-318">`rights` 매개 변수에 포함 되어야 합니다 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 세마포를 입력 하는 스레드를 허용 하도록 플래그 및 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 호출 스레드를 허용 하도록 플래그를 <xref:System.Threading.Semaphore.Release%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-318">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="7e0e0-319"><xref:System.Threading.Semaphore.OpenExisting%2A> 메서드는 기존 명명 된 세마포를 열려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-319">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="7e0e0-320">시스템 세마포가 존재 하지 않는 경우이 메서드는 시스템 세마포를 만들지 않고 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-320">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="7e0e0-321">시스템 세마포를 만들려면 이미 존재 하지 않을 경우 중 하나를 사용 합니다 <xref:System.Threading.Semaphore.%23ctor%2A> 에 생성자를 `name` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-321">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7e0e0-322">에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Semaphore> 개체를 나타내는 반환 되는 개체가 동일한 명명 된 시스템 세마포가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-322">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-323">다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 세마포 프로세스 간 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-323">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e0e0-324">이 예제에서는 사용은 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드 오버 로드는 명명 된 세마포의 존재 여부를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-324">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-325">세마포가 존재 하지 않는 경우 두 개의 최대 개수와 세마포를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 세마포에 대 한 권한이 변경 권한 부여는 액세스 제어 보안을 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-325">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-326">두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-326">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="7e0e0-327">예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 세마포를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-327">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7e0e0-328">권한이 변경 되 면 세마포를 입력 하 고 해제 하는 데 필요한 권한으로 열려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-328">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="7e0e0-329">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-329">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e0e0-330"><paramref name="name" />이 빈 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-330"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="7e0e0-331">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-331">-or-</span></span> 
 <span data-ttu-id="7e0e0-332"><paramref name="name" />이 260자 보다 긴 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-332"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e0e0-333"><paramref name="name" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-333"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e0e0-334">명명된 세마포가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-334">The named semaphore does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e0e0-335">Win32 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-335">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-336">명명된 세마포가 있지만 사용자에게 원하는 보안 액세스 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-336">The named semaphore exists, but the user does not have the desired security access rights.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e0e0-337">명명 된 시스템 세마포를 만들지 비관리 코드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-337">for calling unmanaged code to create a named system semaphore.</span></span> <span data-ttu-id="7e0e0-338">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="7e0e0-338">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span>  
  
<span data-ttu-id="7e0e0-339">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-339">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-340">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-340">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-341">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-341">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7e0e0-342">세마포를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-342">Exits the semaphore.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7e0e0-343">세마포를 종료하고 이전 카운트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-343">Exits the semaphore and returns the previous count.</span></span></summary>
        <returns><span data-ttu-id="7e0e0-344"><see cref="Overload:System.Threading.Semaphore.Release" /> 메서드가 호출되기 전의 세마포 카운트입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-344">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-345">스레드는 일반적으로 사용 된 <xref:System.Threading.WaitHandle.WaitOne%2A> 세마포 있으며 일반적으로 입력 방법 종료 하려면이 메서드 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-345">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="7e0e0-346">경우는 <xref:System.Threading.SemaphoreFullException> 에 의해 throw 되는 <xref:System.Threading.Semaphore.Release%2A> 메서드를 호출 스레드를 사용 하 여 문제가 반드시 나타내지는지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-346">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="7e0e0-347">다른 스레드의 프로그래밍 오류 횟수 보다 더 많이 입력 세마포를 종료 하려면 스레드를 했을 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-347">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="7e0e0-348">하는 경우 현재 <xref:System.Threading.Semaphore> 개체가 명명된 된 시스템 세마포를 나타내는 사용자에 게 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 권한과 세마포 열려 있어야 사용 하 여 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 권한.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-348">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-349">다음 코드 예제에서는 세 개의 최대 개수를 및 0에 대 한 초기 카운트를 사용 하 여 세마포를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-349">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="7e0e0-350">이 예제에서는 세마포를 기다리는 동안 차단 하는 5 개의 스레드를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-350">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="7e0e0-351">주 스레드에서 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 세마포를 입력 하려면 3 개의 스레드를 허용 합니다. 최대값으로 세마포 수를 늘리려면 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-351">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="7e0e0-352">각 스레드가 사용 하는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 1 초 동안 기다린 후 작업을 시뮬레이션 한 다음 호출 하는 방법의 <xref:System.Threading.Semaphore.Release> 세마포를 해제 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-352">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-353">세마포를 해제 될 때마다 이전 세마포 카운트가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-353">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="7e0e0-354">콘솔 메시지 세마포 사용을 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-354">Console messages track semaphore use.</span></span> <span data-ttu-id="7e0e0-355">시뮬레이션 된 작업 간격 출력을 쉽게 읽을 수 있도록 각 스레드에 대해 약간 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-355">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException"><span data-ttu-id="7e0e0-356">세마포 카운트가 이미 최대값인 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-356">The semaphore count is already at the maximum value.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e0e0-357">명명된 세마포에서 Win32 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-357">A Win32 error occurred with a named semaphore.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-358">현재 세마포가 명명된 시스템 세마포를 나타내지만 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-358">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span></span>  
  
<span data-ttu-id="7e0e0-359">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-359">-or-</span></span> 
<span data-ttu-id="7e0e0-360">현재 세마포가 명명된 시스템 세마포를 나타내지만 세마포가 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />를 사용하여 열리지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-360">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-361">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-361">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-362">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-362">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount"><span data-ttu-id="7e0e0-363">세마포를 종료할 횟수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-363">The number of times to exit the semaphore.</span></span></param>
        <summary><span data-ttu-id="7e0e0-364">지정된 횟수만큼 세마포를 종료하고 이전 카운트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-364">Exits the semaphore a specified number of times and returns the previous count.</span></span></summary>
        <returns><span data-ttu-id="7e0e0-365"><see cref="Overload:System.Threading.Semaphore.Release" /> 메서드가 호출되기 전의 세마포 카운트입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-365">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-366">스레드가 세마포를 여러 번 시작 되었으면,이 메서드 오버 로드는 전체 세마포 카운트를를 호출 하 여 복원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-366">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="7e0e0-367">경우는 <xref:System.Threading.SemaphoreFullException> 에 의해 throw 되는 <xref:System.Threading.Semaphore.Release%2A> 메서드를 호출 스레드를 사용 하 여 문제가 반드시 나타내지는지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-367">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="7e0e0-368">다른 스레드의 프로그래밍 오류 횟수 보다 더 많이 입력 세마포를 종료 하려면 스레드를 했을 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-368">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="7e0e0-369">하는 경우 현재 <xref:System.Threading.Semaphore> 개체가 명명된 된 시스템 세마포를 나타내는 사용자에 게 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 권한과 세마포 열려 있어야 사용 하 여 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 권한.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-369">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-370">다음 코드 예제에서는 세 개의 최대 개수를 및 0에 대 한 초기 카운트를 사용 하 여 세마포를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-370">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="7e0e0-371">이 예제에서는 세마포를 기다리는 동안 차단 하는 5 개의 스레드를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-371">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="7e0e0-372">주 스레드에서 <xref:System.Threading.Semaphore.Release%28System.Int32%29> 세마포를 입력 하려면 3 개의 스레드를 허용 합니다. 최대값으로 세마포 수를 늘리려면 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-372">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="7e0e0-373">각 스레드가 사용 하는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 1 초 동안 기다린 후 작업을 시뮬레이션 한 다음 호출 하는 방법의 <xref:System.Threading.Semaphore.Release> 세마포를 해제 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-373">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-374">세마포를 해제 될 때마다 이전 세마포 카운트가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-374">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="7e0e0-375">콘솔 메시지 세마포 사용을 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-375">Console messages track semaphore use.</span></span> <span data-ttu-id="7e0e0-376">시뮬레이션 된 작업 간격 출력을 쉽게 읽을 수 있도록 각 스레드에 대해 약간 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-376">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e0e0-377"><paramref name="releaseCount" />가 1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-377"><paramref name="releaseCount" /> is less than 1.</span></span></exception>
        <exception cref="T:System.Threading.SemaphoreFullException"><span data-ttu-id="7e0e0-378">세마포 카운트가 이미 최대값인 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-378">The semaphore count is already at the maximum value.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e0e0-379">명명된 세마포에서 Win32 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-379">A Win32 error occurred with a named semaphore.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-380">현재 세마포가 명명된 시스템 세마포를 나타내지만 사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-380">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span></span>  
  
<span data-ttu-id="7e0e0-381">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-381">-or-</span></span> 
<span data-ttu-id="7e0e0-382">현재 세마포가 명명된 시스템 세마포를 나타내지만 세마포가 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 권한을 사용하여 열리지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-382">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-383">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-383">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-384">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-384">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity"><span data-ttu-id="7e0e0-385">명명된 시스템 세마포에 적용할 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-385">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span></span></param>
        <summary><span data-ttu-id="7e0e0-386">명명된 시스템 세마포에 대한 액세스 제어 보안을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-386">Sets the access control security for a named system semaphore.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-387">에 액세스 제어 보안을 설정할 수 있습니다 <xref:System.Threading.Semaphore> 명명 된 시스템 세마포를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-387">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="7e0e0-388">사용자에 게 <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> 세마포 및이 메서드를 호출 하는 권한을 사용 하 여 열려 있어야 <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> 권한.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-388">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e0e0-389">다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 세마포 프로세스 간 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-389">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e0e0-390">이 예제에서는 사용은 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드 오버 로드는 명명 된 세마포의 존재 여부를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-390">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-391">세마포가 존재 하지 않는 경우 두 개의 최대 개수와 세마포를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 세마포에 대 한 권한이 변경 권한 부여는 액세스 제어 보안을 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-391">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="7e0e0-392">두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우는 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-392">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="7e0e0-393">예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 세마포를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-393">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7e0e0-394">사용 권한을 사용 하 여 변경 된 후의 <xref:System.Threading.Semaphore.SetAccessControl%2A> 메서드, 세마포를 입력 하 고 해제 하는 데 필요한 권한을 사용 하 여 열입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-394">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="7e0e0-395">세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-395">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e0e0-396"><paramref name="semaphoreSecurity" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-396"><paramref name="semaphoreSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-397">사용자에게 <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-397">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span></span>  
  
<span data-ttu-id="7e0e0-398">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-398">-or-</span></span> 
<span data-ttu-id="7e0e0-399">세마포가 <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> 권한을 사용하여 열리지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-399">The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7e0e0-400">현재 <see cref="T:System.Threading.Semaphore" /> 개체가 명명된 시스템 세마포를 나타내지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-400">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e0e0-401">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="7e0e0-401">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e0e0-402">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e0e0-402">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7e0e0-403">지정된 명명된 semaphore(이미 존재하는 경우)를 열고 작업이 성공적으로 수행되었는지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-403">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7e0e0-404">열려는 시스템 세마포의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-404">The name of the system semaphore to open.</span></span></param>
        <param name="result"><span data-ttu-id="7e0e0-405">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 세마포를 나타내는 <see cref="T:System.Threading.Semaphore" /> 개체를 포함하고 호출에 실패한 경우에는 <see langword="null" />을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-405">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="7e0e0-406">이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-406">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="7e0e0-407">지정한 명명된 세마포(이미 존재하는 경우)를 열고 작업이 성공했는지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-407">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="7e0e0-408">명명된 세마포를 열었으면 <see langword="true" />이고, 그 열지 않았으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-408"><see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-409">명명 된 세마포가 존재 하지 않는 경우이 메서드 만들어지지는지 않습니다 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-409">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="7e0e0-410">시스템 세마포를 만들려면 이미 존재 하지 않을 경우 중 하나를 사용 합니다 <xref:System.Threading.Semaphore.%23ctor%2A> 에 생성자를 `name` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-410">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7e0e0-411">명명된 된 세마포 있는지 확실 하지 않은 경우 대신이 메서드 오버 로드를 사용 합니다 <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> 세마포가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-411">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="7e0e0-412">이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.Semaphore.TryOpenExisting%2A> 메서드 오버 로드 하 고 지정 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-412">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="7e0e0-413">지정 하는 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 플래그는 스레드가 세마포를 입력 될 수 있습니다 지정 하는 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 플래그는 스레드가 호출 될 수 있습니다는 <xref:System.Threading.Semaphore.Release%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-413">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e0e0-414"><paramref name="name" />이 빈 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-414"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="7e0e0-415">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-415">-or-</span></span> 
 <span data-ttu-id="7e0e0-416"><paramref name="name" />이 260자 보다 긴 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-416"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e0e0-417"><paramref name="name" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-417"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e0e0-418">Win32 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-418">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-419">명명된 세마포가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-419">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7e0e0-420">열려는 시스템 세마포의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-420">The name of the system semaphore to open.</span></span></param>
        <param name="rights"><span data-ttu-id="7e0e0-421">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-421">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="7e0e0-422">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 세마포를 나타내는 <see cref="T:System.Threading.Semaphore" /> 개체를 포함하고 호출에 실패한 경우에는 <see langword="null" />을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-422">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="7e0e0-423">이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-423">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="7e0e0-424">지정한 명명된 세마포(이미 존재하는 경우)를 원하는 보안 액세스로 열고 작업이 성공적으로 수행되었는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-424">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="7e0e0-425">명명된 세마포를 열었으면 <see langword="true" />이고, 그 열지 않았으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-425"><see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e0e0-426">명명 된 세마포가 존재 하지 않는 경우이 메서드 만들어지지는지 않습니다 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-426">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="7e0e0-427">시스템 세마포를 만들려면 이미 존재 하지 않을 경우 중 하나를 사용 합니다 <xref:System.Threading.Semaphore.%23ctor%2A> 에 생성자를 `name` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-427">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7e0e0-428">명명된 된 세마포 있는지 확실 하지 않은 경우 대신이 메서드 오버 로드를 사용 합니다 <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> 세마포가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-428">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="7e0e0-429">`rights` 매개 변수에 포함 되어야 합니다 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 세마포를 입력 하는 스레드를 허용 하도록 플래그 및 <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> 호출 스레드를 허용 하도록 플래그를 <xref:System.Threading.Semaphore.Release%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-429">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="7e0e0-430">에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Semaphore> 개체를 나타내는 반환 되는 개체가 동일한 명명 된 시스템 세마포가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-430">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e0e0-431"><paramref name="name" />이 빈 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-431"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="7e0e0-432">또는</span><span class="sxs-lookup"><span data-stu-id="7e0e0-432">-or-</span></span> 
 <span data-ttu-id="7e0e0-433"><paramref name="name" />이 260자 보다 긴 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-433"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e0e0-434"><paramref name="name" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="7e0e0-434"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e0e0-435">Win32 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-435">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e0e0-436">명명된 세마포가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="7e0e0-436">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>