<Type Name="LazyThreadSafetyMode" FullName="System.Threading.LazyThreadSafetyMode">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7f00d9d8962d1fd87330f2e8fe2f3cba1aea4aff" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58702233" /></Metadata><TypeSignature Language="C#" Value="public enum LazyThreadSafetyMode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed LazyThreadSafetyMode extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Threading.LazyThreadSafetyMode" />
  <TypeSignature Language="VB.NET" Value="Public Enum LazyThreadSafetyMode" />
  <TypeSignature Language="C++ CLI" Value="public enum class LazyThreadSafetyMode" />
  <TypeSignature Language="F#" Value="type LazyThreadSafetyMode = " />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary><span data-ttu-id="1c8da-101"><see cref="T:System.Lazy`1" /> 인스턴스가 여러 스레드 간 액세스를 동기화하는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-101">Specifies how a <see cref="T:System.Lazy`1" /> instance synchronizes access among multiple threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1c8da-102">이 열거형을 사용 하 여 지정 된 `mode` 의 매개 변수 <xref:System.Lazy%601> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-102">Use this enumeration to specify the `mode` parameter of <xref:System.Lazy%601> constructors.</span></span> <span data-ttu-id="1c8da-103">가지고 여부 또는이 열거형 측면에서 스레드 동기화에 대 한 모든 생성자의 효과 설명할 수 있습니다 `mode` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-103">The effects of all constructors on thread synchronization can be described in terms of this enumeration, whether or not they have `mode` parameters.</span></span>  
  
 <span data-ttu-id="1c8da-104">A <xref:System.Lazy%601> 인스턴스는 사용자 지정 초기화 메서드에서 또는 대 한 기본 생성자에서 초기화 `T`합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-104">A <xref:System.Lazy%601> instance is initialized either by a user-specified initialization method or by the default constructor for `T`.</span></span> <span data-ttu-id="1c8da-105">지정 된 초기화 메서드가 합니다 `valueFactory` 의 매개 변수를 <xref:System.Lazy%601> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-105">The initialization method is specified by the `valueFactory` parameter of a <xref:System.Lazy%601> constructor.</span></span> <span data-ttu-id="1c8da-106">인스턴스를 반환 하는 메서드 `T`, 인스턴스에서 지연 초기화 되는 형식인 <xref:System.Lazy%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-106">The method returns an instance of `T`, which is the type that is lazily instantiated by the instance of <xref:System.Lazy%601>.</span></span> <span data-ttu-id="1c8da-107">생성자가 없는 경우는 `valueFactory` 매개 변수, 기본 생성자 `T` 초기화 하는 데 사용 되는 <xref:System.Lazy%601> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="1c8da-107">If a constructor does not have a `valueFactory` parameter, the default constructor for `T` is used to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="1c8da-108">두 경우 모두 초기화가 처음 호출 하면 발생 합니다 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-108">In either case, initialization occurs the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="1c8da-109">스레드 보안을 지정 하는 것 외에도 <xref:System.Lazy%601> 예외 캐싱을 하는 경우가이 열거형에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-109">In addition to specifying the thread safety of a <xref:System.Lazy%601> instance, this enumeration affects exception caching.</span></span> <span data-ttu-id="1c8da-110">에 대 한 예외가 캐시 되 면을 <xref:System.Lazy%601> 인스턴스를 표시 한 번만 인스턴스를 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-110">When exceptions are cached for a <xref:System.Lazy%601> instance, you get only one chance to initialize the instance.</span></span> <span data-ttu-id="1c8da-111">처음으로 예외가 발생 하는 경우 호출 하는 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> 예외가 캐시 되 고 모든 후속 호출에서 다시 throw 속성인은 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-111">If an exception is thrown the first time you call the <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> property, that exception is cached and rethrown on all subsequent calls to the <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1c8da-112">예외 캐싱을의 장점은 모든 두 스레드가 오류가 발생 하는 경우에 항상 동일한 결과 얻을 한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-112">The advantage of caching exceptions is that any two threads always get the same result, even when errors occur.</span></span>  
  
 <span data-ttu-id="1c8da-113">PublicationOnly 모드를 지정 하는 경우 예외가 캐시 되지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-113">When you specify the PublicationOnly mode, exceptions are never cached.</span></span> <span data-ttu-id="1c8da-114">None를 지정 하는 경우 ExecutionAndPublication, 초기화 메서드를 지정 또는 기본 생성자를 허용 하는지 여부에 따라 달라 집니다 캐싱 또는 `T` 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-114">When you specify None or ExecutionAndPublication, caching depends on whether you specify an initialization method or allow the default constructor for `T` to be used.</span></span> <span data-ttu-id="1c8da-115">초기화 메서드를 지정하면 이 두 모드에 대해 예외 캐싱을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-115">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="1c8da-116">초기화 메서드는 매우 간단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-116">The initialization method can be very simple.</span></span> <span data-ttu-id="1c8da-117">예를 들어, `T`의 기본 생성자를 호출할 수 있습니다. C#의 경우 `new Lazy<Contents>(() => new Contents(), mode)` 또는 Visual Basic의 경우 `New Lazy(Of Contents)(Function() New Contents())`.</span><span class="sxs-lookup"><span data-stu-id="1c8da-117">For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="1c8da-118">예외에 대 한 기본 생성자가 throw 되는 초기화 메서드를 지정 하지 않는 생성자를 사용 하는 경우 `T` 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-118">If you use a constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached.</span></span> <span data-ttu-id="1c8da-119">다음 표에서 예외 캐싱 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-119">The following table summarizes exception caching behavior.</span></span>  
  
|<span data-ttu-id="1c8da-120">모드</span><span class="sxs-lookup"><span data-stu-id="1c8da-120">Mode</span></span>|<span data-ttu-id="1c8da-121">초기화 메서드를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="1c8da-121">Using initialization method</span></span>|<span data-ttu-id="1c8da-122">에 대 한 기본 생성자를 사용 하 여 `T`</span><span class="sxs-lookup"><span data-stu-id="1c8da-122">Using default constructor for `T`</span></span>|  
|----------|---------------------------------|---------------------------------------|  
|<span data-ttu-id="1c8da-123">없음</span><span class="sxs-lookup"><span data-stu-id="1c8da-123">None</span></span>|<span data-ttu-id="1c8da-124">캐시됨</span><span class="sxs-lookup"><span data-stu-id="1c8da-124">Cached</span></span>|<span data-ttu-id="1c8da-125">캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-125">Not cached</span></span>|  
|<span data-ttu-id="1c8da-126">PublicationOnly</span><span class="sxs-lookup"><span data-stu-id="1c8da-126">PublicationOnly</span></span>|<span data-ttu-id="1c8da-127">캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-127">Not cached</span></span>|<span data-ttu-id="1c8da-128">캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-128">Not cached</span></span>|  
|<span data-ttu-id="1c8da-129">ExecutionAndPublication</span><span class="sxs-lookup"><span data-stu-id="1c8da-129">ExecutionAndPublication</span></span>|<span data-ttu-id="1c8da-130">캐시됨</span><span class="sxs-lookup"><span data-stu-id="1c8da-130">Cached</span></span>|<span data-ttu-id="1c8da-131">캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-131">Not cached</span></span>|  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="1c8da-132">초기화 지연</span><span class="sxs-lookup"><span data-stu-id="1c8da-132">Lazy Initialization</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="ExecutionAndPublication">
      <MemberSignature Language="C#" Value="ExecutionAndPublication" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LazyThreadSafetyMode ExecutionAndPublication = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication" />
      <MemberSignature Language="VB.NET" Value="ExecutionAndPublication" />
      <MemberSignature Language="C++ CLI" Value="ExecutionAndPublication" />
      <MemberSignature Language="F#" Value="ExecutionAndPublication = 2" Usage="System.Threading.LazyThreadSafetyMode.ExecutionAndPublication" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LazyThreadSafetyMode</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary><span data-ttu-id="1c8da-133">잠금을 사용하여 단일 스레드만 스레드로부터 안전한 방식으로 <see cref="T:System.Lazy`1" /> 인스턴스를 초기화할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-133">Locks are used to ensure that only a single thread can initialize a <see cref="T:System.Lazy`1" /> instance in a thread-safe manner.</span></span> <span data-ttu-id="1c8da-134">초기화 메서드(또는 초기화 메서드를 찾을 수 없습니다. 기본 생성자)에서 내부적으로 잠금을 사용하는 경우 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-134">If the initialization method (or the default constructor, if there is no initialization method) uses locks internally, deadlocks can occur.</span></span> <span data-ttu-id="1c8da-135">초기화 메서드(<paramref name="valueFactory" /> 매개 변수)를 지정하는 <see cref="T:System.Lazy`1" /> 생성자를 사용하며 <see cref="P:System.Lazy`1.Value" /> 속성을 처음 호출할 때 해당 초기화 메서드에서 예외가 발생하거나 예외를 처리하지 못하는 경우 예외가 캐시되고 <see cref="P:System.Lazy`1.Value" /> 속성의 후속 호출에서 다시 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-135">If you use a <see cref="T:System.Lazy`1" /> constructor that specifies an initialization method (<paramref name="valueFactory" /> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <see cref="P:System.Lazy`1.Value" /> property, then the exception is cached and thrown again on subsequent calls to the <see cref="P:System.Lazy`1.Value" /> property.</span></span> <span data-ttu-id="1c8da-136">초기화 메서드를 지정하지 않는 <see cref="T:System.Lazy`1" /> 생성자를 사용하는 경우 <paramref name="T" />에 대한 기본 생성자에서 발생한 예외가 캐시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-136">If you use a <see cref="T:System.Lazy`1" /> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <paramref name="T" /> are not cached.</span></span> <span data-ttu-id="1c8da-137">이 경우 <see cref="P:System.Lazy`1.Value" /> 속성의 후속 호출에서 <see cref="T:System.Lazy`1" /> 인스턴스를 초기화할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-137">In that case, a subsequent call to the <see cref="P:System.Lazy`1.Value" /> property might successfully initialize the <see cref="T:System.Lazy`1" /> instance.</span></span> <span data-ttu-id="1c8da-138">초기화 메서드에서 <see cref="T:System.Lazy`1" /> 인스턴스의 <see cref="P:System.Lazy`1.Value" /> 속성에 재귀적으로 액세스하는 경우 <see cref="T:System.InvalidOperationException" />이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-138">If the initialization method recursively accesses the <see cref="P:System.Lazy`1.Value" /> property of the <see cref="T:System.Lazy`1" /> instance, an <see cref="T:System.InvalidOperationException" /> is thrown.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LazyThreadSafetyMode None = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LazyThreadSafetyMode.None" />
      <MemberSignature Language="VB.NET" Value="None" />
      <MemberSignature Language="C++ CLI" Value="None" />
      <MemberSignature Language="F#" Value="None = 0" Usage="System.Threading.LazyThreadSafetyMode.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LazyThreadSafetyMode</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><span data-ttu-id="1c8da-139"><see cref="T:System.Lazy`1" /> 인스턴스는 스레드로부터 안전하지 않습니다. 여러 스레드에서 인스턴스에 액세스하는 경우 해당 동작이 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-139">The <see cref="T:System.Lazy`1" /> instance is not thread safe; if the instance is accessed from multiple threads, its behavior is undefined.</span></span> <span data-ttu-id="1c8da-140">고성능이 중요하며 <see cref="T:System.Lazy`1" /> 인스턴스가 둘 이상의 스레드에서 초기화되지 않는 경우에만 이 모드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-140">Use this mode only when high performance is crucial and the <see cref="T:System.Lazy`1" /> instance is guaranteed never to be initialized from more than one thread.</span></span> <span data-ttu-id="1c8da-141">초기화 메서드(<paramref name="valueFactory" /> 매개 변수)를 지정하는 <see cref="T:System.Lazy`1" /> 생성자를 사용하며 <see cref="P:System.Lazy`1.Value" /> 속성을 처음 호출할 때 해당 초기화 메서드에서 예외가 발생하거나 예외를 처리하지 못하는 경우 예외가 캐시되고 <see cref="P:System.Lazy`1.Value" /> 속성의 후속 호출에서 다시 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-141">If you use a <see cref="T:System.Lazy`1" /> constructor that specifies an initialization method (<paramref name="valueFactory" /> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <see cref="P:System.Lazy`1.Value" /> property, then the exception is cached and thrown again on subsequent calls to the <see cref="P:System.Lazy`1.Value" /> property.</span></span> <span data-ttu-id="1c8da-142">초기화 메서드를 지정하지 않는 <see cref="T:System.Lazy`1" /> 생성자를 사용하는 경우 <paramref name="T" />에 대한 기본 생성자에서 발생한 예외가 캐시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-142">If you use a <see cref="T:System.Lazy`1" /> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <paramref name="T" /> are not cached.</span></span> <span data-ttu-id="1c8da-143">이 경우 <see cref="P:System.Lazy`1.Value" /> 속성의 후속 호출에서 <see cref="T:System.Lazy`1" /> 인스턴스를 초기화할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-143">In that case, a subsequent call to the <see cref="P:System.Lazy`1.Value" /> property might successfully initialize the <see cref="T:System.Lazy`1" /> instance.</span></span> <span data-ttu-id="1c8da-144">초기화 메서드에서 <see cref="T:System.Lazy`1" /> 인스턴스의 <see cref="P:System.Lazy`1.Value" /> 속성에 재귀적으로 액세스하는 경우 <see cref="T:System.InvalidOperationException" />이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-144">If the initialization method recursively accesses the <see cref="P:System.Lazy`1.Value" /> property of the <see cref="T:System.Lazy`1" /> instance, an <see cref="T:System.InvalidOperationException" /> is thrown.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="PublicationOnly">
      <MemberSignature Language="C#" Value="PublicationOnly" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LazyThreadSafetyMode PublicationOnly = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LazyThreadSafetyMode.PublicationOnly" />
      <MemberSignature Language="VB.NET" Value="PublicationOnly" />
      <MemberSignature Language="C++ CLI" Value="PublicationOnly" />
      <MemberSignature Language="F#" Value="PublicationOnly = 1" Usage="System.Threading.LazyThreadSafetyMode.PublicationOnly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LazyThreadSafetyMode</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary><span data-ttu-id="1c8da-145">여러 스레드에서 <see cref="T:System.Lazy`1" /> 인스턴스를 동시에 초기화하려고 하면 모든 스레드에서 초기화 메서드(또는 초기화 메서드를 찾을 수 없습니다. 기본 생성자)를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-145">When multiple threads try to initialize a <see cref="T:System.Lazy`1" /> instance simultaneously, all threads are allowed to run the initialization method (or the default constructor, if there is no initialization method).</span></span> <span data-ttu-id="1c8da-146">초기화를 완료하는 첫 번째 스레드에서 <see cref="T:System.Lazy`1" /> 인스턴스의 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-146">The first thread to complete initialization sets the value of the <see cref="T:System.Lazy`1" /> instance.</span></span> <span data-ttu-id="1c8da-147">초기화 메서드에서 해당 스레드에 대한 예외가 발생하지 않는 경우 초기화 메서드를 동시에 실행하는 다른 모든 스레드에 해당 값이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-147">That value is returned to any other threads that were simultaneously running the initialization method, unless the initialization method throws exceptions on those threads.</span></span> <span data-ttu-id="1c8da-148">경쟁하는 스레드에서 만든 모든 <paramref name="T" /> 인스턴스가 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-148">Any instances of <paramref name="T" /> that were created by the competing threads are discarded.</span></span> <span data-ttu-id="1c8da-149">초기화 메서드에서 스레드에 대한 예외가 발생하는 경우 해당 스레드의 <see cref="P:System.Lazy`1.Value" /> 속성에서 예외가 전파됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-149">If the initialization method throws an exception on any thread, the exception is propagated out of the <see cref="P:System.Lazy`1.Value" /> property on that thread.</span></span> <span data-ttu-id="1c8da-150">예외가 캐시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-150">The exception is not cached.</span></span> <span data-ttu-id="1c8da-151"><see cref="P:System.Lazy`1.IsValueCreated" /> 속성의 값은 <see langword="false" />로 유지되며, 예외가 발생한 스레드나 다른 스레드에 의한 <see cref="P:System.Lazy`1.Value" /> 속성의 후속 호출에서 초기화 메서드를 다시 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-151">The value of the <see cref="P:System.Lazy`1.IsValueCreated" /> property remains <see langword="false" />, and subsequent calls to the <see cref="P:System.Lazy`1.Value" /> property, either by the thread where the exception was thrown or by other threads, cause the initialization method to run again.</span></span> <span data-ttu-id="1c8da-152">초기화 메서드에서 <see cref="T:System.Lazy`1" /> 인스턴스의 <see cref="P:System.Lazy`1.Value" /> 속성에 재귀적으로 액세스하는 경우 예외가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c8da-152">If the initialization method recursively accesses the <see cref="P:System.Lazy`1.Value" /> property of the <see cref="T:System.Lazy`1" /> instance, no exception is thrown.</span></span></summary>
      </Docs>
    </Member>
  </Members>
</Type>