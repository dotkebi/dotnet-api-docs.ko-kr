<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata><Meta Name="ms.openlocfilehash" Value="94fa1b0b52de7d9f1fc5c7d53b8acd7be0623eb3" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58697015" /></Metadata><TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e6c24-101">다중 스레드에서 공유하는 변수에 대한 원자 단위 연산을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-101">Provides atomic operations for variables that are shared by multiple threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-102">이 클래스의 메서드는 스레드는 다른 스레드에서 액세스할 수 있는 변수를 업데이트 하는 동안 스케줄러 컨텍스트를 전환 하는 경우 또는 별도 프로세스에서 두 스레드가 동시에 실행 중일 때 발생할 수 있는 오류 로부터 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="e6c24-103">이 클래스의 멤버는 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="e6c24-104">합니다 <xref:System.Threading.Interlocked.Increment%2A> 고 <xref:System.Threading.Interlocked.Decrement%2A> 메서드 증가 또는 감소 변수 및 결과 값을 단일 작업에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="e6c24-105">대부분의 컴퓨터에서 변수를 증가 아닙니다는 원자성 작업으로 다음 단계를:</span><span class="sxs-lookup"><span data-stu-id="e6c24-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="e6c24-106">레지스터를 인스턴스 변수에서 값을 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="e6c24-107">증가 또는 감소 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="e6c24-108">인스턴스 변수에 값을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="e6c24-109">사용 하지 않는 경우 <xref:System.Threading.Interlocked.Increment%2A> 고 <xref:System.Threading.Interlocked.Decrement%2A>, 처음 두 단계를 실행 한 후 스레드를 선점 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="e6c24-110">다른 스레드가 세 단계를 모두 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="e6c24-111">첫 번째 스레드가 실행을 다시 시작 하는 경우 인스턴스 변수 값을 덮어씁니다을 증가 또는 감소가 두 번째 스레드가 수행한 미치는 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  

 <span data-ttu-id="e6c24-112"><xref:System.Threading.Interlocked.Add%2A> 메서드 원자 단위로를 정수 변수에 정수 값을 추가 하 고 변수의 새 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-112">The <xref:System.Threading.Interlocked.Add%2A> method atomically adds an integer value to an integer variable and returns the new value of the variable.</span></span>  
  
 <span data-ttu-id="e6c24-113"><xref:System.Threading.Interlocked.Exchange%2A> 메서드 지정 된 변수의 값을 원자적으로 교환 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-113">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="e6c24-114"><xref:System.Threading.Interlocked.CompareExchange%2A> 메서드 두 작업이 결합: 비교의 결과에 따라 변수의 하나에 두 값의 비교 및 저장할 세 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-114">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="e6c24-115">비교 및 교환 작업을 원자성 작업으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-115">The compare and exchange operations are performed as an atomic operation.</span></span>  

 <span data-ttu-id="e6c24-116">공유 변수에 대 한 읽기 나 쓰기 원자성 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-116">Ensure that any write or read access to a shared variable is atomic.</span></span> <span data-ttu-id="e6c24-117">그렇지 않으면 데이터가 손상 되었을 수 있습니다 또는 로드 된 값을 잘못 되었을.</span><span class="sxs-lookup"><span data-stu-id="e6c24-117">Otherwise, the data might be corrupted or the loaded value might be incorrect.</span></span>    
   
  
## Examples  
 <span data-ttu-id="e6c24-118">다음 코드 예제에는 스레드로부터 안전한 리소스 잠금 메커니즘을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-118">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="e6c24-119">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-119">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-120">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-120">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-121">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-121">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e6c24-122">원자 단위 연산으로 두 정수를 더하고 첫 번째 정수를 합계로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-122">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-123">더할 첫 번째 값이 있는 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-123">A variable containing the first value to be added.</span></span> <span data-ttu-id="e6c24-124">두 값의 합계는 <paramref name="location1" />에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-124">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-125"><paramref name="location1" />에서 정수에 더할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-125">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="e6c24-126">원자 단위 연산으로 두 32비트 정수를 더하고 첫 번째 정수를 합계로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-126">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-127"><paramref name="location1" />에 저장된 새 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-127">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-128">이 메서드를 래핑하여 오버플로 조건을 처리: 경우 값 `location1` 됩니다 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 및 `value` 이 1 이면 결과 <xref:System.Int32.MinValue?displayProperty=nameWithType>같으면 `value` 가 2 이면 결과 (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); 등.</span><span class="sxs-lookup"><span data-stu-id="e6c24-128">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="e6c24-129">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-129">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-130"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-130">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-131">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-131">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-132">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-132">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-133">더할 첫 번째 값이 있는 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-133">A variable containing the first value to be added.</span></span> <span data-ttu-id="e6c24-134">두 값의 합계는 <paramref name="location1" />에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-134">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-135"><paramref name="location1" />에서 정수에 더할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-135">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="e6c24-136">원자성 연산으로 두 64비트 정수를 더하고 첫 번째 정수를 합계로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-136">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-137"><paramref name="location1" />에 저장된 새 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-137">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-138">이 메서드를 래핑하여 오버플로 조건을 처리: 경우 값 `location1` 됩니다 <xref:System.Int64.MaxValue?displayProperty=nameWithType> 및 `value` 이 1 이면 결과 <xref:System.Int64.MinValue?displayProperty=nameWithType>같으면 `value` 가 2 이면 결과 (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); 등.</span><span class="sxs-lookup"><span data-stu-id="e6c24-138">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="e6c24-139">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-139">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-140"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-140">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-141">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-141">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-142">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-142">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e6c24-143">두 값이 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-143">Compares two values for equality and, if they are equal, replaces the first value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Double" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-144"><paramref name="comparand" />와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-144">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-145">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-145">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="e6c24-146"><paramref name="location1" />의 값과 비교할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-146">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="e6c24-147">두 배 정밀도 부동 소수점 숫자가 같은지 비교하여 같으면 두 값 중 하나를 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-147">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="e6c24-148"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-148">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-149">하는 경우 `comparand` 에 값 `location1` 가 같으면 `value` 에 저장 된 `location1`합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-149">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="e6c24-150">그렇지 않으면 작업이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-150">Otherwise, no operation is performed.</span></span> <span data-ttu-id="e6c24-151">비교 및 교환 작업을 원자성 작업으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-151">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="e6c24-152">반환 값 <xref:System.Threading.Interlocked.CompareExchange%2A> 에서 원래 값인 `location1`교환이 이루어지는 여부.</span><span class="sxs-lookup"><span data-stu-id="e6c24-152">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e6c24-153">다음 코드 예제를 실행 중인 총 누적 스레드로부터 안전한 메서드를 보여 줍니다. <xref:System.Double> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-153">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="e6c24-154">두 개의 스레드를 일련의 추가 <xref:System.Double> 일반적인 더하기를 확인 하 고 스레드로부터 안전한 메서드를 사용 하 여 값의 합계를 비교 하는 스레드가 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-154">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="e6c24-155">이중 프로세서 컴퓨터에서는 합계에는 큰 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-155">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="e6c24-156">스레드로부터 안전한 메서드에 누계의 초기 값이 저장 고를 <xref:System.Threading.Interlocked.CompareExchange%2A> 메서드 누계 새로 계산 된 총 exchange를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-156">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="e6c24-157">반환 값의 누계 저장 된 값과 같으면 없는 경우 다음 다른 스레드가 업데이트 총 그동안.</span><span class="sxs-lookup"><span data-stu-id="e6c24-157">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="e6c24-158">이 경우 누계를 업데이트 하려는 시도 반복 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-158">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-159"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-159">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-160">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-160">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-161">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-161">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-162"><paramref name="comparand" />와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-162">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-163">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-163">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="e6c24-164"><paramref name="location1" />의 값과 비교할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-164">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="e6c24-165">두 개의 부호 있는 32비트 정수가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-165">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="e6c24-166"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-166">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-167">하는 경우 `comparand` 에 값 `location1` 가 같으면 `value` 에 저장 된 `location1`합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-167">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="e6c24-168">그렇지 않으면 작업이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-168">Otherwise, no operation is performed.</span></span> <span data-ttu-id="e6c24-169">비교 및 교환 작업을 원자성 작업으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-169">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="e6c24-170">반환 값 <xref:System.Threading.Interlocked.CompareExchange%2A> 에서 원래 값인 `location1`교환이 이루어지는 여부.</span><span class="sxs-lookup"><span data-stu-id="e6c24-170">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e6c24-171">다음 코드 예제에서는 누계를 누적 하는 스레드로부터 안전한 메서드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-171">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="e6c24-172">누계의 초기 값이 저장 차례로 <xref:System.Threading.Interlocked.CompareExchange%2A> 메서드 누계 새로 계산 된 총 exchange를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-172">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="e6c24-173">반환 값의 누계 저장 된 값과 같으면 없는 경우 다음 다른 스레드가 업데이트 총 그동안.</span><span class="sxs-lookup"><span data-stu-id="e6c24-173">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="e6c24-174">이 경우 누계를 업데이트 하려는 시도 반복 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-174">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6c24-175"><xref:System.Threading.Interlocked.Add%2A> 메서드를.NET Framework 버전 2.0에에서 도입 된 정수에 대 한 누계 스레드로부터 안전한 누적 하는 보다 편리한 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-175">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-176"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-176">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-177">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-177">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-178">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-178">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Int64" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-179"><paramref name="comparand" />와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-179">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-180">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-180">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="e6c24-181"><paramref name="location1" />의 값과 비교할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-181">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="e6c24-182">두 개의 부호 있는 64비트 정수가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-182">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="e6c24-183"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-183">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-184">하는 경우 `comparand` 에 값 `location1` 가 같으면 `value` 에 저장 된 `location1`합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="e6c24-185">그렇지 않으면 작업이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="e6c24-186">비교 및 교환 작업을 원자성 작업으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="e6c24-187">반환 값 <xref:System.Threading.Interlocked.CompareExchange%2A> 에서 원래 값인 `location1`교환이 이루어지는 여부.</span><span class="sxs-lookup"><span data-stu-id="e6c24-187">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-188"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-188">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-189">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-189">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-190">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-190">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.IntPtr" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-191"><paramref name="comparand" /> 값과 비교되어 <paramref name="value" />로 바뀔 수 있는 값을 가진 대상 <see cref="T:System.IntPtr" />입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-191">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <paramref name="comparand" /> and possibly replaced by <paramref name="value" />.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-192">비교 결과가 같은 경우 대상 값을 바꿀 <see cref="T:System.IntPtr" />입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-192">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="e6c24-193"><paramref name="location1" />의 값과 비교할 <see cref="T:System.IntPtr" />입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-193">The <see cref="T:System.IntPtr" /> that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="e6c24-194">두 플랫폼별 핸들이나 포인터가 같은지 비교하고, 같으면 첫 번째 값을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-194">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="e6c24-195"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-195">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-196">하는 경우 `comparand` 에 값 `location1` 가 같으면 `value` 에 저장 된 `location1`합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-196">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="e6c24-197">그렇지 않으면 작업이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-197">Otherwise, no operation is performed.</span></span> <span data-ttu-id="e6c24-198">비교 및 교환 작업을 원자성 작업으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-198">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="e6c24-199">이 메서드의 반환 값은 원래 값에 `location1`교환이 이루어지는 여부.</span><span class="sxs-lookup"><span data-stu-id="e6c24-199">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6c24-200"><xref:System.IntPtr> 플랫폼별 형식이입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-200"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-201"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-201">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-202">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-202">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-203">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-203">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-204">참조에 의해 <paramref name="comparand" />와 비교되어 바뀔 수 있는 대상 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-204">The destination object that is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-205">참조 비교 결과가 같은 경우 대상 개체를 바꾸는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-205">The object that replaces the destination object if the reference comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="e6c24-206">참조에 의해 <paramref name="location1" />에서 개체와 비교되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-206">The object that is compared by reference to the object at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="e6c24-207">두 개체의 참조가 같은지 비교하고, 같으면 첫 번째 개체를 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-207">Compares two objects for reference equality and, if they are equal, replaces the first object.</span></span></summary>
        <returns><span data-ttu-id="e6c24-208"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-208">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="e6c24-209">.NET Framework 2.0 부터는 <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> 메서드 오버 로드 참조 형식의 형식이 안전한 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-209">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="e6c24-210">이 오버 로드 대신 호출 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-210">We recommend that you call it instead of this overload.</span></span>

<span data-ttu-id="e6c24-211">하는 경우 `comparand` 의 개체와 `location1` 같은지 참조 한 다음 `value` 에 저장 됩니다 `location1`합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-211">If `comparand` and the object in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="e6c24-212">그렇지 않으면 작업이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-212">Otherwise, no operation is performed.</span></span> <span data-ttu-id="e6c24-213">비교 및 교환 작업을 원자성 작업으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-213">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="e6c24-214">반환 값 <xref:System.Threading.Interlocked.CompareExchange%2A> 에서 원래 값인 `location1`교환이 이루어지는 여부.</span><span class="sxs-lookup"><span data-stu-id="e6c24-214">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  

> [!NOTE]
>  <span data-ttu-id="e6c24-215">값 같음이 아니라 참조 같음에 대 한 개체 비교 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-215">The objects are compared for reference equality rather than value equality.</span></span> <span data-ttu-id="e6c24-216">결과적으로, 동일한 두 boxed 인스턴스 값 형식 (예: 정수 3) 항상 같지 않은 것으로 표시 되 고 아무 작업도 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-216">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal and no operation is performed.</span></span> <span data-ttu-id="e6c24-217">값 형식과이 오버 로드를 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="e6c24-217">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e6c24-218"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-218">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-219">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-219">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-220">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-220">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-221"><paramref name="comparand" />와 비교하여 바뀔 수 있는 값을 가진 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-221">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-222">비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-222">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="e6c24-223"><paramref name="location1" />의 값과 비교할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-223">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="e6c24-224">두 단정밀도 부동 소수점 숫자가 같은지 비교하여 같으면 첫 번째 값을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-224">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="e6c24-225"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-225">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-226">하는 경우 `comparand` 에 값 `location1` 가 같으면 `value` 에 저장 된 `location1`합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-226">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="e6c24-227">그렇지 않으면 작업이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-227">Otherwise, no operation is performed.</span></span> <span data-ttu-id="e6c24-228">비교 및 교환 작업을 원자성 작업으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-228">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="e6c24-229">반환 값 <xref:System.Threading.Interlocked.CompareExchange%2A> 에서 원래 값인 `location1`교환이 이루어지는 여부.</span><span class="sxs-lookup"><span data-stu-id="e6c24-229">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e6c24-230">다음 코드 예제를 실행 중인 총 누적 스레드로부터 안전한 메서드를 보여 줍니다. <xref:System.Single> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-230">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="e6c24-231">두 개의 스레드를 일련의 추가 <xref:System.Single> 일반적인 더하기를 확인 하 고 스레드로부터 안전한 메서드를 사용 하 여 값의 합계를 비교 하는 스레드가 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-231">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="e6c24-232">이중 프로세서 컴퓨터에서는 합계에는 큰 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-232">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="e6c24-233">스레드로부터 안전한 메서드에 누계의 초기 값이 저장 고를 <xref:System.Threading.Interlocked.CompareExchange%2A> 메서드 누계 새로 계산 된 총 exchange를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-233">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="e6c24-234">반환 값의 누계 저장 된 값과 같으면 없는 경우 다음 다른 스레드가 업데이트 총 그동안.</span><span class="sxs-lookup"><span data-stu-id="e6c24-234">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="e6c24-235">이 경우 누계를 업데이트 하려는 시도 반복 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-235">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-236"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-236">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-237">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-237">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-238">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-238">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="T" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="e6c24-239"><paramref name="location1" />, <paramref name="value" /> 및 <paramref name="comparand" />에 사용될 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-239">The type to be used for <paramref name="location1" />, <paramref name="value" />, and <paramref name="comparand" />.</span></span> <span data-ttu-id="e6c24-240">이 형식은 참조 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-240">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="e6c24-241">참조에 의해 <paramref name="comparand" />와 비교되어 바뀔 수 있는 값을 가진 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-241">The destination, whose value is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span> <span data-ttu-id="e6c24-242">이것은 참조 매개 변수입니다. C#에서는 <see langword="ref" />이고, Visual Basic에서는 <see langword="ByRef" />입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-242">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-243">참조에 의한 비교 결과가 같은 경우 대상 값을 바꿀 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-243">The value that replaces the destination value if the comparison by reference results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="e6c24-244">참조에 의해 <paramref name="location1" />에서 값과 비교되는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-244">The value that is compared by reference to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="e6c24-245">지정된 참조 형식 <paramref name="T" />의 두 인스턴스에 대한 참조가 같은지 비교하고, 같으면 첫 번째 값을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-245">Compares two instances of the specified reference type <paramref name="T" /> for reference equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="e6c24-246"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-246">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-247">하는 경우 `comparand` 에 값 `location1` 같은지 참조 한 다음 `value` 에 저장 됩니다 `location1`합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-247">If `comparand` and the value in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="e6c24-248">그렇지 않으면 작업이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-248">Otherwise, no operation is performed.</span></span> <span data-ttu-id="e6c24-249">비교 및 교환 원자 단위 연산으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-249">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="e6c24-250">이 메서드의 반환 값은 원래 값에 `location1`교환이 이루어지는 여부.</span><span class="sxs-lookup"><span data-stu-id="e6c24-250">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="e6c24-251">이 메서드는 참조 형식만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-251">This method only supports reference types.</span></span> <span data-ttu-id="e6c24-252">오버 로드가 있습니다 합니다 <xref:System.Threading.Interlocked.CompareExchange%2A> 값 형식에 대 한 메서드 <xref:System.Int32>를 <xref:System.Int64>, <xref:System.IntPtr>를 <xref:System.Single>, 및 <xref:System.Double>, 이지만 다른 값 형식에 대해 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-252">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6c24-253">이 메서드 오버 로드에 적합 합니다 <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> 후자 런타임에 바인딩된 액세스는 대상 개체를 필요로 하기 때문에 메서드를 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-253">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-254"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-254">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e6c24-255">원자 단위 연산으로 지정된 변수를 감소시키고 결과를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-255">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="e6c24-256">값을 감소시킬 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-256">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="e6c24-257">원자 단위 연산으로 지정된 변수를 감소시키고 결과를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-257">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-258">감소한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-258">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-259">이 메서드를 래핑하여 오버플로 조건을 처리합니다. 하는 경우 `location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>하십시오 `location` -1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-259">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e6c24-260">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-260">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e6c24-261">다음 예제에서는 범위는 0에서 1,000 수 난수 중간점 값을 사용 하 여 1,000 개의 난수를 생성 하는 데 필요한 것을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-261">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="e6c24-262">변수 중간점 값의 수를 추적 하 `midpointCount`, 1,000 같고 감소 중간점 값을 반환 하는 난수 생성기 때마다 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-262">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="e6c24-263">세 개의 스레드 난수를 생성 하기 때문에 합니다 <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> 메서드는 여러 스레드가 업데이트 하지 않는 되도록 `midpointCount` 동시에 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-263">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="e6c24-264">잠금을 하 고 난수 생성기를 보호 하는 참고를 <xref:System.Threading.CountdownEvent> 개체를 사용 했는지를 `Main` 메서드 세 개의 스레드 하기 전에 실행이 완료 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-264">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="e6c24-265">사용 한다는 점을 제외 하 고 다음 예제는 이전 쿼리와 비슷합니다는 <xref:System.Threading.Tasks.Task> 50,000 임의 중간점 정수를 생성 하는 스레드 프로시저 대신 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-265">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="e6c24-266">이 예제에서는 람다 식을 대체는 `GenerateNumbers` 스레드 프로시저 및 호출 합니다 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 메서드 필요가 <xref:System.Threading.CountdownEvent> 개체.</span><span class="sxs-lookup"><span data-stu-id="e6c24-266">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e6c24-267"><paramref name="location" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-267">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-268">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-268">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-269">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-269">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="e6c24-270">값을 감소시킬 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-270">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="e6c24-271">원자 단위 연산으로 지정된 변수를 감소시키고 결과를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-271">Decrements the specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-272">감소한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-272">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-273">이 메서드를 래핑하여 오버플로 조건을 처리: 경우 `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>하십시오 `location` -1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-273">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e6c24-274">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-274">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e6c24-275"><paramref name="location" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-275">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-276">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-276">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-277">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-277">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e6c24-278">원자 단위 연산으로 변수를 지정된 값으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-278">Sets a variable to a specified value as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-279">지정된 값으로 설정할 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-279">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-280"><paramref name="location1" /> 매개 변수의 설정 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-280">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="e6c24-281">원자 단위 연산으로 배정밀도 부동 소수점 숫자를 지정된 값으로 설정하고 원래 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-281">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-282"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-282">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-283"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-283">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-284">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-284">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-285">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-285">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-286">지정된 값으로 설정할 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-286">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-287"><paramref name="location1" /> 매개 변수의 설정 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-287">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="e6c24-288">원자 단위 연산으로 부호 있는 32비트 정수를 지정된 값으로 설정하고 원래 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-288">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-289"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-289">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e6c24-290">다음 코드 예제에는 스레드로부터 안전한 리소스 잠금 메커니즘을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-290">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e6c24-291"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-291">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-292">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-292">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-293">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-293">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-294">지정된 값으로 설정할 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-294">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-295"><paramref name="location1" /> 매개 변수의 설정 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-295">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="e6c24-296">원자성 연산으로 부호 있는 64비트 정수를 지정된 값으로 설정하고 원래 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-296">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-297"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-297">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-298"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-298">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-299">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-299">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-300">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-300">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-301">지정된 값으로 설정할 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-301">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-302"><paramref name="location1" /> 매개 변수의 설정 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-302">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="e6c24-303">원자 단위 연산으로 플랫폼별 핸들 또는 포인터를 지정된 값으로 설정하고 원래 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-303">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-304"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-304">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-305"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-305">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-306">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-306">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-307">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-307">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-308">지정된 값으로 설정할 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-308">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-309"><paramref name="location1" /> 매개 변수의 설정 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-309">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="e6c24-310">원자 단위 연산으로 개체를 지정된 값으로 설정하고 참조를 원래 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-310">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-311"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-311">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="e6c24-312">.NET Framework 2.0 부터는 <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> 메서드 오버 로드 참조 형식의 형식이 안전한 대안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-312">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="e6c24-313">이 오버 로드 대신 호출 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-313">We recommend that you call it instead of this overload.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e6c24-314"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-314">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-315">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-315">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-316">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-316">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="e6c24-317">지정된 값으로 설정할 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-317">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-318"><paramref name="location1" /> 매개 변수의 설정 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-318">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="e6c24-319">원자 단위 연산으로 단정밀도 부동 소수점 숫자를 지정된 값으로 설정하고 원래 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-319">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-320"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-320">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-321"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-321">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-322">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-322">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-323">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-323">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="e6c24-324"><paramref name="location1" /> 및 <paramref name="value" />에 사용될 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-324">The type to be used for <paramref name="location1" /> and <paramref name="value" />.</span></span> <span data-ttu-id="e6c24-325">이 형식은 참조 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-325">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="e6c24-326">지정된 값으로 설정할 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-326">The variable to set to the specified value.</span></span> <span data-ttu-id="e6c24-327">이것은 참조 매개 변수입니다. C#에서는 <see langword="ref" />이고, Visual Basic에서는 <see langword="ByRef" />입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-327">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="e6c24-328"><paramref name="location1" /> 매개 변수의 설정 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-328">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="e6c24-329">원자 단위 연산으로 지정된 형식 <paramref name="T" />의 변수를 지정된 값으로 설정하고 원래 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-329">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-330"><paramref name="location1" />의 원래 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-330">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-331">이 메서드는 참조 형식만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-331">This method only supports reference types.</span></span> <span data-ttu-id="e6c24-332">오버 로드가 있습니다 합니다 <xref:System.Threading.Interlocked.Exchange%2A> 에 대 한 메서드를 <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, 및 <xref:System.Double> 형식 값 이지만 다른 값 형식에 대해 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-332">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e6c24-333">이 메서드 오버 로드에 적합 합니다 <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> 후자 대상 개체에 런타임에 바인딩된 액세스 해야 하기 때문에 메서드를 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-333">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-334"><paramref name="location1" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-334">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e6c24-335">원자 단위 연산으로 지정된 변수를 증가시키고 결과를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-335">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="e6c24-336">값을 증가시킬 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-336">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="e6c24-337">원자 단위 연산으로 지정된 변수를 증가시키고 결과를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-337">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-338">증가한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-338">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-339">이 메서드를 래핑하여 오버플로 조건을 처리: 경우 `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>하십시오 `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-339">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e6c24-340">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-340">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e6c24-341">다음 예제에서는 범위는 0에서 1,000 수 난수 중간점 값을 사용 하 여 1,000 개의 난수를 생성 하는 데 필요한 것을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-341">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="e6c24-342">변수 중간점 값의 수를 추적 하 `midpointCount`, 0으로 설정 되 고 10, 000 도달할 때까지 난수 생성기의 중간점 값을 반환 될 때마다 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-342">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="e6c24-343">세 개의 스레드 난수를 생성 하기 때문에 합니다 <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> 메서드는 여러 스레드가 업데이트 하지 않는 되도록 `midpointCount` 동시에 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-343">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="e6c24-344">잠금을 하 고 난수 생성기를 보호 하는 참고를 <xref:System.Threading.CountdownEvent> 개체를 사용 했는지를 `Main` 메서드 세 개의 스레드 하기 전에 실행이 완료 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-344">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="e6c24-345">사용 한다는 점을 제외 하 고 다음 예제는 이전 쿼리와 비슷합니다는 <xref:System.Threading.Tasks.Task> 50,000 임의 중간점 정수를 생성 하는 스레드 프로시저 대신 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-345">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="e6c24-346">이 예제에서는 람다 식을 대체는 `GenerateNumbers` 스레드 프로시저 및 호출 합니다 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 메서드 필요가 <xref:System.Threading.CountdownEvent> 개체.</span><span class="sxs-lookup"><span data-stu-id="e6c24-346">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-347"><paramref name="location" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-347">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-348">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-348">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-349">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-349">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="e6c24-350">값을 증가시킬 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-350">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="e6c24-351">원자 단위 연산으로 지정된 변수를 증가시키고 결과를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-351">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-352">증가한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-352">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-353">이 메서드를 래핑하여 오버플로 조건을 처리: 경우 `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>하십시오 `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-353">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e6c24-354">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-354">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="e6c24-355"><paramref name="location" />의 주소는 null 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-355">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-356">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-356">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-357">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-357">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e6c24-358">다음과 같이 메모리 액세스를 동기화합니다. 현재 스레드를 실행하는 프로세서는 <see cref="M:System.Threading.Interlocked.MemoryBarrier" />에 대한 호출 이전의 메모리 액세스가 <see cref="M:System.Threading.Interlocked.MemoryBarrier" />에 대한 호출 이후의 메모리 액세스 뒤에 실행되는 방식으로 명령을 다시 정렬할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-358">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-359">에 추가 된이 메서드는 <xref:System.Threading.Interlocked> 클래스를 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 것에 대 한 래퍼; 편의 <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="e6c24-359">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="e6c24-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> 취약 한 메모리 순서 (예를 들어 여러 Intel Itanium 프로세서를 사용 하는 시스템)는 다중 프로세서 시스템에만 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="e6c24-361">대부분의 용도, C# `lock` 문, Visual Basic `SyncLock` 문 또는 <xref:System.Threading.Monitor> 편리 하 게 데이터를 동기화 할 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-361">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e6c24-362">모든 CPU에서 읽기 및 쓰기가 장벽 간에 이동할 수 없도록 하는 프로세스 전체 메모리 장벽을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-362">Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="e6c24-363">합니다 `MemoryBarrierProcessWide` 메서드는 "normal"에서 다른 <xref:System.Threading.Interlocked.MemoryBarrier%2A> 같이 메서드:</span><span class="sxs-lookup"><span data-stu-id="e6c24-363">The `MemoryBarrierProcessWide` method differs from the "normal" <xref:System.Threading.Interlocked.MemoryBarrier%2A> method as follows:</span></span>

- <span data-ttu-id="e6c24-364">일반적인 메모리 장벽 하면 읽기 및 쓰기는 현재 CPU의 장벽 간에 이동할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-364">The normal memory barrier ensures that the reads and writes from the current CPU can't move across the barrier.</span></span> <span data-ttu-id="e6c24-365">읽기 또는 쓰기 프로세스 전체 메모리 장벽 보장 하는 모든 CPU에서 장벽 간에 이동할 수 없습니다 프로세스에서 사용 되 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-365">The process-wide memory barrier ensures that any read or write from any CPU being used in the process can't move across the barrier.</span></span>

- <span data-ttu-id="e6c24-366">일반적인 메모리 장벽 경우 적절 한 공유 액세스를 허용 *마다* 데이터에 액세스 하는 스레드 barrier를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-366">The normal memory barrier allows reasonable shared access if *every* thread accessing the data uses barriers.</span></span> <span data-ttu-id="e6c24-367">프로세스 전체 메모리 장벽 힘 *다른 Cpu* 프로세스 메모리 (예: 플러시 버퍼를 쓰고 읽기 버퍼 동기화)와 동기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-367">The process-wide memory barrier forces *other CPUs* to synchronize with process memory (for example, to flush write buffers and synchronize read buffers).</span></span> <span data-ttu-id="e6c24-368">이렇게 하면 일부 스레드에서 아닌 연동 작업에 대 한 및 여전히 적절 한 공유 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-368">This allows for non-interlocked operations on some threads and still have reasonable shared access.</span></span> 

- <span data-ttu-id="e6c24-369">일반적인 메모리 장벽 적용 오버 헤드가 매우 적습니다. 아마도 일반적인 연동된 작업에는 백 개 미만의 주기를 비용이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-369">The normal memory barrier imposes very little overhead; normal interlocked operations probably cost fewer than a hundred cycles.</span></span> <span data-ttu-id="e6c24-370">프로세스 전체 메모리 장벽 매우 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-370">The process-wide memory barrier is very expensive.</span></span> <span data-ttu-id="e6c24-371">이 프로세스의 모든 CPU를 강제로를 수천 주기가 가능성이 높은 비용 무언가를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-371">It has to force every CPU in the process do to something, at a probable cost of thousands of cycles.</span></span> 

<span data-ttu-id="e6c24-372">`MemoryBarrierProcessWide` 메서드는 또한 잠금 없음이라고 프로그래밍의 모든 미묘한에서 저하 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-372">The `MemoryBarrierProcessWide` method also suffers from all the subtleties of lock-free programming.</span></span> <span data-ttu-id="e6c24-373">그럼에도 불구 하 고 실제로 호출 해야 하지만 거의 발생 하지 않아야 하는 경우이 메서드가 매우 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-373">Nevertheless, this method can be extremely useful when you actually need to call it, which should be rare.</span></span>

<span data-ttu-id="e6c24-374">이 메서드 호출을 래핑한 [FlushProcessWriteBuffers](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers) Windows에서와 [sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) linux.</span><span class="sxs-lookup"><span data-stu-id="e6c24-374">This method wraps a call to [FlushProcessWriteBuffers](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers) on Windows and [sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) on Linux.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read :  -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="e6c24-375">로드될 64비트 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-375">The 64-bit value to be loaded.</span></span></param>
        <summary><span data-ttu-id="e6c24-376">원자 단위 연산으로 로드된 64비트 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-376">Returns a 64-bit value, loaded as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="e6c24-377">로드된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-377">The loaded value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e6c24-378"><xref:System.Threading.Interlocked.Read%2A> 64-bit 읽기 작업은 원자성 이미 있으므로 메서드는 64 비트 시스템에서 필요 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-378">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="e6c24-379">32 비트 시스템에서 64 비트 읽기 작업은 사용 하 여 수행 하지 않는 한 원자성 <xref:System.Threading.Interlocked.Read%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="e6c24-379">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="e6c24-380">관리되는 스레딩</span><span class="sxs-lookup"><span data-stu-id="e6c24-380">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="e6c24-381">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="e6c24-381">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SpeculationBarrier">
      <MemberSignature Language="C#" Value="public static void SpeculationBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpeculationBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.SpeculationBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpeculationBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpeculationBarrier();" />
      <MemberSignature Language="F#" Value="static member SpeculationBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.SpeculationBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>