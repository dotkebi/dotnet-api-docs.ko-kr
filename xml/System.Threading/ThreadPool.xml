<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dfe939fdbc3c31c6797ac84b6e8ba1c1352523f9" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56386471" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="c6b6f-101">작업 실행, 작업 항목 게시, 비동기 I/O 처리, 다른 스레드 대신 기다리기 및 타이머 처리에 사용할 수 있는 스레드 풀을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-102">대부분의 애플리케이션 상당한 시간 대기 상태에서 이벤트가 발생 하기를 기다리는 소비 하는 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="c6b6f-103">다른 스레드는 대기 상태에 상태 정보를 업데이트 하거나 변경에 대해 폴링하는 데 주기적으로 활성화에 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="c6b6f-104">스레드 풀을 사용 하면 시스템에 의해 관리 되는 작업자 스레드 풀을 사용 하 여 애플리케이션을 제공 하 여 스레드를 보다 효율적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="c6b6f-105">스레드 풀 스레드를 사용 하는 작업의 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="c6b6f-106">만들 때를 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601> 작업을 스레드 풀 스레드에서 실행 되도록 예약 되어 기본적으로 일부 작업을 비동기적으로 수행 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="c6b6f-107">비동기 타이머 스레드 풀을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="c6b6f-108">스레드 풀에서 콜백을 실행 합니다 <xref:System.Threading.Timer?displayProperty=nameWithType> 클래스에서 이벤트 발생 및는 <xref:System.Timers.Timer?displayProperty=nameWithType> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="c6b6f-109">등록 된 대기 핸들을 사용 하는 경우는 시스템 스레드가 대기 핸들의 상태를 모니터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="c6b6f-110">대기 작업이 완료 되 면 스레드 풀에서 작업자 스레드는 해당 하는 콜백 함수를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="c6b6f-111">호출 하는 경우는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 스레드 풀 스레드에서 실행에 대 한 메서드를 큐 대기 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="c6b6f-112">메서드를 전달 하 여이 작업을 수행 하는 <xref:System.Threading.WaitCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="c6b6f-113">시그니처가 대리자</span><span class="sxs-lookup"><span data-stu-id="c6b6f-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="c6b6f-114">여기서 `state` 는 대리자가 사용할 데이터가 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="c6b6f-115">호출 하 여 대리자에 전달할 수는 실제 데이터는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c6b6f-116">관리 되는 스레드 풀의 스레드는 백그라운드 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="c6b6f-117">즉, 해당 <xref:System.Threading.Thread.IsBackground%2A> 속성은 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="c6b6f-118">즉, 한 <xref:System.Threading.ThreadPool> 스레드 모든 포그라운드 스레드가 종료 된 후 실행 중인 애플리케이션을 유지 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c6b6f-119">스레드 풀이 스레드를 다시 사용하면 스레드 로컬 스토리지 또는 <xref:System.ThreadStaticAttribute> 특성으로 표시된 필드의 데이터가 지워지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="c6b6f-120">따라서 메서드가 스레드 로컬 스토리지 또는 <xref:System.ThreadStaticAttribute> 특성으로 표시된 필드를 검사할 때 발견한 값은 스레드 풀 스레드의 이전 사용에서 남겨둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="c6b6f-121">스레드 풀에 대기 작업과 관련 되지 않은 작업 항목을 대기 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="c6b6f-122">작업 항목을 스레드 풀 스레드에 의해 처리 될 요청을 호출 합니다 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="c6b6f-123">이 메서드는 메서드 또는 스레드 풀에서 선택한 스레드에서 호출 될 대리자에 대 한 참조를 매개 변수로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="c6b6f-124">이 대기 후 작업 항목을 취소 하는 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="c6b6f-125">타이머 큐 타이머 및 등록 된 대기 작업 스레드 풀을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="c6b6f-126">해당 콜백 함수는 스레드 풀에 대기 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="c6b6f-127">프로세스당 하나의 스레드 풀이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-127">There is one thread pool per process.</span></span> <span data-ttu-id="c6b6f-128">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]부터 프로세스에 대한 스레드 풀의 기본 크기는 가상 주소 공간의 크기와 같은 여러 요인에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="c6b6f-129">프로세스에서 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 메서드를 호출하여 스레드 수를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="c6b6f-130">사용 하 여 스레드 풀의 스레드 수를 변경할 수 있습니다는 <xref:System.Threading.ThreadPool.SetMaxThreads%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="c6b6f-131">기본 스택 크기를 사용 하 고 기본 우선 순위로 실행 하는 각 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c6b6f-132">.NET Framework를 호스트 하는 관리 되지 않는 코드를 사용 하 여 스레드 풀의 크기를 변경할 수는 `CorSetMaxThreads` mscoree.h 파일에 정의 된 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="c6b6f-133">스레드 풀은 각 범주에 대 한 최소값에 도달할 때까지 주문형 새 작업자 스레드 또는 I/O 완료 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="c6b6f-134">최소에 도달 하면 스레드 풀 해당 범주에 추가 스레드를 만들 수도 있고 일부 작업이 완료 될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="c6b6f-135">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]부터는 스레드 풀이 시간 단위당 완료되는 작업 수로 정의된 처리량을 최적화하기 위해 작업자 스레드를 만들고 소멸시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="c6b6f-136">스레드가 너무 적으면 사용 가능한 리소스가 효율적으로 사용되지 않는 반면, 너무 많으면 리소스 경합이 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c6b6f-137">요구가 적을 때는 실제 스레드 풀 스레드 수가 최소값보다 작을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="c6b6f-138"><xref:System.Threading.ThreadPool.GetMinThreads%2A> 메서드를 사용하여 이러한 최소값을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c6b6f-139">사용할 수는 <xref:System.Threading.ThreadPool.SetMinThreads%2A> 스레드의 최소 수를 늘리려면 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="c6b6f-140">그러나 이러한 값을 불필요하게 늘리면 성능 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="c6b6f-141">너무 많은 작업이 동시에 시작되는 경우 모두 속도가 느린 것처럼 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="c6b6f-142">대부분의 경우 스레드 풀은 고유한 스레드 할당 알고리즘에서 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6b6f-143">다음 예제에서는 기본 애플리케이션 스레드 큐 라는 메서드 `ThreadProc` 대기한 1 초에 한 다음 종료 스레드 풀 스레드에서 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="c6b6f-144">`ThreadProc` 메서드 단순히 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="c6b6f-145">호출을 주석 처리 하는 경우는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드는 스레드 풀 스레드에서 실행 되기 전에 메서드를 주 스레드를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="c6b6f-146">스레드 풀에는 애플리케이션이 모든 포그라운드 스레드가 종료 된 경우 실행을 유지 하지 않는 백그라운드 스레드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="c6b6f-147">(이것이 경합 상태의 간단한 예입니다.)</span><span class="sxs-lookup"><span data-stu-id="c6b6f-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="c6b6f-148">이 형식은 스레드로부터 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-148">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="c6b6f-149">스레드 및 스레딩</span><span class="sxs-lookup"><span data-stu-id="c6b6f-149">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-150">관리 되는 스레드 풀링</span><span class="sxs-lookup"><span data-stu-id="c6b6f-150">The Managed Thread Pooling</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c6b6f-151"><see cref="T:System.Threading.ThreadPool" />에 운영 체제 핸들을 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="c6b6f-152">핸들을 보유하는 <see cref="T:System.IntPtr" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span></span> <span data-ttu-id="c6b6f-153">핸들은 관리되지 않는 쪽의 겹쳐진 I/O에 열려 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="c6b6f-154"><see cref="T:System.Threading.ThreadPool" />에 운영 체제 핸들을 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-155">핸들이 바인딩되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-155"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c6b6f-156">호출자에게 필요한 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-156">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c6b6f-157">비관리 코드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-157">for the ability to call unmanaged code.</span></span> <span data-ttu-id="c6b6f-158">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="c6b6f-158">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="c6b6f-159">운영 체제 핸들을 보유하는 <see cref="T:System.Runtime.InteropServices.SafeHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span></span> <span data-ttu-id="c6b6f-160">핸들은 관리되지 않는 쪽의 겹쳐진 I/O에 열려 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-160">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="c6b6f-161"><see cref="T:System.Threading.ThreadPool" />에 운영 체제 핸들을 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-161">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-162">핸들이 바인딩되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-162"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-163">`osHandle` 매개 변수를 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, 추상에서 파생 되는 <xref:System.Runtime.InteropServices.SafeHandle> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-163">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c6b6f-164"><paramref name="osHandle" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-164"><paramref name="osHandle" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c6b6f-165">비관리 코드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-165">for the ability to call unmanaged code.</span></span> <span data-ttu-id="c6b6f-166">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="c6b6f-166">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="c6b6f-167">사용 가능한 작업자 스레드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-167">The number of available worker threads.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="c6b6f-168">사용 가능한 비동기 I/O 스레드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-168">The number of available asynchronous I/O threads.</span></span></param>
        <summary><span data-ttu-id="c6b6f-169"><see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> 메서드에서 반환하는 최대 스레드 풀 스레드 수와 현재 활성 상태인 스레드 수의 차이를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-169">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-170">때 <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> 에 지정 된 변수는 반환 `workerThreads` 시작할 수 있는 추가 작업자 스레드 및 변수에서 지정한 수가 포함 `completionPortThreads` 포함 될 수 있는 추가 비동기 I/O 스레드 수 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-170">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="c6b6f-171">사용 가능한 스레드가 없는 경우 스레드 풀 스레드가 사용 가능 해질 때까지 추가 스레드 풀 요청이 큐에 대기 중인 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-171">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6b6f-172">다음 예제에서는 간단한 앱이 시작 될 때 작업자 스레드 및 사용할 수 있는 I/O 스레드 수를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-172">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="c6b6f-173">스레드 풀에 있는 최대 작업자 스레드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-173">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="c6b6f-174">스레드 풀에 있는 최대 비동기 I/O 스레드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-174">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="c6b6f-175">동시에 활성 상태가 될 수 있는 스레드 풀에 대한 요청 수를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-175">Retrieves the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="c6b6f-176">해당 개수를 초과하는 모든 요청은 스레드 풀 스레드가 사용 가능해질 때까지 큐에 대기 상태로 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-176">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-177">때 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 에 지정 된 변수는 반환 `workerThreads` 최대 스레드 풀에 허용 된 작업자 스레드 및 지정 된 변수를 포함 `completionPortThreads` 에서 허용 하는 비동기 I/O 스레드의 최대 수를 포함 합니다 스레드 풀입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-177">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="c6b6f-178">사용할 수는 <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> 특정된 시점에 실제 스레드 풀의 스레드 수를 결정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-178">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="c6b6f-179">사용할 수는 <xref:System.Threading.ThreadPool.SetMaxThreads%2A> 스레드 풀에서 최대 작업자 스레드 및 비동기 I/O 스레드 수를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-179">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="c6b6f-180">시스템 메모리에서 허용 하는 만큼 스레드 풀 요청 큐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-180">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="c6b6f-181">스레드 풀 스레드 보다 더 많은 요청이 없으면 스레드 풀 스레드가 사용 가능 해질 때까지 추가 요청은 큐에 대기 중인 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-181">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6b6f-182">다음 코드 예제에는 스레드 풀의 스레드의 최대 및 사용 가능한 수의 개수를 검색 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-182">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="c6b6f-183">작업 항목을 큐에 대기 되는 `FileStream` 비동기적으로 두 개의 파일에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-183">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="c6b6f-184">콜백 메서드는 겹치는 시간이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-184">The callback methods are timed to overlap.</span></span> <span data-ttu-id="c6b6f-185">작업자 스레드가 작업 항목을 처리 하 고 속도 및 컴퓨터의 프로세서 수에 따라 하나 또는 두 개의 완료 포트 스레드 쓰기 작업을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-185">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="c6b6f-186">이 메서드가 반환될 때 스레드 풀에서 필요할 때 만드는 작업자 스레드의 최소 개수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-186">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="c6b6f-187">이 메서드가 반환될 때 스레드 풀에서 필요할 때 만드는 작업자 스레드의 최소 개수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-187">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="c6b6f-188">스레드 생성 및 소멸을 관리하기 위한 알고리즘으로 전환하기 전에 새 요청에 따라 스레드 풀이 만드는 스레드의 최소 개수를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-188">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-189">스레드 풀은 각 범주에 대 한 최소값에 도달할 때까지 주문형 새 작업자 스레드 또는 I/O 완료 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-189">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="c6b6f-190">기본적으로 최소 스레드 수는 시스템에서 프로세서의 수 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-190">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="c6b6f-191">최소값에 도달 하면 스레드 풀 해당 범주에 추가 스레드를 만들 수도 있고 일부 작업이 완료 될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-191">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="c6b6f-192">부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 스레드 풀을 만들고 시간 단위당 완료 하는 작업의 수로 정의 된 처리량을 최적화 하기 위해 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-192">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="c6b6f-193">스레드가 너무 적으면 사용 가능한 리소스가 효율적으로 사용되지 않는 반면, 너무 많으면 리소스 경합이 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-193">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c6b6f-194">요구가 적을 때는 실제 스레드 풀 스레드 수가 최소값보다 작을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-194">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6b6f-195">다음 예제에서는 작업자 스레드의 최소 수를 4 개로 설정 하 고 최소 비동기 I/O 완료 스레드 수에 대 한 원래 값을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-195">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c6b6f-196">실행을 위해 메서드를 큐에 대기시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-196">Queues a method for execution.</span></span> <span data-ttu-id="c6b6f-197">이 메서드는 스레드 풀 스레드를 사용할 수 있을 때 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-197">The method executes when a thread pool thread becomes available.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="c6b6f-198">실행할 메서드를 나타내는 <see cref="T:System.Threading.WaitCallback" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-198">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span></span></param>
        <summary><span data-ttu-id="c6b6f-199">실행을 위해 메서드를 큐에 대기시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-199">Queues a method for execution.</span></span> <span data-ttu-id="c6b6f-200">이 메서드는 스레드 풀 스레드를 사용할 수 있을 때 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-200">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-201">메서드가 성공적으로 큐에 대기되면 <see langword="true" />이고, 작업 항목을 큐에 대기할 수 없으면 <see cref="T:System.NotSupportedException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-201"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-202">큐에 대기 중인된 메서드에는 메서드가 정의 된 하거나 사용할 수는 클래스의 인스턴스 필드에 필요한 데이터를 배치할 수 있습니다는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> 필요한 데이터를 포함 하는 개체를 받아들이는 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-202">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c6b6f-203">Visual Basic 사용자를 생략할 수는 <xref:System.Threading.WaitCallback> 생성자 및 사용할 합니다 `AddressOf` 콜백 메서드를 전달 하는 경우 연산자 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-203">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="c6b6f-204">Visual Basic에는 자동으로 올바른 대리자 생성자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-204">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="c6b6f-205">버전 정보</span><span class="sxs-lookup"><span data-stu-id="c6b6f-205">Version Information</span></span>  
 <span data-ttu-id="c6b6f-206">.NET Framework 버전 2.0에에서는 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-206">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="c6b6f-207">이전 버전에서 주체 정보를 전파 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-207">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6b6f-208">다음 예제에서는 합니다 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> 으로 표현 되는 작업을 큐에 메서드 오버 로드는 `ThreadProc` 스레드 사용 가능 해지면 실행 방법.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-208">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="c6b6f-209">작업 정보가 없습니다이 오버 로드를 사용 하 여 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-209">No task information is supplied with this overload.</span></span> <span data-ttu-id="c6b6f-210">사용할 수 있는 정보를 따라서는 `ThreadProc` 메서드는 메서드가 속하는 개체를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-210">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c6b6f-211"><paramref name="callBack" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-211"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c6b6f-212">CLR(공용 언어 런타임)이 호스팅되며 호스트에서 이 작업을 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-212">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-213">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-213">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="c6b6f-214">실행할 메서드를 나타내는 <see cref="T:System.Threading.WaitCallback" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-214">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-215">메서드에서 사용할 데이터가 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-215">An object containing data to be used by the method.</span></span></param>
        <summary><span data-ttu-id="c6b6f-216">실행을 위해 메서드를 큐에 대기시키고 메서드에서 사용할 데이터가 들어 있는 개체를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-216">Queues a method for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="c6b6f-217">이 메서드는 스레드 풀 스레드를 사용할 수 있을 때 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-217">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-218">메서드가 성공적으로 큐에 대기되면 <see langword="true" />이고, 작업 항목을 큐에 대기할 수 없으면 <see cref="T:System.NotSupportedException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-218"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-219">콜백 메서드는 복잡 한 데이터에 필요한 경우에 데이터를 포함 하는 클래스를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-219">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c6b6f-220">Visual Basic 사용자를 생략할 수는 <xref:System.Threading.WaitCallback> 생성자 및 사용할 합니다 `AddressOf` 콜백 메서드를 전달 하는 경우 연산자 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-220">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="c6b6f-221">Visual Basic에는 자동으로 올바른 대리자 생성자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-221">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="c6b6f-222">버전 정보</span><span class="sxs-lookup"><span data-stu-id="c6b6f-222">Version Information</span></span>  
 <span data-ttu-id="c6b6f-223">.NET Framework 버전 2.0에에서는 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-223">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="c6b6f-224">이전 버전에서 주체 정보를 전파 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-224">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6b6f-225">다음 예제에서는.NET 스레드 풀을 사용 하 여 계산 된 `Fibonacci` 20에서 40 사이의 숫자를 다섯 개에 대 한 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-225">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="c6b6f-226">각 `Fibonacci` 결과는 계산을 수행하는 `ThreadPoolCallback`이라는 메서드를 제공하는 `Fibonacci` 클래스로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-226">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="c6b6f-227">각 `Fibonacci` 값을 나타내는 개체가 생성되고 `ThreadPoolCallback` 메서드가 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>에 전달되면, 여기서 풀에서 사용 가능한 스레드를 할당하여 메서드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-227">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="c6b6f-228">때문에 각 `Fibonacci` 개체 계산을 위해 어느 정도 임의적인 값이 지정 되 고 각 스레드가 프로세서 시간에 대 한 경쟁을 하기 때문에 모든 5 개 결과 계산할 걸리는 기간을 미리 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-228">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="c6b6f-229">이 때문에 생성 중 각 `Fibonacci` 개체에 <xref:System.Threading.ManualResetEvent> 클래스 인스턴스가 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-229">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="c6b6f-230">각 개체에 제공 된 이벤트 개체 신호 해당 계산이 완료 되 면, 기본 스레드를 사용 하 여 실행을 차단할 수 있습니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 모든 5 개까지 `Fibonacci` 결과 계산할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-230">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="c6b6f-231">그런 다음 `Main` 메서드가 각 `Fibonacci` 결과를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-231">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c6b6f-232">CLR(공용 언어 런타임)이 호스팅되며 호스트에서 이 작업을 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-232">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c6b6f-233"><paramref name="callBack" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-233"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-234">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-234">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c6b6f-235"><see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-235">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="c6b6f-236">등록할 <see cref="T:System.Threading.WaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-236">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="c6b6f-237"><see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-237">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="c6b6f-238"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 <see cref="T:System.Threading.WaitOrTimerCallback" /> 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-238">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-239">대리자에 전달되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-239">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="c6b6f-240">제한 시간(밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-240">The time-out in milliseconds.</span></span> <span data-ttu-id="c6b6f-241"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-241">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="c6b6f-242"><paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-242">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="c6b6f-243"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-243"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="c6b6f-244">제한 시간(밀리초)에 부호 있는 32비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-244">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-245">기본 핸들을 캡슐화하는 <see cref="T:System.Threading.RegisteredWaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-245">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-246">완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-246">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="c6b6f-247">항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-247">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="c6b6f-248">가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-248">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="c6b6f-249"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 대리자를 스레드 풀 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-249">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="c6b6f-250">작업자 스레드는 다음 중 하나가 발생 하면 대리자를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-250">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="c6b6f-251">지정된 된 개체가 신호를 받은 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-251">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="c6b6f-252">시간 제한 간격이 경과 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-252">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="c6b6f-253">합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 개체의 현재 상태를 확인 <xref:System.Threading.WaitHandle>합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-253">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c6b6f-254">개체의 상태를 신호 받음 없으면 메서드는 대기 작업을 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-254">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="c6b6f-255">대기 작업을 스레드 풀의 스레드에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-255">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="c6b6f-256">대리자는 개체의 상태를 신호 또는 시간 제한 간격이 경과 하는 경우 작업자 스레드에 의해 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-256">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="c6b6f-257">경우는 `timeOutInterval` 매개 변수가 아닌 0 (영) 및 `executeOnlyOnce` 매개 변수는 `false`, 이벤트 신호를 받는 되거나 시간 제한 간격이 경과 될 때마다 타이머가 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-257">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c6b6f-258">사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Win32 API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-258">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="c6b6f-259">대신를 <xref:System.Threading.Mutex>를 사용 하 여는 <xref:System.Threading.Semaphore> 1의 최대 수.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-259">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="c6b6f-260">대기 작업을 취소 하려면 호출을 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-260">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c6b6f-261">대기 스레드가 Win32를 사용 하 여 `WaitForMultipleObjects` 함수 등록 된 대기 작업을 모니터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-261">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="c6b6f-262">따라서에서 동일한 네이티브 운영 체제 핸들을 사용 해야 하는 경우를 여러 번 호출 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, Win32를 사용 하 여 핸들을 복제 해야 `DuplicateHandle` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-262">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="c6b6f-263">전달할 이벤트 개체를 펄스 하지는 확인 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>이므로 대기 스레드에서 다시 설정 되기 전에 이벤트가 신호를 감지 하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-263">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="c6b6f-264">함수가 반환 되기 전에 일부 유형의 동기화 개체의 상태를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-264">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="c6b6f-265">신호를 받은 상태로 인해 대기 조건이 충족된 하는 개체에 대해서만 수정이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-265">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="c6b6f-266">예를 들어, 세마포 수가 1 씩 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-266">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="c6b6f-267">버전 정보</span><span class="sxs-lookup"><span data-stu-id="c6b6f-267">Version Information</span></span>  
 <span data-ttu-id="c6b6f-268">.NET Framework 버전 2.0부터 합니다 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-268">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="c6b6f-269">이전 버전에서 주체 정보를 전파 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-269">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6b6f-270"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-270">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-271">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-271">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="c6b6f-272">등록할 <see cref="T:System.Threading.WaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-272">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="c6b6f-273"><see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-273">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="c6b6f-274"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 <see cref="T:System.Threading.WaitOrTimerCallback" /> 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-274">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-275">대리자에 전달된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-275">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="c6b6f-276">제한 시간(밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-276">The time-out in milliseconds.</span></span> <span data-ttu-id="c6b6f-277"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-277">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="c6b6f-278"><paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-278">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="c6b6f-279"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-279"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="c6b6f-280">제한 시간(밀리초)에 부호 있는 64비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-280">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-281">기본 핸들을 캡슐화하는 <see cref="T:System.Threading.RegisteredWaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-281">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-282">완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-282">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="c6b6f-283">항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-283">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="c6b6f-284">가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-284">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="c6b6f-285"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 대리자를 스레드 풀 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-285">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="c6b6f-286">작업자 스레드는 다음 중 하나가 발생 하면 대리자를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-286">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="c6b6f-287">지정된 된 개체가 신호를 받은 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-287">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="c6b6f-288">시간 제한 간격이 경과 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-288">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="c6b6f-289">합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 개체의 현재 상태를 확인 <xref:System.Threading.WaitHandle>합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-289">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c6b6f-290">개체의 상태를 신호 받음 없으면 메서드는 대기 작업을 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-290">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="c6b6f-291">대기 작업을 스레드 풀의 스레드에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-291">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="c6b6f-292">대리자는 개체의 상태를 신호 또는 시간 제한 간격이 경과 하는 경우 작업자 스레드에 의해 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-292">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="c6b6f-293">경우는 `timeOutInterval` 매개 변수가 아닌 0 (영) 및 `executeOnlyOnce` 매개 변수는 `false`, 이벤트 신호를 받는 되거나 시간 제한 간격이 경과 될 때마다 타이머가 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-293">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c6b6f-294">사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Win32 API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-294">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="c6b6f-295">대신를 <xref:System.Threading.Mutex>를 사용 하 여는 <xref:System.Threading.Semaphore> 1의 최대 수.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-295">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="c6b6f-296">대기 작업을 취소 하려면 호출을 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-296">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c6b6f-297">대기 스레드가 Win32를 사용 하 여 `WaitForMultipleObjects` 함수 등록 된 대기 작업을 모니터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-297">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="c6b6f-298">따라서에서 동일한 네이티브 운영 체제 핸들을 사용 해야 하는 경우를 여러 번 호출 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, Win32를 사용 하 여 핸들을 복제 해야 `DuplicateHandle` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-298">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="c6b6f-299">전달할 이벤트 개체를 펄스 하지는 확인 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>이므로 대기 스레드에서 다시 설정 되기 전에 이벤트가 신호를 감지 하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-299">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="c6b6f-300">함수가 반환 되기 전에 일부 유형의 동기화 개체의 상태를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-300">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="c6b6f-301">신호를 받은 상태로 인해 대기 조건이 충족된 하는 개체에 대해서만 수정이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-301">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="c6b6f-302">예를 들어, 세마포 수가 1 씩 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-302">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="c6b6f-303">버전 정보</span><span class="sxs-lookup"><span data-stu-id="c6b6f-303">Version Information</span></span>  
 <span data-ttu-id="c6b6f-304">.NET Framework 버전 2.0부터 합니다 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-304">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="c6b6f-305">이전 버전에서 주체 정보를 전파 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-305">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6b6f-306"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-306">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-307">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-307">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="c6b6f-308">등록할 <see cref="T:System.Threading.WaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-308">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="c6b6f-309"><see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-309">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="c6b6f-310"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 <see cref="T:System.Threading.WaitOrTimerCallback" /> 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-310">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-311">대리자에 전달된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-311">The object passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="c6b6f-312"><see cref="T:System.TimeSpan" />으로 나타낸 제한 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-312">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="c6b6f-313"><paramref name="timeout" />이 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-313">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="c6b6f-314"><paramref name="timeout" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-314">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="c6b6f-315"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-315"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="c6b6f-316">제한 시간에 <see cref="T:System.TimeSpan" /> 값을 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-316">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-317">기본 핸들을 캡슐화하는 <see cref="T:System.Threading.RegisteredWaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-317">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-318">완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-318">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="c6b6f-319">항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-319">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="c6b6f-320">가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-320">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="c6b6f-321"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 대리자를 스레드 풀 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-321">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="c6b6f-322">작업자 스레드는 다음 중 하나가 발생 하면 대리자를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-322">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="c6b6f-323">지정된 된 개체가 신호를 받은 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-323">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="c6b6f-324">시간 제한 간격이 경과 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-324">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="c6b6f-325">합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 개체의 현재 상태를 확인 <xref:System.Threading.WaitHandle>합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-325">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c6b6f-326">개체의 상태를 신호 받음 없으면 메서드는 대기 작업을 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-326">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="c6b6f-327">대기 작업을 스레드 풀의 스레드에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-327">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="c6b6f-328">대리자는 개체의 상태를 신호 또는 시간 제한 간격이 경과 하는 경우 작업자 스레드에 의해 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-328">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="c6b6f-329">경우는 `timeOutInterval` 매개 변수가 아닌 0 (영) 및 `executeOnlyOnce` 매개 변수는 `false`, 이벤트 신호를 받는 되거나 시간 제한 간격이 경과 될 때마다 타이머가 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-329">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c6b6f-330">사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Win32 API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-330">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="c6b6f-331">대신를 <xref:System.Threading.Mutex>를 사용 하 여는 <xref:System.Threading.Semaphore> 1의 최대 수.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-331">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="c6b6f-332">대기 작업을 취소 하려면 호출을 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-332">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c6b6f-333">대기 스레드가 Win32를 사용 하 여 `WaitForMultipleObjects` 함수 등록 된 대기 작업을 모니터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-333">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="c6b6f-334">따라서에서 동일한 네이티브 운영 체제 핸들을 사용 해야 하는 경우를 여러 번 호출 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, Win32를 사용 하 여 핸들을 복제 해야 `DuplicateHandle` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-334">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="c6b6f-335">전달할 이벤트 개체를 펄스 하지는 확인 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>이므로 대기 스레드에서 다시 설정 되기 전에 이벤트가 신호를 감지 하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-335">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="c6b6f-336">함수가 반환 되기 전에 일부 유형의 동기화 개체의 상태를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-336">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="c6b6f-337">신호를 받은 상태로 인해 대기 조건이 충족된 하는 개체에 대해서만 수정이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-337">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="c6b6f-338">예를 들어, 세마포 수가 1 씩 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-338">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="c6b6f-339">버전 정보</span><span class="sxs-lookup"><span data-stu-id="c6b6f-339">Version Information</span></span>  
 <span data-ttu-id="c6b6f-340">.NET Framework 버전 2.0부터 합니다 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-340">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="c6b6f-341">이전 버전에서 주체 정보를 전파 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-341">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6b6f-342"><paramref name="timeout" /> 매개 변수가 -1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-342">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c6b6f-343"><paramref name="timeout" /> 매개 변수가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-343">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-344">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-344">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="c6b6f-345">등록할 <see cref="T:System.Threading.WaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-345">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="c6b6f-346"><see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-346">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="c6b6f-347"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 <see cref="T:System.Threading.WaitOrTimerCallback" /> 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-347">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-348">대리자에 전달된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-348">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="c6b6f-349">제한 시간(밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-349">The time-out in milliseconds.</span></span> <span data-ttu-id="c6b6f-350"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-350">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="c6b6f-351"><paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-351">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="c6b6f-352"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-352"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="c6b6f-353">제한 시간(밀리초)에 부호 없는 32비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-353">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-354">등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-354">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-355">완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-355">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="c6b6f-356">항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-356">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="c6b6f-357">가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-357">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="c6b6f-358"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 대리자를 스레드 풀 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-358">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="c6b6f-359">작업자 스레드는 다음 중 하나가 발생 하면 대리자를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-359">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="c6b6f-360">지정된 된 개체가 신호를 받은 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-360">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="c6b6f-361">시간 제한 간격이 경과 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-361">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="c6b6f-362">합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 개체의 현재 상태를 확인 <xref:System.Threading.WaitHandle>합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-362">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c6b6f-363">개체의 상태를 신호 받음 없으면 메서드는 대기 작업을 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-363">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="c6b6f-364">대기 작업을 스레드 풀의 스레드에서 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-364">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="c6b6f-365">대리자는 개체의 상태를 신호 또는 시간 제한 간격이 경과 하는 경우 작업자 스레드에 의해 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-365">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="c6b6f-366">경우는 `timeOutInterval` 매개 변수가 아닌 0 (영) 및 `executeOnlyOnce` 매개 변수는 `false`, 이벤트 신호를 받는 되거나 시간 제한 간격이 경과 될 때마다 타이머가 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-366">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c6b6f-367">사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Win32 API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-367">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="c6b6f-368">대신를 <xref:System.Threading.Mutex>를 사용 하 여는 <xref:System.Threading.Semaphore> 1의 최대 수.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-368">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="c6b6f-369">대기 작업을 취소 하려면 호출을 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-369">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c6b6f-370">대기 스레드가 Win32를 사용 하 여 `WaitForMultipleObjects` 함수 등록 된 대기 작업을 모니터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-370">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="c6b6f-371">따라서에서 동일한 네이티브 운영 체제 핸들을 사용 해야 하는 경우를 여러 번 호출 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, Win32를 사용 하 여 핸들을 복제 해야 `DuplicateHandle` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-371">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="c6b6f-372">전달할 이벤트 개체를 펄스 하지는 확인 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>이므로 대기 스레드에서 다시 설정 되기 전에 이벤트가 신호를 감지 하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-372">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="c6b6f-373">함수가 반환 되기 전에 일부 유형의 동기화 개체의 상태를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-373">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="c6b6f-374">신호를 받은 상태로 인해 대기 조건이 충족된 하는 개체에 대해서만 수정이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-374">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="c6b6f-375">예를 들어, 세마포 수가 1 씩 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-375">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="c6b6f-376">버전 정보</span><span class="sxs-lookup"><span data-stu-id="c6b6f-376">Version Information</span></span>  
 <span data-ttu-id="c6b6f-377">.NET Framework 버전 2.0부터 합니다 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-377">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="c6b6f-378">이전 버전에서 주체 정보를 전파 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-378">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6b6f-379">다음 예제에서는 사용 하는 방법의 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 지정한 대기 핸들이 신호를 받을 때 지정된 된 콜백 메서드를 실행 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-379">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="c6b6f-380">이 예제에서는 콜백 메서드는 `WaitProc`, 및 대기 핸들은는 <xref:System.Threading.AutoResetEvent>합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-380">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="c6b6f-381">이 예제에서는 정의 `TaskInfo` 실행 될 때 콜백에 전달 되는 정보를 보유 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-381">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="c6b6f-382">이 예에서는 만듭니다는 `TaskInfo` 개체 및 문자열 데이터를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-382">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="c6b6f-383"><xref:System.Threading.RegisteredWaitHandle> 에서 반환 하는 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 에 메서드가 할당 됩니다는 `Handle` 필드를 `TaskInfo` 콜백 메서드가에 액세스할 수 있도록 개체를 <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-383">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="c6b6f-384">지정 하는 것 외에도 `TaskInfo` 콜백 메서드 호출에 전달할 개체로 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 지정는 <xref:System.Threading.AutoResetEvent> 에 대 한 작업에서 대기 하는 <xref:System.Threading.WaitOrTimerCallback> 나타내는 대리자입니다는 `WaitProc` 콜백 메서드를 1 초 제한 시간 간격 및 여러 콜백 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-384">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="c6b6f-385">주 스레드가 신호 하는 경우는 <xref:System.Threading.AutoResetEvent> 호출 하 여 해당 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드를를 <xref:System.Threading.WaitOrTimerCallback> 대리자가 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-385">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="c6b6f-386">합니다 `WaitProc` 메서드를 테스트 <xref:System.Threading.RegisteredWaitHandle> 제한 시간에 발생 한 것인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-386">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="c6b6f-387">대기 핸들 신호가 전달 되어 콜백이 호출 되는 경우는 `WaitProc` 메서드를 등록 취소를 <xref:System.Threading.RegisteredWaitHandle>, 콜백을 추가 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-387">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="c6b6f-388">시간 제한의 경우 작업이 계속 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-388">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="c6b6f-389">`WaitProc` 메서드가 콘솔에 메시지를 인쇄 하 여 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-389">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6b6f-390"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-390">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-391">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-391">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="c6b6f-392">스레드 풀에 있는 최대 작업자 스레드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-392">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="c6b6f-393">스레드 풀에 있는 최대 비동기 I/O 스레드 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-393">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="c6b6f-394">동시에 활성 상태가 될 수 있는 스레드 풀에 대한 요청 수를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-394">Sets the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="c6b6f-395">해당 개수를 초과하는 모든 요청은 스레드 풀 스레드가 사용 가능해질 때까지 큐에 대기 상태로 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-395">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-396">성공적으로 변경되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-396"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-397">설정할 수 없습니다 최대 작업자 스레드 또는 I/O 완료 스레드 수는 컴퓨터의 프로세서 수보다 작은 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-397">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="c6b6f-398">얼마나 많은 프로세서를 사용할 수 있는지를 확인 하려면 값을 검색 합니다 <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-398">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c6b6f-399">또한 최대 작업자 스레드 또는 작업자 스레드의 해당 최소 값 보다 작은 수로 I/O 완료 스레드 또는 I/O 완료 스레드를 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-399">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="c6b6f-400">최소 스레드 풀 크기를 확인 하려면 호출을 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-400">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="c6b6f-401">공용 언어 런타임 호스트 되는 경우 예를 들어 인터넷 정보 서비스 (IIS) 또는 SQL Server, 호스트 수 제한 하거나 스레드 풀 크기를 변경 하지 못하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-401">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="c6b6f-402">스레드 풀의 스레드의 최대 수를 변경 하는 경우에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-402">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="c6b6f-403">코드의 이점을 얻을 수, 하는 동안 변경 내용을 코드 라이브러리 사용에 부정적인 영향이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-403">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="c6b6f-404">스레드 풀 크기를 너무 크게 설정 하면 성능 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-404">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="c6b6f-405">너무 많은 스레드를 동시에 실행 하는 경우 작업 전환 오버 헤드가 중요 한 요인이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-405">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c6b6f-406">스레드를 제어 하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-406">for the ability to control threads.</span></span> <span data-ttu-id="c6b6f-407">권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="c6b6f-407">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="c6b6f-408">스레드 풀에서 필요할 때 만드는 작업자 스레드의 최소 개수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-408">The minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="c6b6f-409">스레드 풀에서 필요할 때 만드는 비동기 I/O 스레드의 최소 개수입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-409">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="c6b6f-410">스레드 생성 및 소멸을 관리하기 위한 알고리즘으로 전환하기 전에 새 요청에 따라 스레드 풀이 만드는 스레드의 최소 개수를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-410">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-411">성공적으로 변경되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-411"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-412">스레드 풀은 각 범주에 대 한 최소값에 도달할 때까지 주문형 새 작업자 스레드 또는 I/O 완료 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-412">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="c6b6f-413">최소값에 도달 하면 스레드 풀 해당 범주에 추가 스레드를 만들 수도 있고 일부 작업이 완료 될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-413">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="c6b6f-414">부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 스레드 풀을 만들고 시간 단위당 완료 하는 작업의 수로 정의 된 처리량을 최적화 하기 위해 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-414">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="c6b6f-415">스레드가 너무 적으면 사용 가능한 리소스가 효율적으로 사용되지 않는 반면, 너무 많으면 리소스 경합이 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-415">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="c6b6f-416">요구가 적을 때는 실제 스레드 풀 스레드 수가 최소값보다 작을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-416">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="c6b6f-417">음수 또는 활성 스레드 풀 스레드의 최대 개수 보다 큰 숫자를 지정 하는 경우 (사용 하 여 가져온 <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> 반환 `false` 최소 값 중 하나를 변경 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-417">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c6b6f-418">기본적으로 최소 스레드 수는 시스템에서 프로세서의 수 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-418">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="c6b6f-419">사용할 수는 <xref:System.Threading.ThreadPool.SetMinThreads%2A> 최소 숫자 ofthreads 증가 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-419">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="c6b6f-420">그러나 이러한 값을 불필요하게 늘리면 성능 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-420">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="c6b6f-421">너무 많은 작업이 동시에 시작되는 경우 모두 속도가 느린 것처럼 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-421">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="c6b6f-422">대부분의 경우에서 스레드 풀 스레드 할당 알고리즘을 사용 하 여 더 잘 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-422">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="c6b6f-423">최소 프로세서 수가 성능 저하 될 수 있습니다 보다 작은 값으로 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-423">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6b6f-424">다음 예제에서는 작업자 스레드의 최소 수를 4 개로 설정 하 고 최소 비동기 I/O 완료 스레드 수에 대 한 원래 값을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-424">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c6b6f-425">스레드를 제어 하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-425">for the ability to control threads.</span></span> <span data-ttu-id="c6b6f-426">권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="c6b6f-426">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped"><span data-ttu-id="c6b6f-427">큐에 대기시킬 <see cref="T:System.Threading.NativeOverlapped" /> 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-427">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span></span></param>
        <summary><span data-ttu-id="c6b6f-428">실행할 중첩된 I/O 작업을 큐에 대기시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-428">Queues an overlapped I/O operation for execution.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-429">작업이 I/O 완료 포트 큐에 성공적으로 대기되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-429"><see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-430">네이티브 Win32를 사용 하는 방법은 겹쳐진 I/O에 대 한 참조를 <xref:System.Threading.Overlapped> 클래스를 <xref:System.Threading.NativeOverlapped> 구조 및 `OVERLAPPED` Win32 플랫폼 SDK에는 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-430">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c6b6f-431">사용 하는 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> 메서드 보안 문제가 무심코 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-431">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="c6b6f-432">코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-432">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="c6b6f-433">작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, 스레드 풀 스레드 스택에 실제 호출자의 컨텍스트에서 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-433">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="c6b6f-434">악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-434">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6b6f-435">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-435">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6b6f-436">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="c6b6f-437">스레드 풀에 있는 스레드에서 작업 항목을 선택할 때 호출되는 대리자를 나타내는 <see cref="T:System.Threading.WaitCallback" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-437">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-438">스레드 풀에서 제공할 때 대리자에 전달되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-438">The object that is passed to the delegate when serviced from the thread pool.</span></span></param>
        <summary><span data-ttu-id="c6b6f-439">지정된 대리자를 스레드 풀에 대기시키지만 호출 스택을 작업자 스레드에 전파하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-439">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-440">메서드가 성공하면 <see langword="true" />이고, 작업 항목을 큐에 대기할 수 없으면 <see cref="T:System.OutOfMemoryException" />이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-440"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-441">와 달리 합니다 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-441">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="c6b6f-442">이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-442">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c6b6f-443">사용 하 여 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> 보안 문제가 무심코 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-443">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="c6b6f-444">코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-444">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="c6b6f-445">작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-445">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="c6b6f-446">악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-446">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c6b6f-447">호출자에게 필요한 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-447">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="c6b6f-448">메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-448">An out-of-memory condition was encountered.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c6b6f-449">작업 항목을 큐에 대기할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-449">The work item could not be queued.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c6b6f-450"><paramref name="callBack" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-450"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6b6f-451">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-451">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6b6f-452">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-452">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-453">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-453">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c6b6f-454"><see cref="T:System.Threading.WaitHandle" />를 기다리도록  대리자를 등록하지만 호출 스택을 작업자 스레드에 전파하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-454">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="c6b6f-455">등록할 <see cref="T:System.Threading.WaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-455">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="c6b6f-456"><see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-456">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="c6b6f-457"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-457">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-458">대리자에 전달되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-458">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="c6b6f-459">제한 시간(밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-459">The time-out in milliseconds.</span></span> <span data-ttu-id="c6b6f-460"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-460">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="c6b6f-461"><paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-461">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="c6b6f-462"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-462"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="c6b6f-463">제한 시간(밀리초)에 부호 있는 32비트 정수를 사용하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-463">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="c6b6f-464">이 메서드는 호출 스택을 작업자 스레드에 전파하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-464">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-465">등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-465">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-466">와 달리 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-466">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="c6b6f-467">이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-467">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c6b6f-468">사용 하 여 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 보안 문제가 무심코 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-468">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="c6b6f-469">코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-469">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="c6b6f-470">작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-470">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="c6b6f-471">악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-471">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="c6b6f-472">사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Win32 API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-472">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="c6b6f-473">완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-473">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="c6b6f-474">항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-474">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="c6b6f-475">가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-475">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6b6f-476"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-476">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c6b6f-477">호출자에게 필요한 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-477">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6b6f-478">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-478">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6b6f-479">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-479">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-480">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-480">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="c6b6f-481">등록할 <see cref="T:System.Threading.WaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-481">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="c6b6f-482"><see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-482">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="c6b6f-483"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-483">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-484">대리자에 전달되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-484">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="c6b6f-485">제한 시간(밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-485">The time-out in milliseconds.</span></span> <span data-ttu-id="c6b6f-486"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-486">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="c6b6f-487"><paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-487">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="c6b6f-488"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-488"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="c6b6f-489">제한 시간(밀리초)에 부호 있는 64비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-489">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="c6b6f-490">이 메서드는 호출 스택을 작업자 스레드에 전파하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-490">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-491">등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-491">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-492">와 달리 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-492">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="c6b6f-493">이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-493">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c6b6f-494">사용 하 여 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 보안 문제가 무심코 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-494">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="c6b6f-495">코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-495">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="c6b6f-496">작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-496">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="c6b6f-497">악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-497">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="c6b6f-498">사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Win32 API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-498">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="c6b6f-499">완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-499">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="c6b6f-500">항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-500">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="c6b6f-501">가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-501">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6b6f-502"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-502">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c6b6f-503">호출자에게 필요한 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-503">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6b6f-504">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-504">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6b6f-505">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-505">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-506">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-506">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="c6b6f-507">등록할 <see cref="T:System.Threading.WaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-507">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="c6b6f-508"><see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-508">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="c6b6f-509"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-509">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-510">대리자에 전달되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-510">The object that is passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="c6b6f-511"><see cref="T:System.TimeSpan" />으로 나타낸 제한 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-511">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="c6b6f-512"><paramref name="timeout" />이 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-512">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="c6b6f-513"><paramref name="timeout" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-513">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="c6b6f-514"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-514"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="c6b6f-515">제한 시간에 <see cref="T:System.TimeSpan" /> 값을 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다. 이 메서드는 호출 스택을 작업자 스레드에 전파하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-515">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-516">등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-516">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-517">와 달리 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-517">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="c6b6f-518">이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-518">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c6b6f-519">사용 하 여 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 보안 문제가 무심코 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-519">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="c6b6f-520">코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-520">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="c6b6f-521">작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-521">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="c6b6f-522">악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-522">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="c6b6f-523">사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Win32 API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-523">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="c6b6f-524">완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-524">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="c6b6f-525">항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-525">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="c6b6f-526">가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-526">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6b6f-527"><paramref name="timeout" /> 매개 변수가 -1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-527">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c6b6f-528"><paramref name="timeout" /> 매개 변수가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-528">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c6b6f-529">호출자에게 필요한 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-529">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6b6f-530">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-530">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6b6f-531">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-531">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-532">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-532">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="c6b6f-533">등록할 <see cref="T:System.Threading.WaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-533">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="c6b6f-534"><see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-534">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="c6b6f-535"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-535">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="c6b6f-536">대리자에 전달되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-536">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="c6b6f-537">제한 시간(밀리초)입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-537">The time-out in milliseconds.</span></span> <span data-ttu-id="c6b6f-538"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-538">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="c6b6f-539"><paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-539">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="c6b6f-540"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-540"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="c6b6f-541">제한 시간(밀리초)에 부호 없는 32비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-541">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span> <span data-ttu-id="c6b6f-542">이 메서드는 호출 스택을 작업자 스레드에 전파하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-542">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="c6b6f-543">등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-543">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6b6f-544">와 달리 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-544">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="c6b6f-545">이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-545">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c6b6f-546">사용 하 여 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 보안 문제가 무심코 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-546">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="c6b6f-547">코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-547">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="c6b6f-548">작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-548">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="c6b6f-549">악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-549">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="c6b6f-550">사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Win32 API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-550">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="c6b6f-551">완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-551">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="c6b6f-552">항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-552">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="c6b6f-553">가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-553">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="c6b6f-554">호출자에게 필요한 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="c6b6f-554">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6b6f-555">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-555">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6b6f-556">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6b6f-556">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="c6b6f-557">관리되는 스레드 풀</span><span class="sxs-lookup"><span data-stu-id="c6b6f-557">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>