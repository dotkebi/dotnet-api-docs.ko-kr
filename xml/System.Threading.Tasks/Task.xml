<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4845c0ed859423bf909c0fd95b7d29f966086850" /><Meta Name="ms.sourcegitcommit" Value="dadbb338a88266714d03fdd31e3616e7c61682e7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/05/2019" /><Meta Name="ms.locfileid" Value="57427083" /></Metadata><TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="43a34-101">비동기 작업을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-101">Represents an asynchronous operation.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <span data-ttu-id="43a34-102"><xref:System.Threading.Tasks.Task> 클래스는 반환 하지 않는 값을 지정 하 고는 일반적으로 단일 작업을 비동기적으로 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-102">The <xref:System.Threading.Tasks.Task> class represents a single operation that does not return a value and that usually executes asynchronously.</span></span> <span data-ttu-id="43a34-103"><xref:System.Threading.Tasks.Task> 개체는의 중앙 구성 요소 중 하나는 [작업 기반 비동기 패턴](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) .NET Framework 4에서 처음 도입 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-103"><xref:System.Threading.Tasks.Task> objects are one of the central components of the  [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) first introduced in the .NET Framework 4.</span></span> <span data-ttu-id="43a34-104">작업을 수행 하므로 <xref:System.Threading.Tasks.Task> 개체 일반적으로 비동기적으로 실행 스레드 풀 스레드에서 동기적으로 주 응용 프로그램 스레드에서 사용할 수 있습니다 것이 아니라 합니다 <xref:System.Threading.Tasks.Task.Status%2A> 속성인 뿐만 <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, 및 <xref:System.Threading.Tasks.Task.IsFaulted%2A> 속성에는 작업의 상태를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-104">Because the work performed by a <xref:System.Threading.Tasks.Task> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <xref:System.Threading.Tasks.Task.Status%2A> property, as well as the <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, and <xref:System.Threading.Tasks.Task.IsFaulted%2A> properties, to determine the   state of a task.</span></span> <span data-ttu-id="43a34-105">가장 일반적으로 작업을 수행 하는 작업을 지정 하는 람다 식 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-105">Most commonly, a lambda expression is used to specify the work that the task is to perform.</span></span>  
  
 <span data-ttu-id="43a34-106">사용할 값을 반환 하는 작업의 경우는 <xref:System.Threading.Tasks.Task%601> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-106">For operations that return values, you use the <xref:System.Threading.Tasks.Task%601> class.</span></span>  
  
 <span data-ttu-id="43a34-107">섹션 내용</span><span class="sxs-lookup"><span data-stu-id="43a34-107">In this section:</span></span>  
  
 <span data-ttu-id="43a34-108">[태스크 인스턴스화 예제](#Instant) </span><span class="sxs-lookup"><span data-stu-id="43a34-108">[Task instantiation examples](#Instant) </span></span>  
 <span data-ttu-id="43a34-109">[만들기 및 작업 실행](#Creating) </span><span class="sxs-lookup"><span data-stu-id="43a34-109">[Creating and executing a task](#Creating) </span></span>  
 <span data-ttu-id="43a34-110">[분리 작업 만들기 및 실행](#Separating) </span><span class="sxs-lookup"><span data-stu-id="43a34-110">[Separating task creation and execution](#Separating) </span></span>  
 <span data-ttu-id="43a34-111">[하나 이상의 작업이 완료 되기를 기다리는](#WaitingForOne) </span><span class="sxs-lookup"><span data-stu-id="43a34-111">[Waiting for one or more tasks to complete](#WaitingForOne) </span></span>  
 <span data-ttu-id="43a34-112">[작업 및 문화권](#Culture) </span><span class="sxs-lookup"><span data-stu-id="43a34-112">[Tasks and culture](#Culture) </span></span>  
 [<span data-ttu-id="43a34-113">디버거 개발자를 위한</span><span class="sxs-lookup"><span data-stu-id="43a34-113">For debugger developers</span></span>](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a><span data-ttu-id="43a34-114">작업 인스턴스화</span><span class="sxs-lookup"><span data-stu-id="43a34-114">Task instantiation</span></span>  
 <span data-ttu-id="43a34-115">다음 예제에서는 만들고 4 개의 작업을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-115">The following example creates and executes four tasks.</span></span> <span data-ttu-id="43a34-116">세 가지 작업 실행을 <xref:System.Action%601> 라는 대리자 `action`, 형식의 인수를 받아들이는 <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="43a34-116">Three tasks execute an <xref:System.Action%601> delegate named `action`, which accepts an argument of type <xref:System.Object>.</span></span> <span data-ttu-id="43a34-117">네 번째 태스크가 실행 하는 람다 식 (을 <xref:System.Action> 대리자) 작업 생성 방법에 대 한 호출에서 인라인으로 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-117">A fourth task executes a lambda expression (an <xref:System.Action> delegate) that is defined inline in the call to the task creation method.</span></span> <span data-ttu-id="43a34-118">각 작업 인스턴스화되고를 다른 방식으로 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-118">Each task is instantiated and run in a different way:</span></span>  
  
-   <span data-ttu-id="43a34-119">태스크 `t1` 기능은 작업 클래스 생성자를 호출 하 여 시작 되지만 호출 하 여 시작 하는 해당 <xref:System.Threading.Tasks.Task.Start> 작업 후에 메서드 `t2` 시작 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-119">Task `t1` is instantiated by calling a Task class constructor, but is started by calling its <xref:System.Threading.Tasks.Task.Start> method only after task `t2` has started.</span></span>  
  
-   <span data-ttu-id="43a34-120">태스크 `t2` 인스턴스화되고 호출 하 여 단일 메서드 호출에서 시작 된 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-120">Task `t2` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="43a34-121">태스크 `t3` 인스턴스화되고 호출 하 여 단일 메서드 호출에서 시작 된 <xref:System.Threading.Tasks.Task.Run%28System.Action%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-121">Task `t3` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
-   <span data-ttu-id="43a34-122">태스크 `t4` 주 스레드에서 호출 하 여 동기적으로 실행 되는 <xref:System.Threading.Tasks.Task.RunSynchronously> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-122">Task `t4` is executed synchronously on the main thread by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method.</span></span>  
  
 <span data-ttu-id="43a34-123">때문에 작업 `t4` 동기적으로 실행 응용 프로그램 주 스레드에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-123">Because task `t4` executes synchronously, it executes on the main application thread.</span></span> <span data-ttu-id="43a34-124">나머지 작업 실행 일반적으로 하나 이상의 스레드 풀 스레드에서 비동기적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-124">The remaining tasks execute asynchronously typically on one or more thread pool threads.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a><span data-ttu-id="43a34-125">만들기 및 작업 실행</span><span class="sxs-lookup"><span data-stu-id="43a34-125">Creating and executing a task</span></span>  
 <span data-ttu-id="43a34-126"><xref:System.Threading.Tasks.Task> 인스턴스는 여러 가지 방법으로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-126"><xref:System.Threading.Tasks.Task> instances may be created in a variety of ways.</span></span> <span data-ttu-id="43a34-127">부터 사용할 수 있는 가장 일반적인 방법은 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 정적 호출 하는 것 <xref:System.Threading.Tasks.Task.Run%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-127">The most common approach, which is available starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], is to call the static <xref:System.Threading.Tasks.Task.Run%2A> method.</span></span> <span data-ttu-id="43a34-128"><xref:System.Threading.Tasks.Task.Run%2A> 메서드는 기본값을 사용 하 여 작업을 시작 하는 간단한 방법을 제공 하 고 추가 매개 변수 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-128">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a simple way to start a task using default values and without requiring additional parameters.</span></span> <span data-ttu-id="43a34-129">다음 예제에서는 <xref:System.Threading.Tasks.Task.Run%28System.Action%29> 루프를 실행 한 다음 루프 반복 횟수를 표시 하는 작업을 시작 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="43a34-129">The following example uses the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to start a task that loops and then displays the number of loop iterations:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 <span data-ttu-id="43a34-130">대신 및 작업을 시작 하는 가장 일반적인 방법은 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]에 정적 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-130">An alternative, and the most common method to start a task in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], is the static <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-131"><xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> 속성에서 반환 된 <xref:System.Threading.Tasks.TaskFactory> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-131">The <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> property returns a <xref:System.Threading.Tasks.TaskFactory> object.</span></span> <span data-ttu-id="43a34-132">오버 로드는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드를 사용 하면 작업 생성 옵션 및 작업 스케줄러에 전달할 매개 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-132">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method let you specify parameters to pass to the task creation options and a task scheduler.</span></span> <span data-ttu-id="43a34-133">다음 예제에서는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드 작업을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-133">The following example uses the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to start a task.</span></span> <span data-ttu-id="43a34-134">이전 예제에서 코드에 기능적으로 같습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-134">It is functionally equivalent to the code in the previous example.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 <span data-ttu-id="43a34-135">자세한 예제를 보려면 [태스크 기반 비동기 프로그래밍](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-135">For more complete examples, see [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).</span></span>  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a><span data-ttu-id="43a34-136">분리 작업 만들기 및 실행</span><span class="sxs-lookup"><span data-stu-id="43a34-136">Separating task creation and execution</span></span>  
 <span data-ttu-id="43a34-137"><xref:System.Threading.Tasks.Task> 클래스는 또한 작업을 초기화 하는 하지만 해당 실행에 대 한 예약 하지 않습니다 하는 생성자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-137">The <xref:System.Threading.Tasks.Task> class also provides constructors that initialize the task but that do not schedule it for execution.</span></span> <span data-ttu-id="43a34-138">성능상의 이유로 합니다 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 또는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드를 만들고 계산 태스크를 예약 하기 위한 기본 메커니즘입니다 하지만 생성 및 일정 예약을 구분 해야 합니다는 시나리오에 대 한 생성자를 사용 하 여를 호출 합니다 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> 나중에 실행에 대 한 작업을 예약 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-138">For performance reasons, the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method is the preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation and scheduling must be separated, you can use the constructors and then call the <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> method to schedule the task for execution at a later time.</span></span>  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a><span data-ttu-id="43a34-139">하나 이상의 작업이 완료 되기를 기다리는</span><span class="sxs-lookup"><span data-stu-id="43a34-139">Waiting for one or more tasks to complete</span></span>  
 <span data-ttu-id="43a34-140">작업 일반적으로 스레드 풀 스레드에서 비동기적으로 실행, 때문에 작업을 인스턴스화해야 하는 즉시 만들고 작업을 시작 하는 스레드 실행을 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-140">Because tasks typically run asynchronously on a thread pool thread, the thread that creates and starts the task continues execution as soon as the task has been instantiated.</span></span> <span data-ttu-id="43a34-141">일부 경우에 호출 스레드는 주 응용 프로그램 스레드의 경우 앱을 종료할 수 있습니다 보다 먼저 태스크 실제로 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-141">In some cases, when the calling thread is the main application thread, the app may terminate before any the task actually begins execution.</span></span> <span data-ttu-id="43a34-142">다른 응용 프로그램의 논리는 하나 이상의 작업 실행을 완료 하는 경우에 호출 스레드가 계속 실행 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-142">In others,   your application's logic may require that the calling thread continue execution only when one or more tasks has completed execution.</span></span> <span data-ttu-id="43a34-143">호출 스레드의 실행을 동기화 할 수 있습니다 및 비동기 작업이 출시를 호출 하 여를 `Wait` 메서드를 하나 이상의 작업이 완료 될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-143">You can synchronize the execution of the calling thread and the asynchronous tasks it launches by calling a `Wait` method to wait for one or more tasks to complete.</span></span>  
  
 <span data-ttu-id="43a34-144">완료 하는 단일 작업에 대 한 대기를 호출 하면 해당 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-144">To wait for a single task to complete, you can call its <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-145">에 대 한 호출을 <xref:System.Threading.Tasks.Task.Wait%2A> 메서드는 단일 클래스 인스턴스 실행이 완료 될 때까지 호출 스레드를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-145">A call to the  <xref:System.Threading.Tasks.Task.Wait%2A> method blocks the calling thread until the single class instance has completed execution.</span></span>  
  
 <span data-ttu-id="43a34-146">다음 예제에서는 매개 변수가 없는 호출 <xref:System.Threading.Tasks.Task.Wait> 작업이 완료 될 때까지 무조건 대기 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-146">The following example calls the parameterless <xref:System.Threading.Tasks.Task.Wait> method to wait unconditionally until a task completes.</span></span> <span data-ttu-id="43a34-147">태스크를 호출 하 여 작업을 시뮬레이트하는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 2 초 대기 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-147">The task simulates work by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to sleep for two seconds.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 <span data-ttu-id="43a34-148">또한 조건에 따라 작업이 완료 되기를 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-148">You can also conditionally wait for a task to complete.</span></span> <span data-ttu-id="43a34-149">합니다 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> 및 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> 메서드는 작업이 완료 될 때까지 호출 스레드를 차단 또는 먼저 도달 하는 시간 제한 간격이 경과 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-149">The <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> and <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> methods block the calling thread until the task finishes or a timeout interval elapses, whichever comes first.</span></span> <span data-ttu-id="43a34-150">다음 예제에서는 2 초 동안 대기 하지만 해당 호출 스레드는 차단 시간 제한이 만료 될 때까지 1 초 제한 시간 값을 정의 하는 작업을 시작 하므로 전과 작업 실행이 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-150">Since the following example launches a task that sleeps for two seconds but defines a one-second timeout value, the calling thread blocks until the timeout expires and before the task has completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 <span data-ttu-id="43a34-151">호출 하 여 취소 토큰을 제공할 수도 있습니다는 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> 고 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-151">You can also supply a cancellation token by calling the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> and  <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> methods.</span></span> <span data-ttu-id="43a34-152">경우 토큰의 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 속성은 `true` 는 더 이상 `true` 하는 동안 합니다 <xref:System.Threading.Tasks.Task.Wait%2A> 메서드를 실행, 메서드가 throw는 <xref:System.OperationCanceledException>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-152">If the  token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true` or becomes `true` while the <xref:System.Threading.Tasks.Task.Wait%2A> method is executing, the method throws an <xref:System.OperationCanceledException>.</span></span>  
  
 <span data-ttu-id="43a34-153">경우에 따라 대기 하려는 싶지만 완료 하는 일련의 작업을 실행 중 첫 번째 작업 하는 주의 해야입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-153">In some cases, you may want to wait for the first of a series of executing tasks to complete, but don't care which task it is.</span></span>  <span data-ttu-id="43a34-154">이 위해 수 중 하나를 호출의 오버 로드는 <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-154">For this purpose, you can call one of the overloads of the <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="43a34-155">다음 예제에서는 난수 생성기에서 간격 결정에 대 한 절전 모드로 전환 되는 각 세 가지 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-155">The following example creates three tasks, each of which sleeps for an interval determine by a random number generator.</span></span> <span data-ttu-id="43a34-156"><xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> 메서드 첫 번째 작업이 완료 되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-156">The <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> method waits for the first task to complete.</span></span> <span data-ttu-id="43a34-157">다음 예제에서는 세 작업의 상태에 대 한 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-157">The example then displays information about the status of all three tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 <span data-ttu-id="43a34-158">일련의 작업을 호출 하 여 완료 모든 않을 수도 있습니다는 <xref:System.Threading.Tasks.Task.WaitAll%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-158">You can also wait for all of a series of tasks to complete by calling the <xref:System.Threading.Tasks.Task.WaitAll%2A> method.</span></span> <span data-ttu-id="43a34-159">다음 예제에서는 10 개의 작업을 만드는, 대기를 완료 하려면 모든 10에 대 한 다음 해당 상태를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-159">The following example creates ten tasks, waits for all ten to complete, and then displays their status.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 <span data-ttu-id="43a34-160">하나 이상의 작업이 완료 되기를 기다릴 때 호출 하는 스레드에서 실행 중인 작업에서 throw 된 예외 전파는 참고를 `Wait` 메서드를 다음 예제와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-160">Note that when you wait for one or more tasks to complete, any exceptions thrown in the running tasks are propagated on the thread that calls the `Wait` method, as the following example shows.</span></span> <span data-ttu-id="43a34-161">정상적으로 완료 중 3 개는 12 작업 및 세 가지 예외는 throw를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-161">It launches 12 tasks, three of which complete normally and three of which throw an exception.</span></span> <span data-ttu-id="43a34-162">나머지 6 가지 작업을 시작 하기 전에 취소 되는 세 가지 및 세는 동안 실행 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-162">Of the remaining six tasks, three are cancelled before the start, and three are cancelled while they executing.</span></span> <span data-ttu-id="43a34-163">예외가 throw 되는 <xref:System.Threading.Tasks.Task.WaitAll%2A> 에 의해 처리 되며 메서드 호출을 `try` / `catch` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-163">Exceptions are thrown in the <xref:System.Threading.Tasks.Task.WaitAll%2A> method call and are handled by a `try`/`catch` block.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 <span data-ttu-id="43a34-164">작업 기반 비동기 작업에서 예외 처리에 대 한 자세한 내용은 참조 하세요. [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-164">For more information on exception handling in task-based asynchronous operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a><span data-ttu-id="43a34-165">작업 및 문화권</span><span class="sxs-lookup"><span data-stu-id="43a34-165">Tasks and culture</span></span>  
 <span data-ttu-id="43a34-166">대상으로 하는 데스크톱 앱을 사용 하 여 시작 합니다 [!INCLUDE[net_v46](~/includes/net-v46-md.md)], 스레드 컨텍스트의 일부가 만들고 작업을 호출 하는 스레드의 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-166">Starting with desktop apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the thread that creates and invokes a task becomes part of the thread's context.</span></span> <span data-ttu-id="43a34-167">즉, 태스크가 실행 하는 스레드의 현재 문화권에 관계 없이 현재 태스크의 문화권이 호출 스레드의 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-167">That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</span></span> <span data-ttu-id="43a34-168">이전에.NET Framework의 버전을 대상으로 하는 앱에 대 한는 [!INCLUDE[net_v46](~/includes/net-v46-md.md)], 작업의 문화권은 태스크가 실행 하는 스레드의 문화권입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-168">For apps that target versions of the .NET Framework prior to the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the task is the culture of the thread on which the task executes.</span></span> <span data-ttu-id="43a34-169">자세한 내용은 "문화권 및 작업 기반 비동기 작업" 섹션을 참조 합니다 <xref:System.Globalization.CultureInfo> 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-169">For more information, see the "Culture and task-based asynchronous operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43a34-170">스토어 앱 설정 및 기본 문화권을 가져오는 Windows 런타임을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-170">Store apps follow the Windows Runtime in setting and getting the default culture.</span></span>  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a><span data-ttu-id="43a34-171">디버거 개발자를 위한</span><span class="sxs-lookup"><span data-stu-id="43a34-171">For debugger developers</span></span>  
 <span data-ttu-id="43a34-172">사용자 지정 디버거를 구현 하는 개발자에 대 한 작업의 여러 내부 및 전용 멤버 (릴리스 간에 변경 될 수 있습니다 이러한) 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-172">For developers implementing custom debuggers, several internal and private members of task may be useful (these may change from release to release).</span></span> <span data-ttu-id="43a34-173">하지만 `m_taskId` 필드에 대 한 백업 저장소로 사용 되는 <xref:System.Threading.Tasks.Task.Id%2A> 속성을 액세스이 필드는 디버거를 직접 더 효율적일 수 있습니다 속성의 getter 메서드를 통해 동일한 값에 액세스 하는 보다 (의 `s_taskIdCounter` 카운터는 사용 되는 작업에 대 한 사용 가능한 다음 ID를 검색할).</span><span class="sxs-lookup"><span data-stu-id="43a34-173">The `m_taskId` field serves as the backing store for the <xref:System.Threading.Tasks.Task.Id%2A> property, however accessing this field directly from a debugger may be more efficient than accessing the same value through the property's getter method (the `s_taskIdCounter` counter is used to retrieve the next available ID for a task).</span></span> <span data-ttu-id="43a34-174">마찬가지로, 합니다 `m_stateFlags` 정보를 통해 액세스할 수 있는 작업의 현재 수명 주기 단계에 대 한 정보를 저장 하는 필드는 <xref:System.Threading.Tasks.Task.Status%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="43a34-174">Similarly, the `m_stateFlags` field stores information about the current lifecycle stage of the task, information also accessible through the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="43a34-175">합니다 `m_action` 필드는 작업의 대리자에 대 한 참조를 저장 및 `m_stateObject` 필드는 개발자가 작업에 전달 된 비동기 상태를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-175">The `m_action` field stores a reference to the task's delegate, and the `m_stateObject` field stores the async state passed to the task by the developer.</span></span> <span data-ttu-id="43a34-176">스택 프레임을 구문 분석 하는 디버거를 마지막으로 `InternalWait` 메서드는 다음 작업을 대기 작업을 입력 하는 경우에 대 한 잠재적인 표식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-176">Finally, for debuggers that parse stack frames, the `InternalWait` method serves a potential marker for when a task is entering a wait operation.</span></span>   
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="43a34-177">모든 구성원이 <see cref="T:System.Threading.Tasks.Task" />를 제외 하 고 <see cref="M:System.Threading.Tasks.Task.Dispose" />는 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-177">All members of <see cref="T:System.Threading.Tasks.Task" />, except for <see cref="M:System.Threading.Tasks.Task.Dispose" />, are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="43a34-178">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-178">Task Parallel Library (TPL)</span></span></related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="43a34-179">작업 기반 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="43a34-179">Task-based Asynchronous Programming</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="43a34-180">.NET Framework 사용한 병렬 프로그래밍 샘플</span><span class="sxs-lookup"><span data-stu-id="43a34-180">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-181">새 <see cref="T:System.Threading.Tasks.Task" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-181">Initializes a new <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-182">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-182">The delegate that represents the code to execute in the task.</span></span></param>
        <summary><span data-ttu-id="43a34-183">지정된 작업을 사용하여 새 <see cref="T:System.Threading.Tasks.Task" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-183">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-184">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> 또는 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-184">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-185">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-185">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-186">다음 예제에서는 <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> 생성자에서 파일 이름을 검색 하는 작업을 만드는 디렉터리를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-186">The following example uses the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to create tasks that retrieve the filenames in specified directories.</span></span> <span data-ttu-id="43a34-187">모든 작업을 단일 파일 이름을 쓸 <xref:System.Collections.Concurrent.ConcurrentBag%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-187">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="43a34-188">다음 호출 하 여 합니다 <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> 모든 작업을 완료 하 고 다음에 기록 하는 파일 이름의 총 개수를 표시 하도록 메서드를 <xref:System.Collections.Concurrent.ConcurrentBag%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-188">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 <span data-ttu-id="43a34-189">다음 예제는 사용 한다는 점을 제외 하면 동일 합니다 <xref:System.Threading.Tasks.Task.Run%28System.Action%29> 메서드를 인스턴스화할 때 단일 작업에서 작업을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-189">The following example is identical, except that it used the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to instantiate and run the task in a single operation.</span></span> <span data-ttu-id="43a34-190">메서드는 반환 된 <xref:System.Threading.Tasks.Task> 작업을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-190">The method returns the <xref:System.Threading.Tasks.Task> object that represents the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-191"><paramref name="action" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-191">The <paramref name="action" /> argument is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-192">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-192">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-193">작업이 관찰할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-193">The <see cref="T:System.Threading.CancellationToken" /> that the new  task will observe.</span></span></param>
        <summary><span data-ttu-id="43a34-194">지정된 작업을 사용하여 새 <see cref="T:System.Threading.Tasks.Task" /> 및 <see cref="T:System.Threading.CancellationToken" />을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-194">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and <see cref="T:System.Threading.CancellationToken" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-195">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-195">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="43a34-196">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-196">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="43a34-197">자세한 내용은 [작업 병렬 처리 (작업 병렬 라이브러리)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) 하 고 [관리 되는 스레드의 취소](~/docs/standard/threading/cancellation-in-managed-threads.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-197">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-198">다음 예제에서는 <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> C:\Windows\System32 디렉터리의 파일을 반복 하는 작업을 만드는 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-198">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> constructor to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="43a34-199">람다 식 호출을 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 각 파일에 대 한 정보를 추가 하는 메서드를 <xref:System.Collections.Generic.List%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-199">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="43a34-200">중첩 된 작업을 호출 하 여 각 분리를 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 루프 취소 토큰의 상태를 확인 하 고, 취소가 요청 된 경우 호출 된 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-200">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-201">합니다 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 메서드가 throw를 <xref:System.OperationCanceledException> 에서 처리 되는 예외를 `catch` 호출 호출 스레드를 차단 합니다 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-201">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="43a34-202"><xref:System.Threading.Tasks.Task.Start%2A> 메서드를 호출 하는 작업을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-202">The <xref:System.Threading.Tasks.Task.Start%2A> method is then called to start the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-203">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-203">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-204"><paramref name="action" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-204">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-205">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-205">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="43a34-206">작업의 동작을 사용자 지정하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-206">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="43a34-207">지정된 작업 및 만들기 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-207">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-208">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-208">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-209">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-209">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-210"><paramref name="action" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-210">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-211"><paramref name="creationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-211">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-212">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-212">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-213">동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-213">An object representing data to be used by the action.</span></span></param>
        <summary><span data-ttu-id="43a34-214">지정된 작업 및 상태를 사용하여 새 <see cref="T:System.Threading.Tasks.Task" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-214">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-215">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-215">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-216">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-216">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-217">다음 예제에서는 6 자로 단어 배열을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-217">The following example defines an array of 6-letter words.</span></span> <span data-ttu-id="43a34-218">각 단어에 인수로 전달 됩니다 합니다 <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> 생성자 인 <xref:System.Action%601> 대리자 단어의 문자를 스크램블 다음 원래 단어 및 해당 암호화 된 버전을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-218">Each word is then passed as an argument to the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> constructor, whose <xref:System.Action%601> delegate scrambles the characters in the word, then displays the original word and its scrambled version.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-219"><paramref name="action" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-219">The <paramref name="action" /> argument is null.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-220">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-220">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-221">새 작업이 관찰할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-221">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="43a34-222">작업의 동작을 사용자 지정하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-222">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="43a34-223">지정된 작업 및 만들기 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-223">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-224">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-224">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-225">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-225">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="43a34-226">자세한 내용은 [작업 병렬 처리 (작업 병렬 라이브러리)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) 하 고 [작업 취소](~/docs/standard/parallel-programming/task-cancellation.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-226">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Task Cancellation](~/docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-227"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-227">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-228"><paramref name="action" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-228">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-229"><paramref name="creationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-229">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-230">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-230">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-231">동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-231">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-232">새 작업이 관찰할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-232">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <summary><span data-ttu-id="43a34-233">지정된 작업, 상태 및 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-233">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-234">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-234">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-235">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-235">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-236"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-236">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-237"><paramref name="action" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-237">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-238">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-238">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-239">동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-239">An object representing data to be used by the action.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="43a34-240">작업의 동작을 사용자 지정하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-240">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="43a34-241">지정된 작업, 상태 및 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-241">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-242">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-242">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-243">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-243">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-244"><paramref name="action" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-244">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-245"><paramref name="creationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-245">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-246">작업에서 실행할 코드를 나타내는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-246">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-247">동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-247">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-248">새 작업이 관찰할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-248">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="43a34-249">작업의 동작을 사용자 지정하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-249">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="43a34-250">지정된 작업, 상태 및 옵션을 사용하여 새 <see cref="T:System.Threading.Tasks.Task" />를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-250">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-251">인스턴스화하는 가장 일반적인 방법은이 생성자를 호출 하는 대신 한 <xref:System.Threading.Tasks.Task> 개체 및 작업은 정적 호출 하 여 시작 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-251">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-252">이 생성자에 의해 제공 되는 유일한 장점은 작업 호출에서 분리할 수 개체 인스턴스화 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-252">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-253"><paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-253">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-254"><paramref name="action" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-254">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-255"><paramref name="creationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-255">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-256"><see cref="T:System.Threading.Tasks.Task" />를 만들 때 제공된 상태 개체 또는 제공된 개체가 없는 경우 null을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-256">Gets the state object supplied when the <see cref="T:System.Threading.Tasks.Task" /> was created, or null if none was supplied.</span></span></summary>
        <value><span data-ttu-id="43a34-257">작업을 만들 때 작업에 전달된 상태 데이터를 나타내는 <see cref="T:System.Object" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-257">An <see cref="T:System.Object" /> that represents the state data that was passed in to the task when it was created.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-258">해당 데이터를 검색할 원래 형식에 개체를 캐스팅 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-258">Cast the object back to the original type to retrieve its data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-259">이미 성공적으로 완료된 작업을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-259">Gets a task that has already completed successfully.</span></span></summary>
        <value><span data-ttu-id="43a34-260">작업을 완료했습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-260">The successfully completed task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-261">이 속성은 작업 반환입니다 <xref:System.Threading.Tasks.Task.Status%2A> 속성이 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-261">This property returns a task whose <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="43a34-262">값을 반환 하 고 완료 될 때까지 실행 하는 작업을 만들려면 호출을 <xref:System.Threading.Tasks.Task.FromResult%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-262">To create task that returns a value and runs to completion, call the <xref:System.Threading.Tasks.Task.FromResult%2A> method.</span></span>  
  
 <span data-ttu-id="43a34-263">이 속성 값을 검색 하려는 시도가 여러 번 같은 인스턴스를 항상 반환 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-263">Repeated attempts to retrieve this property value may not always return the same instance.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext"><span data-ttu-id="43a34-264">캡처된 원래 컨텍스트로 연속 마샬링하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-264"><see langword="true" /> to attempt to marshal the continuation back to the original context captured; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="43a34-265">이 <see cref="T:System.Threading.Tasks.Task" />를 기다리는 데 사용되는 awaiter를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-265">Configures an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="43a34-266">이 작업을 기다리는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-266">An object used to await this task.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-267">대상 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-267">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-268"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-268">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-269">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-269">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="43a34-270">대상 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-270">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="43a34-271">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-271">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-272">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-272">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-273">다음 예제에서는 100 임의의 날짜 및 시간 값을 사용 하 여 배열을 채우는 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-273">The following example defines a task that populates an array with 100 random date and time values.</span></span> <span data-ttu-id="43a34-274">사용 된 <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> 배열이 채워진 완벽 하 게 되 면 가능한 한 빨리 및 최신 날짜 값을 선택 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-274">It uses the <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> method to select the earliest and the latest date values once the array is fully populated.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 <span data-ttu-id="43a34-275">연속 작업이 실행 되기 전에 콘솔 응용 프로그램을 종료할 수 있습니다 때문에 <xref:System.Threading.Tasks.Task.Wait> 메서드를 호출 하는 연속 실행이 완료 되는 예제 종료 되기 전에 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-275">Because a console application may terminate before the continuation task executes, the <xref:System.Threading.Tasks.Task.Wait> method is called to ensure that the continuation finishes executing before the example ends.</span></span>  
  
 <span data-ttu-id="43a34-276">추가 예제를 보려면 [연속 작업을 사용 하 여 작업 연결](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-276">For an additional example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-277"><paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-277">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-278">작업이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-278">An action to run when the task completes.</span></span> <span data-ttu-id="43a34-279">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-279">When run, the delegate is passed the completed task and a caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-280">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-280">An object representing data to be used by the continuation action.</span></span></param>
        <summary><span data-ttu-id="43a34-281">호출자 제공 상태 정보를 받으며 대상 <see cref="T:System.Threading.Tasks.Task" />이(가) 완료되면 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-281">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="43a34-282">새 연속 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-282">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-283">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소로 인해 일찍 종료로 인해 완료 여부입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-283">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-284"><paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-284">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-285"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-285">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-286">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-286">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-287">새 연속 작업에 할당할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-287">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="43a34-288">대상 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 취소 토큰을 받고 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-288">Creates a continuation that receives a cancellation token and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="43a34-289">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-289">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-290">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-290">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-291">토큰을 만든 <see cref="T:System.Threading.CancellationTokenSource" />는 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-291">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-292"><paramref name="continuationAction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-292">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-293">지정된 <paramref name="continuationOptions" />에 따라 실행되는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-293">An action to run according to the specified <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="43a34-294">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-294">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="43a34-295">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-295">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="43a34-296">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-296">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="43a34-297">지정된 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 따라 대상 작업이 완료되면 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-297">Creates a continuation that executes when the target task completes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="43a34-298">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-298">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-299">반환 된 <xref:System.Threading.Tasks.Task> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-299">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="43a34-300">통해 연속 조건을 지정 하는 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-300">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-301">다음 예제에서는 <xref:System.Threading.Tasks.TaskContinuationOptions> 선행 작업이 완료 될 때 연속 작업을 동기적으로 실행 해야 함을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-301">The following example demonstrates using <xref:System.Threading.Tasks.TaskContinuationOptions> to specify that a continuation task should run synchronously when the antecedent task completes.</span></span> <span data-ttu-id="43a34-302">(시간에서 지정한 작업에 이미 완료 된 경우 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 가 호출 동기 연속 스레드 호출에서 실행 됩니다 <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)</span><span class="sxs-lookup"><span data-stu-id="43a34-302">(If the specified task has already completed by the time <xref:System.Threading.Tasks.Task.ContinueWith%2A> is called, the synchronous continuation will run on the thread calling <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)</span></span>  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-303"><paramref name="continuationAction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-303">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-304"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-304">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-305"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-305">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-306">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-306">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="43a34-307">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-307">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="43a34-308">대상 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-308">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-309">연속 작업은 지정된 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-309">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="43a34-310">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-310">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-311">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-311">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-312"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-312">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-313"><paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-313">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="43a34-314">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-314">-or-</span></span> 
<span data-ttu-id="43a34-315"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-315">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-316"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-316">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-317">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-317">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-318">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-318">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-319">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-319">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="43a34-320">대상 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 호출자 제공 상태 정보 및 취소 토큰을 받고 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-320">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="43a34-321">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-321">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-322">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-322">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-323"><paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-323">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-324">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-324">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-325"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-325">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-326">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-326">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-327">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-327">An object representing data to be used by the continuation action.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="43a34-328">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-328">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="43a34-329">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-329">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="43a34-330">호출자 제공 상태 정보를 받으며 대상 <see cref="T:System.Threading.Tasks.Task" />이(가) 완료되면 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-330">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-331">연속 작업은 지정된 조건의 집합에 따라 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-331">The continuation executes based on a set of specified conditions.</span></span></summary>
        <returns><span data-ttu-id="43a34-332">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-332">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-333">반환 된 <xref:System.Threading.Tasks.Task> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-333">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="43a34-334">통해 연속 조건을 지정 하는 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-334">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-335"><paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-335">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-336"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-336">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-337"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-337">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="43a34-338">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-338">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-339">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-339">An object representing data to be used by the continuation action.</span></span></param>
        <param name="scheduler"><span data-ttu-id="43a34-340">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-340">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="43a34-341">호출자 제공 상태 정보를 받으며 대상 <see cref="T:System.Threading.Tasks.Task" />이(가) 완료되면 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-341">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-342">연속 작업은 지정된 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-342">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="43a34-343">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-343">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-344">반환 된 <xref:System.Threading.Tasks.Task> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-344">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-345"><paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-345">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-346">지정된 <paramref name="continuationOptions" />에 따라 실행되는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-346">An action to run according to the specified <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="43a34-347">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-347">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-348">새 연속 작업에 할당할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-348">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="43a34-349">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-349">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="43a34-350">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-350">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="43a34-351">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-351">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="43a34-352">지정된 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 따라 대상 작업이 완료되면 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-352">Creates a continuation that executes when the target task competes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span> <span data-ttu-id="43a34-353">연속 작업은 취소 토큰을 받고 지정된 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-353">The continuation receives a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="43a34-354">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-354">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-355">반환 된 <xref:System.Threading.Tasks.Task> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-355">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="43a34-356">조건을 통해 지정 된 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-356">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-357">다음은 작업을 실행 하도록 백그라운드로 사용자 인터페이스 스레드 ContinueWith를 사용 하는 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-357">The following is an example of using ContinueWith to run work both in the background and on the user interface threads.</span></span>  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-358">토큰을 만든 <see cref="T:System.Threading.CancellationTokenSource" />는 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-358">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-359"><paramref name="continuationAction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-359">The <paramref name="continuationAction" /> argument is null.</span></span>  
  
<span data-ttu-id="43a34-360">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-360">-or-</span></span> 
<span data-ttu-id="43a34-361"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-361">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-362"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-362">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="43a34-363"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-363">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-364">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-364">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-365">연속 동작에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-365">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-366">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-366">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="43a34-367">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-367">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="43a34-368">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-368">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="43a34-369">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-369">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="43a34-370">대상 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 호출자 제공 상태 정보 및 취소 토큰을 받고 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-370">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-371">연속 작업은 지정된 조건의 집합에 따라 실행되며 지정된 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-371">The continuation executes based on a set of specified conditions and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="43a34-372">새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-372">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-373">반환 된 <xref:System.Threading.Tasks.Task> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-373">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="43a34-374">조건을 통해 지정 된 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-374">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-375"><paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-375">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-376"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-376">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-377">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-377">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-378">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-378">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-379"><see cref="T:System.Threading.Tasks.Task`1" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-379">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="43a34-380">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-380">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="43a34-381">대상 <see cref="T:System.Threading.Tasks.Task`1" />이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-381">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="43a34-382">새 연속 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-382">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-383">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-383">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-384">다음 예제에 ContinueWith 메서드를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-384">The following example shows how to use the ContinueWith method:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-385"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-385">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-386"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-386">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-387">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-387">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-388"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-388">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-389">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-389">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-390">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-390">An object representing data to be used by the continuation function.</span></span></param>
        <summary><span data-ttu-id="43a34-391">호출자 제공 상태 정보를 받으며 대상 <see cref="T:System.Threading.Tasks.Task" />이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-391">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="43a34-392">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-392">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-393">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-393">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-394"><paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-394">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-395">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-395">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-396"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-396">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-397">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-397">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-398">새 연속 작업에 할당할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-398">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="43a34-399">대상 <see cref="T:System.Threading.Tasks.Task" />이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-399">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="43a34-400">연속 작업은 취소 토큰을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-400">The continuation receives a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="43a34-401">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-401">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-402">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-402">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-403"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-403">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
<span data-ttu-id="43a34-404">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-404">-or-</span></span> 
<span data-ttu-id="43a34-405">토큰을 만든 <see cref="T:System.Threading.CancellationTokenSource" />는 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-405">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-406"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-406">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-407">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-407">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-408"><paramref name="continuationOptions" />에 지정된 조건에 따라 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-408">A function to run according to the condition specified in <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="43a34-409">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-409">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="43a34-410">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-410">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="43a34-411">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-411">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="43a34-412">지정된 연속 작업 옵션에 따라 실행되고 값을 반환하는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-412">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span></summary>
        <returns><span data-ttu-id="43a34-413">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-413">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-414">반환 된 <xref:System.Threading.Tasks.Task%601> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-414">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="43a34-415">통해 연속 조건을 지정 하는 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-415">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-416"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-416">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-417"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-417">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-418"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-418">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-419">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-419">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-420"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-420">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-421">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-421">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="43a34-422">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-422">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="43a34-423">대상 <see cref="T:System.Threading.Tasks.Task" />이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-423">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="43a34-424">연속 작업은 지정된 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-424">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="43a34-425">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-425">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-426">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-426">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-427"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-427">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-428"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-428">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="43a34-429">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-429">-or-</span></span> 
<span data-ttu-id="43a34-430"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-430">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-431">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-431">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-432"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-432">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-433">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-433">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-434">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-434">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-435">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-435">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="43a34-436">대상 <see cref="T:System.Threading.Tasks.Task" />이(가) 완료되고 값을 가져오면 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-436">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="43a34-437">연속 작업은 호출자 제공한 상태 정보 및 취소 토큰을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-437">The continuation receives caller-supplied state information and a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="43a34-438">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-438">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-439">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-439">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-440"><paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-440">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-441">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-441">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-442">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-442">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-443"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-443">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-444">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-444">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-445">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-445">An object representing data to be used by the continuation function.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="43a34-446">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-446">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="43a34-447">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-447">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="43a34-448">대상 <see cref="T:System.Threading.Tasks.Task" />가 완료되면 지정된 작업 연속 옵션에 따라 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-448">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-449">연속 작업은 호출자 제공 상태 정보를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-449">The continuation receives caller-supplied state information.</span></span></summary>
        <returns><span data-ttu-id="43a34-450">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-450">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-451">반환 된 <xref:System.Threading.Tasks.Task%601> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-451">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="43a34-452">통해 연속 조건을 지정 하는 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-452">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-453"><paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-453">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-454"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-454">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-455">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-455">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-456"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-456">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="43a34-457">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-457">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-458">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-458">An object representing data to be used by the continuation function.</span></span></param>
        <param name="scheduler"><span data-ttu-id="43a34-459">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-459">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="43a34-460">대상 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 비동기적으로 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-460">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-461">연속 작업은 호출자 제공 상태 정보를 받고 지정된 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-461">The continuation receives caller-supplied state information and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="43a34-462">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-462">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-463">반환 된 <xref:System.Threading.Tasks.Task%601> 예약 되지 것입니다 실행에 대 한 현재 작업이 완료 될 때까지 성공적으로 완료 될 때까지 실행, 처리 되지 않은 예외로 인해 오류 또는 취소 되어 빨리 종료로 인해 완료 되는지 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-463">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-464"><paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-464">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-465">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-465">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-466">지정된 <c>continuationOptions</c>에 따라 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-466">A function to run according to the specified <c>continuationOptions.</c></span></span> <span data-ttu-id="43a34-467">실행될 때 이 대리자에는 완료된 작업이 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-467">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-468">새 연속 작업에 할당할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-468">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="43a34-469">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-469">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="43a34-470">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-470">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="43a34-471">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-471">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="43a34-472">지정된 연속 작업 옵션에 따라 실행되고 값을 반환하는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-472">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span> <span data-ttu-id="43a34-473">연속 작업에 취소 토큰이 전달되고, 연속 작업은 지정된 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-473">The continuation is passed a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="43a34-474">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-474">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-475">반환 된 <xref:System.Threading.Tasks.Task%601> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-475">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="43a34-476">조건을 통해 지정 된 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-476">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-477">다음 예제에서는 연속 옵션에 ContinueWith 메서드를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-477">The following example shows how to use the ContinueWith method with continuation options:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-478"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-478">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
<span data-ttu-id="43a34-479">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-479">-or-</span></span> 
<span data-ttu-id="43a34-480">토큰을 만든 <see cref="T:System.Threading.CancellationTokenSource" />는 이미 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-480">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-481"><paramref name="continuationFunction" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-481">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="43a34-482">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-482">-or-</span></span> 
<span data-ttu-id="43a34-483"><paramref name="scheduler" /> 인수가 null입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-483">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-484"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-484">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-485">연속 작업에서 생성되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-485">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="43a34-486"><see cref="T:System.Threading.Tasks.Task" />이 완료될 때 실행할 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-486">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="43a34-487">실행되는 경우 대리자에게 완료된 작업과 호출자 제공 상태 개체가 인수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-487">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="43a34-488">연속 함수에서 사용할 데이터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-488">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-489">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-489">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="43a34-490">연속 작업이 예약되는 시기와 연속 작업이 동작하는 방식에 대한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-490">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="43a34-491">여기에는 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />와 같은 조건과 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> 등의 실행 옵션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-491">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="43a34-492">연속 작업과 연결하고 연속 작업의 실행에 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-492">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="43a34-493">대상 <see cref="T:System.Threading.Tasks.Task" />가 완료되고 값을 반환하면 지정된 작업 연속 옵션에 따라 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-493">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="43a34-494">연속 작업은 호출자 제공 상태 정보 및 취소 토큰을 받고 지정된 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-494">The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="43a34-495">새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-495">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-496">반환 된 <xref:System.Threading.Tasks.Task%601> 현재 작업이 완료 될 때까지 실행을 위해 예약 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-496">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="43a34-497">조건을 통해 지정 된 경우는 `continuationOptions` 매개 변수 충족 되지 않으면, 연속 작업을 취소할지 대신 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-497">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-498"><paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-498">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-499"><paramref name="continuationOptions" /> 인수는 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />에 대해 잘못된 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-499">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-500">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-500">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-501">이 작업을 만드는 데 사용된 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-501">Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></summary>
        <value><span data-ttu-id="43a34-502">이 작업을 만드는 데 사용된 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-502">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-503">현재 실행 중인 <see cref="T:System.Threading.Tasks.Task" />의 ID를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-503">Returns the ID of the currently executing <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <value><span data-ttu-id="43a34-504">시스템에서 현재 실행 중인 작업에 할당한 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-504">An integer that was assigned by the system to the currently-executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-505"><xref:System.Threading.Tasks.Task.CurrentId%2A> `static` (`Shared` Visual basic에서) 작업이 실행 되 고 있는 코드에서 현재 실행 중인 작업의 식별자를 가져오는 데 사용 되는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-505"><xref:System.Threading.Tasks.Task.CurrentId%2A> is a `static` (`Shared` in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing.</span></span> <span data-ttu-id="43a34-506">다른 합니다 <xref:System.Threading.Tasks.Task.Id%2A> 특정의 식별자를 반환 하는 속성 <xref:System.Threading.Tasks.Task> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="43a34-506">It differs from the <xref:System.Threading.Tasks.Task.Id%2A> property, which returns the identifier of a particular <xref:System.Threading.Tasks.Task> instance.</span></span> <span data-ttu-id="43a34-507">검색 하려는 경우는 <xref:System.Threading.Tasks.Task.CurrentId%2A> 속성이 반환 하는 작업을 실행 하는 코드 외부에서 값을 `null`입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-507">If you attempt to retrieve the <xref:System.Threading.Tasks.Task.CurrentId%2A> value from outside the code that a task is executing, the property returns `null`.</span></span>  
  
 <span data-ttu-id="43a34-508">Note는 충돌이 거의 발생 하지만, 작업 식별자 보장 되지 고유 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-508">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-509">시간 지연 후 완료되는 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-509">Creates a task that will complete after a time delay.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="43a34-510">반환된 작업을 완료하기 전에 대기하는 시간(밀리초)입니다. -1은 무기한 대기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-510">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="43a34-511">지정된 시간(밀리초) 후에 완료되는 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-511">Creates a task that completes after a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="43a34-512">시간 지연을 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-512">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-513"><xref:System.Threading.Tasks.Task.Delay%2A> 메서드는 일반적으로 데 지정된 된 시간 간격에 대 한 모든 작업 또는 작업의 일부를 지연 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-513">The <xref:System.Threading.Tasks.Task.Delay%2A> method is typically used to delay the operation of all or part of a task for a specified time interval.</span></span> <span data-ttu-id="43a34-514">가장 일반적으로 시간 지연이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-514">Most commonly, the time delay is introduced:</span></span>  
  
-   <span data-ttu-id="43a34-515">에 다음 예제와 같이 작업의 시작 부분을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-515">At the beginning of the task, as the following example shows.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   <span data-ttu-id="43a34-516">사용 하는 동안 작업 실행 중입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-516">Sometime while the task is executing.</span></span> <span data-ttu-id="43a34-517">이 경우에 대 한 호출을 <xref:System.Threading.Tasks.Task.Delay%2A> 메서드는 태스크 내에서 자식 작업으로 다음 예제와 같이 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-517">In this case, the call to the <xref:System.Threading.Tasks.Task.Delay%2A> method executes as a child task within a task, as the following example shows.</span></span> <span data-ttu-id="43a34-518">호출 하는 작업 이후에 합니다 <xref:System.Threading.Tasks.Task.Delay%2A> 메서드를 비동기적으로 실행, 부모 작업을 사용 하 여 완료할 때까지 기다려야 합니다 `await` 키워드입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-518">Note that since the task that calls the <xref:System.Threading.Tasks.Task.Delay%2A> method executes asynchronously, the parent task must wait for it to complete by using the `await` keyword.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 <span data-ttu-id="43a34-519">지정 된 시간 지연 후 작업이 완료 되는 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-519">After the specified time delay, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="43a34-520">이 메서드는 시스템 클록에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-520">This method depends on the system clock.</span></span> <span data-ttu-id="43a34-521">즉, 지연 시간 경우 시스템 클록의 해상도 용량이 약 됩니다는 `millisecondsDelay` 인수를 사용 하는 Windows 시스템에서 약 15 밀리초는 시스템 시계의 정밀도 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-521">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-522">다음 예제에서는의 간단한 사용법을 보여 줍니다는 <xref:System.Threading.Tasks.Task.Delay%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-522">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-523"><paramref name="millisecondsDelay" /> 인수가 -1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-523">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="43a34-524">반환된 작업이 완료되기 전에 대기하는 시간 범위입니다. <see langword="TimeSpan.FromMilliseconds(-1)" />는 무기한 대기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-524">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="43a34-525">지정된 시간 간격 후 완료되는 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-525">Creates a task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="43a34-526">시간 지연을 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-526">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-527">작업이 완료 되는 지정 된 시간 지연 후 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-527">After the specified time delay, the task is completed in <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="43a34-528">사용 시나리오 및 추가 예제에 대 한 설명서를 참조 하십시오.는 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-528">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="43a34-529">이 메서드는 시스템 클록에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-529">This method depends on the system clock.</span></span> <span data-ttu-id="43a34-530">즉, 지연 시간 경우 시스템 클록의 해상도 용량이 약 됩니다는 `delay` 인수를 사용 하는 Windows 시스템에서 약 15 밀리초는 시스템 시계의 정밀도 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-530">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-531">다음 예제에서는의 간단한 사용법을 보여 줍니다는 <xref:System.Threading.Tasks.Task.Delay%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-531">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-532"><paramref name="delay" />는 <see langword="TimeSpan.FromMillseconds(-1)" /> 이외의 음의 시간 간격을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-532"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMillseconds(-1)" />.</span></span>  
  
<span data-ttu-id="43a34-533">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-533">-or-</span></span> 
<span data-ttu-id="43a34-534"><paramref name="delay" /> 인수의 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 속성은 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-534">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="43a34-535">반환된 작업을 완료하기 전에 대기하는 시간(밀리초)입니다. -1은 무기한 대기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-535">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-536">작업이 완료되기를 기다리는 동안 관찰할 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-536">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="43a34-537">지정된 시간(밀리초) 후에 완료되는 취소 가능한 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-537">Creates a cancellable task that completes after a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="43a34-538">시간 지연을 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-538">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-539">취소 토큰, 지정 된 시간 지연이 전에 신호를 받는 경우는 <xref:System.Threading.Tasks.TaskCanceledException> 예외 결과 및 작업에서 완료 되는 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-539">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="43a34-540">작업이 완료 되 고, 그렇지는 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 지정된 시간 지연 기간이 경과 되 면 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-540">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="43a34-541">사용 시나리오 및 추가 예제에 대 한 설명서를 참조 하십시오.는 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-541">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="43a34-542">이 메서드는 시스템 클록에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-542">This method depends on the system clock.</span></span> <span data-ttu-id="43a34-543">즉, 지연 시간 경우 시스템 클록의 해상도 용량이 약 됩니다는 `millisecondsDelay` 인수를 사용 하는 Windows 시스템에서 약 15 밀리초는 시스템 시계의 정밀도 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-543">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-544">다음 예제에서는 호출을 포함 하는 작업을 시작 합니다 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> 1 초 지연 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-544">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> method with a one second delay.</span></span> <span data-ttu-id="43a34-545">지연 간격은 경과 하기 전에 토큰이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-545">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="43a34-546">예제의 출력에 따르면, 결과적으로, <xref:System.Threading.Tasks.TaskCanceledException> 이 throw 및 작업 <xref:System.Threading.Tasks.Task.Status%2A> 속성이 <xref:System.Threading.Tasks.TaskStatus.Canceled>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-546">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-547"><paramref name="millisecondsDelay" /> 인수가 -1보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-547">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="43a34-548">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-548">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-549">제공된 <paramref name="cancellationToken" />가 이미 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-549">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="43a34-550">반환된 작업이 완료되기 전에 대기하는 시간 범위입니다. <see langword="TimeSpan.FromMilliseconds(-1)" />는 무기한 대기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-550">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-551">작업이 완료되기를 기다리는 동안 관찰할 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-551">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="43a34-552">지정된 시간 간격 후 완료되는 취소 가능 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-552">Creates a cancellable task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="43a34-553">시간 지연을 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-553">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-554">취소 토큰, 지정 된 시간 지연이 전에 신호를 받는 경우는 <xref:System.Threading.Tasks.TaskCanceledException> 예외 결과 및 작업에서 완료 되는 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-554">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="43a34-555">작업이 완료 되 고, 그렇지는 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 지정된 시간 지연 기간이 경과 되 면 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-555">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="43a34-556">사용 시나리오 및 추가 예제에 대 한 설명서를 참조 하십시오.는 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-556">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="43a34-557">이 메서드는 시스템 클록에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-557">This method depends on the system clock.</span></span> <span data-ttu-id="43a34-558">즉, 지연 시간 경우 시스템 클록의 해상도 용량이 약 됩니다는 `delay` 인수를 사용 하는 Windows 시스템에서 약 15 밀리초는 시스템 시계의 정밀도 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-558">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-559">다음 예제에서는 호출을 포함 하는 작업을 시작 합니다 <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> 1.5 초 지연 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-559">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method with a 1.5 second delay.</span></span> <span data-ttu-id="43a34-560">지연 간격은 경과 하기 전에 토큰이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-560">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="43a34-561">예제의 출력에 따르면, 결과적으로, <xref:System.Threading.Tasks.TaskCanceledException> 이 throw 및 작업 <xref:System.Threading.Tasks.Task.Status%2A> 속성이 <xref:System.Threading.Tasks.TaskStatus.Canceled>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-561">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 <span data-ttu-id="43a34-562">이 예제에서는 잠재적인 경합 조건을 포함 하는 참고: 토큰이 취소 되 면 지연을 비동기적으로 실행 하는 작업에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-562">Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled.</span></span> <span data-ttu-id="43a34-563">1.5 두 번째 호출에서 지연 되지만 <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> 메서드를 사용 하면 가정 가능성이, 그럼에도 불구 하 고 가능는에 대 한 호출을 <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> 메서드는 토큰은 취소 전에 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-563">Although the 1.5 second delay from the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method makes that assumption likely, it is nevertheless possible that the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method could return before the token is cancelled.</span></span> <span data-ttu-id="43a34-564">이런 경우 예제는 다음 출력을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-564">In that case, the example produces the following output:</span></span>  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-565"><paramref name="delay" />는 <see langword="TimeSpan.FromMillseconds(-1)" /> 이외의 음의 시간 간격을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-565"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMillseconds(-1)" />.</span></span>  
  
<span data-ttu-id="43a34-566">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-566">-or-</span></span> 
<span data-ttu-id="43a34-567"><paramref name="delay" /> 인수의 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 속성은 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-567">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="43a34-568">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-568">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-569">제공된 <paramref name="cancellationToken" />가 이미 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-569">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-570"><see cref="T:System.Threading.Tasks.Task" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-570">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43a34-571"><see cref="T:System.Threading.Tasks.Task" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-571">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-572"><xref:System.Threading.Tasks.Task> 클래스가 구현 하는 <xref:System.IDisposable> 내부적으로 구현 하는 리소스를 사용 하기 때문에 인터페이스 <xref:System.IDisposable>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-572">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="43a34-573">그러나 경우에 특히 앱의 대상 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 없거나 나중에 호출할 필요가 없습니다 <xref:System.Threading.Tasks.Task.Dispose%2A> 성능이 나 확장성 테스트 나타냅니다는 하지 않는 한 사용 패턴에 따라 앱의 성능 향상의 작업을 삭제 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-573">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="43a34-574">자세한 내용은 [태스크를 삭제 해야?](https://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) 에서 Parallel Programming with.NET 블로그.</span><span class="sxs-lookup"><span data-stu-id="43a34-574">For more information, see [Do I need to dispose of Tasks?](https://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43a34-575">작업은 최종 상태(<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 또는 <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />) 중 하나가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-575">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="43a34-576"><see cref="M:System.Threading.Tasks.Task.Dispose" /> 호출로 인해 이 메서드가 호출되는지 여부를 나타내는 부울 값입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-576">A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.Tasks.Task.Dispose" />.</span></span></param>
        <summary><span data-ttu-id="43a34-577"><see cref="T:System.Threading.Tasks.Task" />를 삭제하고 관리되지 않는 해당 리소스를 모두 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-577">Disposes the <see cref="T:System.Threading.Tasks.Task" />, releasing all of its unmanaged resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-578"><xref:System.Threading.Tasks.Task> 클래스가 구현 하는 <xref:System.IDisposable> 내부적으로 구현 하는 리소스를 사용 하기 때문에 인터페이스 <xref:System.IDisposable>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-578">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="43a34-579">그러나 경우에 특히 앱의 대상 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 없거나 나중에 호출할 필요가 없습니다 <xref:System.Threading.Tasks.Task.Dispose%2A> 성능이 나 확장성 테스트 나타냅니다는 하지 않는 한 사용 패턴에 따라 앱의 성능 향상의 작업을 삭제 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-579">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="43a34-580">자세한 내용은 [태스크를 삭제 해야?](https://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) 에서 Parallel Programming with.NET 블로그.</span><span class="sxs-lookup"><span data-stu-id="43a34-580">For more information, see [Do I need to dispose of Tasks?](https://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43a34-581">작업은 최종 상태(<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 또는 <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />) 중 하나가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-581">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
        <threadsafe><span data-ttu-id="43a34-582">멤버 대부분이 달리는 <see cref="T:System.Threading.Tasks.Task" /> 클래스,이 메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-582">Unlike most of the members of the <see cref="T:System.Threading.Tasks.Task" /> class, this method is not thread-safe.</span></span></threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-583"><see cref="T:System.AggregateException" />가 중간에 종료되도록 하는 <see cref="T:System.Threading.Tasks.Task" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-583">Gets the <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span> <span data-ttu-id="43a34-584"><see cref="T:System.Threading.Tasks.Task" />가 완료되었거나 예외를 아직 throw하지 않았을 경우 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-584">If the <see cref="T:System.Threading.Tasks.Task" /> completed successfully or has not yet thrown any exceptions, this will return <see langword="null" />.</span></span></summary>
        <value><span data-ttu-id="43a34-585"><see cref="T:System.AggregateException" />가 중간에 종료되도록 하는 <see cref="T:System.Threading.Tasks.Task" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-585">The <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-586">처리 되지 않은 예외를 throw 하는 작업은 결과 예외를 저장 하 고에 래핑하여 전파는 <xref:System.AggregateException> 에 대 한 호출 <xref:System.Threading.Tasks.Task.Wait%2A> 또는 액세스는 <xref:System.Threading.Tasks.Task.Exception%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-586">Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <xref:System.AggregateException> in calls to <xref:System.Threading.Tasks.Task.Wait%2A> or in accesses to the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span> <span data-ttu-id="43a34-587">작업 인스턴스가 가비지 수집을 수행 하는 시간에 관찰 된 예외가 종료자 스레드에서 전파 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-587">Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread.</span></span> <span data-ttu-id="43a34-588">자세한 내용 및 예제를 참조 하세요 [예외 처리 (작업 병렬 라이브러리)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-588">For more information and an example, see [Exception Handling (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-589"><see cref="T:System.Threading.Tasks.Task" /> 및 <see cref="T:System.Threading.Tasks.Task`1" /> 인스턴스를 만들고 구성하는 팩터리 메서드에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-589">Provides access to factory methods for creating and configuring <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> instances.</span></span></summary>
        <value><span data-ttu-id="43a34-590">다양한 <see cref="T:System.Threading.Tasks.Task" /> 및 <see cref="T:System.Threading.Tasks.Task`1" /> 개체를 만들 수 있는 팩터리 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-590">A factory object that can create a variety of <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-591">이 속성의 기본 인스턴스를 반환 합니다 <xref:System.Threading.Tasks.TaskFactory> 클래스는 매개 변수가 없는 호출 하 여 만든 동일한 <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-591">This property returns a default instance of the <xref:System.Threading.Tasks.TaskFactory> class that is identical to the one created by calling the parameterless <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="43a34-592">다음 속성 값을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-592">It has the following property values:</span></span>  
  
|<span data-ttu-id="43a34-593">속성</span><span class="sxs-lookup"><span data-stu-id="43a34-593">Property</span></span>|<span data-ttu-id="43a34-594">값</span><span class="sxs-lookup"><span data-stu-id="43a34-594">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|<span data-ttu-id="43a34-595">`null`또는 <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="43a34-595">`null`, or <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span></span>|  
  
 <span data-ttu-id="43a34-596">이 속성의 가장 일반적인 용도 만들고 단일 호출에서 새 작업을 시작 하는 것은 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-596">The most common use of this property is to create and start a new task in a single call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43a34-597">부터 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]의 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드를 만드는 가장 쉬운 방법은 제공을 <xref:System.Threading.Tasks.Task> 기본 구성 값을 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-597">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method provides the easiest way to create a <xref:System.Threading.Tasks.Task> object with default configuration values.</span></span>  
  
 <span data-ttu-id="43a34-598">다음 예제에서는 정적 <xref:System.Threading.Tasks.Task.Factory%2A> 속성에 대 한 두 호출을는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-598">The following example uses the static <xref:System.Threading.Tasks.Task.Factory%2A> property to make two calls to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-599">첫 번째 두 번째 사용자의 내 문서 디렉터리의 하위 디렉터리 이름의 배열을 채웁니다 하는 동안 사용자의 내 문서 디렉터리에 있는 파일 이름의 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-599">The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory.</span></span> <span data-ttu-id="43a34-600">그런 다음 호출 하는 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> 처음 두 개의 작업 실행 완료 후 두 배열에서 파일 및 디렉터리의 수에 대 한 정보를 표시 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-600">It then calls the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="43a34-601">작업을 완료하는 데 사용할 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-601">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="43a34-602">지정된 취소 토큰을 사용하여 취소로 인해 완료된 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-602">Creates a <see cref="T:System.Threading.Tasks.Task" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="43a34-603">취소된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-603">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-604"><paramref name="cancellationToken" />에 대해 취소가 요청되지 않았습니다. 해당 <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> 속성은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-604">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-605">작업에서 반환되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-605">The type of the result returned by the task.</span></span></typeparam>
        <param name="cancellationToken"><span data-ttu-id="43a34-606">작업을 완료하는 데 사용할 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-606">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="43a34-607">지정된 취소 토큰을 사용하여 취소로 인해 완료된 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-607">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="43a34-608">취소된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-608">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-609"><paramref name="cancellationToken" />에 대해 취소가 요청되지 않았습니다. 해당 <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> 속성은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-609">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception"><span data-ttu-id="43a34-610">작업을 완료하는 데 사용할 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-610">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="43a34-611">지정된 예외를 사용하여 완료된 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-611">Creates a <see cref="T:System.Threading.Tasks.Task" /> that has completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="43a34-612">오류가 발생한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-612">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-613">이 메서드를 만듭니다는 <xref:System.Threading.Tasks.Task> 개체 <xref:System.Threading.Tasks.Task.Status%2A> 속성은 <xref:System.Threading.Tasks.TaskStatus.Faulted> 을 <xref:System.Threading.Tasks.Task.Exception%2A> 속성에 들어 `exception`합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-613">This method creates a <xref:System.Threading.Tasks.Task> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="43a34-614">메서드는 작업을 수행 하는 작업에서 예외가 발생 긴 코드 경로 실행 하기 전에 즉시 알고 있는 경우에 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-614">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="43a34-615">예를 들어 참조는 <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-615">For an example, see the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-616">작업에서 반환되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-616">The type of the result returned by the task.</span></span></typeparam>
        <param name="exception"><span data-ttu-id="43a34-617">작업을 완료하는 데 사용할 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-617">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="43a34-618">지정된 예외를 사용하여 완료된 <see cref="T:System.Threading.Tasks.Task`1" />을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-618">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="43a34-619">오류가 발생한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-619">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-620">이 메서드를 만듭니다는 <xref:System.Threading.Tasks.Task%601> 개체 <xref:System.Threading.Tasks.Task.Status%2A> 속성은 <xref:System.Threading.Tasks.TaskStatus.Faulted> 을 <xref:System.Threading.Tasks.Task.Exception%2A> 속성에 들어 `exception`합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-620">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="43a34-621">메서드는 작업을 수행 하는 작업에서 예외가 발생 긴 코드 경로 실행 하기 전에 즉시 알고 있는 경우에 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-621">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="43a34-622">예제에서는 그림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-622">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-623">다음 예제는 이름이 명령줄 인수로 전달 되는 각 디렉터리에 있는 파일의 바이트 수를 계산 하는 명령줄 유틸리티입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-623">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="43a34-624">인스턴스화하는 긴 코드 경로 실행 하는 대신를 <xref:System.IO.FileInfo> 개체의 값을 검색 하 고 해당 <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> 예제 디렉터리에 각 파일에 대 한 속성을 호출 합니다 <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> 특정 오류가 발생 한 작업을 만드는 방법 하위 디렉터리는 존재 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-624">Rather than executing a longer code path that instantiates a <xref:System.IO.FileInfo> object and retrieves the value of its <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> method to create a faulted task if a particular subdirectory does not exist.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-625">작업에서 반환되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-625">The type of the result returned by the task.</span></span></typeparam>
        <param name="result"><span data-ttu-id="43a34-626">완료된 작업에 저장할 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-626">The result to store into the completed task.</span></span></param>
        <summary><span data-ttu-id="43a34-627">지정된 결과로 성공적으로 완료되는 <see cref="T:System.Threading.Tasks.Task`1" />을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-627">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed successfully with the specified result.</span></span></summary>
        <returns><span data-ttu-id="43a34-628">작업을 완료했습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-628">The successfully completed task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-629">이 메서드를 만듭니다는 <xref:System.Threading.Tasks.Task%601> 개체 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성은 `result` 을 <xref:System.Threading.Tasks.Task.Status%2A> 속성이 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-629">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is `result` and whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="43a34-630">메서드는 작업의 반환 값에 더 긴 코드 경로 실행 하지 않고 즉시 라고 하는 경우에 일반적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-630">The method is commonly used when the return value of a task is immediately known without executing a longer code path.</span></span> <span data-ttu-id="43a34-631">예제에서는 그림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-631">The example provides an illustration.</span></span>  
  
 <span data-ttu-id="43a34-632">값을 반환 하지 않는 작업 개체를 만들려면 Task 개체에서 검색 된 <xref:System.Threading.Tasks.Task.CompletedTask%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-632">To create a Task object that does not return a value, retrieve the Task object from the <xref:System.Threading.Tasks.Task.CompletedTask%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-633">다음 예제는 이름이 명령줄 인수로 전달 되는 각 디렉터리에 있는 파일의 바이트 수를 계산 하는 명령줄 유틸리티입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-633">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="43a34-634">인스턴스화하는 긴 코드 경로 실행 하는 대신를 <xref:System.IO.FileStream> 개체의 값을 검색 하 고 해당 <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> 예제 디렉터리에 각 파일에 대 한 속성을 호출 합니다 <xref:System.Threading.Tasks.Task.FromResult%2A> 작업을 만드는 방법입니다 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성은 디렉터리에 파일이 없는 경우 영 (0).</span><span class="sxs-lookup"><span data-stu-id="43a34-634">Rather than executing a longer code path that instantiates a <xref:System.IO.FileStream> object and retrieves the value of its <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromResult%2A> method to create a task whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is zero (0) if a directory has no files.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43a34-635">이 <see cref="T:System.Threading.Tasks.Task" />를 기다리는 데 사용되는 awaiter를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-635">Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="43a34-636">awaiter 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-636">An awaiter instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-637">이 메서드는 응용 프로그램 코드에서 사용 하 여 아닌 컴파일러 사용에 대 한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-637">This method is intended for compiler use rather than for use in application code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-638">이 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스에 대한 ID를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-638">Gets an ID for this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></summary>
        <value><span data-ttu-id="43a34-639">시스템이 이 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스에 할당한 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-639">The identifier that is assigned by the system to this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-640">태스크 Id 주문형으로 할당 된 및 반드시 만들어진 인스턴스는 작업에서 순서를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-640">Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created.</span></span> <span data-ttu-id="43a34-641">Note는 충돌이 거의 발생 하지만, 작업 식별자 보장 되지 고유 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-641">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 <span data-ttu-id="43a34-642">실행 되는 작업 코드 내에서 현재 실행 중인 작업의 작업 ID를 가져오려면, 사용 된 <xref:System.Threading.Tasks.Task.CurrentId%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-642">To get the task ID of the currently executing task from within code that task is executing, use the <xref:System.Threading.Tasks.Task.CurrentId%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-643">이 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스가 취소되어 실행을 완료했는지 여부를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-643">Gets whether this <see cref="T:System.Threading.Tasks.Task" /> instance has completed execution due to being canceled.</span></span></summary>
        <value><span data-ttu-id="43a34-644">이 작업이 취소되어 완료되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-644"><see langword="true" /> if the task has completed due to being canceled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-645">A <xref:System.Threading.Tasks.Task> 은 완료를 <xref:System.Threading.Tasks.TaskStatus.Canceled> 다음 조건 중 하나에서 상태:</span><span class="sxs-lookup"><span data-stu-id="43a34-645">A <xref:System.Threading.Tasks.Task> will complete in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="43a34-646">해당 <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> 태스크 실행이 시작 되기 전에 취소 표시 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-646">Its <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> was marked for cancellation before the task started executing,</span></span>  
  
-   <span data-ttu-id="43a34-647">태스크는 이미 신호에서 취소 요청을 승인 <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> throw 하 여는 <xref:System.OperationCanceledException> 갖습니다 동일한 <xref:System.Threading.CancellationToken>입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-647">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by throwing an <xref:System.OperationCanceledException> that bears the same <xref:System.Threading.CancellationToken>.</span></span>  
  
-   <span data-ttu-id="43a34-648">태스크는 이미 신호에서 취소 요청을 승인 <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> 를 호출 하 여는 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> 메서드를 <xref:System.Threading.CancellationToken>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-648">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by calling the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> method on the <xref:System.Threading.CancellationToken>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="43a34-649">값을 검색 합니다 <xref:System.Threading.Tasks.Task.IsCanceled%2A> 속성은 작업이 완료 될 때까지 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-649">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCanceled%2A> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-650">작업이 완료되었는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-650">Gets a value that indicates whether the task has completed.</span></span></summary>
        <value><span data-ttu-id="43a34-651"><see langword="true" /> 태스크를 완료 하는 경우 (즉, 작업 중인 세 가지 최종 상태 중 하나: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, 또는 <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />) 고, 그렇지 않으면 <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="43a34-651"><see langword="true" /> if the task has completed (that is, the task is in one of the three final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />); otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="43a34-652">값을 검색 합니다 <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> 속성은 작업이 완료 될 때까지 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-652">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-653">처리되지 않은 예외로 인해 <see cref="T:System.Threading.Tasks.Task" />가 완료되었는지 여부를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-653">Gets whether the <see cref="T:System.Threading.Tasks.Task" /> completed due to an unhandled exception.</span></span></summary>
        <value><span data-ttu-id="43a34-654">이 작업이 처리되지 않은 예외를 throw했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-654"><see langword="true" /> if the task has thrown an unhandled exception; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-655">경우 <xref:System.Threading.Tasks.Task.IsFaulted%2A> 됩니다 `true`, 작업의 <xref:System.Threading.Tasks.Task.Status%2A> 값과 같음 <xref:System.Threading.Tasks.TaskStatus.Faulted>, 및 해당 <xref:System.Threading.Tasks.Task.Exception%2A> 속성이 null이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-655">If <xref:System.Threading.Tasks.Task.IsFaulted%2A> is `true`, the task's <xref:System.Threading.Tasks.Task.Status%2A> is equal to <xref:System.Threading.Tasks.TaskStatus.Faulted>, and its <xref:System.Threading.Tasks.Task.Exception%2A> property will be non-null.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="43a34-656">값을 검색 합니다 <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> 속성은 작업이 완료 될 때까지 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-656">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-657">지정한 작업을 ThreadPool에서 실행하도록 큐에 대기시키고 해당 작업에 대한 작업 또는 <see cref="T:System.Threading.Tasks.Task`1" /> 핸들을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-657">Queues the specified work to run on the ThreadPool and returns a task or <see cref="T:System.Threading.Tasks.Task`1" /> handle for that work.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-658"><xref:System.Threading.Tasks.Task.Run%2A> 메서드 쉽게 기본값을 사용 하 여 작업을 시작 하는 오버 로드 집합을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-658">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a set of overloads that make it easy to start a task by using default values.</span></span> <span data-ttu-id="43a34-659">경량 대체 하는 것은 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-659">It is a lightweight alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> overloads.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-660">비동기적으로 실행할 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-660">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="43a34-661">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 작업을 나타내는 <see cref="T:System.Threading.Tasks.Task" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-661">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="43a34-662">스레드 풀에서 실행하도록 큐에 대기된 작업(work)을 나타내는 작업(task)입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-662">A task that represents the work queued to execute in the ThreadPool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-663">합니다 <xref:System.Threading.Tasks.Task.Run%2A> 메서드를 만들고 단일 메서드 호출에서 작업을 실행 하면 이며 대안을는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-663">The <xref:System.Threading.Tasks.Task.Run%2A> method allows you to create and execute a task in a single method call and is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="43a34-664">다음과 같은 기본 값을 사용 하 여 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-664">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="43a34-665">취소 토큰은 <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-665">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="43a34-666">해당 <xref:System.Threading.Tasks.Task.CreationOptions%2A> 속성 값이 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-666">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="43a34-667">기본 작업 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-667">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="43a34-668">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-668">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-669">다음 예제에서는 정의 `ShowThreadInfo` 표시 하는 메서드는 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> 현재 스레드의 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-669">The following example defines a `ShowThreadInfo` method  that displays the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> of the current thread.</span></span> <span data-ttu-id="43a34-670">응용 프로그램 스레드에서 직접 호출 하 고에서 호출 되는 <xref:System.Action> 전달 된 대리자는 <xref:System.Threading.Tasks.Task.Run%28System.Action%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-670">It is called directly from the application thread, and is called from the <xref:System.Action> delegate passed to the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 <span data-ttu-id="43a34-671">다음 예제에서는 태스크를 실행 하는 코드를 정의 하는 람다 식을 사용 하 여 이전와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-671">The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 <span data-ttu-id="43a34-672">예제에서는 기본 응용 프로그램 스레드가 아닌 다른 스레드에서 비동기 작업 실행을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-672">The examples show that the asynchronous task executes on a different thread than the main application thread.</span></span>  
  
 <span data-ttu-id="43a34-673">에 대 한 호출을 <xref:System.Threading.Tasks.Task.Wait%2A> 메서드를 사용 하면 태스크를 완료 하는 응용 프로그램 종료 되기 전에 해당 출력을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-673">The call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that the task completes and displays its output before the application ends.</span></span> <span data-ttu-id="43a34-674">그렇지 않을 경우 가능한는 `Main` 메서드는 작업이 완료 되기 전에 완료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-674">Otherwise, it is possible that the `Main` method will complete before the task finishes.</span></span>  
  
 <span data-ttu-id="43a34-675">다음 예제는 <xref:System.Threading.Tasks.Task.Run%28System.Action%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-675">The following example illustrates the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span> <span data-ttu-id="43a34-676">디렉터리 이름의 배열을 정의 하 고 각 디렉터리에 파일 이름을 검색 하는 별도 작업을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-676">It defines an array of directory names and starts a separate task to retrieve the file names in each directory.</span></span> <span data-ttu-id="43a34-677">모든 작업을 단일 파일 이름을 쓸 <xref:System.Collections.Concurrent.ConcurrentBag%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-677">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="43a34-678">다음 호출 하 여 합니다 <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> 모든 작업을 완료 하 고 다음에 기록 하는 파일 이름의 총 개수를 표시 하도록 메서드를 <xref:System.Collections.Concurrent.ConcurrentBag%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-678">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-679"><paramref name="action" /> 매개 변수가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-679">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-680">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-680">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="43a34-681">비동기적으로 실행할 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-681">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="43a34-682">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 <paramref name="function" />에서 반환된 작업에 대한 프록시를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-682">Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="43a34-683"><paramref name="function" />에서 반환하는 작업에 대한 프록시를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-683">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-684">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-684">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-685"><paramref name="function" /> 매개 변수가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-685">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-686">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-686">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="43a34-687">비동기적으로 실행할 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-687">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-688">작업을 취소하는 데 사용할 수 있는 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-688">A cancellation token that can be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="43a34-689">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 작업을 나타내는 <see cref="T:System.Threading.Tasks.Task" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-689">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span> <span data-ttu-id="43a34-690">취소 토큰으로 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-690">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="43a34-691">스레드 풀에서 실행하도록 큐에 대기된 작업을 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-691">A task that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-692">태스크 실행 전에 취소가 요청 될 경우 작업이 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-692">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="43a34-693">로 설정 하는 대신 합니다 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태 및 throw를 <xref:System.Threading.Tasks.TaskCanceledException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-693">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="43a34-694">합니다 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> 메서드는 대안을는 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-694">The <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-695">다음과 같은 기본 값을 사용 하 여 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-695">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="43a34-696">해당 <xref:System.Threading.Tasks.Task.CreationOptions%2A> 속성 값이 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-696">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="43a34-697">기본 작업 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-697">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="43a34-698">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-698">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-699">다음 예제에서는 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> C:\Windows\System32 디렉터리의 파일을 반복 하는 작업을 만드는 방법.</span><span class="sxs-lookup"><span data-stu-id="43a34-699">The following example calls the <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="43a34-700">람다 식 호출을 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 각 파일에 대 한 정보를 추가 하는 메서드를 <xref:System.Collections.Generic.List%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-700">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="43a34-701">중첩 된 작업을 호출 하 여 각 분리를 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 루프 취소 토큰의 상태를 확인 하 고, 취소가 요청 된 경우 호출 된 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-701">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-702">합니다 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 메서드가 throw를 <xref:System.OperationCanceledException> 에서 처리 되는 예외를 `catch` 호출 호출 스레드를 차단 합니다 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-702">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-703"><paramref name="action" /> 매개 변수가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-703">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="43a34-704">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-704">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-705"><paramref name="cancellationToken" />과 연결된 <see cref="T:System.Threading.CancellationTokenSource" />가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-705">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-706">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-706">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="43a34-707">비동기적으로 실행할 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-707">The work to execute asynchronously.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-708">작업을 취소하는 데 사용해야 하는 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-708">A cancellation token that should be used to cancel the work.</span></span></param>
        <summary><span data-ttu-id="43a34-709">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 <paramref name="function" />에서 반환된 작업에 대한 프록시를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-709">Queues the specified work to run on the thread pool and returns a proxy for the task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="43a34-710"><paramref name="function" />에서 반환하는 작업에 대한 프록시를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-710">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-711">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-711">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-712"><paramref name="function" /> 매개 변수가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-712">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="43a34-713">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-713">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-714"><paramref name="cancellationToken" />과 연결된 <see cref="T:System.Threading.CancellationTokenSource" />가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-714">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="43a34-715">작업 취소</span><span class="sxs-lookup"><span data-stu-id="43a34-715">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-716">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-716">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-717">프록시 작업에서 반환되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-717">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="43a34-718">비동기적으로 실행할 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-718">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="43a34-719">지정된 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 <paramref name="function" />에서 반환된 <see langword="Task(TResult)" />에 대한 프록시를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-719">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="43a34-720"><see langword="Task(TResult)" />에서 반환하는 <see langword="Task(TResult)" />에 대한 프록시를 나타내는 <paramref name="function" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-720">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-721">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-721">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-722"><paramref name="function" /> 매개 변수가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-722">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-723">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-723">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-724">작업의 반환 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-724">The return type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="43a34-725">비동기적으로 실행할 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-725">The work to execute asynchronously.</span></span></param>
        <summary><span data-ttu-id="43a34-726">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 작업을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-726">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task`1" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="43a34-727">스레드 풀에서 실행하도록 큐에 대기된 작업을 나타내는 작업 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-727">A task object that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-728">합니다 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 대안을는 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-728">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="43a34-729">다음과 같은 기본 값을 사용 하 여 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-729">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="43a34-730">취소 토큰은 <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-730">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="43a34-731">해당 <xref:System.Threading.Tasks.Task.CreationOptions%2A> 속성 값이 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-731">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="43a34-732">기본 작업 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-732">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="43a34-733">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-733">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-734">다음 예에서는 게시 된 책을 나타내는 텍스트 파일의 단어의 대략적인 수를 셉니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-734">The following example counts the approximate number of words in text files that represent published books.</span></span> <span data-ttu-id="43a34-735">각 태스크는 파일을 열고 전체 콘텐츠를 비동기적으로 읽고, 정규식을 사용 하 여 단어 수를 계산 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-735">Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</span></span> <span data-ttu-id="43a34-736"><xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> 메서드는 콘솔에 각 책의 단어 수를 표시 하기 전에 모든 작업 완료를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-736">The <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method is called to ensure that all tasks have completed before  displaying the word count of each book to the console.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 <span data-ttu-id="43a34-737">정규식 `\p{P}*\s+` 0, 1 또는 뒤에 하나 이상의 공백 문자가 문장 부호 문자가 더 이상 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-737">The regular expression `\p{P}*\s+` matches zero, one, or more punctuation characters followed by one or more white-space characters.</span></span> <span data-ttu-id="43a34-738">일치 항목의 총 수가 대략적인 단어 수를 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-738">It assumes that the total number of matches equals the approximate word count.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-739"><paramref name="function" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-739">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-740">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-740">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-741">프록시 작업에서 반환되는 결과의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-741">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="43a34-742">비동기적으로 실행할 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-742">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-743">작업을 취소하는 데 사용해야 하는 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-743">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="43a34-744">지정된 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 <paramref name="function" />에서 반환된 <see langword="Task(TResult)" />에 대한 프록시를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-744">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="43a34-745"><see langword="Task(TResult)" />에서 반환하는 <see langword="Task(TResult)" />에 대한 프록시를 나타내는 <paramref name="function" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-745">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-746">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-746">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-747"><paramref name="function" /> 매개 변수가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-747">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="43a34-748">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-748">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-749"><paramref name="cancellationToken" />과 연결된 <see cref="T:System.Threading.CancellationTokenSource" />가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-749">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="43a34-750">작업 취소</span><span class="sxs-lookup"><span data-stu-id="43a34-750">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-751">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-751">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-752">작업의 결과 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-752">The result type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="43a34-753">비동기적으로 실행할 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-753">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-754">작업을 취소하는 데 사용해야 하는 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-754">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="43a34-755">지정한 작업을 스레드 풀에서 실행하도록 큐에 대기시키고 작업을 나타내는 <see langword="Task(TResult)" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-755">Queues the specified work to run on the thread pool and returns a <see langword="Task(TResult)" /> object that represents that work.</span></span> <span data-ttu-id="43a34-756">취소 토큰으로 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-756">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="43a34-757">스레드 풀에서 실행하도록 큐에 대기된 작업을 나타내는 <see langword="Task(TResult)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-757">A <see langword="Task(TResult)" /> that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-758">태스크 실행 전에 취소가 요청 될 경우 작업이 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-758">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="43a34-759">로 설정 하는 대신 합니다 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태 및 throw를 <xref:System.Threading.Tasks.TaskCanceledException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-759">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="43a34-760">합니다 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 대안을는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-760">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="43a34-761">다음과 같은 기본 값을 사용 하 여 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-761">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="43a34-762">해당 <xref:System.Threading.Tasks.Task.CreationOptions%2A> 속성 값이 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-762">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="43a34-763">기본 작업 스케줄러를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-763">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="43a34-764">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-764">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-765">다음 예제에서는 2 백만로 카운터가 증가 될 때까지 반복 하는 20 개의 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-765">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="43a34-766">처음 10 개의 작업에 도달 하면 2 백만, 취소 토큰이 취소 되 고 해당 카운터 2 백만 도달 하지 하는 모든 작업이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-766">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="43a34-767">출력을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-767">The example shows possible output.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 <span data-ttu-id="43a34-768">사용 하는 대신는 <xref:System.AggregateException.InnerExceptions%2A> 예외를 검사할 속성 예제에서는 성공적으로 완료 되는 취소 되었으면 확인 하는 모든 작업을 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-768">Instead of using the <xref:System.AggregateException.InnerExceptions%2A> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled.</span></span> <span data-ttu-id="43a34-769">완료에 대해 작업에서 반환 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-769">For those that have completed, it displays the value returned by the task.</span></span>  
  
 <span data-ttu-id="43a34-770">취소는 협조적 이기 때문에 각 작업 취소에 응답 하는 방법을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-770">Because cancellation is cooperative, each task can decide how to respond to cancellation.</span></span> <span data-ttu-id="43a34-771">다음 예제에서는 한다는 점을 제외 하 고 작업은 완료 하지 않고 예외를 throw 하는 반복 횟수를 반환 된 토큰이 취소 되 면 첫 번째와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-771">The following example is like the first, except that, once the token is cancelled, tasks return the number of iterations they've completed rather than throw an exception.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 <span data-ttu-id="43a34-772">이 예제에서는 여전히 처리 해야 합니다는 <xref:System.AggregateException> 취소가 요청 될 때 시작 되지 않은 모든 작업에는 여전히 예외가 throw 되므로 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-772">The example still must handle the <xref:System.AggregateException> exception,   since any tasks that have not started when cancellation is requested still throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-773"><paramref name="function" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-773">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="43a34-774">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-774">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-775"><paramref name="cancellationToken" />과 연결된 <see cref="T:System.Threading.CancellationTokenSource" />가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-775">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="43a34-776">작업 취소</span><span class="sxs-lookup"><span data-stu-id="43a34-776">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-777">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-777">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-778">현재 <see cref="T:System.Threading.Tasks.Task" />에서 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 동기적으로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-778">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43a34-779">현재 <see cref="T:System.Threading.Tasks.Task" />에서 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 동기적으로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-779">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-780">일반적으로 작업 스레드 풀 스레드에서 비동기적으로 실행 되 고 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-780">Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread.</span></span> <span data-ttu-id="43a34-781">작업을 호출 하 여 실행 합니다 <xref:System.Threading.Tasks.Task.RunSynchronously> 메서드는 현재 연결 <xref:System.Threading.Tasks.TaskScheduler> 호출 스레드에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-781">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method are associated with the current <xref:System.Threading.Tasks.TaskScheduler> and are run on the calling thread.</span></span> <span data-ttu-id="43a34-782">대상 스케줄러 호출 스레드에서이 작업을 실행 하는 것을 지원 하지 않으면, 작업 스케줄러에서 실행 하기 위해 예약 되며 작업 실행이 완료 될 때까지 호출 스레드가 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-782">If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution.</span></span> <span data-ttu-id="43a34-783">호출 스레드가 작업이 동기적으로 실행 하는 경우에 계속 호출 해야 <xref:System.Threading.Tasks.Task.Wait%2A> 작업에서 throw 할 수 있는 예외를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-783">Even though the task runs synchronously, the calling thread should still call <xref:System.Threading.Tasks.Task.Wait%2A> to handle any exceptions that the task might throw.</span></span>  <span data-ttu-id="43a34-784">예외 처리에 대 한 자세한 내용은 참조 하세요. [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-784">For more information on exception handling, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 <span data-ttu-id="43a34-785">작업을 호출 하 여 실행 합니다 <xref:System.Threading.Tasks.Task.RunSynchronously%2A> 메서드를 호출 하 여 인스턴스화됩니다를 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601> 클래스 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-785">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="43a34-786">에 작업을 동기적으로 실행할 수 있어야 합니다.는 <xref:System.Threading.Tasks.TaskStatus.Created> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-786">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="43a34-787">작업을 시작 하 고 한 번만 실행 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-787">A task may be started and run only once.</span></span> <span data-ttu-id="43a34-788">예외가 두 번째 시간 결과 작업을 예약 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-788">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-789">다음 예제에서는 호출 하 여 실행 하는 작업을 비교 합니다 <xref:System.Threading.Tasks.Task.RunSynchronously%2A> 비동기적으로 실행 하나를 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-789">The following example compares a task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method with one executed asynchronously.</span></span> <span data-ttu-id="43a34-790">두 경우 모두 작업이 실행 작업 ID 및 스레드 ID를 표시 하는 동일한 람다 식이 실행 되는 작업.</span><span class="sxs-lookup"><span data-stu-id="43a34-790">In both cases, the tasks execute identical lambda expressions that display the task ID and the ID of the thread on which the task is running.</span></span> <span data-ttu-id="43a34-791">작업 1에서 1,000,000 사이의 정수의 합을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-791">The task calculates the sum of the integers between 1 and 1,000,000.</span></span> <span data-ttu-id="43a34-792">호출 하 여 작업 실행 예제의 출력에서 볼 수 있듯이 <xref:System.Threading.Tasks.Task.RunSynchronously%2A> 비동기 작업 하지 않습니다 하는 동안 응용 프로그램 스레드에서 메서드를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-792">As the output from the example shows, the task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method runs on the application thread, while the asynchronous task does not.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-793"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-793">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43a34-794"><see cref="T:System.Threading.Tasks.Task" />가 시작할 수 있는 상태가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-794">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="43a34-795">이미 시작되었거나, 실행되었거나, 취소되었거나 아니면 직접 일정 관리를 지원하지 않는 방식으로 만들어졌을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-795">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-796">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-796">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="43a34-797">이 작업을 인라인으로 실행하려고 하는 스케줄러입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-797">The scheduler on which to attempt to run this task inline.</span></span></param>
        <summary><span data-ttu-id="43a34-798">제공된 <see cref="T:System.Threading.Tasks.Task" />에서 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 동기적으로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-798">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the <see cref="T:System.Threading.Tasks.TaskScheduler" /> provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-799">작업을 호출 하 여 실행 합니다 <xref:System.Threading.Tasks.Task.RunSynchronously%2A> 메서드를 호출 하 여 인스턴스화됩니다를 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601> 클래스 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-799">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="43a34-800">에 작업을 동기적으로 실행할 수 있어야 합니다.는 <xref:System.Threading.Tasks.TaskStatus.Created> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-800">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="43a34-801">작업을 시작 하 고 한 번만 실행 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-801">A task may be started and run only once.</span></span> <span data-ttu-id="43a34-802">예외가 두 번째 시간 결과 작업을 예약 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-802">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
 <span data-ttu-id="43a34-803">대상 스케줄러를 현재 스레드에서이 작업을 실행 하는 것을 지원 하지 않으면, 작업 스케줄러에서 실행 하기 위해 예약 되며 작업 실행이 완료 될 때까지 현재 스레드는 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-803">If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution.</span></span> <span data-ttu-id="43a34-804">이 인해 호출 스레드가 않아도 같은 메서드를 호출할 <xref:System.Threading.Tasks.Task.Wait%2A> 태스크 실행이 완료 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-804">Because of this, the calling thread does not need to call a method such as <xref:System.Threading.Tasks.Task.Wait%2A> to ensure that the task has completed execution.</span></span> <span data-ttu-id="43a34-805">작업에 대 한 예외 처리에 대 한 자세한 내용은 참조 하세요. [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-805">For more information on exception handling for task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-806"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-806">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-807"><paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-807">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43a34-808"><see cref="T:System.Threading.Tasks.Task" />가 시작할 수 있는 상태가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-808">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="43a34-809">이미 시작되었거나, 실행되었거나, 취소되었거나 아니면 직접 일정 관리를 지원하지 않는 방식으로 만들어졌을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-809">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-810">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-810">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-811"><see cref="T:System.Threading.Tasks.Task" />를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-811">Starts the <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43a34-812"><see cref="T:System.Threading.Tasks.Task" />를 시작하고 현재 <see cref="T:System.Threading.Tasks.TaskScheduler" />에 실행을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-812">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-813">작업을 시작 하 고 한 번만 실행 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-813">A task may be started and run only once.</span></span> <span data-ttu-id="43a34-814">작업을 다시 예약 하려고 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-814">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="43a34-815">합니다 <xref:System.Threading.Tasks.Task.Start%2A> 중 하나를 호출 하 여 만든 작업을 실행 하는 데 사용 되는 <xref:System.Threading.Tasks.Task> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-815">The <xref:System.Threading.Tasks.Task.Start%2A> is used to execute a task that has been created by calling one of the <xref:System.Threading.Tasks.Task> constructors.</span></span> <span data-ttu-id="43a34-816">일반적으로 이렇게 하면 사용자가 만든 작업을 조건부로 실행 하는 등의 해당 실행에서 작업의 생성을 구분 해야 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="43a34-816">Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created.</span></span> <span data-ttu-id="43a34-817">실행에서 작업 인스턴스화를 구분할 필요가 보다 일반적인 경우에 대 한 오버 로드를 호출 하는 권장 합니다 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 또는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-817">For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="43a34-818">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-818">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-819">다음 예제에서는 합니다 <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> 새 인스턴스화하는 생성자 <xref:System.Threading.Tasks.Task> 해당 작업 ID 및 관리 되는 스레드 ID를 표시 한 다음 루프를 실행 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-819">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to instantiate a new <xref:System.Threading.Tasks.Task> object that displays its task ID and managed thread ID and then executes a loop.</span></span> <span data-ttu-id="43a34-820">그런 다음 호출 하 여 <xref:System.Threading.Tasks.Task.Start%2A> 작업을 실행 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="43a34-820">It then calls the <xref:System.Threading.Tasks.Task.Start%2A> method to execute the task.</span></span>  <span data-ttu-id="43a34-821">콘솔 앱에 대 한 호출 이므로 <xref:System.Threading.Tasks.Task.Wait%2A> 메서드는 앱 작업 실행 완료 되기 전에 종료 되지 않도록 하려면 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-821">Since this is a console app, the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method is necessary to prevent the app from terminating before the task finishes execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-822"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-822">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43a34-823"><see cref="T:System.Threading.Tasks.Task" />가 시작할 수 있는 상태가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-823">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="43a34-824">이미 시작되었거나, 실행되었거나, 취소되었거나 아니면 직접 일정 관리를 지원하지 않는 방식으로 만들어졌을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-824">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-825">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-825">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="43a34-826">이 작업을 연결하고 실행할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-826">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> with which to associate and execute this task.</span></span></param>
        <summary><span data-ttu-id="43a34-827"><see cref="T:System.Threading.Tasks.Task" />를 시작하고 지정된 <see cref="T:System.Threading.Tasks.TaskScheduler" />에 실행을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-827">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the specified <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-828">만 작업을 시작 및 한 번만 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-828">A task may only be started and run only once.</span></span> <span data-ttu-id="43a34-829">작업을 다시 예약 하려고 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-829">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="43a34-830">작업에서 throw 된 예외 처리에 대 한 자세한 내용은 [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-830">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-831"><paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-831">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="43a34-832"><see cref="T:System.Threading.Tasks.Task" />가 시작할 수 있는 상태가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-832">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="43a34-833">이미 시작되었거나, 실행되었거나, 취소되었거나 아니면 직접 일정 관리를 지원하지 않는 방식으로 만들어졌을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-833">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-834"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-834">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException"><span data-ttu-id="43a34-835">스케줄러가 이 작업을 큐에 대기할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-835">The scheduler was unable to queue this task.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="43a34-836">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="43a34-836">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-837">이 작업의 <see cref="T:System.Threading.Tasks.TaskStatus" />를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-837">Gets the <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task.</span></span></summary>
        <value><span data-ttu-id="43a34-838">이 작업 인스턴스의 현재 <see cref="T:System.Threading.Tasks.TaskStatus" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-838">The current <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-839">값을 검색 합니다 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성은 작업이 완료 될 때까지 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-839">Retrieving the value of the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 <span data-ttu-id="43a34-840">자세한 내용 및 예제를 참조 하세요 [연속 작업을 사용 하 여 작업 연결](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) 고 [방법: 작업 및 해당 자식 취소](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43a34-840">For more information and an example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) and [How to: Cancel a Task and Its Children](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-841">다음 예제에서는 2 백만로 카운터가 증가 될 때까지 반복 하는 20 개의 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-841">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="43a34-842">처음 10 개의 작업에 도달 하면 2 백만, 취소 토큰이 취소 되 고 해당 카운터 2 백만 도달 하지 하는 모든 작업이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-842">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="43a34-843">이 예제에서는 다음 검사를 <xref:System.Threading.Tasks.Task.Status%2A> 있는지 여부를 성공적으로 완료 또는 취소 됨을 나타내려면 각 태스크의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-843">The example then examines the <xref:System.Threading.Tasks.Task.Status%2A> property of each task to indicate whether it completed successfully or was cancelled.</span></span> <span data-ttu-id="43a34-844">완료 하는 것에 대 한 작업에서 반환 값을 표시.</span><span class="sxs-lookup"><span data-stu-id="43a34-844">For those that completed, it displays the value returned by the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-845">작업이 완료되기를 기다리는 데 사용할 수 있는 <see cref="T:System.Threading.WaitHandle" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-845">Gets a <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></summary>
        <value><span data-ttu-id="43a34-846">작업이 완료되기를 기다리는 데 사용할 수 있는 <see cref="T:System.Threading.WaitHandle" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-846">A <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-847">제공 하 여 대기 기능을 사용 하 여 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드보다 선호도 높습니다 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 유사한 기능에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-847">Using the wait functionality provided by <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> is preferable to using <xref:System.IAsyncResult.AsyncWaitHandle%2A> for similar functionality.</span></span> <span data-ttu-id="43a34-848">자세한 내용은 "작업에서 대기 중" 섹션을 참조 하세요 [태스크 기반 비동기 프로그래밍](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) 하 고 [기타 비동기 패턴과 함께 TPL을 사용 하 여](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-848">For more information, see the "Waiting on Tasks" section in [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Using TPL with Other Asynchronous Patterns](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-849"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-849">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="43a34-850">작업이 동기적으로 완료되었는지 여부를 나타내는 표시를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-850">Gets an indication of whether the operation completed synchronously.</span></span></summary>
        <value><span data-ttu-id="43a34-851">작업이 동기적으로 끝나면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-851"><see langword="true" /> if the operation completed synchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-852"><see cref="T:System.Threading.Tasks.Task" />의 실행이 완료되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-852">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43a34-853"><see cref="T:System.Threading.Tasks.Task" />의 실행이 완료되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-853">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-854"><xref:System.Threading.Tasks.Task.Wait%2A> 호출 스레드가 현재 작업이 완료 될 때까지 대기 하는 동기화 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-854"><xref:System.Threading.Tasks.Task.Wait%2A> is a synchronization method that causes the calling thread to wait until the current task has completed.</span></span> <span data-ttu-id="43a34-855">현재 작업 실행 시작 되지 않은 경우 Wait 메서드 스케줄러에서 작업을 제거 하 고 현재 스레드에서 인라인으로 실행 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-855">If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread.</span></span> <span data-ttu-id="43a34-856">이렇게 할 수 없는 경우 또는 현재 작업 실행이 이미 시작 하는 경우 작업이 완료 될 때까지 호출 스레드를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-856">If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes.</span></span> <span data-ttu-id="43a34-857">자세한 내용은 [Task.Wait 및 "인라인"](https://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) 에서 Parallel Programming with.NET 블로그.</span><span class="sxs-lookup"><span data-stu-id="43a34-857">For more information, see [Task.Wait and "Inlining"](https://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) in the Parallel Programming with .NET blog.</span></span>   
  
## Examples  
 <span data-ttu-id="43a34-858">다음 예제에서는 1 백만 0과 100 사이의 임의의 정수를 생성 하 고 해당 평균을 계산 하는 작업을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-858">The following example starts a task that generates one million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="43a34-859">이 예제에서는 사용 된 <xref:System.Threading.Tasks.Task.Wait%2A> 응용 프로그램이 종료 되기 전에 작업이 완료 되도록 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="43a34-859">The example uses the <xref:System.Threading.Tasks.Task.Wait%2A> method to ensure that the task completes before the application terminates.</span></span> <span data-ttu-id="43a34-860">이 고, 그렇지 콘솔 응용 프로그램을 이기 때문에 예제에서는 태스크를 계산 하 고 평균을 표시할 수 전에 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-860">Otherwise, because this is a console application, the example would terminate before the task can compute and display the mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-861"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-861">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-862">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-862">The task was canceled.</span></span> <span data-ttu-id="43a34-863"><see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 개체가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-863">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="43a34-864">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-864">-or-</span></span> 
<span data-ttu-id="43a34-865">작업을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-865">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="43a34-866">예외나 예외에 대한 정보를 포함하는 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-866">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
        <related type="ExternalDocumentation" href="https://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx"><span data-ttu-id="43a34-867">Task.Wait 및 "인라인"</span><span class="sxs-lookup"><span data-stu-id="43a34-867">Task.Wait and "Inlining"</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="43a34-868">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-868">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="43a34-869"><see cref="T:System.Threading.Tasks.Task" />가 지정된 시간(밀리초) 내에 실행을 완료할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-869">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="43a34-870"><see langword="true" />의 실행이 할당된 시간 안에 완료되었으면 <see cref="T:System.Threading.Tasks.Task" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-870"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-871"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> 호출 스레드를 현재 작업 인스턴스 중 하나가 발생할 때까지 완료를 대기 시키는 동기화 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-871"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="43a34-872">작업을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-872">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="43a34-873">작업 자체는 취소 되거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-873">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="43a34-874">이 경우 처리 하는 <xref:System.AggregateException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-874">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="43a34-875"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> 속성 예외 나 예외에 대 한 세부 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-875">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="43a34-876">정의한 간격 `millisecondsTimeout` 경과 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-876">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="43a34-877">이 경우 현재 스레드의 실행을 다시 시작 하 고 메서드를 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-877">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-878">다음 예제에서는 5 백만 0과 100 사이의 임의의 정수를 생성 하 고 해당 평균을 계산 하는 작업을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-878">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="43a34-879">이 예제에서는 사용 된 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> 150 시간 (밀리초) 내에 완료 된 응용 프로그램이 기다리도록 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="43a34-879">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="43a34-880">응용 프로그램이 정상적으로 완료 되 면 작업에서 생성 하는 난수의 평균 및 합계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-880">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="43a34-881">시간 제한 간격이 경과할 경우 예제를 종료 하기 전에 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-881">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-882"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-882">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-883"><paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-883"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-884">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-884">The task was canceled.</span></span> <span data-ttu-id="43a34-885"><see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 개체가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-885">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="43a34-886">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-886">-or-</span></span> 
<span data-ttu-id="43a34-887">작업을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-887">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="43a34-888">예외나 예외에 대한 정보를 포함하는 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-888">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="43a34-889">작업이 완료되기를 기다리는 동안 관찰할 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-889">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="43a34-890"><see cref="T:System.Threading.Tasks.Task" />의 실행이 완료되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-890">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="43a34-891">작업이 완료되기 전에 취소 토큰이 취소되면 대기가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-891">The wait terminates if a cancellation token is canceled before the task completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-892"><xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> 메서드 생성을 취소할 수 있는 대기 하면 즉, 현재 스레드를 다음 중 하나가 발생할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-892">The <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="43a34-893">태스크를 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-893">The task completes.</span></span>  
  
-   <span data-ttu-id="43a34-894">취소 토큰이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-894">The cancellation token is canceled.</span></span> <span data-ttu-id="43a34-895">이 경우에 대 한 호출을 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> 메서드가 throw는 <xref:System.OperationCanceledException>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-895">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43a34-896">취소는 `cancellationToken` 취소 토큰 효과가 있습니다 실행 중인 작업에도 취소 토큰이 전달 되 고 취소를 처리 하도록 준비 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-896">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="43a34-897">전달 된 `cancellationToken` 개체를이 메서드에 사용 하면 취소할 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-897">Passing the `cancellationToken` object to this method simply allows the wait to be canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-898">다음 예제에서는 작업의 완료에 대 한 대기를 취소 하는 취소 토큰의 간단한 사용법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-898">The following example illustrates the simple use of a cancellation token to cancel waiting for a task's completion.</span></span> <span data-ttu-id="43a34-899">작업 호출을 시작 합니다 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 5 초 동안 취소 토큰 소스의 취소 토큰 및 다음 지연 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-899">A task is launched, calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel any of the token source's cancellation tokens, and then delays for five seconds.</span></span> <span data-ttu-id="43a34-900">참고 작업 자체는 취소 토큰이 전달 되지 않은 하 고는 취소할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-900">Note that the task itself has not been passed the cancellation token and is not cancelable.</span></span> <span data-ttu-id="43a34-901">작업을 호출 하는 응용 프로그램 스레드에 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드는 작업이 완료 될 때까지 기다리는를 있지만 대기 취소 토큰이 취소 되 면 및 취소 <xref:System.OperationCanceledException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-901">The application thread calls the task's <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the task to complete, but the wait is canceled once the cancellation token is cancelled and an <xref:System.OperationCanceledException> is thrown.</span></span> <span data-ttu-id="43a34-902">예외 처리기는 예외를 보고 하 고 6 초 동안 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-902">The exception handler reports the exception and then sleeps for six seconds.</span></span> <span data-ttu-id="43a34-903">해당 지연 작업을 완료 하면 예제의 출력에서 볼 수 있듯이 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-903">As the output from the example shows, that delay allows the task to complete in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="43a34-904"><paramref name="cancellationToken" />을 취소했습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-904">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-905">작업이 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-905">The task has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-906">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-906">The task was canceled.</span></span> <span data-ttu-id="43a34-907"><see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 개체가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-907">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="43a34-908">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-908">-or-</span></span> 
<span data-ttu-id="43a34-909">작업을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-909">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="43a34-910">예외나 예외에 대한 정보를 포함하는 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-910">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="43a34-911">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-911">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="43a34-912"><see cref="T:System.Threading.Tasks.Task" />가 지정된 시간 간격 내에 실행을 완료할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-912">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="43a34-913"><see langword="true" />의 실행이 할당된 시간 안에 완료되었으면 <see cref="T:System.Threading.Tasks.Task" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-913"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-914"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> 호출 스레드를 현재 작업 인스턴스 중 하나가 발생할 때까지 완료를 대기 시키는 동기화 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-914"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="43a34-915">작업을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-915">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="43a34-916">작업 자체는 취소 되거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-916">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="43a34-917">이 경우 처리 하는 <xref:System.AggregateException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-917">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="43a34-918"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> 속성 예외 나 예외에 대 한 세부 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-918">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="43a34-919">정의한 간격 `timeout` 경과 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-919">The interval defined by `timeout` elapses.</span></span> <span data-ttu-id="43a34-920">이 경우 현재 스레드의 실행을 다시 시작 하 고 메서드를 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-920">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-921">다음 예제에서는 5 백만 0과 100 사이의 임의의 정수를 생성 하 고 해당 평균을 계산 하는 작업을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-921">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="43a34-922">이 예제에서는 사용 된 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> 150 시간 (밀리초) 내에 완료 된 응용 프로그램이 기다리도록 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="43a34-922">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="43a34-923">응용 프로그램이 정상적으로 완료 되 면 작업에서 생성 하는 난수의 평균 및 합계를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-923">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="43a34-924">시간 제한 간격이 경과할 경우 예제를 종료 하기 전에 메시지를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-924">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-925"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-925">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-926"><paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-926"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="43a34-927">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-927">-or-</span></span> 
 <span data-ttu-id="43a34-928"><paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-928"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-929">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-929">The task was canceled.</span></span> <span data-ttu-id="43a34-930"><see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 개체가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-930">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="43a34-931">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-931">-or-</span></span> 
<span data-ttu-id="43a34-932">작업을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-932">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="43a34-933">예외나 예외에 대한 정보를 포함하는 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-933">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="43a34-934">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-934">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-935">작업이 완료되기를 기다리는 동안 관찰할 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-935">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="43a34-936"><see cref="T:System.Threading.Tasks.Task" />의 실행이 완료되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-936">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="43a34-937">작업이 완료되기 전에 취소 토큰이 취소되었거나 시간 제한 간격이 경과되었으면 대기가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-937">The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes.</span></span></summary>
        <returns><span data-ttu-id="43a34-938"><see langword="true" />의 실행이 할당된 시간 안에 완료되었으면 <see cref="T:System.Threading.Tasks.Task" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-938"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-939"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> 호출 스레드를 현재 작업 인스턴스 중 하나가 발생할 때까지 완료를 대기 시키는 동기화 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-939"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="43a34-940">작업을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-940">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="43a34-941">작업 자체는 취소 되거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-941">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="43a34-942">이 경우 처리 하는 <xref:System.AggregateException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-942">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="43a34-943"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> 속성 예외 나 예외에 대 한 세부 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-943">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="43a34-944">`cancellationToken` 취소 토큰이 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-944">The `cancellationToken` cancellation token is canceled.</span></span> <span data-ttu-id="43a34-945">이 경우에 대 한 호출을 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> 메서드가 throw는 <xref:System.OperationCanceledException>합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-945">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
-   <span data-ttu-id="43a34-946">정의한 간격 `millisecondsTimeout` 경과 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-946">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="43a34-947">이 경우 현재 스레드의 실행을 다시 시작 하 고 메서드를 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-947">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43a34-948">취소는 `cancellationToken` 취소 토큰 효과가 있습니다 실행 중인 작업에도 취소 토큰이 전달 되 고 취소를 처리 하도록 준비 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-948">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="43a34-949">전달 된 `cancellationToken` 개체를이 메서드에 사용 하면 대기가 취소 될 기반 조건에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-949">Passing the `cancellationToken` object to this method simply allows the wait to be canceled based on some condition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-950">다음 예제에서는 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> 있는 제한 시간 값과는 취소 토큰을 제공 하는 메서드는 작업의 완료에 대 한 대기를 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-950">The following example calls the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method to provide both a timeout value and a cancellation token that can end the wait for a task's completion.</span></span> <span data-ttu-id="43a34-951">새 스레드 시작 되 고 실행 합니다 `CancelToken` 메서드를 일시 중지 하 고 호출 하는 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 취소 토큰을 취소 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="43a34-951">A new thread is started and executes the `CancelToken` method, which pauses and then calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel the cancellation tokens.</span></span> <span data-ttu-id="43a34-952">작업을 다음을 실행 하 고 5 초 동안 지연 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-952">A task is then launched and delays for 5 seconds.</span></span> <span data-ttu-id="43a34-953"><xref:System.Threading.Tasks.Task.Wait%2A> 메서드를 호출 하는 작업의 완료를 기다리는 및 간단한 시간 제한 값 및 취소 토큰을 모두 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-953">The <xref:System.Threading.Tasks.Task.Wait%2A> method is then called to wait for the task's completion and is provided both a brief timeout value and a cancellation token.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 <span data-ttu-id="43a34-954">대기가 취소 토큰으로 인해 취소 되었습니다 여부 시간 제한 간격이 경과 하기 때문에 예제의 정확한 출력에 의존 하는 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-954">Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="43a34-955"><paramref name="cancellationToken" />을 취소했습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-955">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-956"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-956">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-957"><paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-957"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-958">작업이 취소되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-958">The task was canceled.</span></span> <span data-ttu-id="43a34-959"><see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 개체가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-959">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="43a34-960">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-960">-or-</span></span> 
<span data-ttu-id="43a34-961">작업을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-961">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="43a34-962">예외나 예외에 대한 정보를 포함하는 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-962">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-963">제공된 모든 <see cref="T:System.Threading.Tasks.Task" /> 개체의 실행이 완료되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-963">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-964">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-964">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="43a34-965">제공된 모든 <see cref="T:System.Threading.Tasks.Task" /> 개체의 실행이 완료되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-965">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="43a34-966">다음 예에서는 인덱스를 상태 개체로 전달 되는 각각 10 개의 작업을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-966">The following example starts 10 tasks, each of which is passed an index as a state object.</span></span> <span data-ttu-id="43a34-967">2 ~ 5 개의 인덱스를 사용 하 여 작업 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-967">Tasks with an index from two to five throw exceptions.</span></span> <span data-ttu-id="43a34-968">에 대 한 호출을 <xref:System.Threading.Tasks.Task.WaitAll%2A> 메서드는 모든 예외를 래핑합니다는 <xref:System.AggregateException> 개체 및 호출 스레드를 전파 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-968">The call to the <xref:System.Threading.Tasks.Task.WaitAll%2A> method wraps all exceptions in an <xref:System.AggregateException> object and propagates it to the calling thread.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-969"><paramref name="tasks" />에서 하나 이상의 <see cref="T:System.Threading.Tasks.Task" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-969">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-970"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-970">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-971"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-971">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="43a34-972">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-972">-or-</span></span> 
<span data-ttu-id="43a34-973"><paramref name="tasks" /> 인수가 빈 배열인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-973">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-974"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상이 취소된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-974">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="43a34-975">작업이 취소된 경우 <see cref="T:System.AggregateException" /> 예외에는 해당 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션의 <see cref="T:System.OperationCanceledException" /> 예외가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-975">If a task was canceled, the <see cref="T:System.AggregateException" /> exception contains an <see cref="T:System.OperationCanceledException" /> exception in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="43a34-976">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-976">-or-</span></span> 
<span data-ttu-id="43a34-977"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-977">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-978">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-978">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="43a34-979">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-979">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="43a34-980">모든 제공된 <see cref="T:System.Threading.Tasks.Task" /> 개체가 지정된 시간(밀리초) 내에 실행을 완료할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-980">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="43a34-981">모든 <see langword="true" /> 인스턴스의 실행이 할당된 시간 안에 완료되었으면 <see cref="T:System.Threading.Tasks.Task" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-981"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-982"><paramref name="tasks" />에서 하나 이상의 <see cref="T:System.Threading.Tasks.Task" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-982">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-983"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-983">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-984"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상이 취소된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-984">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="43a34-985">작업이 취소된 경우 <see cref="T:System.AggregateException" />의 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.OperationCanceledException" />이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-985">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="43a34-986">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-986">-or-</span></span> 
<span data-ttu-id="43a34-987"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-987">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-988"><paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-988"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-989"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-989">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="43a34-990">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-990">-or-</span></span> 
<span data-ttu-id="43a34-991"><paramref name="tasks" /> 인수가 빈 배열인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-991">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-992">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-992">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-993">작업이 완료되기를 기다리는 동안 확인할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-993">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="43a34-994">대기가 취소되지 않는 경우 제공된 모든 <see cref="T:System.Threading.Tasks.Task" /> 개체가 실행을 완료하기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-994">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-995">`cancellationToken` 인수를 사용 하 여 대기 작업을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-995">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="43a34-996">작업을 취소 하는 고유한 작업 및 신호를 보낼는 <xref:System.AggregateException> 위에서 설명한 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-996">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> as noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="43a34-997"><paramref name="cancellationToken" />을 취소했습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-997">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-998"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-998">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-999"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상이 취소된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-999">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="43a34-1000">작업이 취소된 경우 <see cref="T:System.AggregateException" />의 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.OperationCanceledException" />이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1000">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="43a34-1001">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-1001">-or-</span></span> 
<span data-ttu-id="43a34-1002"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1002">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1003"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1003">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="43a34-1004">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-1004">-or-</span></span> 
<span data-ttu-id="43a34-1005"><paramref name="tasks" /> 인수가 빈 배열인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1005">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-1006"><paramref name="tasks" />에서 하나 이상의 <see cref="T:System.Threading.Tasks.Task" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1006">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1007">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1007">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="43a34-1008">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1008">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="43a34-1009">모든 제공된 취소 가능한 <see cref="T:System.Threading.Tasks.Task" /> 개체가 지정된 시간 간격 내에 실행을 완료할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1009">Waits for all of the provided cancellable <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="43a34-1010">모든 <see langword="true" /> 인스턴스의 실행이 할당된 시간 안에 완료되었으면 <see cref="T:System.Threading.Tasks.Task" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1010"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-1011"><paramref name="tasks" />에서 하나 이상의 <see cref="T:System.Threading.Tasks.Task" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1011">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1012"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1012">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-1013"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상이 취소된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1013">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="43a34-1014">작업이 취소된 경우 <see cref="T:System.AggregateException" />의 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.OperationCanceledException" />이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1014">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="43a34-1015">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-1015">-or-</span></span> 
<span data-ttu-id="43a34-1016"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1016">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-1017"><paramref name="timeout" />은 시간 제한이 없음을 나타내는 -1밀리초 이외의 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1017"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="43a34-1018">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-1018">-or-</span></span> 
 <span data-ttu-id="43a34-1019"><paramref name="timeout" />가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1019"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1020"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1020">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="43a34-1021">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-1021">-or-</span></span> 
<span data-ttu-id="43a34-1022"><paramref name="tasks" /> 인수가 빈 배열인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1022">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1023">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1023">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="43a34-1024">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1024">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-1025">작업이 완료되기를 기다리는 동안 확인할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1025">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="43a34-1026">제공된 모든 <see cref="T:System.Threading.Tasks.Task" /> 개체가 지정된 시간(밀리초) 내에 실행을 완료하기를 기다리거나 대기가 취소될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1026">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</span></span></summary>
        <returns><span data-ttu-id="43a34-1027">모든 <see langword="true" /> 인스턴스의 실행이 할당된 시간 안에 완료되었으면 <see cref="T:System.Threading.Tasks.Task" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1027"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1028">`cancellationToken` 인수를 사용 하 여 대기 작업을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1028">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="43a34-1029">작업을 취소 하는 고유한 작업 및 신호를 보낼는 <xref:System.AggregateException> 위에서 설명한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1029">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-1030"><paramref name="tasks" />에서 하나 이상의 <see cref="T:System.Threading.Tasks.Task" /> 개체가 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1030">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1031"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1031">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="43a34-1032"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상이 취소된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1032">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="43a34-1033">작업이 취소된 경우 <see cref="T:System.AggregateException" />의 <see cref="P:System.AggregateException.InnerExceptions" /> 컬렉션에 <see cref="T:System.OperationCanceledException" />이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1033">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="43a34-1034">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-1034">-or-</span></span> 
<span data-ttu-id="43a34-1035"><see cref="T:System.Threading.Tasks.Task" /> 인스턴스 중 하나 이상을 실행하는 동안 예외가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1035">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-1036"><paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1036"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1037"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1037">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="43a34-1038">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-1038">-or-</span></span> 
<span data-ttu-id="43a34-1039"><paramref name="tasks" /> 인수가 빈 배열인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1039">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="43a34-1040"><paramref name="cancellationToken" />을 취소했습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1040">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-1041">제공된 <see cref="T:System.Threading.Tasks.Task" /> 개체 중 임의 개체의 실행이 완료되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1041">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1042">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1042">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="43a34-1043">제공된 <see cref="T:System.Threading.Tasks.Task" /> 개체 중 임의 개체의 실행이 완료되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1043">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <returns><span data-ttu-id="43a34-1044"><paramref name="tasks" /> 배열에서 완료된 <see cref="T:System.Threading.Tasks.Task" /> 개체의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1044">The index of the completed <see cref="T:System.Threading.Tasks.Task" /> object in the <paramref name="tasks" /> array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="43a34-1045">다음 예제에서는 5 개의 작업을 각각 50 밀리초의 최소 또는 최대 1,050 시간 (밀리초)에 대 한 대기를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1045">The following example launches five tasks, each of which sleeps for a minimum of 50 milliseconds or a maximum of 1,050 milliseconds.</span></span> <span data-ttu-id="43a34-1046"><xref:System.Threading.Tasks.Task.WaitAny%2A> 메서드 모든 작업이 완료 되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1046">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method then waits for any of the tasks to complete.</span></span> <span data-ttu-id="43a34-1047">모든 작업의 현재 상태 뿐만 아니라 대기를 종료 하는 작업의 작업 ID를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1047">The example displays the task ID of the task that ended the wait, as well as the current status of all the tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-1048"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1048">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1049"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1049">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1050"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1050">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1051">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1051">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="43a34-1052">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1052">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="43a34-1053">모든 제공된 <see cref="T:System.Threading.Tasks.Task" /> 개체가 지정된 시간(밀리초) 내에 실행을 완료할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1053">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="43a34-1054"><paramref name="tasks" /> 배열 인수의 완료된 작업 인덱스이거나, 제한 시간이 초과되었으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1054">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-1055"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1055">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1056"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1056">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-1057"><paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1057"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1058"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1058">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1059">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1059">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-1060">작업이 완료되기를 기다리는 동안 확인할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1060">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="43a34-1061">대기가 취소되지 않는 경우 제공된 모든 <see cref="T:System.Threading.Tasks.Task" /> 개체가 실행을 완료하기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1061">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <returns><span data-ttu-id="43a34-1062"><paramref name="tasks" /> 배열 인수에서 완료된 작업의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1062">The index of the completed task in the <paramref name="tasks" /> array argument.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-1063"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1063">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1064"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1064">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1065"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1065">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="43a34-1066"><paramref name="cancellationToken" />을 취소했습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1066">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1067">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1067">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="43a34-1068">대기할 시간(밀리초)을 나타내는 <see cref="T:System.TimeSpan" />이거나, 무한 대기하도록 -1밀리초를 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1068">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="43a34-1069">모든 제공된 <see cref="T:System.Threading.Tasks.Task" /> 개체가 지정된 시간 간격 내에 실행을 완료할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1069">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="43a34-1070"><paramref name="tasks" /> 배열 인수의 완료된 작업 인덱스이거나, 제한 시간이 초과되었으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1070">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-1071"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1071">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1072"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1072">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-1073"><paramref name="timeout" /> 인수의 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 속성은 -1이 아닌 음수입니다. -1은 무기한 시간 제한을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1073">The <see cref="P:System.TimeSpan.TotalMilliseconds" /> property of the <paramref name="timeout" /> argument is a negative number other than -1, which represents an infinite time-out.</span></span> 
<span data-ttu-id="43a34-1074">또는</span><span class="sxs-lookup"><span data-stu-id="43a34-1074">-or-</span></span> 
<span data-ttu-id="43a34-1075"><paramref name="timeout" /> 인수의 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 속성은 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1075">The <see cref="P:System.TimeSpan.TotalMilliseconds" /> property of the <paramref name="timeout" /> argument is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1076"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1076">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1077">대기할 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1077">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="43a34-1078">대기할 시간(밀리초)이거나, 무기한 대기할 경우 <see cref="F:System.Threading.Timeout.Infinite" />(-1)입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1078">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="43a34-1079">작업이 완료되기를 기다리는 동안 확인할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1079">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="43a34-1080">모든 제공된 <see cref="T:System.Threading.Tasks.Task" /> 개체가 지정된 시간(밀리초) 내에 실행을 완료하기를 기다리거나 취소 토큰이 취소될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1080">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</span></span></summary>
        <returns><span data-ttu-id="43a34-1081"><paramref name="tasks" /> 배열 인수의 완료된 작업 인덱스이거나, 제한 시간이 초과되었으면 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1081">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="43a34-1082"><see cref="T:System.Threading.Tasks.Task" />가 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1082">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1083"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1083">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="43a34-1084"><paramref name="millisecondsTimeout" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1084"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1085"><paramref name="tasks" /> 인수에 null 요소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1085">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="43a34-1086"><paramref name="cancellationToken" />을 취소했습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1086">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-1087">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1087">Creates a task that will complete when all of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1088">완료를 기다리는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1088">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="43a34-1089">열거 가능한 컬렉션의 모든 <see cref="T:System.Threading.Tasks.Task" /> 개체가 완료되면 완료될 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1089">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="43a34-1090">제공된 모든 작업의 완료를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1090">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1091">오버 로드는 <xref:System.Threading.Tasks.Task.WhenAll%2A> 를 반환 하는 메서드를 <xref:System.Threading.Tasks.Task> 작업 집합에 의해 throw 된 예외 또는 작업 집합의 상태에 관심이 있는 경우에 일반적으로 개체 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1091">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43a34-1092">에 대 한 호출 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> 메서드는 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1092">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="43a34-1093">제공 된 작업 오류 상태로 완료 되 면 반환된 된 작업은 또한 완료를 <xref:System.Threading.Tasks.TaskStatus.Faulted> 상태에 있는 해당 예외 각각 제공 된 작업의 래핑되지 않은 예외 집합을 집계 하는 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1093">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="43a34-1094">제공 된 작업 없음 오류가 발생 하지만 취소 되었습니다. 그 중 하나 이상 반환된 된 작업에서 종료 됩니다는 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1094">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="43a34-1095">결과 작업에 종료 됩니다 작업 중 오류가 발생 한 경우 취소 된 모든 태스크는 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1095">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="43a34-1096">반환 된 작업이 즉시 전환 됩니다 있으면 제공 된 배열/열거형 없는 작업을 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 호출자에 게 반환 되기 전에 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1096">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-1097">다음 예제에서는 배열에 Url을 ping 하는 작업 집합을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1097">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="43a34-1098">작업에 저장 됩니다는 `List<Task>` 에 전달 되는 컬렉션을 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-1098">The tasks are stored in a `List<Task>` collection that is passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="43a34-1099">호출한 후 합니다 <xref:System.Threading.Tasks.Task.Wait%2A> 메서드를 사용 하면 모든 스레드가 완료 된을 검사 하는 예제는 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 작업 faulted가 있는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1099">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1100"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1100">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1101"><see langword="null" /> 작업이 포함된 <paramref name="tasks" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1101">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1102">완료를 기다리는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1102">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="43a34-1103">배열의 모든 <see cref="T:System.Threading.Tasks.Task" /> 개체가 완료되면 완료될 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1103">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="43a34-1104">제공된 모든 작업의 완료를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1104">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1105">오버 로드는 <xref:System.Threading.Tasks.Task.WhenAll%2A> 를 반환 하는 메서드를 <xref:System.Threading.Tasks.Task> 작업 집합에 의해 throw 된 예외 또는 작업 집합의 상태에 관심이 있는 경우에 일반적으로 개체 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1105">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43a34-1106">에 대 한 호출 <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> 메서드는 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1106">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="43a34-1107">제공 된 작업 오류 상태로 완료 되 면 반환된 된 작업은 또한 완료를 <xref:System.Threading.Tasks.TaskStatus.Faulted> 상태에 있는 해당 예외 각각 제공 된 작업의 래핑되지 않은 예외 집합을 집계 하는 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1107">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="43a34-1108">제공 된 작업 없음 오류가 발생 하지만 취소 되었습니다. 그 중 하나 이상 반환된 된 작업에서 종료 됩니다는 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1108">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="43a34-1109">결과 작업에 종료 됩니다 작업 중 오류가 발생 한 경우 취소 된 모든 태스크는 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1109">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="43a34-1110">반환 된 작업이 즉시 전환 됩니다 있으면 제공 된 배열/열거형 없는 작업을 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 호출자에 게 반환 되기 전에 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1110">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-1111">다음 예제에서는 배열에 Url을 ping 하는 작업 집합을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1111">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="43a34-1112">작업에 저장 됩니다는 `List<Task>` 배열로 변환 되 고 전달 하는 컬렉션을 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43a34-1112">The tasks are stored in a `List<Task>` collection that is converted to an array and passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="43a34-1113">호출한 후 합니다 <xref:System.Threading.Tasks.Task.Wait%2A> 메서드를 사용 하면 모든 스레드가 완료 된을 검사 하는 예제는 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 작업 faulted가 있는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1113">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1114"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1114">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1115"><see langword="null" /> 작업이 포함된 <paramref name="tasks" /> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1115">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-1116">완료된 작업의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1116">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="43a34-1117">완료를 기다리는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1117">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="43a34-1118">열거 가능한 컬렉션의 모든 <see cref="T:System.Threading.Tasks.Task`1" /> 개체가 완료되면 완료될 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1118">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="43a34-1119">제공된 모든 작업의 완료를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1119">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1120">에 대 한 호출 <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> 메서드는 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1120">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> method does not block the calling thread.</span></span> <span data-ttu-id="43a34-1121">그러나 반환 된 호출 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성은 호출 스레드를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1121">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="43a34-1122">제공 된 작업 오류 상태로 완료 되 면 반환된 된 작업은 또한 완료를 <xref:System.Threading.Tasks.TaskStatus.Faulted> 상태에 있는 해당 예외 각각 제공 된 작업의 래핑되지 않은 예외 집합을 집계 하는 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1122">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="43a34-1123">제공 된 작업 없음 오류가 발생 하지만 취소 되었습니다. 그 중 하나 이상 반환된 된 작업에서 종료 됩니다는 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1123">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="43a34-1124">결과 작업에 종료 됩니다 작업 중 오류가 발생 한 경우 취소 된 모든 태스크는 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1124">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="43a34-1125">합니다 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 제공 받은 대로 동일한 순서에 따라 제공 된 작업의 결과 모두 포함 된 배열에 반환된 된 작업의 속성이 설정 됩니다 (예: 포함 된 배열 t1, t2, t3, 출력 작업의 입력 작업 하는 경우 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 반환 됩니다 `TResult[]` 여기서 `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1125">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="43a34-1126">경우는 `tasks` 작업을 포함 하는 인수, 반환된 된 작업은 즉시 전환 되는 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 호출자에 게 반환 되기 전에 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1126">If the `tasks` argument contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span> <span data-ttu-id="43a34-1127">반환 된 `TResult[]` 0 요소 배열 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1127">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-1128">다음 예제에서는 1에서 1,000 사이의 임의의 숫자 1, 000을 만들고 해당 평균을 계산 하는 난수 생성기를 인스턴스화하고 각각 10 개 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1128">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="43a34-1129"><xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> 메서드 동일한 초기값을 사용 하 여 생성 되지 않습니다 있도록 난수 생성기의 인스턴스화를 연기를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1129">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="43a34-1130">에 대 한 호출을 <xref:System.Threading.Tasks.Task.WhenAll%2A> 메서드가 반환 됩니다는 <xref:System.Int64> 각 작업에 의해 계산 된 평균을 포함 하는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1130">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="43a34-1131">이러한 전체 평균 계산에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1131">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 <span data-ttu-id="43a34-1132">10 개의 개별 작업에 저장 됩니다 여기서는 <xref:System.Collections.Generic.List%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1132">In this case, the ten individual tasks are stored in a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="43a34-1133"><xref:System.Collections.Generic.List%601>는 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1133"><xref:System.Collections.Generic.List%601> implements the <xref:System.Collections.Generic.IEnumerable%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1134"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1134">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1135"><see langword="null" /> 작업이 포함된 <paramref name="tasks" /> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1135">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-1136">완료된 작업의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1136">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="43a34-1137">완료를 기다리는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1137">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="43a34-1138">배열의 모든 <see cref="T:System.Threading.Tasks.Task`1" /> 개체가 완료되면 완료될 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1138">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="43a34-1139">제공된 모든 작업의 완료를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1139">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1140">에 대 한 호출 <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> 메서드는 호출 스레드를 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1140">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> method does not block the calling thread.</span></span> <span data-ttu-id="43a34-1141">그러나 반환 된 호출 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성은 호출 스레드를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1141">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="43a34-1142">제공 된 작업 오류 상태로 완료 되 면 반환된 된 작업은 또한 완료를 <xref:System.Threading.Tasks.TaskStatus.Faulted> 상태에 있는 해당 예외 각각 제공 된 작업의 래핑되지 않은 예외 집합을 집계 하는 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1142">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="43a34-1143">제공 된 작업 없음 오류가 발생 하지만 취소 되었습니다. 그 중 하나 이상 반환된 된 작업에서 종료 됩니다는 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1143">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="43a34-1144">결과 작업에 종료 됩니다 작업 중 오류가 발생 한 경우 취소 된 모든 태스크는 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1144">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="43a34-1145">합니다 <xref:System.Threading.Tasks.Task%601.Result%2A> 반환된 된 작업의 설정이 적용 됩니다 제공 받은 대로 동일한 순서에 따라 제공 된 작업의 결과 모두 포함 된 배열 (예: 포함 된 배열 t1, t2, t3, 출력 작업의 입력 작업 하는 경우 <xref:System.Threading.Tasks.Task%601.Result%2A> 돌아갑니다는 `TResult[]` 여기서 `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1145">The <xref:System.Threading.Tasks.Task%601.Result%2A> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <xref:System.Threading.Tasks.Task%601.Result%2A> will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="43a34-1146">반환 된 작업이 즉시 전환 됩니다 있으면 제공 된 배열/열거형 없는 작업을 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 호출자에 게 반환 되기 전에 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1146">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  <span data-ttu-id="43a34-1147">반환 된 `TResult[]` 0 요소 배열 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1147">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43a34-1148">다음 예제에서는 1에서 1,000 사이의 임의의 숫자 1, 000을 만들고 해당 평균을 계산 하는 난수 생성기를 인스턴스화하고 각각 10 개 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1148">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="43a34-1149">10 개의 개별 작업에 저장 됩니다 여기서는 `Task<Int64>` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1149">In this case, the ten individual tasks are stored in a `Task<Int64>` array.</span></span>  <span data-ttu-id="43a34-1150"><xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> 메서드 동일한 초기값을 사용 하 여 생성 되지 않습니다 있도록 난수 생성기의 인스턴스화를 연기를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1150">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="43a34-1151">에 대 한 호출을 <xref:System.Threading.Tasks.Task.WhenAll%2A> 메서드가 반환 됩니다는 <xref:System.Int64> 각 작업에 의해 계산 된 평균을 포함 하는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1151">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="43a34-1152">이러한 전체 평균 계산에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1152">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1153"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1153">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1154"><see langword="null" /> 작업이 포함된 <paramref name="tasks" /> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1154">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="43a34-1155">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1155">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1156">완료를 기다리는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1156">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="43a34-1157">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1157">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="43a34-1158">제공된 한 작업의 완료를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1158">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="43a34-1159">반환 작업의 결과는 완료된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1159">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1160">경우에 반환 된 작업이 완료 됩니다 제공 된 작업을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1160">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="43a34-1161">반환 된 작업이 종료 됩니다. 항상를 `RanToCompletion` 첫 번째 작업을 완료로 설정 하는 해당 결과가 포함 된 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1161">The returned task will always end in the `RanToCompletion` state  with its Result set to the first task to complete.</span></span>  <span data-ttu-id="43a34-1162">첫 번째 작업이 완료 되기를 인해 종료 된 경우에 마찬가지 합니다 `Canceled` 또는 `Faulted` 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1162">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1163"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1163">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1164">null 작업이 포함되었거나 비어 있는 <paramref name="tasks" /> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1164">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="43a34-1165">완료를 기다리는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1165">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="43a34-1166">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1166">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="43a34-1167">제공된 한 작업의 완료를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1167">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="43a34-1168">반환 작업의 결과는 완료된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1168">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1169">경우에 반환 된 작업이 완료 됩니다 제공 된 작업을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1169">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="43a34-1170">반환 된 작업이 종료 됩니다. 항상을 `RanToCompletion` 상태 이며 해당 `Result` 첫 번째 작업을 완료로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1170">The returned task will always end in the `RanToCompletion` state   with its `Result` set to the first task to complete.</span></span>  <span data-ttu-id="43a34-1171">첫 번째 작업이 완료 되기를 인해 종료 된 경우에 마찬가지 합니다 `Canceled` 또는 `Faulted` 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1171">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1172"><paramref name="tasks" /> 인수가 null인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1172">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1173">null 작업이 포함되었거나 비어 있는 <paramref name="tasks" /> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1173">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-1174">완료된 작업의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1174">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="43a34-1175">완료를 기다리는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1175">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="43a34-1176">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1176">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="43a34-1177">제공된 한 작업의 완료를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1177">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="43a34-1178">반환 작업의 결과는 완료된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1178">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1179">경우에 반환 된 작업이 완료 됩니다 제공 된 작업을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1179">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="43a34-1180">반환된 된 작업 결과 완료 하려면 첫 번째 작업 집합을 사용 하 여 RanToCompletion 상태의 항상 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1180">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="43a34-1181">첫 번째 작업이 완료 되기를 Canceled 또는 Faulted 상태에서 종료 하는 경우에 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1181">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1182"><paramref name="tasks" /> 인수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1182">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1183">null 작업이 포함되었거나 비어 있는 <paramref name="tasks" /> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1183">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="43a34-1184">완료된 작업의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1184">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="43a34-1185">완료를 기다리는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1185">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="43a34-1186">제공된 작업을 모두 완료했을 때 완료할 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1186">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="43a34-1187">제공된 한 작업의 완료를 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1187">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="43a34-1188">반환 작업의 결과는 완료된 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1188">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1189">경우에 반환 된 작업이 완료 됩니다 제공 된 작업을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1189">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="43a34-1190">반환된 된 작업 결과 완료 하려면 첫 번째 작업 집합을 사용 하 여 RanToCompletion 상태의 항상 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1190">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="43a34-1191">첫 번째 작업이 완료 되기를 Canceled 또는 Faulted 상태에서 종료 하는 경우에 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1191">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43a34-1192"><paramref name="tasks" /> 인수가 null인 경우</span><span class="sxs-lookup"><span data-stu-id="43a34-1192">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43a34-1193">null 작업이 포함되었거나 비어 있는 <paramref name="tasks" /> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1193">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43a34-1194">대기할 때 현재 컨텍스트로 비동기적으로 전환되는 awaitable 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1194">Creates an awaitable task that asynchronously yields back to the current context when awaited.</span></span></summary>
        <returns><span data-ttu-id="43a34-1195">대기할 때 대기 시의 현재 컨텍스트로 비동기적으로 전환될 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1195">A context that, when awaited, will asynchronously transition back into the current context at the time of the await.</span></span> <span data-ttu-id="43a34-1196">현재 <see cref="T:System.Threading.SynchronizationContext" />가 null이 아닌 경우 현재 컨텍스트로 취급됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1196">If the current <see cref="T:System.Threading.SynchronizationContext" /> is non-null, it is treated as the current context.</span></span> <span data-ttu-id="43a34-1197">그렇지 않으면 현재 실행 중인 작업과 관련된 작업 스케줄러를 현재 컨텍스트로 취급 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1197">Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43a34-1198">사용할 수 있습니다 `await Task.Yield();` 비동기 메서드에서 메서드가 비동기적으로 완료 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1198">You can use `await Task.Yield();` in an asynchronous method to force the method to complete asynchronously.</span></span> <span data-ttu-id="43a34-1199">현재 동기화 컨텍스트가 없는 경우 (<xref:System.Threading.SynchronizationContext> 개체),이를 해당 컨텍스트로 메서드의 실행의 나머지 부분에서는 게시 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1199">If there is a current synchronization context (<xref:System.Threading.SynchronizationContext> object), this will post the remainder of the method's execution back to that context.</span></span> <span data-ttu-id="43a34-1200">그러나 컨텍스트는 보류 될 수 있는 다른 작업을 기준으로이 작업을 우선 순위를 지정 하는 방법을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1200">However, the context will decide how to prioritize this work relative to other work that may be pending.</span></span> <span data-ttu-id="43a34-1201">대부분의 UI 환경에 있는 UI 스레드에서 동기화 컨텍스트를 입력 하 고 렌더링 작업 보다 높은 컨텍스트에 게시 된 작업의 우선 순위 종종 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1201">The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work.</span></span> <span data-ttu-id="43a34-1202">이러한 이유로 의존 하지 마십시오 `await Task.Yield();` UI를 응답 가능한 상태로 유지 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="43a34-1202">For this reason, do not rely on `await Task.Yield();` to keep a UI responsive.</span></span>  <span data-ttu-id="43a34-1203">자세한 내용은 항목을 참조 하세요 [ContinueWith를 사용 하 여 유용한 추상화 설정](https://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) 에서 Parallel Programming with.NET 블로그.</span><span class="sxs-lookup"><span data-stu-id="43a34-1203">For more information, see the entry [Useful Abstractions Enabled with ContinueWith](https://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>