<Type Name="CipherMode" FullName="System.Security.Cryptography.CipherMode">
  <Metadata><Meta Name="ms.openlocfilehash" Value="29061d38d229a7a5285c4d290068c58028e78658" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56402175" /></Metadata><TypeSignature Language="C#" Value="public enum CipherMode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed CipherMode extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.CipherMode" />
  <TypeSignature Language="VB.NET" Value="Public Enum CipherMode" />
  <TypeSignature Language="C++ CLI" Value="public enum class CipherMode" />
  <TypeSignature Language="F#" Value="type CipherMode = " />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b396b-101">암호화에 사용할 블록 암호화 모드를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-101">Specifies the block cipher mode to use for encryption.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b396b-102">블록 암호화 알고리즘에는 한 번에 단일 바이트 보다는 데이터를 블록 단위로 암호화 합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-102">Block cipher algorithms encrypt data in block units, rather than a single byte at a time.</span></span> <span data-ttu-id="b396b-103">가장 일반적인 블록 크기가 8 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-103">The most common block size is 8 bytes.</span></span> <span data-ttu-id="b396b-104">각 블록은 과도 하 게 처리 하기 때문에 블록 암호화 스트림 암호화 보다 더 높은 수준의 보안을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-104">Because each block is heavily processed, block ciphers provide a higher level of security than stream ciphers.</span></span> <span data-ttu-id="b396b-105">그러나 블록 암호화 알고리즘 스트림 암호화 보다 더 느리게 실행 하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-105">However, block cipher algorithms tend to execute more slowly than stream ciphers.</span></span>  
  
 <span data-ttu-id="b396b-106">각 블록에 대해 동일한 암호화 알고리즘을 사용 하는 블록 암호화 합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-106">Block ciphers use the same encryption algorithm for each block.</span></span> <span data-ttu-id="b396b-107">이 때문에 일반 텍스트 블록을 항상 동일한 키 및 알고리즘을 사용 하 여 암호화 하는 경우 동일한 암호화 텍스트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-107">Because of this, a block of plain text will always return the same cipher text when encrypted with the same key and algorithm.</span></span> <span data-ttu-id="b396b-108">이 동작을 암호 해독에 사용할 수, 있으므로 이전 블록 암호화의 의견에 따라 암호화 프로세스를 수정 하는 암호화 모드가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-108">Because this behavior can be used to crack a cipher, cipher modes are introduced that modify the encryption process based on feedback from earlier block encryptions.</span></span> <span data-ttu-id="b396b-109">암호화 결과 단순 블록 암호화 보다 더 높은 수준의 보안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-109">The resulting encryption provides a higher level of security than a simple block encryption.</span></span>  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="b396b-110">암호화 서비스</span><span class="sxs-lookup"><span data-stu-id="b396b-110">Cryptographic Services</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="CBC">
      <MemberSignature Language="C#" Value="CBC" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode CBC = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.CBC" />
      <MemberSignature Language="VB.NET" Value="CBC" />
      <MemberSignature Language="C++ CLI" Value="CBC" />
      <MemberSignature Language="F#" Value="CBC = 1" Usage="System.Security.Cryptography.CipherMode.CBC" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b396b-111"><see langword="CBC" />(Cipher Block Chaining) 모드를 통해 피드백이 형성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-111">The Cipher Block Chaining (<see langword="CBC" />) mode introduces feedback.</span></span> <span data-ttu-id="b396b-112">일반 텍스트 블록이 암호화되기 전에 비트 배타적 OR 연산에 의해 이전 블록의 암호화 텍스트와 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-112">Before each plain text block is encrypted, it is combined with the cipher text of the previous block by a bitwise exclusive OR operation.</span></span> <span data-ttu-id="b396b-113">따라서 일반 텍스트에 여러 개의 동일한 블록이 들어 있어도 각각 다른 암호화 텍스트 블록으로 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-113">This ensures that even if the plain text contains many identical blocks, they will each encrypt to a different cipher text block.</span></span> <span data-ttu-id="b396b-114">블록이 암호화되기 전에 비트 배타적 OR 연산에 의해 초기화 벡터에 첫 번째 일반 텍스트 블록이 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-114">The initialization vector is combined with the first plain text block by a bitwise exclusive OR operation before the block is encrypted.</span></span> <span data-ttu-id="b396b-115">암호화 텍스트 블록의 한 비트라도 손상되면 대응하는 일반 텍스트 블록도 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-115">If a single bit of the cipher text block is mangled, the corresponding plain text block will also be mangled.</span></span> <span data-ttu-id="b396b-116">또한 손상된 원본 비트와 같은 위치에 있는 다음 블록의 비트도 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-116">In addition, a bit in the subsequent block, in the same position as the original mangled bit, will be mangled.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="CFB">
      <MemberSignature Language="C#" Value="CFB" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode CFB = int32(4)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.CFB" />
      <MemberSignature Language="VB.NET" Value="CFB" />
      <MemberSignature Language="C++ CLI" Value="CFB" />
      <MemberSignature Language="F#" Value="CFB = 4" Usage="System.Security.Cryptography.CipherMode.CFB" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b396b-117"><see langword="CFB" />(Cipher Feedback) 모드는 한 번에 전체 블록을 처리하지 않고 일반 텍스트를 조금씩 암호화 텍스트로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-117">The Cipher Feedback (<see langword="CFB" />) mode processes small increments of plain text into cipher text, instead of processing an entire block at a time.</span></span> <span data-ttu-id="b396b-118">이 모드는 한 블록 길이를 가지며 섹션으로 구분되는 이동 레지스터를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-118">This mode uses a shift register that is one block in length and is divided into sections.</span></span> <span data-ttu-id="b396b-119">예를 들어 블록 크기가 한 번에 1바이트씩 처리되는 8바이트이면 이동 레지스터는 여덟 개의 섹션으로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-119">For example, if the block size is 8 bytes, with one byte processed at a time, the shift register is divided into eight sections.</span></span> <span data-ttu-id="b396b-120">암호화 텍스트에서 하나의 비트가 손상되면, 하나의 일반 텍스트 비트가 손상되고 이동 레지스터도 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-120">If a bit in the cipher text is mangled, one plain text bit is mangled and the shift register is corrupted.</span></span> <span data-ttu-id="b396b-121">이로 인해 잘못된 비트가 이동 레지스터 밖으로 이동될 때까지 이어지는 일반 텍스트 비트는 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-121">This results in the next several plain text increments being mangled until the bad bit is shifted out of the shift register.</span></span> <span data-ttu-id="b396b-122">기본 피드백 크기는 알고리즘에 따라 달라질 수 있지만 일반적으로 8비트이거나 블록 크기의 비트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-122">The default feedback size can vary by algorithm, but is typically either 8 bits or the number of bits of the block size.</span></span> <span data-ttu-id="b396b-123"><see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" /> 속성을 사용하여 피드백 비트 수를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-123">You can alter the number of feedback bits by using the <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" /> property.</span></span> <span data-ttu-id="b396b-124">CFB를 지원하는 알고리즘은 이 속성을 사용하여 피드백을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-124">Algorithms that support CFB use this property to set the feedback.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="CTS">
      <MemberSignature Language="C#" Value="CTS" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode CTS = int32(5)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.CTS" />
      <MemberSignature Language="VB.NET" Value="CTS" />
      <MemberSignature Language="C++ CLI" Value="CTS" />
      <MemberSignature Language="F#" Value="CTS = 5" Usage="System.Security.Cryptography.CipherMode.CTS" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>5</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b396b-125"><see langword="CTS" />(Cipher Text Stealing) 모드는 길이 제한 없이 일반 텍스트를 처리하고 일반 텍스트와 동일한 길이를 갖는 암호화 텍스트를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-125">The Cipher Text Stealing (<see langword="CTS" />) mode handles any length of plain text and produces cipher text whose length matches the plain text length.</span></span> <span data-ttu-id="b396b-126">이 모드는 일반 텍스트의 마지막 두 블록을 제외한 모든 블록에 대해 <see langword="CBC" /> 모드와 동일하게 작동됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-126">This mode behaves like the <see langword="CBC" /> mode for all but the last two blocks of the plain text.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="ECB">
      <MemberSignature Language="C#" Value="ECB" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode ECB = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.ECB" />
      <MemberSignature Language="VB.NET" Value="ECB" />
      <MemberSignature Language="C++ CLI" Value="ECB" />
      <MemberSignature Language="F#" Value="ECB = 2" Usage="System.Security.Cryptography.CipherMode.ECB" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b396b-127"><see langword="ECB" />(Electronic Codebook) 모드는 각 블록을 개별적으로 암호화합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-127">The Electronic Codebook (<see langword="ECB" />) mode encrypts each block individually.</span></span> <span data-ttu-id="b396b-128">동일하면서 같은 메시지에 포함되어 있는 일반 텍스트의 블록이나 같은 키로 암호화된 다른 메시지에 있는 일반 텍스트의 블록이 모두 동일한 암호화 텍스트 블록으로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-128">Any blocks of plain text that are identical and in the same message, or that are in a different message encrypted with the same key, will be transformed into identical cipher text blocks.</span></span> <span data-ttu-id="b396b-129">**중요**:  이 모드를 사용하면 여러 보안 위험에 노출될 수 있으므로 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-129">**Important**:  This mode is not recommended because it opens the door for multiple security exploits.</span></span> <span data-ttu-id="b396b-130">암호화할 일반 텍스트에 반복 부분이 포함되어 있으면 암호화 텍스트를 한 번에 하나의 블록으로 쉽게 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-130">If the plain text to be encrypted contains substantial repetition, it is feasible for the cipher text to be broken one block at a time.</span></span> <span data-ttu-id="b396b-131">블록 분석을 사용하여 암호화 키를 확인할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-131">It is also possible to use block analysis to determine the encryption key.</span></span> <span data-ttu-id="b396b-132">또한 다른 사용자가 몰래 개별 블록을 대체하거나 교환할 수 있으므로 다른 시점에 몰래 블록을 스트림에 저장 및 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-132">Also, an active adversary can substitute and exchange individual blocks without detection, which allows blocks to be saved and inserted into the stream at other points without detection.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="OFB">
      <MemberSignature Language="C#" Value="OFB" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode OFB = int32(3)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.OFB" />
      <MemberSignature Language="VB.NET" Value="OFB" />
      <MemberSignature Language="C++ CLI" Value="OFB" />
      <MemberSignature Language="F#" Value="OFB = 3" Usage="System.Security.Cryptography.CipherMode.OFB" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>3</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b396b-133"><see langword="OFB" />(Output Feedback) 모드는 한 번에 전체 블록을 처리하지 않고 일반 텍스트를 조금씩 암호화 텍스트로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-133">The Output Feedback (<see langword="OFB" />) mode processes small increments of plain text into cipher text instead of processing an entire block at a time.</span></span> <span data-ttu-id="b396b-134">이 모드는 <see langword="CFB" />와 비슷하며 이동 레지스터를 채우는 방식에서만 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-134">This mode is similar to <see langword="CFB" />; the only difference between the two modes is the way that the shift register is filled.</span></span> <span data-ttu-id="b396b-135">암호화 텍스트의 한 비트가 손상되면 일반 텍스트의 해당 비트도 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-135">If a bit in the cipher text is mangled, the corresponding bit of plain text will be mangled.</span></span> <span data-ttu-id="b396b-136">그러나 암호화 텍스트에 추가 비트나 누락된 비트가 있으면 그 지점부터 일반 텍스트가 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="b396b-136">However, if there are extra or missing bits from the cipher text, the plain text will be mangled from that point on.</span></span></summary>
      </Docs>
    </Member>
  </Members>
</Type>