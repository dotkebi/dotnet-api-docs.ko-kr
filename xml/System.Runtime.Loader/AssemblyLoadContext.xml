<Type Name="AssemblyLoadContext" FullName="System.Runtime.Loader.AssemblyLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e3cdf5b1dd5217e7f54ec5ce6fcb7f581a871d9d" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58455214" /></Metadata><TypeSignature Language="C#" Value="public abstract class AssemblyLoadContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AssemblyLoadContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Loader.AssemblyLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AssemblyLoadContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyLoadContext abstract" />
  <TypeSignature Language="F#" Value="type AssemblyLoadContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Loader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="28488-101">바인딩에 대한 범위의 런타임 개념을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="28488-101">Represents the runtime's concept of a scope for binding.</span></span> <span data-ttu-id="28488-102">이 클래스는 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-102">This class is abstract.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="28488-103"><xref:System.Runtime.Loader.AssemblyLoadContext> 로드 컨텍스트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="28488-103">The <xref:System.Runtime.Loader.AssemblyLoadContext> represents a load context.</span></span> <span data-ttu-id="28488-104">개념적으로 로드 컨텍스트에 어셈블리의 집합을 잠재적으로 언로드 및 로드, 확인, 범위를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="28488-104">Conceptually, a load context creates a scope for loading, resolving, and potentially unloading a set of assemblies.</span></span>
 
 <span data-ttu-id="28488-105"><xref:System.Runtime.Loader.AssemblyLoadContext>는 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-105"><xref:System.Runtime.Loader.AssemblyLoadContext> is an abstract class.</span></span> <span data-ttu-id="28488-106"><xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> 구체적 클래스를 만드는 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-106">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> needs to be implemented to create a concrete class.</span></span>
 
 <span data-ttu-id="28488-107"><xref:System.Runtime.Loader.AssemblyLoadContext> 어셈블리 바인딩 격리를 제공 하기 위해 주로 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-107">The <xref:System.Runtime.Loader.AssemblyLoadContext> exists primarily to provide assembly binding isolation.</span></span> <span data-ttu-id="28488-108">단일 프로세스 내에서 로드 되도록 동일한 어셈블리의 여러 버전이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-108">It allows multiple versions of the same assembly to be loaded within a single process.</span></span> <span data-ttu-id="28488-109">여러 제공 하는 격리 메커니즘 대체 <xref:System.AppDomain> .NET Framework의 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="28488-109">It replaces the isolation mechanisms provided by multiple <xref:System.AppDomain> instances in the .NET Framework.</span></span>
 
 > [!NOTE]
 > <span data-ttu-id="28488-110"><xref:System.Runtime.Loader.AssemblyLoadContext> 모든 보안 기능을 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-110"><xref:System.Runtime.Loader.AssemblyLoadContext> does not provide any security features.</span></span> <span data-ttu-id="28488-111">모든 코드에는 프로세스의 전체 권한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-111">All code has full permissions of the process.</span></span>

### <a name="usage-in-the-runtime"></a><span data-ttu-id="28488-112">런타임 사용</span><span class="sxs-lookup"><span data-stu-id="28488-112">Usage in the runtime</span></span>
 <span data-ttu-id="28488-113">런타임은 두 어셈블리 로드 컨텍스트를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-113">The runtime implements two assembly load contexts:</span></span>
 * <span data-ttu-id="28488-114"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 응용 프로그램 주 어셈블리 및 해당 정적 종속성에 사용 되는 런타임의 기본 바인딩 컨텍스트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="28488-114"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> represents the runtime's default binding context which is used for the application main assembly and its static dependencies.</span></span>
 * <span data-ttu-id="28488-115">합니다 <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType> 메서드가 가장 기본적인 인스턴스화하여 로드 하는 어셈블리를 격리 <xref:System.Runtime.Loader.AssemblyLoadContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-115">The <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType> method isolates the assemblies it loads by instantiating the most basic <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="28488-116">자체의 각 어셈블리를 로드 하는 간단한 격리 구성표 있기 <xref:System.Runtime.Loader.AssemblyLoadContext> 종속성 해결 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-116">It has a simplistic isolation scheme which loads each assembly in its own <xref:System.Runtime.Loader.AssemblyLoadContext> with no dependency resolution.</span></span>
 
### <a name="application-usage"></a><span data-ttu-id="28488-117">응용 프로그램 사용</span><span class="sxs-lookup"><span data-stu-id="28488-117">Application usage</span></span>
 <span data-ttu-id="28488-118">응용 프로그램을 만들 수는 자체 <xref:System.Runtime.Loader.AssemblyLoadContext> 고급 바인딩 시나리오에 대 한 사용자 지정 솔루션을 만들려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-118">An application can create its own <xref:System.Runtime.Loader.AssemblyLoadContext> to create a custom solution for advanced binding scenarios.</span></span> <span data-ttu-id="28488-119">사용자 지정 종속성 해결 메커니즘을 정의에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="28488-119">The customization focuses on defining dependency resolution mechanisms.</span></span>
 
 <span data-ttu-id="28488-120"><xref:System.Runtime.Loader.AssemblyLoadContext> 는 관리 되는 어셈블리 확인을 구현 하려면 두 개의 확장 지점을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-120">The <xref:System.Runtime.Loader.AssemblyLoadContext> provides two extension points to implement managed assembly resolution:</span></span>
 1. <span data-ttu-id="28488-121">합니다 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> 에 대 한 첫 번째 기회를 제공 합니다 <xref:System.Runtime.Loader.AssemblyLoadContext> 어셈블리를 해결 하려면 로드 하 고 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-121">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> provides the first chance for the <xref:System.Runtime.Loader.AssemblyLoadContext> to resolve the assembly, load it and return it.</span></span> <span data-ttu-id="28488-122">경우는 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> 반환 `null`, 로더 어셈블리를 로드 하려고 합니다.는 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-122">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> returns `null`, the loader will try to load the assembly into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span>
 2. <span data-ttu-id="28488-123">경우는 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 원래 어셈블리를 확인할 수 없는 <xref:System.Runtime.Loader.AssemblyLoadContext> 어셈블리를 해결 하려면 두 번째 기회를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="28488-123">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> is unable to resolve the assembly, the original <xref:System.Runtime.Loader.AssemblyLoadContext> gets a second chance to resolve the assembly.</span></span> <span data-ttu-id="28488-124">런타임에서 발생 시키는 <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-124">The runtime raises the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.</span></span>
 
 <span data-ttu-id="28488-125">또한는 <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType> 가상 메서드는 관리 되지 않는 기본 어셈블리 해상도의 사용자 지정을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-125">Additionally the <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType> virtual method allows customization of the default unmanaged assembly resolution.</span></span> <span data-ttu-id="28488-126">기본 구현은 반환 `null`, 대부분의 시나리오에 대 한 충분 한 인 기본 검색 정책을 사용 하 여 런타임 검색 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="28488-126">The default implementation returns `null`, which causes the runtime search to use its default search policy which is sufficient for most scenarios.</span></span>

### <a name="technical-challenges"></a><span data-ttu-id="28488-127">기술적인 문제</span><span class="sxs-lookup"><span data-stu-id="28488-127">Technical challenges</span></span>
 * <span data-ttu-id="28488-128">여러 버전의 단일 프로세스에서 런타임 로드 하는 것이 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-128">It is not possible to load multiple versions of the runtime in a single process.</span></span>
     > [!CAUTION]
     > <span data-ttu-id="28488-129">여러 복사본 또는 다른 버전의 프레임 워크 어셈블리 로드 문제를 진단 하기가 어렵고 예기치 않은 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-129">Loading multiple copies or different versions of framework assemblies can lead to unexpected and hard to diagnose behavior.</span></span>
     
     > [!TIP]
     > <span data-ttu-id="28488-130">이 격리 문제를 해결 하려면 원격 및/또는 프로세스 간 통신을 사용 하 여 프로세스 경계를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-130">Use process boundaries with remoting and/or interprocess communication to solve this isolation problem.</span></span>
 
 * <span data-ttu-id="28488-131">어셈블리 로드의 타이밍 어렵게 만들 수 있습니다 테스트 및 디버깅 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-131">The timing of assembly loading can make testing and debugging difficult.</span></span> <span data-ttu-id="28488-132">어셈블리 확인 즉시 해당 종속성이 없는 일반적으로 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="28488-132">Assemblies are typically loaded without their dependencies immediately being resolved.</span></span> <span data-ttu-id="28488-133">종속성은 필요에 따라 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="28488-133">The dependencies are loaded as they are needed:</span></span>
     * <span data-ttu-id="28488-134">종속 어셈블리가 나뉩니다 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-134">When code branches into a dependent assembly.</span></span>
     * <span data-ttu-id="28488-135">경우 코드는 리소스를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-135">When code loads resources.</span></span>
     * <span data-ttu-id="28488-136">때 코드 어셈블리를 명시적으로 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-136">When code explicitly loads assemblies.</span></span>
 
 * <span data-ttu-id="28488-137">구현의 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> 있으려면 다른 버전을 허용 하도록 격리 되어야 할 수 있는 새 종속성을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-137">The implementation of <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> can add new dependencies which may need to be isolated to allow different versions to exist.</span></span> <span data-ttu-id="28488-138">가장 일반적인 구현은 기본 컨텍스트에서 이러한 종속성을 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-138">The most natural implementation would place these dependencies in the default context.</span></span> <span data-ttu-id="28488-139">신중 하 게 디자인 새 종속성을 격리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-139">Careful design can isolate the new dependencies.</span></span>
 
 * <span data-ttu-id="28488-140">바인딩 격리 프로세스를 사용 하는 형식 이름이 같은 여러 종류를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="28488-140">The binding isolation process creates multiple types with the same type name.</span></span>
     * <span data-ttu-id="28488-141">혼란 스러운 오류 메시지 해도, 예를 들어 "Foo.Foo 형식 캐스팅할 수 없는 Foo.Foo를 입력 합니다."</span><span class="sxs-lookup"><span data-stu-id="28488-141">This can lead to confusing error messages, for example "type Foo.Foo cannot be cast to type Foo.Foo."</span></span>
     * <span data-ttu-id="28488-142">격리 경계를 넘어 마샬링 trivial이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="28488-142">Marshalling across isolation boundaries is non-trivial.</span></span> <span data-ttu-id="28488-143">일반적인 솔루션만 기본 로드 컨텍스트에 로드 된 어셈블리에 정의 된 인터페이스를 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-143">A typical solution would be to use an interface defined in an assembly which is only loaded into the default load context.</span></span>
 
 ]]></format>
    </remarks>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md"><span data-ttu-id="28488-144">AssemblyLoadContext CoreCLR 디자인 문서</span><span class="sxs-lookup"><span data-stu-id="28488-144">AssemblyLoadContext CoreCLR design document</span></span></related>
    <related type="Article" href="/en-us/dotnet/standard/assembly/unloadability-howto"><span data-ttu-id="28488-145">.NET Core에서 디버그 어셈블리 unloadability 및 사용 방법</span><span class="sxs-lookup"><span data-stu-id="28488-145">How to use and debug assembly unloadability in .NET Core</span></span></related>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/unloadability.md"><span data-ttu-id="28488-146">AssemblyLoadContext unloadability 디자인 문서</span><span class="sxs-lookup"><span data-stu-id="28488-146">AssemblyLoadContext unloadability design document</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28488-147"><see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-147">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="28488-148">이 생성자는 보호되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-148">This constructor is protected.</span></span> <span data-ttu-id="28488-149">에서만 호출할 수는 <xref:System.Runtime.Loader.AssemblyLoadContext> 클래스 또는 해당 파생된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-149">It can only be called from the <xref:System.Runtime.Loader.AssemblyLoadContext> class or its derived classes.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext (bool isCollectible);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (isCollectible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext(bool isCollectible);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext isCollectible" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isCollectible" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isCollectible"><span data-ttu-id="28488-150">가비지 수집을 사용하도록 설정하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-150"><see langword="true" /> to enable garbage collection; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="28488-151">가비지 수집 사용 여부를 나타내는 값을 사용하여 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-151">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class with a value that indicates whether garbage collection is enabled.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ Default { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="28488-152">기본 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="28488-152">Gets the default <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span> <span data-ttu-id="28488-153">기본 컨텍스트에는 주 애플리케이션 어셈블리 및 해당 정적 종속성이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="28488-153">The default context contains the main application assembly and its static dependencies.</span></span></summary>
        <value><span data-ttu-id="28488-154">기본 어셈블리 로드 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-154">The default assembly load context.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyPath As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="28488-155">어셈블리에 대한 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-155">The path to the assembly.</span></span></param>
        <summary><span data-ttu-id="28488-156">어셈블리 경로에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="28488-156">Gets an <see cref="T:System.Reflection.AssemblyName" /> for an assembly path.</span></span></summary>
        <returns><span data-ttu-id="28488-157"><paramref name="assemblyPath" />에서 어셈블리에 대해 완전히 구문 분석된 어셈블리 이름을 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-157">An object that contains the fully parsed assembly name for the assembly at <paramref name="assemblyPath" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="28488-158"><paramref name="assemblyPath" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-158"><paramref name="assemblyPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="28488-159">어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-159">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="28488-160">어셈블리는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-160">The assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext GetLoadContext (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Loader.AssemblyLoadContext GetLoadContext(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext ^ GetLoadContext(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetLoadContext : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.GetLoadContext assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="28488-161">어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-161">An assembly.</span></span></param>
        <summary><span data-ttu-id="28488-162">지정된 <see cref="T:System.Reflection.Assembly" />를 포함하는 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-162">Gets the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> containing the specified <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="28488-163"><paramref name="assembly" />를 포함하는 어셈블리 로드 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-163">The assembly load context containing the <paramref name="assembly" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="28488-164"><paramref name="assembly" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-164"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="28488-165">이 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />가 수집 가능한지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="28488-165">Gets a value that indicates whether this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible.</span></span></summary>
        <value><span data-ttu-id="28488-166"><see langword="true" /> 이 경우 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 이 고, 그렇지 않으면 수집 가능한 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-166"><see langword="true" /> if this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="28488-167">생성자에서 값을 지정 하지 않으면이 값은 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-167">If a value is not specified in the constructor, the value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="28488-168">자세한 내용은 참조 <see href="/en-us/dotnet/standard/assembly/unloadability-howto">사용 하 여.NET Core에서 unloadability 어셈블리를 디버그 하는 방법을</see>합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-168">For more information see <see href="/en-us/dotnet/standard/assembly/unloadability-howto">How to use and debug assembly unloadability in .NET Core</see>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="28488-169">로드될 어셈블리를 설명하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-169">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="28488-170">파생된 클래스에서 재정의될 때 해당 <see cref="T:System.Reflection.AssemblyName" />에 따라 어셈블리를 확인하고 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-170">When overridden in a derived class, allows an assembly to be resolved and loaded based on its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="28488-171">로드된 어셈블리 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-171">The loaded assembly, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks
 <span data-ttu-id="28488-172">어셈블리 확인 동안는 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> 메서드가 첫 번째 로드 된 어셈블리에서 어셈블리 이름을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-172">During assembly resolution, the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> method has the first chance to resolve the assembly name to a loaded assembly.</span></span> <span data-ttu-id="28488-173">어셈블리를 로드 하거나 반환 하기 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-173">It can either load an assembly or return `null`.</span></span> <span data-ttu-id="28488-174">반환 하는 경우 `null`, 확인 프로세스를 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-174">If it returns `null`, the resolution process continues.</span></span> <span data-ttu-id="28488-175">참조 <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> 전체 프로세스가 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-175">See <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> for the full process description.</span></span>
 
 > [!IMPORTANT]
 > <span data-ttu-id="28488-176">재귀 스택 오버플로 방지 하려면이 인스턴스의 호출 하지 마십시오 <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> 이 메서드에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="28488-176">To prevent recursive stack overflow, do not call this instance's <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> method from this method.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="28488-177">로드할 어셈블리를 설명하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-177">The object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="28488-178">해당 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 확인하고 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-178">Resolves and loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="28488-179">로드된 어셈블리 또는 throw입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-179">The loaded assembly, or throws.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="28488-180"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> 확인 하 여 어셈블리를 로드 합니다 <xref:System.Reflection.AssemblyName>합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-180"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> loads an assembly by resolving the <xref:System.Reflection.AssemblyName>.</span></span> <span data-ttu-id="28488-181">이렇게 하면 전체 해상도 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="28488-181">This triggers a full resolution.</span></span> <span data-ttu-id="28488-182">해상도 대체 시퀀스는이 프로세스를 따릅니다. 1.</span><span class="sxs-lookup"><span data-stu-id="28488-182">The resolution fallback sequence follows this process: 1.</span></span> <span data-ttu-id="28488-183">메서드 호출 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-183">The method calls <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>.</span></span>
         > [!IMPORTANT]
         > <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> must not call this method to prevent recursive stack overflow.
     2. Unless the assembly is loaded or an exception is thrown, the method attempts to load the assembly in the default <xref:System.Runtime.Loader.AssemblyLoadContext>.
     3. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.
     4. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.AppDomain.AssemblyResolve> event.
 
 > [!NOTE]
 > <span data-ttu-id="28488-184"><xref:System.IO.FileLoadException> 이 throw `assemblyRef` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 호환 되지 않는 버전 또는 문화권을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-184"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a incompatible version or culture.</span></span> <span data-ttu-id="28488-185">로더는 간단한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-185">The loader does not continue probing for other assemblies that match the simple name.</span></span>
 
 <span data-ttu-id="28488-186">각 <xref:System.Runtime.Loader.AssemblyLoadContext> 만 로드할 수 있습니다. \*를 실행 하는 어셈블리의 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-186">Each <xref:System.Runtime.Loader.AssemblyLoadContext> can load only: \* One version of an executable assembly.</span></span>
<span data-ttu-id="28488-187">\* 각 문화권에 대 한 위성 어셈블리의 버전 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-187">\* One version of a satellite assembly for each culture.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="28488-188"><paramref name="assemblyName" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-188"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="28488-189"><paramref name="assemblyName" />가 없는 경우</span><span class="sxs-lookup"><span data-stu-id="28488-189"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="28488-190"><paramref name="assemblyName" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-190"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="28488-191"><paramref name="assemblyName" />과 일치하지 않는 어셈블리 또는 모듈이 로드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-191">An assembly or module was loaded which did not match the <paramref name="assemblyName" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="28488-192">로드할 파일의 정규화된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-192">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="28488-193">지정된 경로에 있는 어셈블리 파일의 내용을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-193">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="28488-194">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-194">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="28488-195"><paramref name="assemblyPath" /> 인수가 절대 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-195">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="28488-196"><paramref name="assemblyPath" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="28488-196">The <paramref name="assemblyPath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="28488-197">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-197">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="28488-198"><paramref name="assemblyPath" /> 매개 변수가 빈 문자열("")이거나 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-198">The <paramref name="assemblyPath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="28488-199"><paramref name="assemblyPath" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-199"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromNativeImagePath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromNativeImagePath (string nativeImagePath, string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromNativeImagePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromNativeImagePath (nativeImagePath As String, assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromNativeImagePath(System::String ^ nativeImagePath, System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromNativeImagePath : string * string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromNativeImagePath (nativeImagePath, assemblyPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeImagePath" Type="System.String" />
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nativeImagePath"><span data-ttu-id="28488-200">로드할 파일의 정규화된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-200">The fully qualified path of the file to load.</span></span></param>
        <param name="assemblyPath"><span data-ttu-id="28488-201">로드할 IL 버전 파일의 정규화된 경로 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-201">The fully qualified path of the IL version of the file to load, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="28488-202">지정된 경로에서 관리 어셈블리 파일의 네이티브 이미지 콘텐츠를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-202">Loads the contents of the native image of a managed assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="28488-203">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-203">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="28488-204">관리 되는 어셈블리의 네이티브 이미지는 특정 플랫폼에서 실행을 최적화 하도록 prejit입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-204">The native image of a managed assembly is pre-jitted to optimize running on a specific platform.</span></span>
 
 <span data-ttu-id="28488-205">어셈블리 경로 어셈블리의 IL 버전에 대 한 경로 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="28488-205">The assembly path refers to the path to the IL version of the assembly.</span></span> <span data-ttu-id="28488-206">IL은 일반적으로 네이티브 이미지에 포함 된 형태로 선택적 인수를입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-206">It is an optional argument as the IL is typically included in the native image.</span></span> <span data-ttu-id="28488-207">이 경우 사용할 수 있습니다 런타임에서 대체 방법으로 네이티브 이미지를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-207">It can be used by the runtime as a fallback if the native image is not found.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="28488-208"><paramref name="nativeImagePath" /> 인수가 절대 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-208">The <paramref name="nativeImagePath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="28488-209"><paramref name="assemblyPath" /> 인수가 절대 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-209">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="28488-210"><paramref name="nativeImagePath" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="28488-210">The <paramref name="nativeImagePath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="28488-211">찾은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-211">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="28488-212"><paramref name="nativeImagePath" /> 매개 변수가 빈 문자열("")이거나 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-212">The <paramref name="nativeImagePath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="28488-213"><paramref name="assemblyPath" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-213"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="28488-214">관리 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-214">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <summary><span data-ttu-id="28488-215">관리 어셈블리가 포함된 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-215">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly.</span></span></summary>
        <returns><span data-ttu-id="28488-216">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-216">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="28488-217"><paramref name="assembly" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-217"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="28488-218"><paramref name="assembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-218"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly, System.IO.Stream assemblySymbols);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly, class System.IO.Stream assemblySymbols) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly, System::IO::Stream ^ assemblySymbols);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream * System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream (assembly, assemblySymbols)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
        <Parameter Name="assemblySymbols" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="28488-219">관리 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-219">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <param name="assemblySymbols"><span data-ttu-id="28488-220">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-220">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="28488-221">관리 어셈블리가 포함되고 경우에 따라 어셈블리에 대한 기호가 포함되는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-221">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly, optionally including symbols for the assembly.</span></span></summary>
        <returns><span data-ttu-id="28488-222">로드된 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-222">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="28488-223"><paramref name="assembly" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-223"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="28488-224"><paramref name="assembly" />는 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-224"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDll">
      <MemberSignature Language="C#" Value="protected virtual IntPtr LoadUnmanagedDll (string unmanagedDllName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int LoadUnmanagedDll(string unmanagedDllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadUnmanagedDll (unmanagedDllName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr LoadUnmanagedDll(System::String ^ unmanagedDllName);" />
      <MemberSignature Language="F#" Value="abstract member LoadUnmanagedDll : string -&gt; nativeint&#xA;override this.LoadUnmanagedDll : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDll unmanagedDllName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllName"><span data-ttu-id="28488-225">관리되지 않는 라이브러리의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-225">Name of the unmanaged library.</span></span> <span data-ttu-id="28488-226">일반적으로 해당 경로 또는 확장명이 없는 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-226">Typically this is the filename without its path or extensions.</span></span></param>
        <summary><span data-ttu-id="28488-227">파생된 클래스가 이름별로 관리되지 않는 라이브러리를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-227">Allows derived class to load an unmanaged library by name.</span></span></summary>
        <returns><span data-ttu-id="28488-228">로드된 라이브러리에 대한 핸들 또는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-228">A handle to the loaded library, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="28488-229">기본 구현은 항상 반환 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-229">The default implementation always return `null`.</span></span> <span data-ttu-id="28488-230">때 `null` 반환 되 면 런타임에서 기본 정책 사용 하 여 라이브러리를 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-230">When `null` is returned, the runtime loads the library with its default policy.</span></span>
 
 <span data-ttu-id="28488-231">관리 되지 않는 라이브러리 검색 알고리즘을 사용자 지정 하려면이 가상 메서드를 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-231">This virtual method can be overridden to customize the unmanaged library search algorithm.</span></span> <span data-ttu-id="28488-232">재정의 된 경우 해당 라이브러리를 식별 하는 이름을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-232">When overridden the name can be used to identify the library.</span></span> <span data-ttu-id="28488-233">로드 된 라이브러리는 요청 된 일치 하지 않아도 이름은 같지만 필요에 따라 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-233">The loaded library does not need to match the requested name, but can be transformed as needed.</span></span> <span data-ttu-id="28488-234">이 플랫폼 특정 명명에 대 한 이름을 조정 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-234">This could include adjusting the name for platform specific naming.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDllFromPath">
      <MemberSignature Language="C#" Value="protected IntPtr LoadUnmanagedDllFromPath (string unmanagedDllPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance native int LoadUnmanagedDllFromPath(string unmanagedDllPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDllFromPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function LoadUnmanagedDllFromPath (unmanagedDllPath As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IntPtr LoadUnmanagedDllFromPath(System::String ^ unmanagedDllPath);" />
      <MemberSignature Language="F#" Value="member this.LoadUnmanagedDllFromPath : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDllFromPath unmanagedDllPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllPath"><span data-ttu-id="28488-235">관리되지 않는 라이브러리의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-235">The path to the unmanaged library.</span></span></param>
        <summary><span data-ttu-id="28488-236">지정된 경로에서 관리되지 않는 라이브러리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-236">Loads an unmanaged library from the specified path.</span></span></summary>
        <returns><span data-ttu-id="28488-237">로드된 라이브러리에 대한 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-237">A handle to the loaded library.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="28488-238"><paramref name="unmanagedDllPath" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="28488-238"><paramref name="unmanagedDllPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="28488-239"><paramref name="unmanagedDllPath" /> 인수가 절대 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28488-239">The <paramref name="unmanagedDllPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="28488-240">관리되지 않는 라이브러리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-240">The unmanaged library cannot be found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Resolving">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt; Resolving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Runtime.Loader.AssemblyLoadContext, class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; Resolving" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Resolving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Runtime::Loader::AssemblyLoadContext ^, System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ Resolving;" />
      <MemberSignature Language="F#" Value="member this.Resolving : Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " Usage="member this.Resolving : System.Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="28488-241">이 어셈블리 로드 컨텍스트에 로드하려고 할 때 어셈블리를 확인하는 데 실패하는 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-241">Occurs when the resolution of an assembly fails when attempting to load into this assembly load context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="28488-242">지정 된 어셈블리를 반환 하거나 반환 하려면이 이벤트 처리기의 책임이 `null` 어셈블리 인식 되지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="28488-242">It is the responsibility of the handler for this event to return the assembly that is specified, or to return `null` if the assembly is not recognized.</span></span>
 
 > [!IMPORTANT]
 >  <span data-ttu-id="28488-243">둘 이상의 이벤트 처리기는이 이벤트에 대 한 등록 되 면 이벤트 처리기를 이벤트 처리기에 없는 값 반환 될 때까지 순서 대로 호출 됩니다 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-243">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="28488-244">후속 이벤트 처리기는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="28488-244">Subsequent event handlers are ignored.</span></span>
 
 <span data-ttu-id="28488-245">이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="28488-245">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>
 
 <span data-ttu-id="28488-246">이 이벤트에 대 한 처리기를 추가할 수는 주목할 만한 것 <xref:System.Runtime.Loader.AssemblyLoadContext>, 기본 컨텍스트를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-246">It is noteworthy that a handler can be added for this event on any <xref:System.Runtime.Loader.AssemblyLoadContext>, including the default context.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvingUnmanagedDll">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Reflection.Assembly,string,IntPtr&gt; ResolvingUnmanagedDll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Reflection.Assembly, string, native int&gt; ResolvingUnmanagedDll" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.ResolvingUnmanagedDll" />
      <MemberSignature Language="VB.NET" Value="Public Event ResolvingUnmanagedDll As Func(Of Assembly, String, IntPtr) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Reflection::Assembly ^, System::String ^, IntPtr&gt; ^ ResolvingUnmanagedDll;" />
      <MemberSignature Language="F#" Value="member this.ResolvingUnmanagedDll : Func&lt;System.Reflection.Assembly, string, nativeint&gt; " Usage="member this.ResolvingUnmanagedDll : System.Func&lt;System.Reflection.Assembly, System.string, System.nativeint&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Reflection.Assembly,System.String,System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProfileOptimizationRoot">
      <MemberSignature Language="C#" Value="public void SetProfileOptimizationRoot (string directoryPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetProfileOptimizationRoot(string directoryPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.SetProfileOptimizationRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetProfileOptimizationRoot (directoryPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetProfileOptimizationRoot(System::String ^ directoryPath);" />
      <MemberSignature Language="F#" Value="member this.SetProfileOptimizationRoot : string -&gt; unit" Usage="assemblyLoadContext.SetProfileOptimizationRoot directoryPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directoryPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directoryPath">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProfileOptimization">
      <MemberSignature Language="C#" Value="public void StartProfileOptimization (string profile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartProfileOptimization(string profile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.StartProfileOptimization(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartProfileOptimization (profile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartProfileOptimization(System::String ^ profile);" />
      <MemberSignature Language="F#" Value="member this.StartProfileOptimization : string -&gt; unit" Usage="assemblyLoadContext.StartProfileOptimization profile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="profile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="profile">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="assemblyLoadContext.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="28488-247">이 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />의 언로드를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-247">Initiates an unload of this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

+ <span data-ttu-id="28488-248">AssemblyLoadContext만 언로드할 수 수집 가능한 경우.</span><span class="sxs-lookup"><span data-stu-id="28488-248">An AssemblyLoadContext can only be unloaded if it is collectible.</span></span>
+ <span data-ttu-id="28488-249">언로드 비동기적으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="28488-249">Unloading will occur asynchronously.</span></span>
+ <span data-ttu-id="28488-250">언로드를 AssemblyLoadContext에 대 한 참조가 하는 동안 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-250">Unloading will not occur while there are references to the AssemblyLoadContext.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="28488-251">언로드가 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="28488-251">Unloading is not allowed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; Unloading" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloading As Action(Of AssemblyLoadContext) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Action&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " Usage="member this.Unloading : System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="28488-252"><see cref="T:System.Runtime.Loader.AssemblyLoadContext" />를 언로드하는 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="28488-252">Occurs when the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is unloaded.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>