<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="da5dc35ec340c9b7b1c4afd38e9a57afce3acb49" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58719286" /></Metadata><TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="2db76-101">복소수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-101">Represents a complex number.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-102">복소수는 실수 부분과 허수 부분이 구성 하는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="2db76-103">복소수 z z 형태로 일반적으로 기록 됩니다 = x + yi, 여기서 *x* 및 *y* 실수에는 및 *합니까* 는 속성이 있는 허수 단위 *i* <sup>2</sup> =-1입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="2db76-104">복소수의 실수 부분으로 표시 됩니다 *x*, 및 복소수의 허수 부분으로 나타납니다. *y*합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="2db76-105"><xref:System.Numerics.Complex> 데카르트 좌표계 (real의 경우 허수부)을 사용 하 여 형식을 인스턴스화하고 복소수를 조작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="2db76-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="2db76-106">복소수의 복합 평면의 이라고 하는 2 차원 좌표 시스템에서는 지점으로 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="2db76-107">복소수의 실수 부분을 x 축 (가로 축)에 놓이고 허수 부분을 y 축 (세로 축)에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="2db76-108">복합 평면에서 든 지 값을 기준으로 절대, 극좌표 형 좌표계를 사용 하 여 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system.</span></span> <span data-ttu-id="2db76-109">극좌표 형 좌표로 지점은 두 숫자의 특징은:</span><span class="sxs-lookup"><span data-stu-id="2db76-109">In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="2db76-110">원본에서 요소의 거리는 해당 크기 (즉, 0, 0, 또는 x 축 및 y 축 교차 하는 지점)입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-110">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="2db76-111">단계는 실수 축을 지점 원본에서 그린 선 사이의 각도입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-111">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="2db76-112">복소수의 인스턴스화</span><span class="sxs-lookup"><span data-stu-id="2db76-112">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="2db76-113">다음 방법 중 하나를 복소수로 값을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-113">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="2db76-114">두 개를 전달 하 여 <xref:System.Double> 생성자에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-114">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="2db76-115">첫 번째 값은 복소수의 실수부를 나타내고 두 번째 값의 허수 부분을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-115">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="2db76-116">이러한 값 2 차원 데카르트 좌표계에 복잡 한 수의 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-116">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="2db76-117">정적 호출 하 여 (`Shared` Visual Basic에서) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> 극좌표에서 복소수를 만드는 방법.</span><span class="sxs-lookup"><span data-stu-id="2db76-117">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="2db76-118">할당 하 여는 <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, 또는 <xref:System.Double> 값을 <xref:System.Numerics.Complex> 개체.</span><span class="sxs-lookup"><span data-stu-id="2db76-118">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="2db76-119">값은 복소수의 실수부 되며 허수 부분에는 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-119">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="2db76-120">캐스팅 (C#) 또는 변환 (Visual Basic)를 <xref:System.Decimal> 또는 <xref:System.Numerics.BigInteger> 값을 <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-120">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="2db76-121">값은 복소수의 실수부 되며 허수 부분에는 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-121">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="2db76-122">메서드 또는 연산자에서 반환 되는 복소수를 할당 하 여를 <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-122">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="2db76-123">예를 들어 <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> 합계인 두 복소수는 복소수를 반환 하는 정적 메서드는 및 <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> 두 복소수를 더 추가 하 고 결과 반환 하는 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-123">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="2db76-124">다음 예제에서는 각 복소수에 값을 할당 하는 5 가지를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-124">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="2db76-125">복소수를 사용 하 여 작업</span><span class="sxs-lookup"><span data-stu-id="2db76-125">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="2db76-126"><xref:System.Numerics.Complex> .NET Framework의 구조는 다음과 같은 기능을 제공 하는 멤버를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-126">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="2db76-127">두 복소수가 같은지 여부를 비교 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-127">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="2db76-128">복소수에서 산술 연산을 수행 하는 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-128">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="2db76-129"><xref:System.Numerics.Complex> 연산자를 사용 하 여 더하기, 빼기, 곱하기, 나누기 및 단항 부정 연산자 복소수를 사용 하 여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-129"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="2db76-130">복소수에 숫자 다른 작업을 수행 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-130">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="2db76-131">네 개의 기본 산술 연산자 외에도 지정 된 거듭제곱 복소수의 복합 숫자의 제곱근을 구합니다를 복소수의 절대 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-131">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="2db76-132">복소수에서 삼각 연산을 수행 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-132">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="2db76-133">예를 들어, 복소수를 나타내는 각도의 탄젠트를 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-133">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="2db76-134">때문에 합니다 <xref:System.Numerics.Complex.Real%2A> 하 고 <xref:System.Numerics.Complex.Imaginary%2A> 속성은 읽기 전용, 기존 값을 수정할 수 없습니다. <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-134">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="2db76-135">작업을 수행 하는 모든 메서드는 <xref:System.Numerics.Complex> 반환 값 형식인 경우 숫자 <xref:System.Numerics.Complex>, 새 반환 <xref:System.Numerics.Complex> 수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-135">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="2db76-136">전체 자릿수와 복소수</span><span class="sxs-lookup"><span data-stu-id="2db76-136">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="2db76-137">복소수의 실수와 허수 부분 두 배정밀도 부동 소수점 값으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-137">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="2db76-138">즉 <xref:System.Numerics.Complex> 배정밀도 부동 소수점 값을 같은 값을 숫자 작업의 결과로 정밀도 떨어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-138">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="2db76-139">이 엄격한 의미의 같음 비교 <xref:System.Numerics.Complex> 값 정밀도 손실로 인해 두 값 간의 차이점은 경우에 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-139">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="2db76-140">자세한 내용은 <xref:System.Double>를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="2db76-140">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="2db76-141">예를 들어, 숫자의 로그에 지 수 연산을 수행 원본 수를 반환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-141">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="2db76-142">그러나 경우에 따라 부동 소수점 값의 정밀도 손실이 발생할 수 있습니다 두 값 간에 약간의 차이가 다음 예제와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-142">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="2db76-143">마찬가지로, 다음 예제에서는의 제곱근을 계산 하는 한 <xref:System.Numerics.Complex> 번호, 32 비트 및 IA64 버전의.NET Framework에서 약간 다른 결과 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-143">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="2db76-144">복소수, 무한대 및 NaN</span><span class="sxs-lookup"><span data-stu-id="2db76-144">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="2db76-145">복소수의 실수와 허수 부분으로 표시 됩니다 <xref:System.Double> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-145">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="2db76-146">이르는 하는 것 외에도 <xref:System.Double.MinValue?displayProperty=nameWithType> 하 <xref:System.Double.MaxValue?displayProperty=nameWithType>, 또는 허수 부분 복소수 값을 가질 수 있습니다 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-146">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2db76-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>를 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 및 <xref:System.Double.NaN?displayProperty=nameWithType> 모두 산술 또는 삼각 작업에 전파 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="2db76-148">다음 예에서 나누기 <xref:System.Numerics.Complex.Zero> 복소수의 실수부와 허수부 둘 다 생성 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-148">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2db76-149">결과적으로,이 값을 사용 하 여 곱하기를 수행 합니다. 또한 생성 복소수의 실수부와 허수부는 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-149">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2db76-150">마찬가지로, 범위를 오버플로 하는 곱하기를 수행 합니다 <xref:System.Double> 복소수의 실수부를 생성 하는 형식 <xref:System.Double.NaN?displayProperty=nameWithType> 허수부 이며 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-150">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2db76-151">복소수의 실수부 반환 이후에이 복소수와 나누기를 수행 <xref:System.Double.NaN?displayProperty=nameWithType> 허수부 이며 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-151">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="2db76-152">잘못 된 또는 범위를 오버플로 하는 복소수를 사용 하 여 수학 연산을 <xref:System.Double> 데이터 형식 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-152">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="2db76-153">대신, 반환 된 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType> 다음 조건:</span><span class="sxs-lookup"><span data-stu-id="2db76-153">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="2db76-154">0 반환 하 여 양수의 나누기 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-154">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="2db76-155">상한을 오버플로 하는 모든 작업은 <xref:System.Double> 데이터 형식 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-155">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="2db76-156">음수를 0 개 반환의 나누기 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-156">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="2db76-157">하 한 범위를 오버플로 하는 모든 작업은 <xref:System.Double> 데이터 형식 반환 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-157">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="2db76-158">0으로 나누기 반환 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-158">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="2db76-159">해당 값은 피연산자에 대해 수행 되는 모든 작업 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType> 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>에 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 또는 <xref:System.Double.NaN?displayProperty=nameWithType>특정 작업에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-159">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="2db76-160">메서드에 의해 수행 된 모든 중간 계산에 적용 되도록이 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-160">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="2db76-161">예를 들어, 곱하기가 `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` 수식을 사용 (ac-bd) + (ad + bc) i.</span><span class="sxs-lookup"><span data-stu-id="2db76-161">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="2db76-162">곱하기의 결과 실수 구성 요소에 대 한 계산 식 9e308 평가 \* 2.5-9e308 \* 3.5.</span><span class="sxs-lookup"><span data-stu-id="2db76-162">The calculation of the real component that results from the multiplication evaluates the expression 9e308 \* 2.5 - 9e308 \* 3.5.</span></span> <span data-ttu-id="2db76-163">이 식의 각 중간 곱하기 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, 및 뺄 시도 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 에서 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 반환 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-163">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="2db76-164">복합 숫자의 서식을 지정</span><span class="sxs-lookup"><span data-stu-id="2db76-164">Formatting a Complex Number</span></span>  
 <span data-ttu-id="2db76-165">기본적으로 복합 숫자의 문자열 표현 형식은 `(` *real* `,` *허수*`)`여기서 *실제* 및 *허수* 의 문자열 표현은 <xref:System.Double> 복소수의 실수와 허수 구성 요소를 구성 하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-165">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="2db76-166">일부 오버 로드는 <xref:System.Numerics.Complex.ToString%2A> 메서드 다음의 문자열 표현 사용자 지정할 수 있도록 <xref:System.Double> 값을 특정 문화권의 서식 규칙을 반영 하거나 표준 또는 사용자 지정 숫자를 정의한 특정 형식으로 표시 서식 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-166">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="2db76-167">(자세한 내용은 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="2db76-167">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="2db76-168">복합 숫자의 문자열 표현을 표현 하는 일반적인 방법 중 하나는 a + bi 여기서는 복소수의 실수 구성 요소 이며 b 복소수의 허수 구성 요소.</span><span class="sxs-lookup"><span data-stu-id="2db76-168">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="2db76-169">전기공학, 복소수 일반적으로 표시 되는 + bj 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-169">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="2db76-170">이러한 두 형식 중 하나에서 복합 숫자의 문자열 표현을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-170">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="2db76-171">이 위해 사용자 지정 형식 공급자를 구현 하 여 정의 합니다 <xref:System.ICustomFormatter> 및 <xref:System.IFormatProvider> 인터페이스 및 다음 호출을 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-171">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2db76-172">다음 예제에서는 정의 `ComplexFormatter` 중 하나의 형식인 문자열로 복소수를 나타내는 클래스 a + bi 또는 + bj 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-172">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="2db76-173">다음 예제에서는 다음이 사용자 지정 포맷터를 사용 하 여 복합 숫자의 문자열 표현을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-173">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real"><span data-ttu-id="2db76-174">복소수의 실수 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-174">The real part of the complex number.</span></span></param>
        <param name="imaginary"><span data-ttu-id="2db76-175">복소수의 허수 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-175">The imaginary part of the complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-176">지정된 실수 값과 허수 값을 사용하여 <see cref="T:System.Numerics.Complex" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-176">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-177">합니다 `real` 또는 `imaginary` 명시적 캐스트를 필요로 하는 데이터 형식인 경우 인수 정밀도 떨어지는 <xref:System.Double>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-177">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-178">다음 예제에서는 두 개의 복소수를 인스턴스화하고 더하기, 빼기, 곱하기 및 나누기 연산에서 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-178">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-179">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-179">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-180">복소수의 절대 값 또는 크기를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-180">Gets the absolute value (or magnitude) of a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-181"><paramref name="value" />의 절대값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-181">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-182">복소수의 절대 값은 해당 <xref:System.Numerics.Complex.Magnitude%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-182">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="2db76-183">숫자는 실수의 절대값을 + bi는 다음과 같이 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-183">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="2db76-184">경우 b = 0 이면 결과 0입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-184">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="2db76-185">경우는 > b, 결과는 \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="2db76-185">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="2db76-186">경우 b > 인 결과 b는 \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="2db76-186">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="2db76-187">절대값 계산 결과로 오버플로가 발생을 메서드 반환 하거나 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-187">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2db76-188">경우는 <xref:System.Numerics.Complex.Real%2A> 또는 <xref:System.Numerics.Complex.Imaginary%2A> 속성은 <xref:System.Double.NaN?displayProperty=nameWithType> 다른 속성은 모두 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 나 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, 메서드가 반환 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-188">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-189">다음 예제는 복소수의 절대값을 계산 하 고의 값에 해당 하는 방법을 보여 줍니다는 <xref:System.Numerics.Complex.Magnitude%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-189">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-190">코사인을 나타내는 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-190">A complex number that represents a cosine.</span></span></param>
        <summary><span data-ttu-id="2db76-191">지정된 복소수의 아크코사인인 각도를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-191">Returns the angle that is the arc cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-192"><paramref name="value" />의 아크코사인인 각도인, 라디안 단위로 측정됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-192">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-193">합니다 <xref:System.Numerics.Complex.Acos%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Acos%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-193">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="2db76-194"><xref:System.Numerics.Complex.Acos%2A> 메서드는 다음 수식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-194">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="2db76-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="2db76-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="2db76-196">다음 예제는 <xref:System.Numerics.Complex.Acos%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-196">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="2db76-197">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Acos%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Cos%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="2db76-197">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2db76-198">더할 첫 번째 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-198">The first complex number to add.</span></span></param>
        <param name="right"><span data-ttu-id="2db76-199">더할 두 번째 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-199">The second complex number to add.</span></span></param>
        <summary><span data-ttu-id="2db76-200">두 개의 복소수를 더한 후 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-200">Adds two complex numbers and returns the result.</span></span></summary>
        <returns><span data-ttu-id="2db76-201"><paramref name="left" />와 <paramref name="right" />의 합입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-201">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-202">복잡 한 추가 a + bi, 번호 및 두 번째 복소수, c + di를 다음 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-202">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="2db76-203">(a + c) + (b + d) i.</span><span class="sxs-lookup"><span data-stu-id="2db76-203">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="2db76-204">요소의 값은 메서드 호출 결과 또는 허수 구성 요소에서 오버플로가 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-204">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2db76-205">사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.Complex.Add%2A> 복소수를 사용 하 여 추가 수행 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-205">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-206">다음 예제에서는 복소수를 사용 하 여 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-206">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-207">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-207">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-208">지정된 복소수의 아크사인인 각도를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-208">Returns the angle that is the arc sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-209"><paramref name="value" />의 아크사인인 각도입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-209">The angle which is the arc sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-210">합니다 <xref:System.Numerics.Complex.Asin%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Asin%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-210">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="2db76-211"><xref:System.Numerics.Complex.Asin%2A> 메서드는 다음 수식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-211">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="2db76-212">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* 값 + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -값 \* 값))</span><span class="sxs-lookup"><span data-stu-id="2db76-212">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="2db76-213">다음 예제는 <xref:System.Numerics.Complex.Asin%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-213">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="2db76-214">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Asin%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Sin%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="2db76-214">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-215">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-215">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-216">지정된 복소수의 아크탄젠트인 각도를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-216">Returns the angle that is the arc tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-217"><paramref name="value" />의 아크탄젠트인 각도입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-217">The angle that is the arc tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-218">합니다 <xref:System.Numerics.Complex.Atan%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Atan%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-218">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="2db76-219"><xref:System.Numerics.Complex.Atan%2A> 메서드는 다음 수식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-219">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="2db76-220">(<xref:System.Numerics.Complex.ImaginaryOne> / 새 복합 (2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* 값)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* 값))</span><span class="sxs-lookup"><span data-stu-id="2db76-220">(<xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value))</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="2db76-221">다음 예제는 <xref:System.Numerics.Complex.Atan%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-221">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="2db76-222">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Atan%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Tan%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="2db76-222">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-223">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-223">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-224">복소수의 켤레 복소수를 계산한 후 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-224">Computes the conjugate of a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="2db76-225"><paramref name="value" />의 켤레 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-225">The conjugate of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-226">복소수의 켤레 복소수 허수 구성 요소 부호 반전 즉, 허수 구성 요소에 단항 부정 연산자를 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-226">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="2db76-227">경우는 + bi는 복소수의 켤레 복소수는, a – bi 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-227">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-228">다음 예제에서는 두 복소수의 켤레 복소수를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-228">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-229">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-229">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-230">지정된 복소수의 코사인을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-230">Returns the cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-231"><paramref name="value" />의 코사인입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-231">The cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-232">합니다 <xref:System.Numerics.Complex.Cos%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Cos%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-232">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="2db76-233"><xref:System.Numerics.Complex.Cos%2A> 메서드 다음 수식을 사용 하 여 복소수의 코사인을 계산 a + bi:</span><span class="sxs-lookup"><span data-stu-id="2db76-233">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="2db76-234">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="2db76-234">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-235">다음 예제는 <xref:System.Numerics.Complex.Acos%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-235">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="2db76-236">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Acos%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Cos%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="2db76-236">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-237">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-237">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-238">지정된 복소수의 하이퍼볼릭 코사인을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-238">Returns the hyperbolic cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-239"><paramref name="value" />의 쌍곡선 코사인입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-239">The hyperbolic cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-240">합니다 <xref:System.Numerics.Complex.Cosh%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Cosh%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-240">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="2db76-241"><xref:System.Numerics.Complex.Cosh%2A> 메서드는 다음 수식을 사용 하 여 복소수의 쌍 곡 코사인을 계산 a + bi:</span><span class="sxs-lookup"><span data-stu-id="2db76-241">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="2db76-242">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="2db76-242">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (double dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(float64 dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Double, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(double dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="dividend">To be added.</param>
        <param name="divisor">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, double divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, float64 divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, double divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="divisor" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="dividend">To be added.</param>
        <param name="divisor">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="2db76-243">나눌 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-243">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="2db76-244">값을 나눌 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-244">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="2db76-245">한 복소수를 다른 복소수로 나눈 후 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-245">Divides one complex number by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="2db76-246">나누기의 몫입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-246">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-247">복합 숫자의 나누기를 bi, 두 번째 복소수, 수, c + di를 형식은 +:</span><span class="sxs-lookup"><span data-stu-id="2db76-247">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="2db76-248">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="2db76-248">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="2db76-249">몫의 계산 결과 또는 허수 구성 요소에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-249">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2db76-250"><xref:System.Numerics.Complex.Divide%2A> 메서드를 사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-250">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="2db76-251">해당 동작 나누기는 나누기 연산자를 사용 하는 것과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-251">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-252">다음 예제에서는 복소수를 배열의 각 요소에 의해 복소수를 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-252">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2db76-253">두 복소수가 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-253">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-254">비교할 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-254">The complex number to compare.</span></span></param>
        <summary><span data-ttu-id="2db76-255">현재 인스턴스와 지정된 복소수의 값이 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-255">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span></span></summary>
        <returns><span data-ttu-id="2db76-256">이 복소수와 <paramref name="value" />가 동일한 값을 가지면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-256"><see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-257"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드를 제공 합니다 <xref:System.IEquatable%601> 구현에 대 한는 <xref:System.Numerics.Complex> 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-257">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="2db76-258">성능이 약간 보다 <xref:System.Numerics.Complex.Equals%28System.Object%29> 메서드 복소수의 매개 변수를 변환할 필요가 없기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-258">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="2db76-259">두 복소수는 해당 실수 부분도 같으면 해당 허수 부분도 동일한 경우 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-259">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="2db76-260"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드는 다음 식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-260">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="2db76-261">사용 된 <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> 메서드를 주의 해 서 되므로 두 값을 명백히 같은 간주할 수 실수 및 허수 구성 요소 정밀도 차이 같지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-261">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="2db76-262">다음 예제를 보고 하는 <c>(3.33333, 0.142857)</c> 하 고 <c>(10/3, 1/7)</c> 같지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-262">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span></span>  
  
<span data-ttu-id="2db76-263">[! 코드 csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! 코드 vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="2db76-263">[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span></span> 
<span data-ttu-id="2db76-264">하나 방법은 두 값 간의 차이 허용 가능한 여백을 정의 하는 것이 좋습니다 (같은. 값의 실수 및 허수 구성 요소 중 하나의.01%)의 값이 같은지를 비교 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-264">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="2db76-265">두 값 간의 차이의 절대값 보다 작거나 동일한 경우 차이 정밀도에 차이가 있기 때문일 가능성이 않으며, 따라서 값과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-265">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="2db76-266">다음 예에서는 같지 않은 것으로 이전 코드 예제에 있는 두 복소수 값을 비교할이 기법을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-266">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span> <span data-ttu-id="2db76-267">같아야 두 복소수를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-267">It finds the two complex numbers to be equal.</span></span>  
  
<span data-ttu-id="2db76-268">[! 코드 csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! 코드 vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="2db76-268">[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span></span></para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="2db76-269">비교할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-269">The object to compare.</span></span></param>
        <summary><span data-ttu-id="2db76-270">현재 인스턴스와 지정된 개체의 값이 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-270">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns><span data-ttu-id="2db76-271"><paramref name="obj" /> 매개 변수가 <see cref="T:System.Numerics.Complex" /> 개체이거나 <see cref="T:System.Numerics.Complex" /> 개체로 암시적 변환이 가능한 형식이고 해당 값이 현재 <see cref="T:System.Numerics.Complex" /> 개체의 값과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-271"><see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-272">두 복소수는 해당 실수 부분도 같으면 해당 허수 부분도 동일한 경우 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-272">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="2db76-273"><xref:System.Numerics.Complex.Equals%28System.Object%29> 메서드는 다음 식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-273">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="2db76-274">경우는 `obj` 매개 변수가 아닙니다를 <xref:System.Numerics.Complex> 개체를 변환 하는 암시적 변환을 정의 되는 데이터 형식이 <xref:System.Numerics.Complex.Equals%28System.Object%29> 메서드 변환 `obj` 에 <xref:System.Numerics.Complex> 실수부 의값과같은개체`obj`고 비교를 수행 하기 전에 허수 부분이 0입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-274">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="2db76-275">다음 예제에서는이 복소수와 배정밀도 부동 소수점 값이 같음을 검색 하 여 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-275">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="2db76-276">사용 된 <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> 메서드를 주의 해 서 되므로 두 값을 명백히 같은 간주할 수 실수 및 허수 구성 요소 정밀도 차이 같지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-276">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="2db76-277">문제 경우 더욱 두드러집니다 수 <paramref name="obj" /> 으로 변환 되어야 합니다는 <see cref="T:System.Double" /> 비교를 수행 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-277">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span></span> <span data-ttu-id="2db76-278">다음 예제에서는 비교 복소수의 실수 부분이 같은 것으로 표시 됩니다는 <see cref="T:System.Single" /> 값이 점을 <see cref="T:System.Single" /> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-278">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span></span> <span data-ttu-id="2db76-279">같음 비교를 반환 하는 출력에서 볼 수 있듯이 <see langword="False" />합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-279">As the output shows, the comparison for equality returns <see langword="False" />.</span></span>  
  
<span data-ttu-id="2db76-280">[! 코드 csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! 코드 vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="2db76-280">[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span></span> 
<span data-ttu-id="2db76-281">하나 방법은 두 값 간의 차이 허용 가능한 여백을 정의 하는 것이 좋습니다 (같은. 값의 실수 및 허수 구성 요소 중 하나의.01%)의 값이 같은지를 비교 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-281">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="2db76-282">두 값 간의 차이의 절대값 보다 작거나 동일한 경우 차이 정밀도에 차이가 있기 때문일 가능성이 않으며, 따라서 값과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-282">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="2db76-283">다음 예제는 이전 코드 예제에서는 서로 다른 두 값을 비교 하려면이 기술을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-283">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span> <span data-ttu-id="2db76-284">이제 같아야 하기를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-284">It now finds them to be equal.</span></span>  
  
<span data-ttu-id="2db76-285">[! 코드 csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! 코드 vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="2db76-285">[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-286">지수를 지정하는 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-286">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="2db76-287"><see langword="e" />를 복소수로 지정된 지수만큼 거듭제곱하여 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-287">Returns <see langword="e" /> raised to the power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-288"><see langword="e" />의 <paramref name="value" />승입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-288">The number <see langword="e" /> raised to the power <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-289">사용 된 <xref:System.Numerics.Complex.Pow%2A> 다른 밑의 승수를 계산 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-289">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="2db76-290">합니다 <xref:System.Numerics.Complex.Exp%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Exp%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-290">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="2db76-291"><xref:System.Numerics.Complex.Exp%2A> 역 수는 <xref:System.Numerics.Complex.Log%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-291"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-292">다음 예제는 <xref:System.Numerics.Complex.Exp%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-292">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="2db76-293">정밀도 부족에 대 한 일부 여유를 보여 줍니다는 <xref:System.Double> 데이터 형식으로 반환 하는 값을 전달 합니다 <xref:System.Numerics.Complex.Log%2A> 메서드를를 <xref:System.Numerics.Complex.Exp%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="2db76-293">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude"><span data-ttu-id="2db76-294">원점(x축과 y축의 교차점)에서 숫자까지의 거리인 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-294">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span></span></param>
        <param name="phase"><span data-ttu-id="2db76-295">선에서 가로 축까지의 각도인 위상으로서, 라디안 단위로 측정됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-295">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span></span></param>
        <summary><span data-ttu-id="2db76-296">점의 극좌표를 사용하여 복소수를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-296">Creates a complex number from a point's polar coordinates.</span></span></summary>
        <returns><span data-ttu-id="2db76-297">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-297">A complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-298"><xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드 극좌표를 기반으로 복잡 한 횟수를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-298">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="2db76-299">반환 값은 복합 평면에서 점의 여러 표현 되므로 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드 정규화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-299">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="2db76-300">크기는 양수 하도록 표준화 되 고 단계-범위의 값으로 정규화 됩니다<xref:System.Math.PI> 에 <xref:System.Math.PI>입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-300">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="2db76-301">결과적으로 값을 <xref:System.Numerics.Complex.Phase%2A> 및 <xref:System.Numerics.Complex.Magnitude%2A> 결과 복소수 속성의 원래 값을 같지 않을 수 있습니다 합니다 `magnitude` 및 `phase` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-301">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="2db76-302">에 대 한 라디안으로 각도에서 값을 변환 하는 `phase` 매개 변수를 곱합니다  <xref:System.Math.PI?displayProperty=nameWithType> /180입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-302">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-303">다음 예제에서는 합니다 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 복소수를 인스턴스화하기 위한 메서드를 극좌표를 기반으로 하며 값을 표시 한 다음 해당 <xref:System.Numerics.Complex.Magnitude%2A> 및 <xref:System.Numerics.Complex.Phase%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-303">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2db76-304">현재 <see cref="T:System.Numerics.Complex" /> 개체에 대한 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-304">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <returns><span data-ttu-id="2db76-305">부호 있는 32비트 정수 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-305">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2db76-306">현재 <see cref="T:System.Numerics.Complex" /> 개체의 허수 구성 요소를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-306">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="2db76-307">복소수의 허수 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-307">The imaginary component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-308">복소수 a + bi는 <xref:System.Numerics.Complex.Imaginary%2A> 속성 b의 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-308">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-309">다음 예제에서는의 배열을 인스턴스화하고 <xref:System.Numerics.Complex> 개체 형태로 각 실수 및 허수 구성 요소를 표시 및 a + bi 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-309">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2db76-310">0과 같은 실수와 1과 같은 허수를 포함하는 새 <see cref="T:System.Numerics.Complex" /> 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-310">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2db76-311">다음 예제에서는 한 <xref:System.Numerics.Complex> 사용 하 여 값을 <xref:System.Numerics.Complex.ImaginaryOne> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-311">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="2db76-312">그런 다음이 값을 호출 하 여 인스턴스화된 다른 값을 비교 합니다 <xref:System.Numerics.Complex> 0 실수부는 실수부와 허수부 하나를 사용 하 여 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-312">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="2db76-313">예제의 출력에서 볼 수 있듯이 두 값이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-313">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="Infinity">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Infinity" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Infinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Infinity As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Infinity;" />
      <MemberSignature Language="F#" Value=" staticval mutable Infinity : System.Numerics.Complex" Usage="System.Numerics.Complex.Infinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsFinite(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsFinite : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsFinite value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsInfinity(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsInfinity value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsNaN(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsNaN : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsNaN value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2db76-314">복소수의 로그를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-314">Returns the logarithm of a complex number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-315">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-315">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-316">지정된 복소수의 자연(밑 <see langword="e" />) 로그를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-316">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-317"><paramref name="value" />의 자연(밑 <see langword="e" />) 로그입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-317">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-318">합니다 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-318">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-319">다음 예제는 <xref:System.Numerics.Complex.Log%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-319">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="2db76-320">정밀도 부족에 대 한 일부 여유를 보여 줍니다는 <xref:System.Double> 데이터 형식으로 반환 하는 값을 전달 합니다 <xref:System.Numerics.Complex.Log%2A> 메서드를를 <xref:System.Numerics.Complex.Exp%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="2db76-320">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-321">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-321">A complex number.</span></span></param>
        <param name="baseValue"><span data-ttu-id="2db76-322">로그의 밑입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-322">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="2db76-323">지정된 밑을 사용하여 지정된 복소수의 로그를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-323">Returns the logarithm of a specified complex number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="2db76-324">밑이 <paramref name="value" />인 <paramref name="baseValue" />의 로그입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-324">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-325">합니다 <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-325">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-326">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-326">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-327">밑이 10인 지정된 복소수의 로그를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-327">Returns the base-10 logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-328">밑이 10인 <paramref name="value" />의 로그입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-328">The base-10 logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-329">합니다 <xref:System.Numerics.Complex.Log10%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Log10%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-329">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2db76-330">복소수의 크기 또는 절대 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-330">Gets the magnitude (or absolute value) of a complex number.</span></span></summary>
        <value><span data-ttu-id="2db76-331">현재 인스턴스의 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-331">The magnitude of the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-332"><xref:System.Numerics.Complex.Magnitude%2A> 속성은 복합 숫자의 절대 값과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-332">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="2db76-333">원점 (x 축과 데카르트 좌표계에 y 축 교차)에서 복소수의 표시 되는 2 차원 점을 거리를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-333">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="2db76-334">절대 값을 다음과 같이 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-334">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="2db76-335">&#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(한 \*는 + b \* b)</span><span class="sxs-lookup"><span data-stu-id="2db76-335">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span></span>  
  
 <span data-ttu-id="2db76-336">절대 값의 계산 결과에서 오버플로가 발생 하는 경우이 속성이 반환 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-336">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2db76-337"><xref:System.Numerics.Complex.Magnitude%2A> 하며 <xref:System.Numerics.Complex.Phase%2A> 속성 복소수의 극좌표 형 좌표 시스템을 나타내는 지점의 위치를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-337">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="2db76-338">호출 하 여 데카르트 좌표 대신 극좌표를 기반으로 복잡 한 횟수를 인스턴스화할 수 있습니다는 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-338">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-339">다음 예제는 복소수의 절대값을 계산 하 고의 값에 해당 하는 방법을 보여 줍니다는 <xref:System.Numerics.Complex.Magnitude%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-339">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2db76-340">곱할 첫 번째 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-340">The first complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="2db76-341">곱할 두 번째 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-341">The second complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="2db76-342">두 복소수의 곱을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-342">Returns the product of two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="2db76-343"><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 곱입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-343">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-344">복잡 한 곱셈 a + bi, 번호 및 두 번째 복소수, c + di를 다음 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-344">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="2db76-345">(ac-bd) + (ad + bc) i</span><span class="sxs-lookup"><span data-stu-id="2db76-345">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="2db76-346">곱셈 결과 또는 허수 구성 요소에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-346">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2db76-347"><xref:System.Numerics.Complex.Multiply%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-347">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="2db76-348">해당 동작은 곱셈 연산자를 사용 하는 곱하기 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-348">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-349">다음 예제에서는 복소수를 배열의 각 요소에 의해 복소수 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-349">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex NaN" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NaN As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex NaN;" />
      <MemberSignature Language="F#" Value=" staticval mutable NaN : System.Numerics.Complex" Usage="System.Numerics.Complex.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-350">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-350">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-351">지정된 복소수의 덧셈 역원을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-351">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-352"><paramref name="value" /> 매개 변수의 <see cref="P:System.Numerics.Complex.Real" /> 및 <see cref="P:System.Numerics.Complex.Imaginary" /> 구성 요소에 -1을 곱한 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-352">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-353">복소수의 덧셈 역 원을 값을 생성 하는 복소수 <xref:System.Numerics.Complex> 경우 원래 복소수에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-353">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="2db76-354">이 메서드는 원래 복소수의 실수와 허수 구성 요소는-1을 곱한 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-354">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="2db76-355"><xref:System.Numerics.Complex.Negate%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-355">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="2db76-356">해당 동작은 동일 단항 부정 연산자를 사용 하는 부정 <xref:System.Numerics.Complex.op_UnaryNegation%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-356">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-357">다음 예제에서는 복합 숫자의 배열에 있는 각 요소의 덧셈 역 원을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-357">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2db76-358">1과 같은 실수와 0과 같은 허수를 포함하는 새 <see cref="T:System.Numerics.Complex" /> 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-358">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2db76-359">다음 예제에서는 한 <xref:System.Numerics.Complex> 사용 하 여 값을 <xref:System.Numerics.Complex.One> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-359">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="2db76-360">그런 다음이 값을 호출 하 여 인스턴스화된 다른 값을 비교 합니다 <xref:System.Numerics.Complex> 실수부 1, 0을 허수 부분을 사용 하 여 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-360">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="2db76-361">예제의 출력에서 볼 수 있듯이 두 값이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-361">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2db76-362">더할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-362">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="2db76-363">더할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-363">The second value to add.</span></span></param>
        <summary><span data-ttu-id="2db76-364">두 복소수를 더합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-364">Adds two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="2db76-365"><paramref name="left" />와 <paramref name="right" />의 합입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-365">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-366"><xref:System.Numerics.Complex.op_Addition%2A> 메서드 복소수에 대 한 추가 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-366">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="2db76-367">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-367">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="2db76-368">복잡 한 추가 a + bi, 번호 및 두 번째 복소수, c + di를 다음 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-368">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="2db76-369">(a + c) + (b + d) i</span><span class="sxs-lookup"><span data-stu-id="2db76-369">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="2db76-370">메서드 호출 결과 또는 허수 구성 요소 중 하나에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-370">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2db76-371">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Add%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-371">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="2db76-372">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="2db76-372">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="2db76-373">다음 예제에서는 복소수를 사용 하 여 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-373">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2db76-374">나눌 대상 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-374">The value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="2db76-375">나눌 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-375">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="2db76-376">지정된 복소수를 다른 지정된 복소수로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-376">Divides a specified complex number by another specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-377"><paramref name="left" />를 <paramref name="right" />로 나눈 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-377">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-378"><xref:System.Numerics.Complex.op_Division%2A> 메서드 복소수는 나누기 연산을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-378">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="2db76-379">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-379">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="2db76-380">복잡 한의 부서 번호, a + bi, 하며 두 번째 복소수, c + di를 다음 형식:</span><span class="sxs-lookup"><span data-stu-id="2db76-380">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="2db76-381">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="2db76-381">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="2db76-382">나누기 결과 또는 허수 구성 요소에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-382">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2db76-383">사용자 지정 연산자 및 연산자 오버 로드를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Divide%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-383">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="2db76-384">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="2db76-384">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2db76-385">비교할 첫 번째 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-385">The first complex number to compare.</span></span></param>
        <param name="right"><span data-ttu-id="2db76-386">비교할 두 번째 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-386">The second complex number to compare.</span></span></param>
        <summary><span data-ttu-id="2db76-387">두 복소수가 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-387">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
        <returns><span data-ttu-id="2db76-388"><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-388"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-389">합니다 <xref:System.Numerics.Complex.op_Equality%2A> 메서드 정의 작업에 대 한 같음 연산자의 <xref:System.Numerics.Complex> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-389">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="2db76-390">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-390">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="2db76-391">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-391">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="2db76-392">두 복소수는 해당 실수 부분도 같으면 해당 허수 부분도 동일한 경우 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-392">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="2db76-393"><xref:System.Numerics.Complex.op_Equality%2A> 메서드는 다음 식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-393">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="2db76-394">전체 자릿수의 차이점으로 인해 분명히 동일한 두 복소수 간주 될 수 있습니다 같지 않은 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-394">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="2db76-395">자세한 내용 및 가능한 해결 방법에 대 한 참조를 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-395">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="2db76-396">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="2db76-396">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2db76-397"><see cref="T:System.Numerics.Complex" /> 개체와 다른 형식 간의 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-397">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-398">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-398">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-399"><see cref="T:System.Decimal" /> 값을 복소수로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-399">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-400"><paramref name="value" />와 일치하는 실수 구성 요소와 0과 일치하는 허수 구성 요소가 있는 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-400">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-401">명시적 변환 연산자를 변환할 수 있는 형식 정의 <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-401">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="2db76-402">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="2db76-402">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="2db76-403">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-403">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="2db76-404">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-404">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="2db76-405">변환을 <xref:System.Decimal> 복소수의 실수 부분 값 하므로 정밀도 손실 될 수 있습니다를 <xref:System.Double>, 복소수의 형식인 <xref:System.Numerics.Complex.Real%2A> 속성 보다 유효 자릿수가 적어 짐에 <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="2db76-405">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="2db76-406">다음 예제에서는 명시적 변환 <xref:System.Decimal> 값을 <xref:System.Numerics.Complex> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-406">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-407">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-407">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-408"><see cref="T:System.Numerics.BigInteger" /> 값을 복소수로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-408">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-409"><paramref name="value" />와 일치하는 실수 구성 요소와 0과 일치하는 허수 구성 요소가 있는 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-409">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-410">명시적 변환 연산자를 변환할 수 있는 형식 정의 <xref:System.Numerics.Complex> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-410">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="2db76-411">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="2db76-411">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="2db76-412">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-412">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="2db76-413">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-413">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="2db76-414">변환을 <xref:System.Numerics.BigInteger> 복소수의 실수 부분 값 하므로 정밀도 손실 될 수 있습니다를 <xref:System.Double>, 복소수의 형식인 <xref:System.Numerics.Complex.Real%2A> 속성 보다 유효 자릿수가 적어 짐에 <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="2db76-414">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="2db76-415">변환이 성공한 경우 때문에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다 합니다 <xref:System.Double> 형식 작업을 throw 하지 않습니다는 <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="2db76-415">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="2db76-416">대신 경우 `value` 는 보다 작은 <xref:System.Double.MinValue>, 결과 있는 복소수를 <xref:System.Numerics.Complex.Real%2A> 속성 값 <xref:System.Double.NegativeInfinity>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-416">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="2db76-417">경우 `value` 보다 크면 <xref:System.Double.MaxValue>, 결과 있는 복소수를 <xref:System.Numerics.Complex.Real%2A> 속성 값 <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="2db76-417">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="2db76-418">다음 예제에서는 명시적 변환 <xref:System.Numerics.BigInteger> 값을 <xref:System.Numerics.Complex> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-418">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2db76-419"><see cref="T:System.Numerics.Complex" /> 개체와 다른 형식 간의 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-419">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-420">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-420">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-421">부호 없는 바이트를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-421">Defines an implicit conversion of an unsigned byte to a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-422"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-422">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-423">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-423">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-424">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-424">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-425">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Byte> 다음 예와 같이 복소수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-425">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-426">변환의 결과 복소수의 실수 부분을 해당 값과 같음는 <xref:System.Byte> 값 및 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-426">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-427">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-427">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-428">배정밀도 부동 소수점 숫자를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-428">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-429"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-429">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-430">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-430">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-431">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-431">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-432">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Double> 다음 예와 같이 복소수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-432">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-433">변환의 결과 복소수의 실수 부분을 해당 값과 같음는 <xref:System.Double> 값 및 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-433">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-434">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-434">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-435">부호 있는 16비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-435">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-436"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-436">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-437">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-437">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-438">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-438">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-439">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 있는 16 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="2db76-439">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-440">Note 변환의 결과 복소수의 실수부 부호 있는 16 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-440">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-441">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-441">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-442">부호 있는 32비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-442">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-443"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-443">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-444">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-444">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-445">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-445">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-446">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 있는 32 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="2db76-446">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-447">Note 변환의 결과 복소수의 실수부 부호 있는 32 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-447">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-448">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-448">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-449">부호 있는 64비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-449">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-450"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-450">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-451">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-451">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-452">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-452">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-453">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 있는 64 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="2db76-453">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-454">Note 변환의 결과 복소수의 실수부 부호 있는 64 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-454">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-455">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-455">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-456">부호 있는 바이트를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-456">Defines an implicit conversion of a signed byte to a complex number.</span></span>   
           
<span data-ttu-id="2db76-457">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-457">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="2db76-458"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-458">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-459">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-459">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-460">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-460">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-461">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 있는 바이트의 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="2db76-461">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-462">Note 변환의 결과 복소수의 실수부를 부호 있는 바이트로 같은지 및 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-462">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-463">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-463">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-464">단정밀도 부동 소수점 숫자를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-464">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-465"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-465">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-466">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-466">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-467">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-467">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-468">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Single> 다음 예와 같이 복소수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-468">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-469">변환의 결과 복소수의 실수 부분을 해당 값과 같음는 <xref:System.Single> 값 및 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-469">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-470">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-470">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-471">부호 없는 16비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-471">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="2db76-472">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-472">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="2db76-473"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-473">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-474">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-474">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-475">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-475">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-476">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 없는 16 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="2db76-476">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-477">Note 변환의 결과 복소수의 실수부 부호 없는 16 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-477">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-478">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-478">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-479">부호 없는 32비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-479">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="2db76-480">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-480">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="2db76-481"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-481">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-482">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-482">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-483">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-483">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-484">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 없는 32 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="2db76-484">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-485">Note 변환의 결과 복소수의 실수부 부호 없는 32 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-485">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-486">복소수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-486">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-487">부호 없는 64비트 정수를 복소수로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-487">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="2db76-488">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-488">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="2db76-489"><paramref name="value" /> 매개 변수의 값을 실수 부분으로 포함하고 0을 허수 부분으로 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-489">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-490">오버 로드는 <xref:System.Numerics.Complex.op_Implicit%2A> 연산자를 컴파일러가 자동으로 변환할 수 형식을 정의 <xref:System.Numerics.Complex> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-490">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="2db76-491">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-491">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="2db76-492">이 오버 로드를 사용 하면 다음 예와 같이 복소수를 부호 없는 64 비트 정수에서 변환을 처리할 컴파일러.</span><span class="sxs-lookup"><span data-stu-id="2db76-492">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="2db76-493">Note 변환의 결과 복소수의 실수부 부호 없는 64 비트 정수 이며 허수부가 0과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-493">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2db76-494">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-494">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="2db76-495">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-495">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="2db76-496">두 복소수가 다른지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-496">Returns a value that indicates whether two complex numbers are not equal.</span></span></summary>
        <returns><span data-ttu-id="2db76-497"><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-497"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-498"><xref:System.Numerics.Complex.op_Equality%2A> 메서드 복소수를 같지 않음 연산자의 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-498">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="2db76-499">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-499">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="2db76-500">사용자 지정 연산자를 지원 하지 않는 언어를 호출 하 여 같지 않은지 테스트할 수는 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드 및 해당 값을 반전 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-500">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="2db76-501">전체 자릿수의 차이점으로 인해 분명히 동일한 두 복소수 간주 될 수 있습니다 같지 않은 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-501">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="2db76-502">해결 방법 중 하나를 반환 하는 비교 메서드를 구현 하는 `true` 복소수의 실수부 및 허수부 두 부분 간의 차이 특정 임계값을 초과 하는 경우에 (같은.의 실제 또는 허수 구성 요소 값의 0.1% 하나는 복소수)입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-502">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="2db76-503">자세한 내용은 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2db76-503">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2db76-504">곱할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-504">The first value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="2db76-505">곱할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-505">The second value to multiply.</span></span></param>
        <summary><span data-ttu-id="2db76-506">지정된 두 복소수를 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-506">Multiplies two specified complex numbers.</span></span></summary>
        <returns><span data-ttu-id="2db76-507"><paramref name="left" />와 <paramref name="right" />의 곱입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-507">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-508"><xref:System.Numerics.Complex.op_Multiply%2A> 메서드 복소수에 대 한 곱하기 연산자의 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-508">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="2db76-509">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-509">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="2db76-510">복잡 한 곱셈 a + bi, 번호 및 두 번째 복소수, c + di를 다음 형식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-510">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="2db76-511">(ac-bd) + (ad + bc) i</span><span class="sxs-lookup"><span data-stu-id="2db76-511">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="2db76-512">곱셈 결과 또는 허수 구성 요소에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-512">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2db76-513">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Multiply%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-513">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="2db76-514">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="2db76-514">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2db76-515">뺄 대상 값(피감수)입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-515">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="2db76-516">뺄 값(감수)입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-516">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="2db76-517">한 복소수에서 다른 복소수를 뺍니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-517">Subtracts a complex number from another complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-518"><paramref name="left" />에서 <paramref name="right" />를 뺀 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-518">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-519"><xref:System.Numerics.Complex.op_Subtraction%2A> 메서드 복소수는 빼기 연산자 연산을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-519">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="2db76-520">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-520">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="2db76-521">메서드 호출 결과 또는 허수 구성 요소 중 하나에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-521">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2db76-522">복소수, c +에서 다른 복소수 di의 빼기는 bi 형식은 +:</span><span class="sxs-lookup"><span data-stu-id="2db76-522">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="2db76-523">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="2db76-523">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="2db76-524">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Subtract%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-524">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="2db76-525">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="2db76-525">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-526">부정할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-526">The value to negate.</span></span></param>
        <summary><span data-ttu-id="2db76-527">지정된 복소수의 덧셈 역원을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-527">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-528"><paramref name="value" /> 매개 변수의 <see cref="P:System.Numerics.Complex.Real" /> 및 <see cref="P:System.Numerics.Complex.Imaginary" /> 구성 요소에 -1을 곱한 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-528">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-529"><xref:System.Numerics.Complex.op_UnaryNegation%2A> 메서드 복소수에 대 한 단항 부정 연산자 (덧셈 역 원을) 연산자의 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-529">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="2db76-530">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-530">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="2db76-531">값을 생성 하는 결과 복소수 <xref:System.Numerics.Complex> 0 (영) 원래 복소수에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-531">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="2db76-532">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.Complex.Negate%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-532">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="2db76-533">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="2db76-533">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2db76-534">복소수의 위상을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-534">Gets the phase of a complex number.</span></span></summary>
        <value><span data-ttu-id="2db76-535">복소수의 위상(라디안 단위)입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-535">The phase of a complex number, in radians.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-536">복소수를 bi, 단계로 계산 됩니다 + <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b는).</span><span class="sxs-lookup"><span data-stu-id="2db76-536">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="2db76-537">복소수의 복합 평면의 데카르트 좌표 또는 극좌표를 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-537">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="2db76-538">복소수의 위상 (인수) 복소수를 나타내는 지점으로의 원점 (x 축과 y 축의 교차점)에서 그린 선의 실제 축 각도입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-538">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="2db76-539">크기 (나타내는 <xref:System.Numerics.Complex.Magnitude%2A> 속성)는 복잡 한 수로 표현 되는 지점으로의 원점 거리입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-539">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="2db76-540">호출 하 여 데카르트 좌표 대신 극좌표를 기반으로 복잡 한 횟수를 인스턴스화할 수 있습니다는 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-540">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="2db76-541">변환할 단계 라디안에서 각도도로 곱한 180 /<xref:System.Math.PI?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-541">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-542">다음 예제에서는 합니다 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 복소수를 인스턴스화하기 위한 메서드를 해당 극좌표를 기반으로 하며 값을 표시 한 다음 해당 <xref:System.Numerics.Complex.Magnitude%2A> 및 <xref:System.Numerics.Complex.Phase%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-542">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2db76-543">지정된 복소수를 지정된 지수만큼 거듭제곱하여 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-543">Returns a specified complex number raised to a specified power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-544">지수만큼 거듭제곱할 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-544">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="2db76-545">거듭제곱을 지정하는 배정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-545">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="2db76-546">지정된 복소수를 배정밀도 부동 소수점 숫자로 지정된 지수만큼 거듭제곱하여 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-546">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="2db76-547">복소수 <paramref name="value" />를 지수 <paramref name="power" />만큼 거듭제곱한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-547">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-548">`value`가 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>이면 메서드에서 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-548">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2db76-549">다른 값에 대 한 경우 `power` 은 0으로, 메서드가 반환 <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, 경우에 `power` 이 1 이면 반환 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-549">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="2db76-550">에 해당 하는이 메서드는 <xref:System.Math.Pow%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-550">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-551">다음 예제에서는 해당 값의 범위를-1에서 10 복소수와 지 수를 사용 하 여 지 수를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-551">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-552">지수만큼 거듭제곱할 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-552">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="2db76-553">지수를 지정하는 복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-553">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="2db76-554">지정된 복소수를 복소수로 지정된 지수만큼 거듭제곱하여 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-554">Returns a specified complex number raised to a power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-555">복소수 <paramref name="value" />를 지수 <paramref name="power" />만큼 거듭제곱한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-555">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2db76-556">현재 <see cref="T:System.Numerics.Complex" /> 개체의 실수 구성 요소를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-556">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="2db76-557">복소수의 실수 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-557">The real component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-558">복소수 a + bi는 <xref:System.Numerics.Complex.Real%2A> 속성의 값을 반환을 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-558">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-559">다음 예제에서는의 배열을 인스턴스화하고 <xref:System.Numerics.Complex> 개체 형태로 각 실수 및 허수 구성 요소를 표시 및 a + bi 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-559">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-560">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-560">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-561">복소수의 역수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-561">Returns the multiplicative inverse of a complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-562"><paramref name="value" />의 역수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-562">The reciprocal of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-563">역 수 또는 숫자의 역 *x* 숫자인 *y* 여기서 *x* 곱한 *y* 1을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-563">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="2db76-564">복소수의 역 수는 생성 하는 복소수 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> 때 두 숫자를 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-564">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="2db76-565">식에서 역 a + bi 복소수의 표현 하는 경우 표시 됩니다는 / (을<sup>2</sup>+ b<sup>2</sup>) +-b / (을<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="2db76-565">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="2db76-566">값이 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, 메서드가 반환 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-566">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2db76-567">그렇지 않으면 식의 결과 반환 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-567">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-568">다음 예제에서는 <xref:System.Numerics.Complex.Reciprocal%2A> 여러 복소수의 역 수 값을 계산 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-568">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="2db76-569">복합 숫자의 역 수를 곱한 결과 방법도 보여 줍니다 <xref:System.Numerics.Complex.One?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-569">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-570">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-570">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-571">지정된 복소수의 사인을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-571">Returns the sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-572"><paramref name="value" />의 사인입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-572">The sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-573">합니다 <xref:System.Numerics.Complex.Sin%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Sin%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-573">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="2db76-574"><xref:System.Numerics.Complex.Sin%2A> 메서드는 다음 수식을 사용 하 여 복소수의 사인을 계산 a + bi:</span><span class="sxs-lookup"><span data-stu-id="2db76-574">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="2db76-575">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="2db76-575">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-576">다음 예제는 <xref:System.Numerics.Complex.Sin%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-576">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="2db76-577">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Asin%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Sin%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="2db76-577">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-578">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-578">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-579">지정된 복소수의 하이퍼볼릭 사인을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-579">Returns the hyperbolic sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-580"><paramref name="value" />의 쌍곡선 사인입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-580">The hyperbolic sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-581">합니다 <xref:System.Numerics.Complex.Sinh%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Sinh%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-581">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="2db76-582"><xref:System.Numerics.Complex.Sinh%2A> 메서드는 다음 수식을 사용 하 여 복소수의 쌍 곡 사인을 계산 a + bi:</span><span class="sxs-lookup"><span data-stu-id="2db76-582">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="2db76-583">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="2db76-583">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-584">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-584">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-585">지정된 복소수의 제곱근을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-585">Returns the square root of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-586"><paramref name="value" />의 제곱근입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-586">The square root of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-587">복소수의 제곱근 `value` 다음 수식을 사용 하 여 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-587">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="2db76-588"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span><span class="sxs-lookup"><span data-stu-id="2db76-588"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="2db76-589">합니다 <xref:System.Numerics.Complex.Sqrt%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-589">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="2db76-590">뺄 대상 값(피감수)입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-590">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="2db76-591">뺄 값(감수)입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-591">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="2db76-592">한 복소수에서 다른 복소수를 뺀 후 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-592">Subtracts one complex number from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="2db76-593"><paramref name="left" />에서 <paramref name="right" />를 뺀 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-593">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-594">복소수, c +에서 다른 복소수 di의 빼기는 bi 형식은 +:</span><span class="sxs-lookup"><span data-stu-id="2db76-594">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="2db76-595">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="2db76-595">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="2db76-596">메서드 호출 결과 또는 허수 구성 요소 중 하나에서 오버플로가 발생 하는 경우 해당 구성 요소의 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 또는 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-596">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2db76-597">사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.Complex.Subtract%2A> 복소수를 사용 하 여 빼기를 수행 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-597">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-598">다음 예제에서는 복소수에서 배열에 각 복소수를 뺍니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-598">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-599">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-599">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-600">지정된 복소수의 탄젠트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-600">Returns the tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-601"><paramref name="value" />의 접선입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-601">The tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-602">합니다 <xref:System.Numerics.Complex.Tan%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Tan%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-602">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="2db76-603">합니다 <xref:System.Numerics.Complex.Tan%2A> 메서드는 다음 수식을 사용 하 여 복소수의 탄젠트를 계산할 `value`:</span><span class="sxs-lookup"><span data-stu-id="2db76-603">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="2db76-604"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="2db76-604"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-605">다음 예제는 <xref:System.Numerics.Complex.Tan%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-605">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="2db76-606">표시 반환 하는 값을 전달 하는 <xref:System.Numerics.Complex.Atan%2A> 메서드를 합니다 <xref:System.Numerics.Complex.Tan%2A> 메서드는 원래 <xref:System.Numerics.Complex> 값.</span><span class="sxs-lookup"><span data-stu-id="2db76-606">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2db76-607">복소수입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-607">A complex number.</span></span></param>
        <summary><span data-ttu-id="2db76-608">지정된 복소수의 하이퍼볼릭 탄젠트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-608">Returns the hyperbolic tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="2db76-609"><paramref name="value" />의 쌍곡선 접선입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-609">The hyperbolic tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-610">합니다 <xref:System.Numerics.Complex.Tanh%2A> 에 해당 하는 복소수에 대 한 메서드는 <xref:System.Math.Tanh%2A?displayProperty=nameWithType> 실수에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="2db76-610">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="2db76-611">합니다 <xref:System.Numerics.Complex.Tanh%2A> 메서드는 다음 수식을 사용 하 여 복소수의 쌍 곡 탄젠트를 계산 `value`:</span><span class="sxs-lookup"><span data-stu-id="2db76-611">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="2db76-612"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="2db76-612"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2db76-613">복소수 값을 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-613">Converts the value of a complex number to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2db76-614">현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-614">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span></span></summary>
        <returns><span data-ttu-id="2db76-615">현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-615">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-616">데카르트 좌표를 사용 하 여 폼의 수를 표시 하는 복소수의 기본 문자열 표현을 `(` *는* `,` *b*`)`여기서 *는* 되는 복소수의 실수부 및 *b* 복소수의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-616">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="2db76-617">둘 다 *는* 하 고 *b* 일반 서식 지정자 ("G") 및 현재 시스템 문화권의 규칙을 사용 하 여 서식이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-617">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-618">다음 예제에서는 여러 복합 숫자의 문자열 표현을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-618">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="2db76-619">영어-미국 ("EN-US") 문화권에는,이 경우 현재 시스템 문화권의 서식 규칙을 사용 하는 출력입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-619">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="2db76-620">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-620">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="2db76-621">지정된 문화권별 서식 정보를 사용하여 현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-621">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="2db76-622"><paramref name="provider" />에서 지정한 형식에 따른 현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-622">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-623">데카르트 좌표를 사용 하 여 폼의 수를 표시 하는이 메서드에서 반환 된 복잡 한 숫자의 문자열 표현을 `(` *는* `,` *b*`)`, 여기서 *는* 되는 복소수의 실수부 및 *b* 복소수의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-623">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="2db76-624">둘 다 *를* 하 고 *b* 일반 서식 지정자 ("G") 및 정의한 문화권의 규칙을 사용 하 여 포맷 된 `provider`합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-624">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="2db76-625">합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-625">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="2db76-626">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 실수 및 허수 반환된 된 문자열에서 형식에 대 한 문화권별 형식 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-626">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="2db76-627">경우 `provider` 됩니다 `null`, 반환된 된 문자열을 사용 하 여 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-627">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="2db76-628">`provider` 매개 변수는 다음 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-628">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="2db76-629"><xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체</span><span class="sxs-lookup"><span data-stu-id="2db76-629">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="2db76-630"><xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-630">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="2db76-631">구현 하는 사용자 지정 개체를 <xref:System.IFormatProvider> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-631">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="2db76-632">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-632">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-633">다음 예제에서는 여러 복합 숫자의 문자열 표현을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-633">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="2db76-634">결과 영어-미국 ("EN-US") 및 프랑스어-프랑스 ("FR-FR") 문화권의 서식 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-634">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="2db76-635">표준 또는 사용자 지정 숫자 서식 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-635">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="2db76-636">실수와 허수 부분에 대해 지정된 서식을 사용하여 현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-636">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="2db76-637">현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-637">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-638">데카르트 좌표를 사용 하 여 폼의 수를 표시 하는이 메서드에서 반환 된 복잡 한 숫자의 문자열 표현을 `(` *는* `,` *b*`)`, 여기서 *는* 되는 복소수의 실수부 및 *b* 복소수의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-638">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="2db76-639">둘 다 *는* 하 고 *b* 는 지정 된 형식 문자열을 사용 하 여 서식이 지정 `format`합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-639">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="2db76-640">`format` 매개 변수는 모든 유효한 표준 숫자 서식 지정자 또는 사용자 지정 숫자 서식 지정자의 임의 조합 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-640">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="2db76-641">경우 `format` 값과 같음 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 복소수의 실수와 허수 부분 일반 서식 지정자 ("G")로 포맷 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-641">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="2db76-642">하는 경우 `format` 다른 값을 메서드가 throw를 <xref:System.FormatException>입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-642">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="2db76-643">다음 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:</span><span class="sxs-lookup"><span data-stu-id="2db76-643">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="2db76-644">숫자 형식 문자열에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-644">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="2db76-645">.NET Framework의 형식에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-645">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="2db76-646">반환된 된 문자열의 형식은 의해 결정 되는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-646">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="2db76-647">에 따라는 `format` 매개 변수를이 개체는 출력 문자열에 소수점 기호가 음수 기호, 그룹 구분 기호 등 기호를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-647">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="2db76-648">현재 문화권이 아닌 문화권에 대 한 서식 지정 정보를 제공 하려면 호출을 <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-648">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-649">다음 예제에서는 복소수를 초기화 하 고 몇 가지 표준 형식 문자열을 사용 하 여 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-649">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="2db76-650"><paramref name="format" />은 유효한 서식 문자열이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-650"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="2db76-651">표준 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="2db76-651">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="2db76-652">사용자 지정 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="2db76-652">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="2db76-653">표준 또는 사용자 지정 숫자 서식 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-653">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="2db76-654">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-654">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="2db76-655">실수와 허수 부분에 대해 지정된 서식과 문화권별 서식 정보를 사용하여 현재 복소수 값을 데카르트 형식의 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-655">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="2db76-656"><paramref name="format" /> 및 <paramref name="provider" />에서 지정한 형식에 따른 현재 인스턴스에 대한 데카르트 형식의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-656">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-657">데카르트 좌표를 사용 하 여 폼의 수를 표시 하는이 메서드에서 반환 된 복잡 한 숫자의 문자열 표현을 `(` *는* `,` *b*`)`, 여기서 *는* 되는 복소수의 실수부 및 *b* 복소수의 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-657">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="2db76-658">둘 다 *는* 하 고 *b* 는 지정 된 형식 문자열을 사용 하 여 서식이 지정 `format`합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-658">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="2db76-659">`format` 매개 변수는 모든 유효한 표준 숫자 서식 지정자 또는 사용자 지정 숫자 서식 지정자의 임의 조합 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-659">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="2db76-660">경우 `format` 값과 같음 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 복소수의 실수와 허수 부분 일반 서식 지정자 ("G")로 포맷 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-660">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="2db76-661">하는 경우 `format` 다른 값을 메서드가 throw를 <xref:System.FormatException>입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-661">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="2db76-662">다음 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:</span><span class="sxs-lookup"><span data-stu-id="2db76-662">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="2db76-663">숫자 형식 문자열에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-663">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="2db76-664">.NET Framework의 형식에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-664">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="2db76-665">합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-665">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="2db76-666">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 실수 및 허수 반환된 된 문자열에서 형식에 대 한 문화권별 형식 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-666">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="2db76-667">에 따라는 `format` 매개 변수를이 개체는 출력 문자열에 소수점 기호가 음수 기호, 그룹 구분 기호 등 기호를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-667">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="2db76-668">경우 `provider` 됩니다 `null`, 반환된 된 문자열을 사용 하 여 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-668">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="2db76-669">`provider` 매개 변수는 다음 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-669">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="2db76-670"><xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체</span><span class="sxs-lookup"><span data-stu-id="2db76-670">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="2db76-671"><xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-671">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="2db76-672">구현 하는 사용자 지정 개체를 <xref:System.IFormatProvider> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-672">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="2db76-673">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-673">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-674">다음 예제에서는 복소수를 배열을 만들고 표시 하는 몇 가지 표준 형식 문자열을 사용 하 여 각 뿐만 <xref:System.Globalization.CultureInfo> 영어-미국 ("EN-US") 및 프랑스어-프랑스 ("FR-FR") 문화권을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-674">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="2db76-675"><paramref name="format" />은 유효한 서식 문자열이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-675"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="2db76-676">표준 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="2db76-676">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="2db76-677">사용자 지정 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="2db76-677">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2db76-678">0과 같은 실수와 0과 같은 허수를 포함하는 새 <see cref="T:System.Numerics.Complex" /> 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-678">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2db76-679">합니다 <xref:System.Numerics.Complex.Zero> 속성은 가장 자주 비교 하는 데는 <xref:System.Numerics.Complex> 값을 0입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-679">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2db76-680">다음 예제에서는 한 <xref:System.Numerics.Complex> 사용 하 여 값을 <xref:System.Numerics.Complex.Zero> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-680">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="2db76-681">그런 다음이 값을 호출 하 여 인스턴스화된 다른 값을 비교 합니다 <xref:System.Numerics.Complex> 실수부 0, 0을 허수 부분을 사용 하 여 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-681">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="2db76-682">예제의 출력에서 볼 수 있듯이 두 값이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2db76-682">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>