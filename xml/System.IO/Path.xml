<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4e8893043c2c4b47f803b56f96b316d8bab660c4" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57914881" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3f07d-101">파일이나 디렉터리 경로 정보를 포함하는 <see cref="T:System.String" /> 인스턴스에 대한 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="3f07d-102">이러한 작업은 플랫폼 간에 호환되는 방식으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="3f07d-103">경로가 파일 또는 디렉터리의 위치를 제공 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="3f07d-104">디스크의 위치로 경로 반드시 가리키지 않습니다 예를 들어, 경로 메모리에 또는 장치에서 위치를 매핑할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="3f07d-105">패스의 정확한 형식은 현재 플랫폼에 의해 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="3f07d-106">예를 들어 일부 시스템 경로 시작할 수 드라이브 또는 볼륨 문자를 사용 하 여이 요소를 다른 시스템에 없을 때.</span><span class="sxs-lookup"><span data-stu-id="3f07d-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="3f07d-107">일부 시스템에서는 파일 경로 파일에 저장 된 정보 유형을 지정 하는 확장을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="3f07d-108">파일 이름 확장명의 형식은 플랫폼에 따라 다릅니다. 예를 들어 일부 시스템 3 자에 대 한 확장을 제한 하 고 없기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="3f07d-109">현재 플랫폼에는 또한 경로의 요소를 구분 하는 데 사용 되는 문자 집합 및 경로 지정 하는 경우에 사용할 수 없는 문자 집합을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="3f07d-110">필드 이러한 차이로 인해 합니다 `Path` 클래스의 일부 멤버의 정확한 동작 뿐만 아니라는 `Path` 클래스는 플랫폼에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="3f07d-111">경로 절대 또는 상대 위치 정보를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="3f07d-112">위치를 완벽 하 게 지정 하는 절대 경로: 파일 또는 디렉터리 고유 하 게 식별할 수 현재 위치에 관계 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="3f07d-113">상대 경로 부분 위치를 지정 합니다: 상대 경로 사용 하 여 지정 된 파일을 찾을 때 현재 위치가 시작 지점으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="3f07d-114">현재 디렉터리를 확인 하려면 호출 <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="3f07d-115">.NET core 1.1 및 이후 버전 및.NET Framework 4.6.2 이상와 같은 장치 이름에는 파일 시스템 개체에 대 한 액세스도 지원 "\\? \C:\"합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="3f07d-116">Windows에서 파일 경로 형식에 대 한 자세한 내용은 참조 하세요. [Windows 시스템에서 파일 경로 형식](~/docs/standard/io/file-path-formats.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="3f07d-117">멤버는 대부분의 `Path` 클래스와 파일 시스템으로 작용 하지 경로 문자열에서 지정 된 파일의 존재 여부를 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="3f07d-118">`Path` 클래스와 같은 경로 문자열을 수정 하는 멤버 <xref:System.IO.Path.ChangeExtension%2A>, 파일 시스템의 파일 이름에 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="3f07d-119">`Path` 하지만 멤버 않습니다, 지정 된 경로 문자열의 내용을 검사 및 throw를 <xref:System.ArgumentException> 문자열에서 반환 된 문자에 정의 된 경로 문자열에서 유효 하지 않은 문자를 포함 하는 경우 예외를 <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="3f07d-120">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 포함 될 수 있습니다 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), (\0), null 및 18 번 및 20부터 25 통해 유니코드 문자 16입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="3f07d-121">멤버는 `Path` 클래스를 사용 하면 쉽고 빠르게 파일 이름 확장명을 경로의 일부를 인지 여부를 확인 하 고 두 문자열을 하나의 경로 이름으로 결합 등 일반적인 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="3f07d-122">모든 멤버는 `Path` 클래스는 정적이 고 경로의 인스턴스 없이 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f07d-123">입력 문자열로 경로 허용 하는 멤버를 해당 경로 올바른 형식 이어야 합니다. 또는 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="3f07d-124">예를 들어, 경로 정규화 공백으로 시작 하지만 경로 클래스의 메서드에서 잘리지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="3f07d-125">따라서 경로 잘못 되었으며 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="3f07d-126">마찬가지로, 경로 또는 경로의 조합을 두 번 정규화 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="3f07d-127">예를 들어, "c:\temp c:\windows"는 또한 대부분의 경우에서 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="3f07d-128">경로 잘 구성 된 경우에 경로 문자열을 허용 하는 메서드를 사용 하 여 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="3f07d-129">경로 허용 하는 멤버의 경로 파일 또는 디렉터리를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="3f07d-130">지정된 된 경로 상대 경로 또는 서버 및 공유 이름에 대 한 범용 명명 규칙 (UNC) 경로 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="3f07d-131">예를 들어, 다음은 허용 가능한 경로.</span><span class="sxs-lookup"><span data-stu-id="3f07d-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="3f07d-132">"c:\\\MyDir\\\MyFile.txt" C# 또는 Visual Basic의 "c:\MyDir\MyFile.txt"입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="3f07d-133">"c:\\\MyDir" C# 또는 Visual Basic의 "c:\MyDir"입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="3f07d-134">"MyDir\\\MySubdir" C# 또는 Visual Basic의 "MyDir\MySubDir"입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="3f07d-135">"\\\\\\\MyServer\\\MyShare" C#에서 또는 "\\\MyServer\MyShare" Visual Basic의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="3f07d-136">문자열에서 이러한 모든 작업이 수행 되 되므로 모든 시나리오에서 결과가 올바른지 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="3f07d-137">예를 들어를 <xref:System.IO.Path.GetExtension%2A> 메서드를 전달 하는 문자열을 구문 분석 하 고 해당 문자열에서 확장명을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="3f07d-138">그러나 해당 확장을 사용 하 여 파일을 디스크에 있는지이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="3f07d-139">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="3f07d-140">다음 예제에서는 기본 멤버 중 일부는 `Path` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-141">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-142">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-143">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="3f07d-144">방법: 새로 만든 데이터 파일 읽기 및 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-145">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f07d-146">계층적 파일 시스템 구조를 반영하는 경로 문자열에서 디렉터리 수준을 구분하는 데 사용되는 플랫폼 특정 대체 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="3f07d-147">이 필드와 동일한 값을 가질 수 있습니다 <xref:System.IO.Path.DirectorySeparatorChar>합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="3f07d-148">`AltDirectorySeparatorChar` 및 <xref:System.IO.Path.DirectorySeparatorChar> 은 모두 경로 문자열에서 디렉터리 수준을 구분 하는 것에 대 한 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="3f07d-149">이 필드의 값은 Windows와 Unix 기반 운영 체제에서 슬래시 ('/').</span><span class="sxs-lookup"><span data-stu-id="3f07d-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="3f07d-150">다음 예제에서는 <xref:System.IO.Path> Unix 기반 시스템에서 Windows에 값 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="3f07d-151">Windows 지원 하거나 슬래시는 (에서 반환 된 합니다 <xref:System.IO.Path.AltDirectorySeparatorChar> 필드) 또는 백슬래시 (에서 반환 된는 <xref:System.IO.Path.DirectorySeparatorChar> 필드)를 경로 구분 기호 문자로, Unix 기반 시스템 슬래시만을 지원 하지만.</span><span class="sxs-lookup"><span data-stu-id="3f07d-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-152">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-153">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-154">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-155">수정할 경로 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-155">The path information to modify.</span></span> <span data-ttu-id="3f07d-156">경로에는 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 문자가 포함될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="3f07d-157">앞에 마침표가 있거나 없는 새 확장명입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="3f07d-158"><paramref name="path" />에서 기존 확장명을 제거하려면 <see langword="null" />을(를) 지정하세요.</span><span class="sxs-lookup"><span data-stu-id="3f07d-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="3f07d-159">경로 문자열의 확장명을 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="3f07d-160">수정된 경로 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-160">The modified path information.</span></span>  
  
<span data-ttu-id="3f07d-161">Windows 기반 데스크톱 플랫폼에서 <paramref name="path" />이(가) <see langword="null" />이거나 빈 문자열("")이면 경로 정보가 수정되지 않고 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="3f07d-162"><paramref name="extension" />이(가) <see langword="null" />이면 반환된 문자열에 확장명이 제거된 지정된 경로가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="3f07d-163"><paramref name="path" />에 확장명이 없고 <paramref name="extension" />이(가) <see langword="null" />이 아니면 반환된 경로 문자열에는 <paramref name="path" /> 끝에 추가된 <paramref name="extension" />이(가) 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-164">모두 `path` 나 `extension` 마침표 (.) `ChangeExtension` 기간을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="3f07d-165">`extension` 매개 변수는 여러 개의 마침표 및 올바른 경로 문자를 포함할 수 있습니다 및 길이 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="3f07d-166">경우 `extension` 됩니다 `null`, 반환된 된 문자열의 내용이 들어 `path` 마지막 기간 및 그 다음에 모든 문자 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="3f07d-167">하는 경우 `extension` 빈 문자열이 면 반환된 된 경로 문자열의 내용이 들어 `path` 마지막 마침표 다음 문자를 사용 하 여 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="3f07d-168">하는 경우 `path` 확장 되지 않은 및 `extension` 아닙니다 `null`, 반환 된 문자열에 포함 되어 `path` 뒤에 `extension`입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="3f07d-169">하는 경우 `extension` 아닙니다 `null` 앞에 마침표를 포함 하지 않습니다 마침표가 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="3f07d-170">경우 `path` 여러 마침표로 구분 된 여러 확장을 포함 합니다. 반환된 된 문자열의 내용을 포함 `path` 마지막을 사용 하 여 기간 및 다음 문자만으로 대체 `extension`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="3f07d-171">예를 들어 경우 `path` "\Dir1\examples\pathtests.csx.txt"은 및 `extension` "cs" 이면 수정 된 경로 "\Dir1\examples\pathtests.csx.cs"입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="3f07d-172">반환된 된 결과 모든 시나리오에서 유효한 지 확인 하는 것이 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="3f07d-173">예를 들어 있으면 `path` 비어 `extension` 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="3f07d-174">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-175">다음 예제를 사용 하는 방법을 보여 줍니다는 `ChangeExtension` 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-176"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-177">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-178">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-179">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-180">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3f07d-181">여러 문자열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="3f07d-182">이 메서드는 개별 문자열 파일 경로 나타내는 단일 문자열로 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="3f07d-183">그러나 아닌 첫 번째 인수는 루트 경로 있으면 모든 이전 경로 구성 요소 무시 되 고 해당 루트 경로 구성 요소를 사용 하 여 반환된 된 문자열을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="3f07d-184">대 안으로 합니다 `Combine` 메서드를 사용 하는 것이 좋습니다 합니다 <xref:System.IO.Path.Join%2A> 또는 <xref:System.IO.Path.TryJoin%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3f07d-185">이 메서드는 첫 번째 인수는 절대 경로 및 다음 인수 또는 인수는 상대 경로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="3f07d-186">이 경우 없는 경우 모든 후속 인수는 사용자가 문자열 입력 하는 경우에 특히를 호출 합니다 <xref:System.IO.Path.Join%2A> 또는 <xref:System.IO.Path.TryJoin%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="3f07d-187">경로 각 부분의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="3f07d-188">문자열 배열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="3f07d-189">결합된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="3f07d-190">`paths` 배열을 결합 하는 경로 부분을 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="3f07d-191">후속 경로 중 하나를 절대 경로 결합 작업을 다시 결합 된 모든 이전 경로 삭제 하는 절대 경로 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="3f07d-192">경우에 있는 모든 요소 `paths` 마지막 드라이브가 아닌로 끝나지 않습니다 하지만 합니다 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar> 문자를 `Combine` 메서드를 추가 <xref:System.IO.Path.DirectorySeparatorChar> 해당 요소와 다음 사이의 문자.</span><span class="sxs-lookup"><span data-stu-id="3f07d-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="3f07d-193">요소는 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료 하는 경우는 `Combine` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 항목을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="3f07d-194">다음 예에서는 백슬래시를 경로 구분 기호 문자로 사용 되는 경우 Windows 및 Unix 기반 시스템에서 결과 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="3f07d-195">길이가 0 인 문자열 조합된 된 경로에서 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="3f07d-196">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="3f07d-197">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="3f07d-198">예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="3f07d-199">성공적으로 해석 되므로 `Combine` 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="3f07d-200">다음 예제에서는 경로에 문자열 배열을 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-201">배열의 문자열 중 하나에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f07d-202">배열의 문자열 중 하나가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-203">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="3f07d-204">결합할 첫 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="3f07d-205">결합할 두 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="3f07d-206">두 문자열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="3f07d-207">결합된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-207">The combined paths.</span></span> <span data-ttu-id="3f07d-208">지정된 경로 중 하나가 0 길이의 문자열이면 이 메서드는 다른 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="3f07d-209"><paramref name="path2" />에 절대 경로가 포함되어 있으면 이 메서드는 <paramref name="path2" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-210">하는 경우 `path1` (즉, "c:" 또는 "d:") 드라이브 참조가 아닌 경우 및에 정의 된 대로 유효한 구분 기호 문자로 끝나지 않습니다 <xref:System.IO.Path.DirectorySeparatorChar>를 <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar>를 <xref:System.IO.Path.DirectorySeparatorChar> 에 추가 됩니다 `path1` 연결 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="3f07d-211">해당 경우 `path1` 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Combine` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 항목을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="3f07d-212">다음 예에서는 백슬래시를 경로 구분 기호 문자로 사용 되는 경우 Windows 및 Unix 기반 시스템에서 결과 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="3f07d-213">경우 `path2` 루트를 포함 하지 않습니다 (예를 들어 `path2` 시작 하지 않고 구분 기호 문자 또는 드라이브 지정), 결과 중간에 다른 구분 기호 문자로 두 경로 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="3f07d-214">하는 경우 `path2` 루트가 포함 `path2` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="3f07d-215">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="3f07d-216">따라서 경우 `path2` 공백 (예: "\file.txt")를 포함 합니다 <xref:System.IO.Path.Combine%2A> 메서드를 추가 `path2` 에 `path1` 만 반환 하는 대신 `path2`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="3f07d-217">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="3f07d-218">예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="3f07d-219">성공적으로 해석 되므로 `Combine` 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="3f07d-220">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-221">다음 예제는 `Combine` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-222"><paramref name="path1" /> 또는 <paramref name="path2" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f07d-223"><paramref name="path1" /> 또는 <paramref name="path2" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-224">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-225">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-226">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-227">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="3f07d-228">결합할 첫 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="3f07d-229">결합할 두 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="3f07d-230">결합할 세 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="3f07d-231">세 문자열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="3f07d-232">결합된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-233">`path1` 절대 경로 여야 합니다 (예를 들어, "d:\archives" 또는 "\\\archives\public").</span><span class="sxs-lookup"><span data-stu-id="3f07d-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="3f07d-234">하는 경우 `path2` 또는 `path3` 결합 작업 이전에 모두 무시 항목 경로 및 절대 경로를 다시 설정 합니다. 절대 경로 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="3f07d-235">길이가 0 인 문자열 조합된 된 경로에서 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="3f07d-236">하는 경우 `path1` 또는 `path2` (즉, "c:" 또는 "d:") 드라이브 참조가 아닌 경우 및에 정의 된 대로 유효한 구분 기호 문자로 끝나지 않습니다 <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> 에 추가 됩니다 `path1` 또는`path2` 연결 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="3f07d-237">경우 `path1` 나 `path2` 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Combine` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 항목을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="3f07d-238">다음 예에서는 백슬래시를 경로 구분 기호 문자로 사용 되는 경우 Windows 및 Unix 기반 시스템에서 결과 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="3f07d-239">경우 `path2` 루트를 포함 하지 않습니다 (예를 들어 `path2` 시작 하지 않고 구분 기호 문자 또는 드라이브 지정), 결과 중간에 다른 구분 기호 문자로 두 경로 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="3f07d-240">하는 경우 `path2` 루트가 포함 `path2` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="3f07d-241">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="3f07d-242">따라서 경우 `path2` 공백 문자 (예: "\file.txt")를 포함 합니다 <xref:System.IO.Path.Combine%2A> 메서드 추가 `path2` 에 `path1`입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="3f07d-243">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="3f07d-244">예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="3f07d-245">성공적으로 해석 되므로 `Combine` 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-246">다음 예제에서는 세 개의 경로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-247"><paramref name="path1" />, <paramref name="path2" /> 또는 <paramref name="path3" />이 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자 중 하나 이상을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f07d-248"><paramref name="path1" />, <paramref name="path2" /> 또는 <paramref name="path3" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-249">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="3f07d-250">결합할 첫 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="3f07d-251">결합할 두 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="3f07d-252">결합할 세 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="3f07d-253">결합할 네 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="3f07d-254">네 문자열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="3f07d-255">결합된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-256">`path1` 절대 경로 여야 합니다 (예를 들어, "d:\archives" 또는 "\\\archives\public"). 후속 경로 중 하나 이면 절대 경로 결합 작업은 이전에 결합 된 모든 경로 삭제 하 고 절대 경로를 다시 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="3f07d-257">길이가 0 인 문자열 조합된 된 경로에서 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="3f07d-258">하는 경우 `path1`, `path2`, 또는 `path3` (즉, "c:" 또는 "d:") 드라이브 참조가 아닌 경우 및에 정의 된 대로 유효한 구분 기호 문자로 끝나지 않습니다 <xref:System.IO.Path.DirectorySeparatorChar>에 <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> 추가 됩니다 이전 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="3f07d-259">경우 `path1`, `path2`, 또는 `path3` 는 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Combine` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 항목을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="3f07d-260">다음 예에서는 백슬래시를 경로 구분 기호 문자로 사용 되는 경우 Windows 및 Unix 기반 시스템에서 결과 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="3f07d-261">경우 `path2` 루트를 포함 하지 않습니다 (예를 들어 `path2` 시작 하지 않고 구분 기호 문자 또는 드라이브 지정), 결과 중간에 다른 구분 기호 문자로 두 경로 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="3f07d-262">하는 경우 `path2` 루트가 포함 `path2` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="3f07d-263">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="3f07d-264">따라서 경우 `path2` 공백 문자 (예: "\file.txt")를 포함 합니다 <xref:System.IO.Path.Combine%2A> 메서드 추가 `path2` 에 `path1`입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="3f07d-265">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="3f07d-266">예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="3f07d-267">성공적으로 해석 되므로 `Combine` 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-268">다음 예제에서는 네 개의 경로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> 또는 <paramref name="path4" />가 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자 중 하나 이상을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f07d-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> 또는 <paramref name="path4" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-271">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f07d-272">계층적 파일 시스템 구조를 반영하는 경로 문자열에서 디렉터리 수준을 구분하는 데 사용되는 플랫폼 특정 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="3f07d-273"><xref:System.IO.Path.AltDirectorySeparatorChar> 및 `DirectorySeparatorChar` 은 모두 경로 문자열에서 디렉터리 수준을 구분 하는 것에 대 한 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="3f07d-274">경우.NET Core를 사용 하 여 여러 플랫폼에서 실행 되는 응용 프로그램을 개발 하는:</span><span class="sxs-lookup"><span data-stu-id="3f07d-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="3f07d-275">슬래시를 사용 해야를 하드 코드 디렉터리 구분 문자로 선호 하는 경우 (`/`) 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="3f07d-276">Unix 시스템에서 인식할 수 있는 유일한 디렉터리 구분 문자는 예제에서 출력으로 며는 <xref:System.IO.Path.AltDirectorySeparatorChar> Windows에서.</span><span class="sxs-lookup"><span data-stu-id="3f07d-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="3f07d-277">문자열 연결을 사용 하 여 동적으로 런타임 시 경로 구분 기호 문자를 검색 하 고 파일 시스템 경로에 통합.</span><span class="sxs-lookup"><span data-stu-id="3f07d-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="3f07d-278">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   <span data-ttu-id="3f07d-279">값을 검색할 수도 있습니다는 <xref:System.IO.Path.AltDirectorySeparatorChar> 속성, Windows 및 Unx 기반 시스템 모두에서 동일 이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="3f07d-280">검색 된 <xref:System.IO.Path.AltDirectorySeparatorChar> 속성</span><span class="sxs-lookup"><span data-stu-id="3f07d-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="3f07d-281">응용 프로그램 플랫폼 간 없는 경우에 시스템에 대 한 적절 한 구분 기호를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="3f07d-282">다음 예제에서는 <xref:System.IO.Path> Unix 기반 시스템에서 Windows에 값 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="3f07d-283">Windows 지원 하거나 슬래시는 (에서 반환 된 합니다 <xref:System.IO.Path.AltDirectorySeparatorChar> 필드) 또는 백슬래시 (에서 반환 된는 <xref:System.IO.Path.DirectorySeparatorChar> 필드)를 경로 구분 기호 문자로, Unix 기반 시스템 슬래시만을 지원 하지만.</span><span class="sxs-lookup"><span data-stu-id="3f07d-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-284">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-285">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-286">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-287">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary><span data-ttu-id="3f07d-288">문자 범위로 표시되는 지정된 경로의 디렉터리 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-288">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="3f07d-289"><paramref name="path" />의 디렉터리 정보 또는 <paramref name="path" />가 <see langword="null" />인 경우 빈 범위, 빈 범위 또는 루트(예: \,C: 또는 \\server\share)입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-289">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-290">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-290">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-291">파일 또는 디렉터리의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-291">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="3f07d-292">지정된 경로 문자열에 대한 디렉터리 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-292">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="3f07d-293"><paramref name="path" />에 대한 디렉터리 정보이며, <paramref name="path" />이(가) 루트 디렉터리를 나타내거나 null인 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-293">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="3f07d-294"><see cref="F:System.String.Empty" />에 디렉터리 정보가 포함되어 있지 않으면 <paramref name="path" />이(가) 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-294">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-295">대부분의 경우에서이 메서드에서 반환 된 문자열 모든 문자로 구성 경로의 마지막 포함 되지 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-295">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="3f07d-296">경로 구성 된 경우의 루트 디렉터리와 같은 "c:\\", null이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-296">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="3f07d-297">이 메서드를 사용 하 여 경로 지원 하지 않습니다 "파일:".</span><span class="sxs-lookup"><span data-stu-id="3f07d-297">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="3f07d-298">반환 된 경로 포함 되어 있지 않으므로 합니다 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 다시 반환 된 경로 전달 합니다 <xref:System.IO.Path.GetDirectoryName%2A> 메서드는 결과 문자열에 대 한 후속 호출 당 하나의 폴더 수준의 잘림이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-298">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="3f07d-299">예를 들어, "C:\Directory\SubDirectory\test.txt" 경로에 전달 된 <xref:System.IO.Path.GetDirectoryName%2A> 메서드는 "C:\Directory\SubDirectory"를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-299">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="3f07d-300">해당 문자열이 "C:\Directory\SubDirectory" 전달 <xref:System.IO.Path.GetDirectoryName%2A> "C:\Directory" 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-300">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="3f07d-301">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-301">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-302">다음 예제는 `GetDirectoryName` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-302">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-303"><paramref name="path" /> 매개 변수가 잘못된 문자를 포함하거나, 비어 있거나, 공백만 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-303">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="3f07d-304"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-304">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="3f07d-305"><paramref name="path" /> 매개변수가 시스템에 정의된 최대 길이보다 깁니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-305">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-306">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-306">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-307">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-307">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-308">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-308">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-309">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-309">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-310">확장명을 가져올 파일 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-310">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="3f07d-311">읽기 전용 문자 범위로 표시되는 파일 경로의 확장명을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-311">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3f07d-312">지정된 경로(마침표 “.” 포함)의 확장명 또는 <paramref name="path" />에 확장명 정보가 없는 경우 <see cref="P:System.ReadOnlySpan`1.Empty" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-312">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="3f07d-313">이 메서드는 확장명을 가져옵니다 `path` 를 검색 하 여 `path` 동안 ("."), 읽기 전용 범위에서 마지막 문자에서 시작 하 고 해당 첫 번째 문자까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-313">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="3f07d-314">잠시 전에 발견 되는 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar> 문자, 후, 기간 및 문자를 포함 하는 반환 된 읽기 전용 범위가 고, 그렇지 <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-314">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-315">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-315">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-316">확장명을 가져올 경로 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-316">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="3f07d-317">지정된 경로 문자열에서 확장명을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-317">Returns the extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="3f07d-318">"."(마침표)를 포함한 지정된 경로의 확장명, <see langword="null" /> 또는 <see cref="F:System.String.Empty" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-318">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="3f07d-319"><paramref name="path" />이(가) <see langword="null" />이면, <see cref="M:System.IO.Path.GetExtension(System.String)" />은(는) <see langword="null" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-319">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="3f07d-320"><paramref name="path" />에 확장명 정보가 없는 경우 <see cref="M:System.IO.Path.GetExtension(System.String)" />은(는) <see cref="F:System.String.Empty" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-320">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="3f07d-321">이 메서드는 확장명을 가져옵니다 `path` 를 검색 하 여 `path` 마침표 (.)의 마지막 문자를 사용 하 여 시작에 대 한 `path` 첫 번째 문자까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-321">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="3f07d-322">잠시 전에 발견 되는 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar> 뒤; 기간 및 문자를 포함 하는 반환 되는 문자열 문자이 고, 그렇지 <xref:System.String.Empty?displayProperty=nameWithType> 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="3f07d-323">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-323">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="3f07d-324">다음 예제는 `GetExtension` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-324">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-325"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-325"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-326">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-326">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-327">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-327">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-328">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-328">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-329">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-329">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-330">파일 이름과 확장명을 가져올 경로를 포함하는 읽기 전용 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-330">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="3f07d-331">읽기 전용 문자 범위로 표시되는 파일 경로의 파일 이름 및 확장명을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-331">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3f07d-332"><paramref name="path" />에서 마지막 디렉터리 구분 문자 뒤의 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-332">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="3f07d-333">반환 된 읽기 전용 범위에서 마지막 구분 기호를 수행 하는 경로 문자가 `path`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-333">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="3f07d-334">하는 경우의 마지막 문자 `path` 메서드는 반환 디렉터리나 볼륨 구분 기호 문자는 <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithtype>합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-334">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithtype>.</span></span> <span data-ttu-id="3f07d-335">하는 경우 `path` 메서드는 반환 없음 구분 기호 문자를 포함 `path`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-335">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-336">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-336">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-337">파일 이름과 확장명을 가져올 경로 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-337">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="3f07d-338">지정된 경로 문자열에서 파일 이름과 확장명을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-338">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="3f07d-339"><paramref name="path" />에서 마지막 디렉터리 구분 문자 뒤의 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-339">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="3f07d-340"><paramref name="path" />의 마지막 문자가 디렉터리나 볼륨 구분 문자이면 이 메서드는 <see cref="F:System.String.Empty" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-340">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="3f07d-341"><paramref name="path" />이(가) <see langword="null" />이면 이 메서드는 <see langword="null" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-341">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="3f07d-342">반환된 된 값이 `null` 파일 경로 이면 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-342">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="3f07d-343">시작 파일 이름 부분을 확인 하는 데 구분 기호 문자 <xref:System.IO.Path.DirectorySeparatorChar> 고 <xref:System.IO.Path.AltDirectorySeparatorChar>입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-343">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="3f07d-344">때문에 *\\* Unix에서 올바른 파일 이름이 `GetFileName` Unix 기반 플랫폼에서 실행 되는 Windows에서 파일 이름을 올바르게 반환 없습니다 =와 같은 기반된 경로 *c:\\mydir\\myfile.ext*, 하지만 `GetFileName` 와 같은 Unix 기반 경로에서 Windows 기반 플랫폼에서 실행 파일 이름을 올바르게 반환할 수 있습니다 */tmp/myfile.ext*이므로의 동작을 `GetFileName` 메서드는 하지 엄격 하 게 Unix 및 Windows 기반 플랫폼에서 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-344">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows=based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="3f07d-345">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-345">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-346">다음 예제에서는 동작을 보여 줍니다.는 `GetFileName` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-346">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-347"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-347"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-348">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-348">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-349">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-349">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-350">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-350">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-351">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-351">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-352">확장명 없이 파일 이름을 가져올 경로를 포함하는 읽기 전용 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-352">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="3f07d-353">읽기 전용 문자 범위로 표시되는 파일 경로의 확장명 없는 파일 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-353">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3f07d-354">마지막 마침표(.)와 그다음에 나오는 모든 문자를 제외한 <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />에서 반환된 읽기 전용 범위의 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-354">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-355">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-355">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-356">파일의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-356">The path of the file.</span></span></param>
        <summary><span data-ttu-id="3f07d-357">확장명 없이 지정된 경로 문자열의 파일 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-357">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="3f07d-358">마지막 마침표(.)와 그 다음에 나오는 모든 문자인 <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />에서 반환한 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-358">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-359">이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-359">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="3f07d-360">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-360">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-361">다음 예제를 사용 하는 방법을 보여 줍니다는 `GetFileNameWithoutExtension` 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-361">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-362"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-362"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-363">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-363">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-364">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-364">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-365">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-365">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-366">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-366">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-367">절대 경로 정보를 가져올 파일 또는 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-367">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="3f07d-368">지정된 경로 문자열에 대한 절대 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-368">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="3f07d-369">"C:\MyFile.txt"처럼 <paramref name="path" />의 정규화된 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-369">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="3f07d-370">시스템에서 파일 또는 디렉터리를 찾는 데 필요한 모든 정보를 포함 하는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-370">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="3f07d-371">파일 또는 지정 된 디렉터리가 `path` 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-371">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="3f07d-372">예를 들어 경우 *c:\temp\newdir* 은 현재 디렉터리 호출 `GetFullPath` 와 같은 파일 이름을 *test.txt* 반환 *c:\temp\newdir\test.txt*합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-372">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="3f07d-373">파일이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-373">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="3f07d-374">경우 `path` 상대 경로이 오버 로드에 현재 드라이브 및 현재 디렉터리에 기반 할 수 있습니다 하는 정규화 된 경로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-374">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="3f07d-375">응용 프로그램을 실행할 때 현재 디렉터리와 현재 드라이브 언제 든 지 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-375">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="3f07d-376">결과적으로,이 오버 로드에서 반환 하는 경로가 사전에 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-376">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="3f07d-377">명확한 경로 반환 하려면 호출을 <xref:System.IO.Path.GetFullPath(System.String,System.String)> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-377">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="3f07d-378">호출할 수도 있습니다는 <xref:System.IO.Path.IsPathFullyQualified%2A> 이거나 상대 경로 경로 정규화 된 여부를 결정 하는 방법 및 여부에 대 한 호출 `GetFullPath` 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-378">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="3f07d-379">그러나 경우 `path` 없으면 호출자에 대 한 경로 정보를 얻을 수 있는 권한이 있어야 합니다. `path`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-379">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="3f07d-380">멤버는 대부분 달리는 <xref:System.IO.Path> 클래스,이 메서드는 파일 시스템에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-380">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="3f07d-381">이 메서드는 현재 디렉터리와 현재 볼륨 정보를 사용 하 여 정규화 `path`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-381">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="3f07d-382">파일을 지정 하는 경우에 이름을 `path`, `GetFullPath` 현재 디렉터리의 정규화 된 경로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-382">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="3f07d-383">짧은 파일 이름에 전달 하는 경우 긴 파일 이름으로 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-383">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="3f07d-384">경로 중요 한 문자가 없는 경우 사용할 수 없는 하나 이상 포함 되어 있지 않으면 "." 문자 뒤에 공백 개수에 관계 없이 로 구문 분석 됩니다 "."또는"..".</span><span class="sxs-lookup"><span data-stu-id="3f07d-384">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="3f07d-385">.NET core 1.1 및 이후 버전 및.NET Framework 4.6.2 및 이상 버전도 같은 장치 이름을 포함 하는 경로 지원 "\\? \C:\"합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-385">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="3f07d-386">Windows에서 파일 경로 형식에 대 한 자세한 내용은 참조 하세요. [Windows 시스템에서 파일 경로 형식](~/docs/standard/io/file-path-formats.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-386">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="3f07d-387">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-387">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="3f07d-388">다음 예제는 `GetFullPath` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-388">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-389"><paramref name="path" />가 길이가 0인 문자열이거나 공백만 포함하거나 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 하나 이상의 잘못된 문자를 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-389"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="3f07d-390">또는</span><span class="sxs-lookup"><span data-stu-id="3f07d-390">-or-</span></span> 
<span data-ttu-id="3f07d-391">절대 경로를 검색할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-391">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3f07d-392">호출자에게 필요한 사용 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-392">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f07d-393"><paramref name="path" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-393"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3f07d-394"><paramref name="path" />에 볼륨 식별자(예: "c:\\")의 일부가 아닌 콜론(":")이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-394"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="3f07d-395">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-395">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="3f07d-396">경로에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-396">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-397">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-397">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-398">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-398">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-399">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-399">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-400">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-400">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-401"><see paramref="basePath" />에 연결할 상대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-401">A relative path to concatenate to <see paramref="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="3f07d-402">정규화된 경로의 시작입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-402">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="3f07d-403">정규화된 기본 경로의 절대 경로와 상대 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-403">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="3f07d-404">절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-404">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="3f07d-405">하는 경우 `path` 메서드는 빈 경로 `basePath`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-405">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="3f07d-406">하는 경우 `path` 메서드에 전달 하는 정규화 된 경로가 `path` 에 <xref:System.IO.Path.GetFullPath(System.String)> 메서드 결과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-406">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="3f07d-407">이 메서드를 사용 하 여 결정적 경로 지정된 된 볼륨을 기반으로 하며 상대 경로 사용 하는 경우 디렉터리를 루트 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-407">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="3f07d-408">미리 정의 된를 사용 하 여 `basePath` 현재 드라이브 및 디렉터리에서 예기치 않은 변경 사항으로 인해 불필요 한 파일 경로 대 한 현재 드라이브 디렉터리 가드에 기반 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-408">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="3f07d-409">예제</span><span class="sxs-lookup"><span data-stu-id="3f07d-409">Example</span></span>

<span data-ttu-id="3f07d-410">다음 예에서는 변수를 정의 `basePath`를 응용 프로그램의 현재 디렉터리를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-410">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="3f07d-411">그런 다음 전달 하는 `GetFullPath` 응용 프로그램의 데이터 디렉터리로 정규화 된 경로 가져올 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-411">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f07d-412"><paramref name="path" /> 또는 <paramref name="basePath" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-412"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-413"><paramref name="basePath" />는 정규화된 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-413"><paramref name="basePath" /> is not a fully qualified path.</span></span>
<span data-ttu-id="3f07d-414">또는 <paramref name="path" />나 <paramref name="basePath" />에 U+0000과 같은 잘못된 경로 문자가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-414">-or- <paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f07d-415">파일 이름에 사용할 수 없는 문자가 포함된 배열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-415">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="3f07d-416">파일 이름에 사용할 수 없는 문자가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-416">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-417">이 메서드에서 반환 된 배열 전체 파일 및 디렉터리 이름에 잘못 된 문자 집합을 포함 하는 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-417">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="3f07d-418">전체 집합이 잘못 된 문자는 파일 시스템에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-418">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="3f07d-419">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 있습니다/유니코드 문자 1-31, 뿐만 아니라 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-419">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-420">다음 예제는 <xref:System.IO.Path.GetInvalidFileNameChars%2A> 메서드 및 <xref:System.IO.Path.GetInvalidPathChars%2A> 잘못 된 문자를 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-420">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f07d-421">경로 이름에 사용할 수 없는 문자가 포함된 배열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-421">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="3f07d-422">파일 이름에 사용할 수 없는 문자가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-422">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-423">이 메서드에서 반환 된 배열 전체 파일 및 디렉터리 이름에 잘못 된 문자 집합을 포함 하는 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-423">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="3f07d-424">전체 집합이 잘못 된 문자는 파일 시스템에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-424">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="3f07d-425">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 있습니다/유니코드 문자 1-31, 뿐만 아니라 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-425">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-426">다음 예제는 <xref:System.IO.Path.GetInvalidFileNameChars%2A> 메서드 및 <xref:System.IO.Path.GetInvalidPathChars%2A> 잘못 된 문자를 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-426">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-427">루트 디렉터리 정보를 가져올 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-427">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="3f07d-428">지정된 문자 범위에 포함된 경로에서 루트 디렉터리 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-428">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="3f07d-429">`path`의 루트 디렉터리를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-429">A character span containing the root directory of `path`.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-430">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-430">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-431">루트 디렉터리 정보를 가져올 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-431">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="3f07d-432">지정된 경로의 루트 디렉터리 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-432">Gets the root directory information of the specified path.</span></span></summary>
        <returns><span data-ttu-id="3f07d-433"><paramref name="path" />의 루트 디렉터리이며, <paramref name="path" />가 <see langword="null" />인 경우 <see langword="null" />이며 <paramref name="path" />에 루트 디렉터리 정보가 포함되어 있지 않은 경우 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-433">The root directory of <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-434">이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-434">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="3f07d-435">이 메서드에서 반환 된 문자열에 대 한 가능한 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-435">Possible patterns for the string returned by this method are as follows:</span></span>  
  
- <span data-ttu-id="3f07d-436">빈 문자열 (`path` 현재 드라이브 또는 볼륨에 대 한 상대 경로 지정).</span><span class="sxs-lookup"><span data-stu-id="3f07d-436">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
- <span data-ttu-id="3f07d-437">"\" (`path` 현재 드라이브의 절대 경로 지정).</span><span class="sxs-lookup"><span data-stu-id="3f07d-437">"\" (`path` specified an absolute path on the current drive).</span></span>  
  
- <span data-ttu-id="3f07d-438">"X:" (`path` 여기서 X 나타냅니다 드라이브 또는 볼륨 문자를 드라이브에 대 한 상대 경로 지정).</span><span class="sxs-lookup"><span data-stu-id="3f07d-438">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
- <span data-ttu-id="3f07d-439">"X:\" (`path` 절대 경로가 지정된 된 드라이브에서 지정).</span><span class="sxs-lookup"><span data-stu-id="3f07d-439">"X:\" (`path` specified an absolute path on a given drive).</span></span>  
  
- <span data-ttu-id="3f07d-440">"\\\ComputerName\SharedFolder" (UNC 경로).</span><span class="sxs-lookup"><span data-stu-id="3f07d-440">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
- <span data-ttu-id="3f07d-441">"\\? \C:" (DOS 장치 경로.NET Core 1.1 이상 및.NET Framework 4.6.2 이상 버전에서 지원)</span><span class="sxs-lookup"><span data-stu-id="3f07d-441">"\\?\C:" (a DOS device path, supported in .NET Core 1.1 and later versions and in .NET Framework 4.6.2 and later versions)</span></span>
   
 <span data-ttu-id="3f07d-442">Windows에서 파일 경로에 대 한 자세한 내용은 참조 하세요. [Windows 시스템에서 파일 경로 형식](~/docs/standard/io/file-path-formats.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-442">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="3f07d-443">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-443">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## Examples  
 <span data-ttu-id="3f07d-444">다음 예제를 사용 하는 방법을 보여 줍니다는 `GetPathRoot` 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-444">The following example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-445"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-445"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="3f07d-446">또는</span><span class="sxs-lookup"><span data-stu-id="3f07d-446">-or-</span></span> 
 <span data-ttu-id="3f07d-447"><paramref name="path" />에 <see cref="F:System.String.Empty" />가 전달된 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-447"><see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-448">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-448">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-449">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-449">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-450">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-450">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-451">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-451">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f07d-452">임의의 폴더 이름 또는 파일 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-452">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="3f07d-453">임의의 폴더 이름 또는 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-453">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-454"><xref:System.IO.Path.GetRandomFileName%2A> 메서드는 폴더 이름 또는 파일 이름으로 사용할 수 있는 강력 하 게 암호화, 임의 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-454">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="3f07d-455">와 달리 <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> 파일을 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-455">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="3f07d-456">파일 시스템의 보안을 매우 중요 하지만,이 메서드 대신 사용 해야 <xref:System.IO.Path.GetTempFileName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-456">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-457">다음 예제에서 출력 보기는 <xref:System.IO.Path.GetRandomFileName%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-457">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="3f07d-458">결과 경로의 기준이 되는 소스 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-458">The source path the result should be relative to.</span></span> <span data-ttu-id="3f07d-459">이 경로는 항상 디렉터리로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-459">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="3f07d-460">대상 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-460">The destination path.</span></span></param>
        <summary><span data-ttu-id="3f07d-461">한 경로에서 다른 경로까지 상대 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-461">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="3f07d-462">상대 경로 또는 경로가 동일한 루트를 공유하지 않는 경우 <paramref name="path" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-462">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="3f07d-463">호출 하 여 경로로 확인 되는 <xref:System.IO.Path.GetFullPath%2A> 차이 계산 하기 전에 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-463">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="3f07d-464">현재 플랫폼에 대 한 기본 파일 경로 비교를 사용 하는 메서드 (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> Windows 및 MacOs 용 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> Linux에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-464">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f07d-465"><paramref name="relativeTo" /> 또는 <paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-465"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-466">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-466">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f07d-467">디스크에 크기가 0바이트인 고유한 이름의 임시 파일을 만들고 해당 파일의 전체 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-467">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="3f07d-468">임시 파일의 전체 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-468">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-469">이 방법을 사용 하 여 임시 파일을 만듭니다는 합니다. TMP 파일 확장명입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-469">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="3f07d-470">사용자의 임시 폴더 경로 내에서 임시 파일을 만들 반환한는 <xref:System.IO.Path.GetTempPath%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-470">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="3f07d-471">합니다 <xref:System.IO.Path.GetTempFileName%2A> 메서드를 발생 시킵니다는 <xref:System.IO.IOException> 이전 임시 파일을 삭제 하지 않고 65535 개 파일을 만들려면 사용 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="3f07d-471">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="3f07d-472">합니다 <xref:System.IO.Path.GetTempFileName%2A> 메서드를 발생 시킵니다는 <xref:System.IO.IOException> 고유한 임시 파일 이름은 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="3f07d-472">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="3f07d-473">이 오류를 해결 하려면 모든 필요 없는 임시 파일을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-473">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="3f07d-474">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-474">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="3f07d-475">사용할 수 있는 고유한 임시 파일 이름이 없는 경우와 같은 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-475">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="3f07d-476">또는</span><span class="sxs-lookup"><span data-stu-id="3f07d-476">-or-</span></span> 
<span data-ttu-id="3f07d-477">이 메서드로 임시 파일을 만들지 못한 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-477">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="3f07d-478">임시 디렉터리에 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-478">for writing to the temporary directory.</span></span> <span data-ttu-id="3f07d-479">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="3f07d-479">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-480">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-480">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-481">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-481">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-482">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-482">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f07d-483">현재 사용자의 임시 폴더 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-483">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="3f07d-484">백슬래시로 끝나는 임시 폴더 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-484">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-485">이 메서드는 다음 순서 대로 환경 변수의 존재 유무를 확인 하 고 찾은 첫 번째 경로 사용 하 여:</span><span class="sxs-lookup"><span data-stu-id="3f07d-485">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="3f07d-486">TMP 환경 변수로 지정 된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-486">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="3f07d-487">TEMP 환경 변수로 지정 된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-487">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="3f07d-488">USERPROFILE 환경 변수로 지정 된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-488">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="3f07d-489">Windows 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-489">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-490">다음 코드에서는 <xref:System.IO.Path.GetTempPath%2A> 메서드를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-490">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="3f07d-491">이 예제에서는 다음과 유사한 출력을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-491">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3f07d-492">호출자에게 필요한 사용 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-492">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="3f07d-493">환경 변수를 무제한으로 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-493">for unrestricted access to environment variables.</span></span> <span data-ttu-id="3f07d-494">연결 된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="3f07d-494">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-495">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-495">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-496">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-496">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-497">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-497">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-498">확장명을 검색할 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-498">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="3f07d-499">지정된 문자 범위로 표시되는 경로에 파일 이름 확장명이 포함되는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-499">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="3f07d-500">경로의 마지막 디렉터리 구분 문자 또는 볼륨 구분 기호 다음에 나오는 문자에 마침표(“.”)와 하나 이상의 문자가 차례로 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-500"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="3f07d-501">마침표 `path` 확장으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-501">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-502">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-502">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-503">확장명을 검색할 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-503">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="3f07d-504">경로에 파일 확장명이 포함된지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-504">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="3f07d-505">경로의 마지막 디렉터리 구분 문자(\\\ 또는 /) 또는 볼륨 구분 기호 문자(:) 다음에 나오는 문자에 마침표(.)와 하나 이상의 문자가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-505"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-506">끝에서 시작 `path`, 하나 이상의 문자 뒤에 마침표 (.)이이 메서드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-506">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="3f07d-507">이 패턴은 되기 전에 발견 되는 경우는 <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar> 문자가 발견 되는이 메서드가 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-507">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="3f07d-508">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-508">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-509">다음 예제에서는 `HasExtension` 메서드를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-509">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-510"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-510"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-511">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-511">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-512">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-512">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-513">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-513">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-514">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-514">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f07d-515"><see cref="T:System.IO.Path" /> 클래스의 멤버에 전달되는 경로 문자열 인수에 사용할 수 없는 플랫폼 특정 문자 배열을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-515">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-516">이 메서드에서 반환 된 배열 전체 파일 및 디렉터리 이름에 잘못 된 문자 집합을 포함 하는 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-516">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="3f07d-517">전체 집합이 잘못 된 문자는 파일 시스템에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-517">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="3f07d-518">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 있습니다/유니코드 문자 1-31, 뿐만 아니라 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-518">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3f07d-519">사용 하지 않는 <xref:System.IO.Path.InvalidPathChars> 경우 코드는 신뢰할 수 없는 코드와 동일한 응용 프로그램 도메인에서 실행 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-519">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="3f07d-520"><xref:System.IO.Path.InvalidPathChars> 배열 이므로 해당 요소를 덮어쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-520"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="3f07d-521">신뢰할 수 없는 코드의 요소를 덮어쓰면 <xref:System.IO.Path.InvalidPathChars>, 악용 될 수 있는 방식으로 작동 하지 코드 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-521">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-522">다음 예제에서는 사용 된 `InvalidPathChars` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-522">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-523">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-523">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-524">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-524">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-525">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-525">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="3f07d-526">파일 경로가 정규화되었는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-526">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="3f07d-527">오버 로드는 `IsPathFullyQualified` 둘 다 사용 하는 메서드 핸들 경로 <xref:System.IO.Path.DirectorySeparatorChar> 및 <xref:System.IO.Path.AltDirectorySeparatorChar> 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-527">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="3f07d-528">인수로 전달 되는 경로에 모든 유효성 검사를 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-528">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="3f07d-529">Uri 상대 경로로 해석 되 고 반환 결과적으로, `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-529">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="3f07d-530">정규화 된 경로 차이가 (나타난 것 처럼 합니다 `IsPathFullyQualified` 메서드) 및 루트 경로 (나타난 것 처럼는 <xref:System.IO.Path.IsPathRooted%2A> 메서드).</span><span class="sxs-lookup"><span data-stu-id="3f07d-530">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="3f07d-531">A *정규화 된 경로* 하거나 *절대 경로* 항상 대상 파일 또는 디렉터리에는 특정 드라이브 또는 장치에서 정확한 경로 정의 하 고 현재 디렉터리를 현재 드라이브에 종속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-531">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="3f07d-532">Windows 시스템에서 예를 들어 *C:/users/user1/documents/reports/2019/january/highlights.pdf* c: 드라이브의 루트에서 대상 파일에 절대 경로 정의 *highlights.pdf*합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-532">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="3f07d-533">A *루트 경로* 시작 드라이브 또는 루트 디렉터리를 지정 하지만 (루트 디렉터리에서 루 팅) 하는 경우 현재 디렉터리 (드라이브를 지정된 하 여 루트) 하는 경우 또는 현재 드라이브에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-533">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="3f07d-534">다음 예제에서는 정규화 된 경로 및 루트 경로 간의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-534">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-535">파일 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-535">A file path.</span></span></param>
        <summary><span data-ttu-id="3f07d-536">지정된 문자 범위로 표시되는 파일 경로가 특정 드라이브 또는 UNC 경로에 고정되었는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-536">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="3f07d-537">경로가 특정 드라이브 또는 UNC 경로에 고정된 경우 <see langword="true" />이고, 경로가 현재 드라이브 또는 작업 디렉터리에 상대적인 경우 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-537"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-538">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-538">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-539">파일 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-539">A file path.</span></span></param>
        <summary><span data-ttu-id="3f07d-540">지정된 파일 경로가 특정 드라이브 또는 UNC 경로에 고정되었는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-540">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="3f07d-541">경로가 특정 드라이브 또는 UNC 경로에 고정된 경우 <see langword="true" />이고, 경로가 현재 드라이브 또는 작업 디렉터리에 상대적인 경우 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-541"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3f07d-542"><paramref name="path" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-542"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-543">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-543">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="3f07d-544">파일 경로에 루트가 포함되는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-544">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="3f07d-545">A **루트 경로** 파일 경로가 UNIC 경로 또는 특정 드라이브에 고정 되어 있는; 현재 드라이브 또는 작업 디렉터리를 기준으로 하는 경로 사용 하 여 대조 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-545">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="3f07d-546">예를 들어, Windows 시스템에서 루트 경로 (예: "\Documents") 백슬래시 또는 드라이브 문자 및 콜론 (예: "C:Documents")를 사용 하 여 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-546">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="3f07d-547">루트 경로 (즉, 정규화 된) 절대 또는 상대 경로일 수 있습니다는 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-547">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="3f07d-548">절대 루트 경로 특정 디렉터리를 드라이브의 루트에서 정규화 된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-548">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="3f07d-549">상대 루트 경로 드라이브를 지정 하지만 해당 정규화 된 경로가 현재 디렉터리에 대 한 해결.</span><span class="sxs-lookup"><span data-stu-id="3f07d-549">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="3f07d-550">다음 예제에서 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-550">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-551">테스트할 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-551">The path to test.</span></span></param>
        <summary><span data-ttu-id="3f07d-552">파일 경로를 나타내는 지정된 문자 범위가 루트를 포함하는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-552">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="3f07d-553"><paramref name="path" />에 루트가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-553"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-554">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-554">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="3f07d-555">테스트할 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-555">The path to test.</span></span></param>
        <summary><span data-ttu-id="3f07d-556">지정된 경로 문자열에 루트가 포함되는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-556">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="3f07d-557"><paramref name="path" />에 루트가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-557"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-558">합니다 <xref:System.IO.Path.IsPathRooted%2A> 메서드가 반환 `true` 첫 번째 문자 디렉터리 구분 기호 문자가 문자 인지와 같은 "\\", 경로 드라이브 문자와 콜론 (:)으로 시작 하는 경우 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-558">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="3f07d-559">예를 들어 반환 `true` 에 대 한 `path` 와 같은 문자열 "\\\MyDir\\\MyFile.txt", "c:\\\MyDir", 또는 "C:MyDir"입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-559">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="3f07d-560">반환 `false` 에 대 한 `path` "MyDir"와 같은 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-560">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="3f07d-561">이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-561">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="3f07d-562">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-562">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="3f07d-563">다음 예제에서는 방법을 `IsPathRooted` 세 개의 문자열을 테스트 하려면 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-563">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3f07d-564"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="3f07d-564"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-565">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-565">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-566">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-566">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-567">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-567">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-568">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-568">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="3f07d-569">조인할 첫 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-569">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="3f07d-570">조인할 두 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-570">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="3f07d-571">두 경로 구성 요소를 단일 경로로 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-571">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="3f07d-572">결합된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-572">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="3f07d-573">이 메서드를 단순히 연결 `path` 하 고 `path2` 끝에 있는 이미 있지 않은 경우 두 개의 경로 구성 요소 간에 디렉터리 구분 문자를 추가 하 고 `path1` 의 시작 이나 `path2`합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-573">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="3f07d-574">경우는 <xref:System.ReadOnlySpan%601.Length> 중 `path1` 또는 `path2` 가 0 이면 메서드는 다른 경로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-574">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="3f07d-575">경우는 <xref:System.ReadOnlySpan%601.Length> 둘 다의 `path1` 하 고 `path2` 가 0 이면 메서드는 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-575">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="3f07d-576">하는 경우 `path1` 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Join` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 것을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-576">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="3f07d-577">Windows 백슬래시를 사용 하는 하드 코드 된 경로에서이 문제가 발생 합니다 ("\") 문자를 경로 구분 기호로 Unix 기반 시스템에서 인식 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-577">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="3f07d-578">이 문제를 해결 하려면 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-578">To work around this issue, you can:</span></span>

- <span data-ttu-id="3f07d-579">값을 검색 합니다 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 디렉터리 구분 문자를 하드 코딩 하는 것이 아니라 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-579">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="3f07d-580">디렉터리 구분 기호로 슬래시 ("/")를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-580">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="3f07d-581">이 문자에서 반환 되는 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Unix 기반 시스템 및 속성을 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> Windows 시스템에서 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-581">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="3f07d-582">달리 합니다 <xref:System.IO.Path.Combine%2A> 메서드는 <xref:System.IO.Path.Join%2A> methhod 반환 된 경로 루트를 시도 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-582">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> methhod does not attempt to root the returned path.</span></span> <span data-ttu-id="3f07d-583">(즉, `path2` 절대 경로 합니다 `Join` 메서드는 삭제 하지 않습니다 `path1` 반환 `path2` 으로 <xref:System.IO.Path.Combine%2A> 메서드는.) 다음 예제에서는 두 가지 방법으로 반환 된 경로에서 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-583">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="3f07d-584">경우 원인을 `path2` 사용자 입력이를 <xref:System.IO.Path.Combine%2A> 메서드를 사용 하면 파일 시스템 리소스에 액세스 하는 사용자 (같은 *c: /사용자/User1/문서/재무/* 예제의 경우) 응용 프로그램에서 수행한 액세스할 수 있도록 하려는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-584">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of hte example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="3f07d-585">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Join` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-585">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="3f07d-586">예를 들어 while `Path.Join("c:\\", "*.txt")` 있습니다 수 잘못 된 경우 파일을 만드는 것이 올바른 검색 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-586">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="3f07d-587">`Join` 메서드 따라서 성공적으로 해석 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-587">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="3f07d-588">예제</span><span class="sxs-lookup"><span data-stu-id="3f07d-588">Example</span></span>

<span data-ttu-id="3f07d-589">다음 예제에서 반환 된 경로에서 차이점을 보여 줍니다.는 <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> 고 <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-589">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="3f07d-590">첫 번째 문자열은 드라이브 및 루트 디렉터리를 포함 하는 정규화 된 경로 두 번째는 첫 번째 경로에서 상대 경로 두 메서드는 동일한 결과 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-590">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="3f07d-591">두 번째와 세 번째 호출에서는 `ShowPathInformation` 메서드를 두 가지 방법으로 반환 된 문자열을 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-591">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="3f07d-592">두 번째 메서드 호출에서 첫 번째 문자열 인수는 드라이브, 두 번째는 루트 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-592">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="3f07d-593">`Join` 두 문자열을 연결 하는 메서드 및 유지 중복 경로 구분 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-593">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="3f07d-594">`Combine` 메서드 드라이브를 중단 하 고 현재 드라이브에서 루트 디렉터리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-594">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="3f07d-595">C:\ 드라이브에는 응용 프로그램의 현재 문자열은 파일이 나 디렉터리의 파일을 사용 하 고 c: d: 대신에 액세스 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-595">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="3f07d-596">마지막으로, 때문에 세 번째 호출에서 두 인수 `ShowPathInformation` 루 팅 된를 `Join` 메서드에서 단순히 추가 동안 무의미 파일 경로 만들 수는 `Combine` 메서드 첫 번째 문자열을 삭제 anmd 두 번째 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-596">Finally, becasue both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string anmd returns the second.</span></span> <span data-ttu-id="3f07d-597">파일 액세스 수 있도록 응용 프로그램에 대 한이 문자열을 사용 하 여 중요 한 파일에 대 한 의도 하지 않은 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-597">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-598">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-598">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="3f07d-599">조인할 첫 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-599">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="3f07d-600">조인할 두 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-600">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="3f07d-601">조인할 세 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-601">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="3f07d-602">세 개의 경로 구성 요소를 단일 경로로 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-602">Concatenates three path components into a single path.</span></span></summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="3f07d-603">이 메서드를 단순히 연결 `path`, `path2`, 및 `path3` 표시 되어 있지 않으면 하는 경우 경로 구성 요소 간에 디렉터리 구분 문자를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-603">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="3f07d-604">경우는 <xref:System.ReadOnlySpan%601.Length> 하나라 `path1`, `path2`, 또는 `path3` 인수가 0 이면 메서드 contatenates 나머지 인수.</span><span class="sxs-lookup"><span data-stu-id="3f07d-604">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` argument is zero, the method contatenates the remaining arguments.</span></span> <span data-ttu-id="3f07d-605">경우는 <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> 가 0 이면 모든 구성 요소의 메서드 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-605">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>    

<span data-ttu-id="3f07d-606">하는 경우 `path1` 또는 `path2` 는 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Join` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 것을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-606">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="3f07d-607">Windows 백슬래시를 사용 하는 하드 코드 된 경로에서이 문제가 발생 합니다 ("\") 문자를 경로 구분 기호로 Unix 기반 시스템에서 인식 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-607">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="3f07d-608">이 문제를 해결 하려면 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-608">To work around this issue, you can:</span></span>

- <span data-ttu-id="3f07d-609">값을 검색 합니다 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 디렉터리 구분 문자를 하드 코딩 하는 것이 아니라 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-609">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="3f07d-610">디렉터리 구분 기호로 슬래시 ("/")를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-610">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="3f07d-611">이 문자에서 반환 되는 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Unix 기반 시스템 및 속성을 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> Windows 시스템에서 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-611">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="3f07d-612">달리 합니다 <xref:System.IO.Path.Combine%2A> 메서드는 <xref:System.IO.Path.Join%2A> methhod 반환 된 경로 루트를 시도 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-612">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> methhod does not attempt to root the returned path.</span></span> <span data-ttu-id="3f07d-613">(즉, `path2` 또는 `path2` 절대 경로를 `Join` 메서드는 이전 경로를 삭제 하지 않습니다는 <xref:System.IO.Path.Combine%2A> 메서드는 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-613">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>  
  
<span data-ttu-id="3f07d-614">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Join` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-614">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="3f07d-615">예를 들어 while `Path.Join("c:\\", "temp", "*.txt")` 있습니다 수 잘못 된 경우 파일을 만드는 것이 올바른 검색 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-615">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="3f07d-616">`Join` 메서드 따라서 성공적으로 해석 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-616">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="3f07d-617">예제</span><span class="sxs-lookup"><span data-stu-id="3f07d-617">Example</span></span>

<span data-ttu-id="3f07d-618">다음 예제에서 반환 된 경로에서 차이점을 보여 줍니다.는 <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> 고 <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="3f07d-618">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="3f07d-619">첫 번째 문자열은 드라이브 및 루트 디렉터리를 포함 하는 정규화 된 경로 두 번째는 첫 번째 경로에서 상대 경로 두 메서드는 동일한 결과 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-619">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="3f07d-620">두 번째와 세 번째 호출에서는 `ShowPathInformation` 메서드를 두 가지 방법으로 반환 된 문자열을 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-620">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="3f07d-621">두 번째 메서드 호출에서 첫 번째 문자열 인수는 드라이브, 두 번째는 루트 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-621">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="3f07d-622">`Join` 두 문자열을 연결 하는 메서드 및 유지 중복 경로 구분 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-622">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="3f07d-623">에 대 한 호출을 <xref:System.IO.Path.GetFullPath%2A> 메서드는 중복을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-623">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="3f07d-624">`Combine` 메서드 드라이브를 중단 하 고 현재 드라이브에서 루트 디렉터리를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-624">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="3f07d-625">C:\ 드라이브에는 응용 프로그램의 현재 문자열은 파일이 나 디렉터리의 파일을 사용 하 고 c: d: 대신에 액세스 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-625">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="3f07d-626">마지막으로, 때문에 세 번째 호출에서 마지막 인수 `ShowPathInformation` 루트 되는 `Join` 메서드 단순히 추가 무의미 파일 경로 만들려면 먼저 두 개의 인수를 하는 동안는 `Combine` anmd 반환 처음 두 문자열을 삭제 하는 메서드 세 번째입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-626">Finally, becasue the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings anmd returns the third.</span></span> <span data-ttu-id="3f07d-627">파일 액세스 수 있도록 응용 프로그램에 대 한이 문자열을 사용 하 여 중요 한 파일에 대 한 의도 하지 않은 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-627">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-628">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-628">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f07d-629">환경 변수에서 경로 문자열을 구분하는 데 사용되는 플랫폼 특정 구분 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-629">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-630">Windows 기반 데스크톱 플랫폼에서이 필드의 값에 세미콜론 (;) 기본적으로 하지만 다른 플랫폼에서 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-630">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-631">다음 예제에서는 사용 된 `PathSeparator` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-631">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-632">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-632">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-633">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-633">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-634">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-634">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="3f07d-635">개별 경로 구성 요소를 미리 할당된 문자 범위로 연결하려고 시도하고 작업이 성공했는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-635">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="3f07d-636">대상 문자 범위를 충분히 수용할 concatentated 경로 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-636">The destination character span must be large enough to hold the concatentated path.</span></span> <span data-ttu-id="3f07d-637">연결 된 경로 호출 하 여 검색할 수 있습니다는 <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> 메서드를 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-637">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="3f07d-638">조인할 첫 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-638">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="3f07d-639">조인할 두 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-639">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="3f07d-640">연결된 경로를 포함할 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-640">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="3f07d-641">메서드가 반환하는 경우 <paramref name="destination" />에 기록된 문자 수를 나타내는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-641">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="3f07d-642">두 개의 경로 구성 요소를 미리 할당된 단일 문자 범위로 연결하려고 시도하고 작업이 성공했는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-642">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="3f07d-643">연결 작업이 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-643"><see langword="true" /> if the concatentation operaton is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="3f07d-644">`destination` concatentated 경로 포함할 수 있는 크기 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-644">`destination` must be large enough to hold the concatentated path.</span></span> <span data-ttu-id="3f07d-645">연결 된 경로 호출 하 여 검색할 수 있습니다는 <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> 메서드를 예로 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-645">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-646">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-646">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="3f07d-647">조인할 첫 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-647">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="3f07d-648">조인할 두 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-648">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="3f07d-649">조인할 세 번째 경로를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-649">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="3f07d-650">연결된 경로를 포함할 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-650">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="3f07d-651">메서드가 반환하는 경우 <paramref name="destination" />에 기록된 문자 수를 나타내는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-651">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="3f07d-652">두 개의 경로 구성 요소를 미리 할당된 단일 문자 범위로 연결하려고 시도하고 작업이 성공했는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-652">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="3f07d-653">연결 작업이 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-653"><see langword="true" /> if the concatentation operaton is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="3f07d-654">`destination` concatentated 경로 포함할 수 있는 크기 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-654">`destination` must be large enough to hold the concatentated path.</span></span> <span data-ttu-id="3f07d-655">연결 된 경로 호출 하 여 검색할 수 있습니다는 <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> 메서드를 예로 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-655">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="3f07d-656">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="3f07d-656">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f07d-657">플랫폼 특정 볼륨 구분 기호 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-657">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f07d-658">이 필드의 값은 Windows 및 Macintosh 및 UNIX 운영 체제에서 슬래시 (/)에 콜론 (:).</span><span class="sxs-lookup"><span data-stu-id="3f07d-658">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="3f07d-659">예: "c:\windows" 또는 "MacVolume:System 폴더" 경로 구문 분석에 가장 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-659">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f07d-660">다음 예제에서는 사용 된 `VolumeSeparatorChar` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="3f07d-660">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="3f07d-661">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="3f07d-661">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="3f07d-662">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="3f07d-662">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="3f07d-663">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="3f07d-663">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>