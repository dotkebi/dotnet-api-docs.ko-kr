<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="907d850ea1900b2568962d72ccba9e30501a6d99" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57935330" /></Metadata><TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StreamReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b790f-101">특정 인코딩의 바이트 스트림에서 문자를 읽는 <see cref="T:System.IO.TextReader" />를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-101">Implements a <see cref="T:System.IO.TextReader" /> that reads characters from a byte stream in a particular encoding.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-102"><xref:System.IO.StreamReader> 특정 인코딩에서 문자 입력 반면 용인지를 <xref:System.IO.Stream> 클래스는 바이트 입력 및 출력용으로 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-102"><xref:System.IO.StreamReader> is designed for character input in a particular encoding, whereas the <xref:System.IO.Stream> class is designed for byte input and output.</span></span> <span data-ttu-id="b790f-103">사용 하 여 <xref:System.IO.StreamReader> 표준 텍스트 파일에서 줄 정보를 읽기 위한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-103">Use <xref:System.IO.StreamReader> for reading lines of information from a standard text file.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b790f-104">이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-104">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="b790f-105">형식을 사용 하 여 마쳤으면 직접 또는 간접적으로의 삭제 해야 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-105">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="b790f-106">직접 형식의 dispose 호출 해당 <xref:System.IDisposable.Dispose%2A> 의 메서드를 `try` / `catch` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-106">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="b790f-107">삭제 하지 직접, 언어 구문 같은 사용 `using` (C#에서) 또는 `Using` (Visual Basic에서는).</span><span class="sxs-lookup"><span data-stu-id="b790f-107">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="b790f-108">자세한 내용은 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하세요.를 <xref:System.IDisposable> 인터페이스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-108">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="b790f-109"><xref:System.IO.StreamReader> u t F-8 인코딩 현재 시스템의 ANSI 코드 페이지를 기본값으로 지정 하는 대신이 고, 그렇지 지정 하지 않으면 기본값은입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-109"><xref:System.IO.StreamReader> defaults to UTF-8 encoding unless specified otherwise, instead of defaulting to the ANSI code page for the current system.</span></span> <span data-ttu-id="b790f-110">U t F-8에서 유니코드 문자를 올바르게 처리 하 고 운영 체제의 언어 버전에서 일관 된 결과 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-110">UTF-8 handles Unicode characters correctly and provides consistent results on localized versions of the operating system.</span></span> <span data-ttu-id="b790f-111">사용 하 여 현재 문자 인코딩을 받게 되 면 합니다 <xref:System.IO.StreamReader.CurrentEncoding%2A> 속성 값이 될 때까지 신뢰할 수 있는 첫 번째 이후 <xref:System.IO.StreamReader.Read%2A> 메서드를으로 검색 되므로 인코딩 자동 감지를 처음으로 호출 될 때까지 <xref:System.IO.StreamReader.Read%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="b790f-111">If you get the current character encoding using the <xref:System.IO.StreamReader.CurrentEncoding%2A> property, the value is not reliable until after the first <xref:System.IO.StreamReader.Read%2A> method, since encoding auto detection is not done until the first call to a <xref:System.IO.StreamReader.Read%2A> method.</span></span>  
  
 <span data-ttu-id="b790f-112">기본적으로 <xref:System.IO.StreamReader> 은 스레드로부터 안전 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-112">By default, a <xref:System.IO.StreamReader> is not thread safe.</span></span> <span data-ttu-id="b790f-113">참조 <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> 스레드로부터 안전한 래퍼에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-113">See <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> for a thread-safe wrapper.</span></span>  
  
 <span data-ttu-id="b790f-114">합니다 <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 하 고 <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드로 지정 된 문자의 수를 읽고는 `count` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-114">The <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method overloads read and write the number of characters specified by the `count` parameter.</span></span> <span data-ttu-id="b790f-115">고유 해야 하는 이러한 <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> 및 <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>에 의해 지정 된 바이트 수를 읽고 있는 `count` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-115">These are to be distinguished from <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> and <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, which read and write the number of bytes specified by the `count` parameter.</span></span> <span data-ttu-id="b790f-116">사용 된 <xref:System.IO.BufferedStream> 읽기 및 쓰기는 정수를 바이트의 배열 요소에 대해서만 메서드.</span><span class="sxs-lookup"><span data-stu-id="b790f-116">Use the <xref:System.IO.BufferedStream> methods only for reading and writing an integral number of byte array elements.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b790f-117">읽을 때를 <xref:System.IO.Stream>를 보다 효율적으로 스트림의 내부 버퍼와 같은 크기로 사용 되는 버퍼를 사용할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-117">When reading from a <xref:System.IO.Stream>, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span>  
  
 <span data-ttu-id="b790f-118">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-118">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-119">다음 예에서는 인스턴스의 <xref:System.IO.StreamReader> 파일에서 텍스트를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-119">The following example uses an instance of <xref:System.IO.StreamReader> to read text from a file.</span></span> <span data-ttu-id="b790f-120">이 예제에서 사용 하는 생성자에서 사용 하 여 지원 되지 않습니다 [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 앱.</span><span class="sxs-lookup"><span data-stu-id="b790f-120">The constructor used in this example is not supported for use in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] Apps.</span></span>  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 <span data-ttu-id="b790f-121">다음 예제에서는 <xref:System.IO.StreamReader> 개체와 호출 해당 <xref:System.IO.StreamReader.ReadAsync%2A> 메서드를 비동기적으로 파일을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-121">The following example instantiates a <xref:System.IO.StreamReader> object and calls its <xref:System.IO.StreamReader.ReadAsync%2A> method to read a file asynchronously.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-122">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-122">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-123">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-123">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-124">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-124">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="b790f-125">방법: 새로 만든 데이터 파일 읽기 및 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-125">How to: Read and Write to a Newly Created Data File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b790f-126">지정된 스트림에 대한 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-126">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b790f-127">읽을 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-127">The stream to be read.</span></span></param>
        <summary><span data-ttu-id="b790f-128">지정된 스트림에 대한 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-128">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-129">이 생성자를 초기화 하는 인코딩 <xref:System.Text.UTF8Encoding>의 <xref:System.IO.StreamReader.BaseStream%2A> 사용 하 여 속성을 `stream` 매개 변수 및 내부 버퍼 크기를 1024 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-129">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding>, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="b790f-130">합니다 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 에 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-130">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b790f-131">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-131">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="b790f-132">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-132">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-133">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-133">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-134"><paramref name="stream" />이 읽기를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-134"><paramref name="stream" /> does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-135"><paramref name="stream" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-135"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-136">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-136">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-137">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-137">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-138">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-138">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b790f-139">읽을 전체 파일 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-139">The complete file path to be read.</span></span></param>
        <summary><span data-ttu-id="b790f-140">지정된 파일 이름에 대한 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-140">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-141">전체 파일 경로에서 지정 된 `path` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-141">The complete file path is specified by the `path` parameter.</span></span> <span data-ttu-id="b790f-142">이 생성자를 초기화 하는 인코딩 <xref:System.Text.UTF8Encoding> 및 버퍼 크기를 1024 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-142">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding> and the buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="b790f-143">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-143">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="b790f-144">`path` 매개 변수는 필요 하지 않습니다 파일로 디스크에 저장 된 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-144">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b790f-145">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-145">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="b790f-146">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-146">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-147">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-147">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-148"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-148"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-149"><paramref name="path" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-149"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b790f-150">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-150">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="b790f-151">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span><span class="sxs-lookup"><span data-stu-id="b790f-151">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b790f-152"><paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-152"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-153">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-153">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-154">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-154">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-155">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-155">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b790f-156">읽을 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-156">The stream to be read.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="b790f-157">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-157">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <summary><span data-ttu-id="b790f-158">지정한 바이트 순서 표시 검색 옵션을 사용하여 지정된 스트림으로 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-158">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified byte order mark detection option.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-159">이 생성자를 초기화 하는 인코딩 <xref:System.Text.UTF8Encoding>의 <xref:System.IO.StreamReader.BaseStream%2A> 사용 하 여 속성을 `stream` 매개 변수 및 내부 버퍼 크기를 1024 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-159">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding>, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="b790f-160">`detectEncodingFromByteOrderMarks` 매개 변수 스트림의 처음 4 바이트를 확인 하 여 인코딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-160">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="b790f-161">자동으로 인식 u t F-8, little endian 유니코드 big endian 유니코드, little endian UTF-32 big endian UTF-32 텍스트 파일을 적절 한 바이트 순서 표시를 사용 하 여 시작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b790f-161">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="b790f-162">자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b790f-162">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="b790f-163">합니다 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 에 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-163">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
 <span data-ttu-id="b790f-164">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-164">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-165">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-165">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-166"><paramref name="stream" />이 읽기를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-166"><paramref name="stream" /> does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-167"><paramref name="stream" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-167"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-168">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-168">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-169">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-169">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-170">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-170">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b790f-171">읽을 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-171">The stream to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="b790f-172">사용할 문자 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-172">The character encoding to use.</span></span></param>
        <summary><span data-ttu-id="b790f-173">지정된 문자 인코딩을 사용하여 지정된 스트림으로 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-173">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified character encoding.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-174">문자 인코딩은 의해 설정 됩니다는 `encoding` 매개 변수 및 버퍼 크기를 1024 바이트로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-174">The character encoding is set by the `encoding` parameter, and the buffer size is set to 1024 bytes.</span></span> <span data-ttu-id="b790f-175"><xref:System.IO.StreamReader> 스트림의 처음 4 바이트를 확인 하 여 인코딩을 검색을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-175">The <xref:System.IO.StreamReader> object attempts to  detect the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="b790f-176">자동으로 인식 u t F-8, little endian 유니코드 big endian 유니코드, little endian UTF-32 big endian UTF-32 텍스트 파일을 적절 한 바이트 순서 표시를 사용 하 여 시작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b790f-176">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="b790f-177">그렇지 않으면 사용자가 제공한 인코딩이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-177">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="b790f-178">자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b790f-178">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="b790f-179">합니다 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 에 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-179">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b790f-180">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-180">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="b790f-181">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-181">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-182">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-182">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-183"><paramref name="stream" />이 읽기를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-183"><paramref name="stream" /> does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-184"><paramref name="stream" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-184"><paramref name="stream" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-185">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-185">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-186">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-186">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-187">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-187">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b790f-188">읽을 전체 파일 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-188">The complete file path to be read.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="b790f-189">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-189">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <summary><span data-ttu-id="b790f-190">지정한 바이트 순서 표시 검색 옵션을 사용하여 지정한 파일 이름에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-190">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified byte order mark detection option.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-191">이 생성자를 초기화 하는 인코딩 <xref:System.Text.UTF8Encoding>의 <xref:System.IO.StreamReader.BaseStream%2A> 사용 하 여 속성을 `stream` 매개 변수 및 내부 버퍼 크기를 1024 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-191">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding>, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="b790f-192">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-192">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="b790f-193">`path` 매개 변수는 필요 하지 않습니다 파일로 디스크에 저장 된 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-193">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
 <span data-ttu-id="b790f-194">`detectEncodingFromByteOrderMarks` 매개 변수 스트림의 처음 4 바이트를 확인 하 여 인코딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-194">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="b790f-195">자동으로 인식 u t F-8, little endian 유니코드 big endian 유니코드, little endian UTF-32 big endian UTF-32 텍스트 파일을 적절 한 바이트 순서 표시를 사용 하 여 시작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b790f-195">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="b790f-196">그렇지 않은 경우는 <xref:System.Text.UTF8Encoding> 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-196">Otherwise, the <xref:System.Text.UTF8Encoding> is used.</span></span> <span data-ttu-id="b790f-197">자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b790f-197">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="b790f-198">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-198">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-199">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-199">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-200"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-200"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-201"><paramref name="path" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-201"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b790f-202">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-202">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="b790f-203">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span><span class="sxs-lookup"><span data-stu-id="b790f-203">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b790f-204"><paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-204"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-205">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-205">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-206">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-206">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-207">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-207">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b790f-208">읽을 전체 파일 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-208">The complete file path to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="b790f-209">사용할 문자 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-209">The character encoding to use.</span></span></param>
        <summary><span data-ttu-id="b790f-210">지정된 문자 인코딩을 사용하여 지정된 파일 이름에 대한 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-210">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified character encoding.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-211">이 생성자에 지정 된 대로 인코딩 초기화는 `encoding` 매개 변수 및 내부 버퍼 크기를 1024 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-211">This constructor initializes the encoding as specified by the `encoding` parameter, and the internal buffer size to 1024 bytes.</span></span> <span data-ttu-id="b790f-212"><xref:System.IO.StreamReader> 스트림의 처음 4 바이트를 확인 하 여 인코딩을 검색을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-212">The <xref:System.IO.StreamReader> object attempts to  detect the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="b790f-213">자동으로 인식 u t F-8, little endian 유니코드 big endian 유니코드, little endian UTF-32 big endian UTF-32 텍스트 파일을 적절 한 바이트 순서 표시를 사용 하 여 시작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b790f-213">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="b790f-214">그렇지 않으면 사용자가 제공한 인코딩이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-214">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="b790f-215">자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b790f-215">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="b790f-216">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-216">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="b790f-217">`path` 매개 변수는 필요 하지 않습니다 파일로 디스크에 저장 된 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-217">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b790f-218">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-218">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="b790f-219">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-219">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-220">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-220">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-221"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-221"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-222"><paramref name="path" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-222"><paramref name="path" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b790f-223">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-223">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="b790f-224">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span><span class="sxs-lookup"><span data-stu-id="b790f-224">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b790f-225"><paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-225"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-226">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-226">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-227">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-227">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-228">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-228">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b790f-229">읽을 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-229">The stream to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="b790f-230">사용할 문자 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-230">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="b790f-231">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-231">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <summary><span data-ttu-id="b790f-232">지정된 문자 인코딩과 바이트 순서 표시 검색 옵션을 사용하여 특정 스트림에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-232">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified character encoding and byte order mark detection option.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-233">이 생성자에 지정 된 대로 인코딩 초기화를 `encoding` 매개 변수를 <xref:System.IO.StreamReader.BaseStream%2A> 사용 하 여 속성을 `stream` 매개 변수 및 내부 버퍼 크기를 1024 바이트.</span><span class="sxs-lookup"><span data-stu-id="b790f-233">This constructor initializes the encoding as specified by the `encoding` parameter, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="b790f-234">`detectEncodingFromByteOrderMarks` 매개 변수 스트림의 처음 4 바이트를 확인 하 여 인코딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-234">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="b790f-235">자동으로 인식 u t F-8, little endian 유니코드 big endian 유니코드, little endian UTF-32 big endian UTF-32 텍스트 파일을 적절 한 바이트 순서 표시를 사용 하 여 시작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b790f-235">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="b790f-236">그렇지 않으면 사용자가 제공한 인코딩이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-236">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="b790f-237">자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b790f-237">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="b790f-238">합니다 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 에 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-238">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b790f-239">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-239">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="b790f-240">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-240">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-241">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-241">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-242"><paramref name="stream" />이 읽기를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-242"><paramref name="stream" /> does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-243"><paramref name="stream" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-243"><paramref name="stream" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-244">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-244">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-245">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-245">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-246">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-246">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b790f-247">읽을 전체 파일 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-247">The complete file path to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="b790f-248">사용할 문자 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-248">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="b790f-249">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-249">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <summary><span data-ttu-id="b790f-250">지정한 문자 인코딩과 바이트 순서 표시 검색 옵션을 사용하여 특정 파일 이름에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-250">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified character encoding and byte order mark detection option.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-251">이 생성자에 지정 된 대로 인코딩 초기화는 `encoding` 매개 변수 및 내부 버퍼 크기를 1024 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-251">This constructor initializes the encoding as specified by the `encoding` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="b790f-252">`detectEncodingFromByteOrderMarks` 매개 변수 스트림의 처음 4 바이트를 확인 하 여 인코딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-252">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="b790f-253">자동으로 인식 u t F-8, little endian 유니코드 big endian 유니코드, little endian UTF-32 big endian UTF-32 텍스트 파일을 적절 한 바이트 순서 표시를 사용 하 여 시작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b790f-253">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="b790f-254">그렇지 않으면 사용자가 제공한 인코딩이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-254">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="b790f-255">자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b790f-255">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="b790f-256">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-256">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="b790f-257">`path` 매개 변수는 필요 하지 않습니다 파일로 디스크에 저장 된 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-257">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b790f-258">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-258">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="b790f-259">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-259">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-260">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-260">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-261"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-261"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-262"><paramref name="path" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-262"><paramref name="path" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b790f-263">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-263">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="b790f-264">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span><span class="sxs-lookup"><span data-stu-id="b790f-264">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b790f-265"><paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-265"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-266">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-266">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-267">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-267">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-268">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-268">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b790f-269">읽을 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-269">The stream to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="b790f-270">사용할 문자 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-270">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="b790f-271">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-271">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="b790f-272">최소 버퍼 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-272">The minimum buffer size.</span></span></param>
        <summary><span data-ttu-id="b790f-273">지정된 문자 인코딩과 바이트 순서 표시 검색 옵션을 사용하여 특정 스트림에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-273">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified character encoding, byte order mark detection option, and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-274">버퍼 크기를 16 비트 문자 수에서는 설정한는 `bufferSize` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-274">The buffer size, in number of 16-bit characters, is set by the `bufferSize` parameter.</span></span> <span data-ttu-id="b790f-275">경우 `bufferSize` 작습니다. 최소 허용 크기는 최소 허용 크기 보다 (128 자).</span><span class="sxs-lookup"><span data-stu-id="b790f-275">If `bufferSize` is less than the minimum allowable size (128 characters), the minimum allowable size is used.</span></span>  
  
 <span data-ttu-id="b790f-276">이 생성자를 사용 하면 인코딩을에서 읽고 처음으로 변경할 수 있습니다는 <xref:System.IO.StreamReader> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-276">This constructor allows you to change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="b790f-277">`detectEncodingFromByteOrderMarks` 매개 변수 스트림의 처음 4 바이트를 확인 하 여 인코딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-277">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="b790f-278">자동으로 인식 u t F-8, little endian 유니코드 big endian 유니코드, little endian UTF-32 big endian UTF-32 텍스트 파일을 적절 한 바이트 순서 표시를 사용 하 여 시작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b790f-278">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="b790f-279">그렇지 않으면 사용자가 제공한 인코딩이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-279">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="b790f-280">자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b790f-280">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="b790f-281">합니다 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 에 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-281">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b790f-282">읽을 때를 <xref:System.IO.Stream>를 보다 효율적으로 스트림의 내부 버퍼와 같은 크기로 사용 되는 버퍼를 사용할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-282">When reading from a <xref:System.IO.Stream>, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b790f-283">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-283">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="b790f-284">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-284">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-285">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-285">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-286">스트림이 읽기를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-286">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-287"><paramref name="stream" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-287"><paramref name="stream" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b790f-288"><paramref name="bufferSize" />가 0보다 작거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-288"><paramref name="bufferSize" /> is less than or equal to zero.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-289">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-289">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-290">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-290">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-291">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-291">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b790f-292">읽을 전체 파일 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-292">The complete file path to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="b790f-293">사용할 문자 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-293">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="b790f-294">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-294">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="b790f-295">최소 버퍼 크기(16비트 문자 수)입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-295">The minimum buffer size, in number of 16-bit characters.</span></span></param>
        <summary><span data-ttu-id="b790f-296">지정된 문자 인코딩과 바이트 순서 표시 검색 옵션을 사용하여 특정 파일 이름에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-296">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified character encoding, byte order mark detection option, and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-297">이 생성자에 지정 된 대로 인코딩 초기화는 `encoding` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-297">This constructor initializes the encoding as specified by the `encoding` parameter.</span></span>  
  
 <span data-ttu-id="b790f-298">이 생성자를 사용 하면 인코딩을에서 읽고 처음으로 변경할 수 있습니다는 <xref:System.IO.StreamReader> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-298">This constructor allows you to change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="b790f-299">`detectEncodingFromByteOrderMarks` 매개 변수 스트림의 처음 4 바이트를 확인 하 여 인코딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-299">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="b790f-300">자동으로 인식 u t F-8, little endian 유니코드 big endian 유니코드, little endian UTF-32 big endian UTF-32 텍스트 파일을 적절 한 바이트 순서 표시를 사용 하 여 시작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b790f-300">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="b790f-301">그렇지 않으면 사용자가 제공한 인코딩이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-301">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="b790f-302">자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b790f-302">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="b790f-303">버퍼 크기를 16 비트 문자 수에서는 설정한는 `bufferSize` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-303">The buffer size, in number of 16-bit characters, is set by the `bufferSize` parameter.</span></span> <span data-ttu-id="b790f-304">경우 `bufferSize` 작습니다. 최소 허용 크기는 최소 허용 크기 보다 (128 자).</span><span class="sxs-lookup"><span data-stu-id="b790f-304">If `bufferSize` is less than the minimum allowable size (128 characters), the minimum allowable size is used.</span></span>  
  
 <span data-ttu-id="b790f-305">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-305">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="b790f-306">`path` 매개 변수는 필요 하지 않습니다 파일로 디스크에 저장 된 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-306">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b790f-307">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-307">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="b790f-308">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-308">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-309">다음 코드 예제에서는이 <xref:System.IO.StreamReader> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-309">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-310"><paramref name="path" />가 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-310"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-311"><paramref name="path" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-311"><paramref name="path" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="b790f-312">파일을 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-312">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="b790f-313">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span><span class="sxs-lookup"><span data-stu-id="b790f-313">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b790f-314"><paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-314"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b790f-315"><paramref name="buffersize" />가 0보다 작거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-315"><paramref name="buffersize" /> is less than or equal to zero.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-316">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-316">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-317">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-317">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-318">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-318">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b790f-319">읽을 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-319">The stream to read.</span></span></param>
        <param name="encoding"><span data-ttu-id="b790f-320">사용할 문자 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-320">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="b790f-321">파일의 시작 부분에서 바이트 순서 표시를 찾으려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-321"><see langword="true" /> to look for byte order marks at the beginning of the file; otherwise, <see langword="false" />.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="b790f-322">최소 버퍼 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-322">The minimum buffer size.</span></span></param>
        <param name="leaveOpen"><span data-ttu-id="b790f-323"><see cref="T:System.IO.StreamReader" /> 개체를 삭제한 후 스트림을 열어 두려면 <see langword="true" />이고, 닫으려면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-323"><see langword="true" /> to leave the stream open after the <see cref="T:System.IO.StreamReader" /> object is disposed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="b790f-324">지정된 문자 인코딩, 바이트 순서 표시 검색 옵션 및 버퍼 크기를 사용하여 특정 스트림에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화하며, 선택적으로 스트림을 연 상태로 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-324">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream based on the specified character encoding, byte order mark detection option, and buffer size, and optionally leaves the stream open.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-325">설정 하지 않으면 합니다 `leaveOpen` 매개 변수를 `true`의 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 에 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-325">Unless you set the `leaveOpen` parameter to `true`, the <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
 <span data-ttu-id="b790f-326">버퍼 크기를 16 비트 문자 수에서는 설정한는 `bufferSize` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-326">The buffer size, in number of 16-bit characters, is set by the `bufferSize` parameter.</span></span> <span data-ttu-id="b790f-327">경우 `bufferSize` 작습니다. 최소 허용 크기는 최소 허용 크기 보다 (128 자).</span><span class="sxs-lookup"><span data-stu-id="b790f-327">If `bufferSize` is less than the minimum allowable size (128 characters), the minimum allowable size is used.</span></span>  
  
 <span data-ttu-id="b790f-328">이 생성자를 사용 하면 인코딩을에서 읽고 처음으로 변경할 수 있습니다는 <xref:System.IO.StreamReader> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-328">This constructor enables you to change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="b790f-329">경우는 `detectEncodingFromByteOrderMarks` 매개 변수는 `true`, 생성자 스트림의 처음 4 바이트를 확인 하 여 인코딩을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-329">If the `detectEncodingFromByteOrderMarks` parameter is `true`, the constructor detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="b790f-330">자동으로 인식 u t F-8, little endian 유니코드 big endian 유니코드, little endian UTF-32 big endian UTF-32 텍스트 파일을 적절 한 바이트 순서 표시를 사용 하 여 시작 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b790f-330">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="b790f-331">그렇지 않으면 사용자가 제공한 인코딩이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-331">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="b790f-332">자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b790f-332">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b790f-333">읽을 때를 <xref:System.IO.Stream>를 보다 효율적으로 스트림의 내부 버퍼와 같은 크기로 사용 되는 버퍼를 사용할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-333">When reading from a <xref:System.IO.Stream>, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b790f-334">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 올바르게 해석할 수 있습니다 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-334">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpreted correctly, and could cause an exception to be thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b790f-335">내부 스트림을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-335">Returns the underlying stream.</span></span></summary>
        <value><span data-ttu-id="b790f-336">내부 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-336">The underlying stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-337">기본 스트림에 액세스 하려면이 속성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-337">You use this property to access the underlying stream.</span></span> <span data-ttu-id="b790f-338">합니다 <xref:System.IO.StreamReader> 중 하나를 호출 하는 경우 기본 스트림의 입력 버퍼 클래스는 <xref:System.IO.StreamReader.Read%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="b790f-338">The <xref:System.IO.StreamReader> class buffers input from the underlying stream when you call one of the <xref:System.IO.StreamReader.Read%2A> methods.</span></span> <span data-ttu-id="b790f-339">버퍼에 데이터를 읽은 후 기본 스트림의 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치와 일치 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-339">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="b790f-340">내부 버퍼를 다시 설정 하려면 호출는 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 경우 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-340">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span> <span data-ttu-id="b790f-341"><xref:System.IO.StreamReader> 있는 생성자는 `detectEncodingFromByteOrderMarks` 매개 변수는 인코딩을에서 읽고 처음으로 변경할 수는 <xref:System.IO.StreamReader> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-341">The <xref:System.IO.StreamReader> constructors that have the `detectEncodingFromByteOrderMarks` parameter can change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span>  
  
 <span data-ttu-id="b790f-342">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-342">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-343">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-343">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-344">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-344">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-345">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-345">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="streamReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b790f-346"><see cref="T:System.IO.StreamReader" /> 개체와 내부 스트림을 닫고 판독기와 관련된 모든 시스템 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-346">Closes the <see cref="T:System.IO.StreamReader" /> object and the underlying stream, and releases any system resources associated with the reader.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-347">이 메서드를 재정의 합니다 <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="b790f-347">This method overrides the <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b790f-348">이 구현의 <xref:System.IO.StreamReader.Close%2A> 호출을 <xref:System.IO.StreamReader.Dispose%2A> 전달 하는 메서드를 `true` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-348">This implementation of <xref:System.IO.StreamReader.Close%2A> calls the <xref:System.IO.StreamReader.Dispose%2A> method passing a `true` value.</span></span>  
  
 <span data-ttu-id="b790f-349">명시적으로 호출 하지 않으면 스트림을 내부 인코더가 플러시되지 것입니다 <xref:System.IO.StreamReader.Close%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-349">Flushing the stream will not flush its underlying encoder unless you explicitly call <xref:System.IO.StreamReader.Close%2A>.</span></span> <span data-ttu-id="b790f-350">설정 <xref:System.IO.StreamWriter.AutoFlush%2A> 에 `true` 스트림 버퍼에서 데이터를 플러시할 수는 있지만 인코더 상태는 플러시되지 있다는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-350">Setting <xref:System.IO.StreamWriter.AutoFlush%2A> to `true` means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="b790f-351">이 수는 다음 문자 블록을 올바르게 인코딩할 수 있도록 상태로 (부분 자)를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-351">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="b790f-352">이 시나리오는 UTF8 및 UTF7, 여기서 인코더는 인접 한 문자를 받은 후에 특정 문자를 인코딩할 수 있는 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-352">This scenario affects UTF8 and UTF7, where certain characters can be encoded only after the encoder receives the adjacent character or characters.</span></span>  
  
 <span data-ttu-id="b790f-353">호출한 다음 <xref:System.IO.StreamReader.Close%2A>, 판독기에 대 한 작업에는 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-353">Following a call to <xref:System.IO.StreamReader.Close%2A>, any operations on the reader might raise exceptions.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-354">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-354">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-355">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-355">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-356">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-356">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentEncoding : System.Text.Encoding" Usage="System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b790f-357">현재 <see cref="T:System.IO.StreamReader" /> 개체에서 사용 중인 현재 문자 인코딩을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-357">Gets the current character encoding that the current <see cref="T:System.IO.StreamReader" /> object is using.</span></span></summary>
        <value><span data-ttu-id="b790f-358">현재 판독기에서 사용하는 문자 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-358">The current character encoding used by the current reader.</span></span> <span data-ttu-id="b790f-359"><see cref="Overload:System.IO.StreamReader.Read" /> 메서드를 처음으로 호출할 때 인코딩이 자동으로 검색되므로 <see cref="T:System.IO.StreamReader" />의 <see cref="Overload:System.IO.StreamReader.Read" /> 메서드를 처음으로 호출하면 값이 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-359">The value can be different after the first call to any <see cref="Overload:System.IO.StreamReader.Read" /> method of <see cref="T:System.IO.StreamReader" />, since encoding autodetection is not done until the first call to a <see cref="Overload:System.IO.StreamReader.Read" /> method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-360">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-360">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-361">다음 코드 예제에서는 지정 된 인코딩을 가져옵니다 <xref:System.IO.StreamReader> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-361">The following code example gets the encoding of the specified <xref:System.IO.StreamReader> object.</span></span>  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-362">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-362">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-363">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-363">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-364">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-364">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberSignature Language="F#" Value="member this.DiscardBufferedData : unit -&gt; unit" Usage="streamReader.DiscardBufferedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b790f-365">내부 버퍼를 지웁니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-365">Clears the internal buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-366">사용 된 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 에 대 한 내부 버퍼를 다시 설정 하는 방법의 <xref:System.IO.StreamReader> 개체.</span><span class="sxs-lookup"><span data-stu-id="b790f-366">Use the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method to reset the internal buffer for the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="b790f-367">이 메서드를 호출 해야 할 경우에만 내부 버퍼의 위치 및 <xref:System.IO.StreamReader.BaseStream%2A> 일치 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-367">You need to call this method only when the position of the internal buffer and the <xref:System.IO.StreamReader.BaseStream%2A> do not match.</span></span> <span data-ttu-id="b790f-368">버퍼에 데이터를 읽고 다음 내부 스트림 내의 새 위치를 검색 하는 경우 해당이 위치는 일치 하지 않는 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-368">These positions can become mismatched when you read data into the buffer and then seek a new position in the underlying stream.</span></span> <span data-ttu-id="b790f-369">이 경우 성능이 저하 메서드와 콘텐츠의 일부를 읽고 싶은 경우와 같이 반드시 필요한 경우에 사용 해야는 <xref:System.IO.StreamReader> 개체를 한 번 이상.</span><span class="sxs-lookup"><span data-stu-id="b790f-369">This method slows performance and should be used only when absolutely necessary, such as when you want to read a portion of the contents of a <xref:System.IO.StreamReader> object more than once.</span></span>  
  
 <span data-ttu-id="b790f-370">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-370">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-371">다음 예제에서는 시나리오를 보여 줍니다. 여기서는 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 내부 버퍼 및 내부 스트림을 동기화 할 메서드를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-371">The following example shows a scenario where the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method must be called to synchronize the internal buffer and the underlying stream.</span></span> <span data-ttu-id="b790f-372">예제에서 파일 위치를 설명 하기 위해 사용 되 고 텍스트 이루어져 `abcdefghijklmnopqrstuvwxyz`합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-372">The file in the example is used to illustrate position and consists of the text `abcdefghijklmnopqrstuvwxyz`.</span></span> <span data-ttu-id="b790f-373">호출 하 여 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 예제 예상 대로 작동 데이터를 읽은 후 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-373">By calling <xref:System.IO.StreamReader.DiscardBufferedData%2A> after the data is read, the example works as expected.</span></span> <span data-ttu-id="b790f-374">처음 15 문자를 읽은 후 위치 2의 오프셋된 값을 다시 설정 되 고 나머지는 모든 문자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-374">After the first 15 characters are read, the position is reset to the offset value of 2 and all the remaining characters are read.</span></span> <span data-ttu-id="b790f-375">에 대 한 호출을 제거 하면 <xref:System.IO.StreamReader.DiscardBufferedData%2A>, 예제에는 예상 대로 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-375">If you remove the call to <xref:System.IO.StreamReader.DiscardBufferedData%2A>, the example does not work as expected.</span></span> <span data-ttu-id="b790f-376">첫 15 문자는 읽을 수 있지만 기본 스트림의 위치에만 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-376">The first 15 characters are read, but only the position of the underlying stream is reset.</span></span> <span data-ttu-id="b790f-377">내부 버퍼를 <xref:System.IO.StreamReader> 개체는 여전히 16 번째 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-377">The internal buffer of the <xref:System.IO.StreamReader> object is still on the 16th character.</span></span> <span data-ttu-id="b790f-378">따라서 <xref:System.IO.StreamReader.ReadToEnd%2A> 재설정 위치에서 시작 하는 기본 스트림에 문자 버퍼의 모든 문자를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-378">Therefore, <xref:System.IO.StreamReader.ReadToEnd%2A> returns all the characters in the buffer plus the characters in the underlying stream starting from the reset position.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-379">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-379">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-380">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-380">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-381">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-381">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="streamReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="b790f-382">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-382"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="b790f-383">내부 스트림을 닫고 <see cref="T:System.IO.StreamReader" />에서 사용하는 관리되지 않는 리소스를 해제하고 관리되는 리소스를 선택적으로 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-383">Closes the underlying stream, releases the unmanaged resources used by the <see cref="T:System.IO.StreamReader" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-384">이 메서드는 공용 <xref:System.IDisposable.Dispose%2A> 메서드 및 <xref:System.Object.Finalize%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="b790f-384">This method is called by the public <xref:System.IDisposable.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="b790f-385"><xref:System.IDisposable.Dispose%2A> 보호 된 호출 <xref:System.IO.StreamReader.Dispose%2A> 메서드는 `disposing` 매개 변수가 true로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-385"><xref:System.IDisposable.Dispose%2A> invokes the protected <xref:System.IO.StreamReader.Dispose%2A> method with the `disposing` parameter set to true.</span></span> <span data-ttu-id="b790f-386"><xref:System.Object.Finalize%2A> 호출 <xref:System.IO.StreamReader.Dispose%2A> 사용 하 여 `disposing` false로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-386"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.StreamReader.Dispose%2A> with `disposing` set to false.</span></span>  
  
 <span data-ttu-id="b790f-387">경우는 `disposing` 매개 변수가 `true`이 메서드 릴리스 관리 되는 모든 리소스를 보유 하는 개체는 <xref:System.IO.StreamReader> 개체 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-387">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that the <xref:System.IO.StreamReader> object references.</span></span> <span data-ttu-id="b790f-388">이 메서드는 참조되는 각 개체의 <xref:System.IDisposable.Dispose%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-388">This method invokes the <xref:System.IDisposable.Dispose%2A> method of each referenced object.</span></span>  
  
 <span data-ttu-id="b790f-389">.</span><span class="sxs-lookup"><span data-stu-id="b790f-389">.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="b790f-390">Dispose는 다른 개체에서 여러 번 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-390">Dispose can be called multiple times by other objects.</span></span> <span data-ttu-id="b790f-391">재정의 하는 경우 <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />삭제 [cref,...]에 대 한 이전 호출에서 삭제 된 개체를 참조 하지 않도록 주의 하십시오. 구현 하는 방법에 대 한 자세한 내용은 <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> 참조 [Dispose 메서드 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-391">When overriding <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to Dispose[cref,...]. For more information about how to implement <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="b790f-392">에 대 한 자세한 내용은 <see cref="M:System.IDisposable.Dispose" /> 하 고 <see cref="M:System.Object.Finalize" />를 참조 하세요 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-392">For more information about <see cref="M:System.IDisposable.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-393">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-393">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-394">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-394">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-395">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-395">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfStream : bool" Usage="System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b790f-396">현재 스트림 위치가 스트림의 끝에 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-396">Gets a value that indicates whether the current stream position is at the end of the stream.</span></span></summary>
        <value><span data-ttu-id="b790f-397">현재 스트림 위치가 스트림의 맨 끝에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-397"><see langword="true" /> if the current stream position is at the end of the stream; otherwise <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b790f-398">내부 스트림이 삭제된 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-398">The underlying stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.StreamReader" Usage="System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b790f-399">빈 스트림 주위의 <see cref="T:System.IO.StreamReader" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-399">A <see cref="T:System.IO.StreamReader" /> object around an empty stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-400">메서드는 호출을 읽을 때 <xref:System.IO.StreamReader.Null>, 0이 항상 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-400">When read methods are invoked on <xref:System.IO.StreamReader.Null>, zero is always returned.</span></span> <span data-ttu-id="b790f-401">때 <xref:System.IO.StreamReader.ReadLine%2A> 에서 호출 됩니다 <xref:System.IO.StreamReader.Null>, `null` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-401">When <xref:System.IO.StreamReader.ReadLine%2A> is invoked on <xref:System.IO.StreamReader.Null>, `null` is returned.</span></span>  
  
 <span data-ttu-id="b790f-402">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-402">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-403">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-403">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-404">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-404">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-405">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-405">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="streamReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b790f-406">사용할 수 있는 다음 문자를 반환하지만 사용하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-406">Returns the next available character but does not consume it.</span></span></summary>
        <returns><span data-ttu-id="b790f-407">읽을 다음 문자를 나타내는 정수이거나, 읽을 문자가 없거나 스트림에서 검색을 지원하지 않을 경우 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-407">An integer representing the next character to be read, or -1 if there are no characters to be read or if the stream does not support seeking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-408"><xref:System.IO.StreamReader.Peek%2A> 메서드 끝 파일 또는 다른 오류가 발생 했는지 여부를 확인 하기 위해 정수 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-408">The <xref:System.IO.StreamReader.Peek%2A> method returns an integer value in order to determine whether the end of the file, or another error has occurred.</span></span> <span data-ttu-id="b790f-409">이렇게 하면 사용자는 반환된 값은-1로 캐스팅 하기 전에 먼저 확인 하는 <xref:System.Char> 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-409">This allows a user to first check if the returned value is -1 before casting it to a <xref:System.Char> type.</span></span>  
  
 <span data-ttu-id="b790f-410">이 메서드는 <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-410">This method overrides <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b790f-411">현재 위치를 <xref:System.IO.StreamReader> 개체에 의해 변경 되지 <xref:System.IO.StreamReader.Peek%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-411">The current position of the <xref:System.IO.StreamReader> object is not changed by <xref:System.IO.StreamReader.Peek%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-412">다음 코드 예제에서는 파일의 끝에 도달할 때까지 파일에서 줄을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-412">The following code example reads lines from a file until the end of the file is reached.</span></span>  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b790f-413">I/O 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-413">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-414">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-414">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-415">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-415">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-416">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-416">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b790f-417">입력 스트림에서 다음 문자 또는 다음 문자 집합을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-417">Reads the next character or next set of characters from the input stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="streamReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b790f-418">입력 스트림에서 다음 문자를 읽고 문자 위치를 한 문자씩 앞으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-418">Reads the next character from the input stream and advances the character position by one character.</span></span></summary>
        <returns><span data-ttu-id="b790f-419"><see cref="T:System.Int32" /> 개체로 표시되는 입력 스트림의 다음 문자입니다. 사용할 수 있는 문자가 더 이상 없는 경우에는 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-419">The next character from the input stream represented as an <see cref="T:System.Int32" /> object, or -1 if no more characters are available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-420">이 메서드는 <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-420">This method overrides <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b790f-421">이 메서드는 스트림의 맨 끝에 도달한 경우-1을 반환할 수 있도록 하는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-421">This method returns an integer so that it can return -1 if the end of the stream has been reached.</span></span> <span data-ttu-id="b790f-422">버퍼에 데이터를 읽은 후 기본 스트림의 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치와 일치 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-422">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="b790f-423">내부 버퍼를 다시 설정 하려면 호출는 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 경우 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-423">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="b790f-424">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-424">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-425">다음 코드 예제는 간단한 사용 방법을 보여 줍니다는 <xref:System.IO.StreamReader.Read%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="b790f-425">The following code example demonstrates a simple use of the <xref:System.IO.StreamReader.Read%2A> method.</span></span>  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 <span data-ttu-id="b790f-426">다음 코드 예제를 사용 하 여 단일 문자를 읽는 방법을 보여 줍니다는 <xref:System.IO.StreamReader.Read> ASCII 정수 10 진수 및 16 진수 출력 형식 지정 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-426">The following code example demonstrates reading a single character using the <xref:System.IO.StreamReader.Read> method overload, formatting the ASCII integer output as decimal and hexadecimal.</span></span>  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b790f-427">I/O 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-427">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-428">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-428">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-429">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-429">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-430">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-430">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="streamReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="streamReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b790f-431">이 메서드는 지정된 문자 배열의 값이 <paramref name="index" />와 (<c>인덱스 + 카운트 - 1</c>) 사이에서 현재 원본로부터 읽어온 문자로 교체된 상태로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-431">When this method returns, contains the specified character array with the values between <paramref name="index" /> and (<c>index + count - 1</c>) replaced by the characters read from the current source.</span></span></param>
        <param name="index"><span data-ttu-id="b790f-432">쓰기를 시작할 <paramref name="buffer" />의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-432">The index of <paramref name="buffer" /> at which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="b790f-433">읽을 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-433">The maximum number of characters to read.</span></span></param>
        <summary><span data-ttu-id="b790f-434">현재 스트림에서 지정된 최대 문자를 지정된 인덱스부터 버퍼로 읽어 들입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-434">Reads a specified maximum of characters from the current stream into a buffer, beginning at the specified index.</span></span></summary>
        <returns><span data-ttu-id="b790f-435">읽은 문자 수를 반환하거나 스트림의 끝에 있고 읽은 데이터가 없으면 0을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-435">The number of characters that have been read, or 0 if at the end of the stream and no data was read.</span></span> <span data-ttu-id="b790f-436">이 수는 스트림 내에서 데이터를 사용할 수 있는지 여부에 따라 <paramref name="count" /> 매개 변수보다 작거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-436">The number will be less than or equal to the <paramref name="count" /> parameter, depending on whether the data is available within the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-437">이 메서드는 <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-437">This method overrides <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b790f-438">이 메서드는 스트림의 맨 끝에 도달한 경우 0을 반환할 수 있도록 하는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-438">This method returns an integer so that it can return 0 if the end of the stream has been reached.</span></span>  
  
 <span data-ttu-id="b790f-439">사용 하는 경우는 <xref:System.IO.StreamReader.Read%2A> 메서드 것이 버퍼는 내부 버퍼를 원하는 블록 크기 설정 되어 있는 스트림 내부 버퍼와 같은 크기를 사용 하 고 항상 블록 크기 보다 작은지를 읽을 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-439">When using the <xref:System.IO.StreamReader.Read%2A> method, it is more efficient to use a buffer that is the same size as the internal buffer of the stream, where the internal buffer is set to your desired block size, and to always read less than the block size.</span></span> <span data-ttu-id="b790f-440">스트림을 생성할 때에 내부 버퍼의 크기를 지정 하지 않은, 해당 기본 크기는 4kb (4096 바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-440">If the size of the internal buffer was unspecified when the stream was constructed, its default size is 4 kilobytes (4096 bytes).</span></span> <span data-ttu-id="b790f-441">버퍼에 데이터를 읽은 후 기본 스트림의 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치와 일치 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-441">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="b790f-442">내부 버퍼를 다시 설정 하려면 호출는 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 경우 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-442">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="b790f-443">이 메서드가 반환 후 지정 된 문자의 수를 `count` 매개 변수를 읽거나 파일의 끝에 도달 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-443">This method returns after either the number of characters specified by the `count` parameter are read, or the end of the file is reached.</span></span> <span data-ttu-id="b790f-444"><xref:System.IO.TextReader.ReadBlock%2A> 차단 버전이 <xref:System.IO.StreamReader.Read%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-444"><xref:System.IO.TextReader.ReadBlock%2A> is a blocking version of <xref:System.IO.StreamReader.Read%2A>.</span></span>  
  
 <span data-ttu-id="b790f-445">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-445">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-446">다음 코드 예제에서는 파일의 끝에 도달할 때까지 한 번에 5 개 문자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-446">The following code example reads five characters at a time until the end of the file is reached.</span></span>  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-447">버퍼 길이에서 <paramref name="index" />를 빼면 <paramref name="count" />보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-447">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-448"><paramref name="buffer" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-448"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b790f-449"><paramref name="index" /> 또는 <paramref name="count" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-449"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b790f-450">스트림이 닫히는 등의 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-450">An I/O error occurs, such as the stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-451">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-451">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-452">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-452">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-453">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-453">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b790f-454">이 메서드는 지정된 문자 배열의 값이 <paramref name="index" />와 (<paramref name="index" /> + <paramref name="count" /> - 1) 사이에서 현재 원본으로부터 읽어온 문자로 교체된 상태로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-454">When this method returns, contains the specified character array with the values between <paramref name="index" /> and (<paramref name="index" /> + <paramref name="count" /> - 1) replaced by the characters read from the current source.</span></span></param>
        <param name="index"><span data-ttu-id="b790f-455">쓰기를 시작할 <paramref name="buffer" />의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-455">The position in <paramref name="buffer" /> at which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="b790f-456">읽을 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-456">The maximum number of characters to read.</span></span> <span data-ttu-id="b790f-457">지정한 문자 수를 버퍼에 기록하기 전에 스트림의 끝에 도달하면 현재 메서드가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-457">If the end of the stream is reached before the specified number of characters is written into the buffer, the current method returns.</span></span></param>
        <summary><span data-ttu-id="b790f-458">현재 스트림에서 지정된 최대 수의 문자를 비동기적으로 읽어 이 데이터를 지정된 인덱스에서 시작되는 버퍼에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-458">Reads a specified maximum number of characters from the current stream asynchronously and writes the data to a buffer, beginning at the specified index.</span></span></summary>
        <returns><span data-ttu-id="b790f-459">비동기 읽기 작업을 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-459">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="b790f-460"><paramref name="TResult" /> 매개 변수의 값은 버퍼 안으로 읽어 들인 총 문자 수를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-460">The value of the <paramref name="TResult" /> parameter contains the total number of characters read into the buffer.</span></span> <span data-ttu-id="b790f-461">현재 사용할 수 있는 문자 수가 요청된 수보다 작을 경우 결과 값이 요청된 문자 수보다 작을 수 있으며, 스트림의 끝에 도달한 경우에는 0이 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-461">The result value can be less than the number of characters requested if the number of characters currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-462">작업 완료 후 지정 된 문자의 수를 `count` 매개 변수를 읽거나 스트림의 맨 끝에 도달 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-462">The task completes after either the number of characters specified by the `count` parameter are read or the end of the stream is reached.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-463">다음 예제에 사용 하 여 파일에 있는 모든 문자를 읽는 방법을 보여 줍니다는 <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="b790f-463">The following example shows how to read all the characters in a file by using the <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="b790f-464">각 문자는 문자, 숫자 또는 공백 문자의 인스턴스를 추가 하기 전에 인지 여부를 확인 합니다 <xref:System.Text.StringBuilder> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-464">It checks whether each character is a letter, digit, or white space before adding the character to an instance of the <xref:System.Text.StringBuilder> class.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-465"><paramref name="buffer" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-465"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b790f-466"><paramref name="index" /> 또는 <paramref name="count" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-466"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-467"><paramref name="index" /> 및 <paramref name="count" />의 합계가 버퍼 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-467">The sum of <paramref name="index" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b790f-468">스트림이 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-468">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b790f-469">판독기가 현재 이전 읽기 작업에서 사용 중입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-469">The reader is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="streamReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : char[] * int * int -&gt; int" Usage="streamReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b790f-470">이 메서드는 지정된 문자 배열의 값이 <paramref name="index" />와 (<c>인덱스 + 카운트 - 1</c>) 사이에서 현재 원본로부터 읽어온 문자로 교체된 상태로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-470">When this method returns, contains the specified character array with the values between <paramref name="index" /> and (<c>index + count - 1</c>) replaced by the characters read from the current source.</span></span></param>
        <param name="index"><span data-ttu-id="b790f-471">쓰기를 시작할 <paramref name="buffer" />의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-471">The position in <paramref name="buffer" /> at which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="b790f-472">읽을 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-472">The maximum number of characters to read.</span></span></param>
        <summary><span data-ttu-id="b790f-473">현재 스트림에서 지정된 최대 수의 문자를 읽어 이 데이터를 지정된 인덱스에서 시작되는 버퍼에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-473">Reads a specified maximum number of characters from the current stream and writes the data to a buffer, beginning at the specified index.</span></span></summary>
        <returns><span data-ttu-id="b790f-474">읽은 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-474">The number of characters that have been read.</span></span> <span data-ttu-id="b790f-475">이 문자 수는 모든 입력 문자를 읽었는지 여부에 따라 <paramref name="count" />보다 작거나 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-475">The number will be less than or equal to <paramref name="count" />, depending on whether all input characters have been read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-476">내부 스트림의 위치를 읽은 문자 수로 고급 `buffer`합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-476">The position of the underlying stream is advanced by the number of characters that were read into `buffer`.</span></span>  
  
 <span data-ttu-id="b790f-477">될 때까지 메서드 블록 `count` 스트림의 맨 끝에 도달 하거나 문자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-477">The method blocks until either `count` characters are read, or the end of the stream has been reached.</span></span> <span data-ttu-id="b790f-478">이 버전이 차단 <xref:System.IO.StreamReader.Read%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-478">This is a blocking version of <xref:System.IO.StreamReader.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-479"><paramref name="buffer" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-479"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-480">버퍼 길이에서 <paramref name="index" />를 빼면 <paramref name="count" />보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="b790f-480">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b790f-481"><paramref name="index" /> 또는 <paramref name="count" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-481"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b790f-482"><see cref="T:System.IO.StreamReader" />가 닫혔습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-482">The <see cref="T:System.IO.StreamReader" /> is closed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b790f-483">I/O 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-483">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b790f-484">이 메서드는 지정된 문자 배열의 값이 <paramref name="index" />와 (<paramref name="index" /> + <paramref name="count" /> - 1) 사이에서 현재 원본으로부터 읽어온 문자로 교체된 상태로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-484">When this method returns, contains the specified character array with the values between <paramref name="index" /> and (<paramref name="index" /> + <paramref name="count" /> - 1) replaced by the characters read from the current source.</span></span></param>
        <param name="index"><span data-ttu-id="b790f-485">쓰기를 시작할 <paramref name="buffer" />의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-485">The position in <paramref name="buffer" /> at which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="b790f-486">읽을 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-486">The maximum number of characters to read.</span></span> <span data-ttu-id="b790f-487">지정한 문자 수를 버퍼에 기록하기 전에 스트림의 끝에 도달하면 메서드가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-487">If the end of the stream is reached before the specified number of characters is written into the buffer, the method returns.</span></span></param>
        <summary><span data-ttu-id="b790f-488">현재 스트림에서 지정된 최대 수의 문자를 비동기적으로 읽어 이 데이터를 지정된 인덱스에서 시작되는 버퍼에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-488">Reads a specified maximum number of characters from the current stream asynchronously and writes the data to a buffer, beginning at the specified index.</span></span></summary>
        <returns><span data-ttu-id="b790f-489">비동기 읽기 작업을 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-489">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="b790f-490"><paramref name="TResult" /> 매개 변수의 값은 버퍼 안으로 읽어 들인 총 문자 수를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-490">The value of the <paramref name="TResult" /> parameter contains the total number of characters read into the buffer.</span></span> <span data-ttu-id="b790f-491">현재 사용할 수 있는 문자 수가 요청된 수보다 작을 경우 결과 값이 요청된 문자 수보다 작을 수 있으며, 스트림의 끝에 도달한 경우에는 0이 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-491">The result value can be less than the number of characters requested if the number of characters currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-492">작업이 완료 되지 않으면 될 때까지 지정 된 문자의 수를 `count` 매개 변수를 읽거나 스트림의 맨 끝에 도달 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-492">The task does not complete until either the number of characters specified by the `count` parameter are read, or the end of the stream has been reached.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b790f-493"><paramref name="buffer" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-493"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b790f-494"><paramref name="index" /> 또는 <paramref name="count" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-494"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b790f-495"><paramref name="index" /> 및 <paramref name="count" />의 합계가 버퍼 길이보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-495">The sum of <paramref name="index" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b790f-496">스트림이 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-496">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b790f-497">판독기가 현재 이전 읽기 작업에서 사용 중입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-497">The reader is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="streamReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b790f-498">현재 스트림에서 한 줄의 문자를 읽고 데이터를 문자열로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-498">Reads a line of characters from the current stream and returns the data as a string.</span></span></summary>
        <returns><span data-ttu-id="b790f-499">입력 스트림의 다음 줄을 반환하거나 입력 스트림의 끝에 도달한 경우 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-499">The next line from the input stream, or <see langword="null" /> if the end of the input stream is reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-500">줄 뒤에 줄 문자의 시퀀스 ("\n") 피드, 캐리지 리턴 ("\r") 또는 캐리지 리턴 바로 뒤에 줄 바꿈 ("\r\n")으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-500">A line is defined as a sequence of characters followed by a line feed ("\n"), a carriage return ("\r"), or a carriage return immediately followed by a line feed ("\r\n").</span></span> <span data-ttu-id="b790f-501">반환 되는 문자열 종료 캐리지 리턴 또는 줄 바꿈 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-501">The string that is returned does not contain the terminating carriage return or line feed.</span></span> <span data-ttu-id="b790f-502">반환된 값은 `null` 입력 스트림의 끝에 도달한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-502">The returned value is `null` if the end of the input stream is reached.</span></span>  
  
 <span data-ttu-id="b790f-503">이 메서드는 <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-503">This method overrides <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b790f-504">현재 메서드가 throw 하는 경우는 <xref:System.OutOfMemoryException>, 기본 판독기의 위치 <xref:System.IO.Stream> 개체는 메서드를 읽지 못한 자 이지만 내부에 이미 읽은 문자 수 만큼 앞에 <xref:System.IO.StreamReader.ReadLine%2A> 버퍼는 삭제 됩니다. .</span><span class="sxs-lookup"><span data-stu-id="b790f-504">If the current method throws an <xref:System.OutOfMemoryException>, the reader's position in the underlying <xref:System.IO.Stream> object is advanced by the number of characters the method was able to read, but the characters already read into the internal <xref:System.IO.StreamReader.ReadLine%2A> buffer are discarded.</span></span> <span data-ttu-id="b790f-505">버퍼에 데이터를 읽은 후 기본 스트림의 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치와 일치 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-505">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="b790f-506">내부 버퍼를 다시 설정 하려면 호출는 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 경우 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-506">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="b790f-507">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-507">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-508">다음 코드 예제에서는 파일의 끝에 도달할 때까지 파일에서 줄을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-508">The following code example reads lines from a file until the end of the file is reached.</span></span>  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="b790f-509">메모리가 부족하여 반환된 문자열의 버퍼를 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-509">There is insufficient memory to allocate a buffer for the returned string.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b790f-510">I/O 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-510">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-511">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-511">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-512">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-512">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-513">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-513">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b790f-514">현재 스트림에서 한 줄의 문자를 비동기적으로 읽고 데이터를 문자열로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-514">Reads a line of characters asynchronously from the current stream and returns the data as a string.</span></span></summary>
        <returns><span data-ttu-id="b790f-515">비동기 읽기 작업을 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-515">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="b790f-516"><paramref name="TResult" /> 매개 변수의 값은 스트림의 다음 줄을 포함하거나 모든 문자가 읽혀진 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-516">The value of the <paramref name="TResult" /> parameter contains the next line from the stream, or is <see langword="null" /> if all the characters have been read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b790f-517">다음 예제에 사용 하 여 파일의 첫 번째 줄을 읽는 방법을 보여 줍니다는 <xref:System.IO.StreamReader.ReadLineAsync> 메서드.</span><span class="sxs-lookup"><span data-stu-id="b790f-517">The following example shows how to read the first line of a file by using the <xref:System.IO.StreamReader.ReadLineAsync> method.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b790f-518">다음 줄의 문자 수가 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-518">The number of characters in the next line is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b790f-519">스트림이 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-519">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b790f-520">판독기가 현재 이전 읽기 작업에서 사용 중입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-520">The reader is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="streamReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b790f-521">현재 위치부터 스트림 끝까지의 모든 문자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-521">Reads all characters from the current position to the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="b790f-522">현재 위치에서 끝까지의 스트림은 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-522">The rest of the stream as a string, from the current position to the end.</span></span> <span data-ttu-id="b790f-523">현재 위치가 스트림 끝에 있으면 빈 문자열("")을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-523">If the current position is at the end of the stream, returns an empty string ("").</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b790f-524">이 메서드는 <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-524">This method overrides <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b790f-525"><xref:System.IO.StreamReader.ReadToEnd%2A> 현재 위치에서 모든 입력 스트림의 끝까지 읽는 해야 할 경우 가장 잘 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-525"><xref:System.IO.StreamReader.ReadToEnd%2A> works best when you need to read all the input from the current position to the end of the stream.</span></span> <span data-ttu-id="b790f-526">사용 하 여 더 많은 제어 문자 수는 스트림에서 읽기를 통해 필요한 경우는 <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 일반적으로 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-526">If more control is needed over how many characters are read from the stream, use the <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method overload, which generally results in better performance.</span></span>  
  
 <span data-ttu-id="b790f-527"><xref:System.IO.StreamReader.ReadToEnd%2A> 스트림의 끝에 도달 하면 알고 있는 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-527"><xref:System.IO.StreamReader.ReadToEnd%2A> assumes that the stream knows when it has reached an end.</span></span> <span data-ttu-id="b790f-528">데이터를 보내고 서버가 연결을 닫지 않습니다를 요청할 경우에 대화형 프로토콜에 대 한 <xref:System.IO.StreamReader.ReadToEnd%2A> 끝에 도달 하지 않아야 하므로 무기한으로 차단 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-528">For interactive protocols in which the server sends data only when you ask for it and does not close the connection, <xref:System.IO.StreamReader.ReadToEnd%2A> might block indefinitely because it does not reach an end, and should be avoided.</span></span>  
  
 <span data-ttu-id="b790f-529">사용할 때는 <xref:System.IO.StreamReader.Read%2A> 스트림의 내부 버퍼와 같은 크기로 사용 되는 버퍼를 사용 하는 것이 효율적 이기는 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-529">Note that when using the <xref:System.IO.StreamReader.Read%2A> method, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span> <span data-ttu-id="b790f-530">스트림을 생성할 때에 버퍼의 크기를 지정 하지 않은, 해당 기본 크기는 4kb (4096 바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-530">If the size of the buffer was unspecified when the stream was constructed, its default size is 4 kilobytes (4096 bytes).</span></span>  
  
 <span data-ttu-id="b790f-531">현재 메서드가 throw 하는 경우는 <xref:System.OutOfMemoryException>, 기본 판독기의 위치 <xref:System.IO.Stream> 개체는 메서드를 읽지 못한 자 이지만 내부에 이미 읽은 문자 수 만큼 앞에 <xref:System.IO.StreamReader.ReadLine%2A> 버퍼는 삭제 됩니다. .</span><span class="sxs-lookup"><span data-stu-id="b790f-531">If the current method throws an <xref:System.OutOfMemoryException>, the reader's position in the underlying <xref:System.IO.Stream> object is advanced by the number of characters the method was able to read, but the characters already read into the internal <xref:System.IO.StreamReader.ReadLine%2A> buffer are discarded.</span></span> <span data-ttu-id="b790f-532">버퍼에 데이터를 읽은 후 기본 스트림의 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치와 일치 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-532">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="b790f-533">내부 버퍼를 다시 설정 하려면 호출는 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 경우 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-533">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="b790f-534">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-534">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b790f-535">다음 코드 예제에서는 하나의 작업 파일의 끝까지 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-535">The following code example reads all the way to the end of a file in one operation.</span></span>  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="b790f-536">메모리가 부족하여 반환된 문자열의 버퍼를 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-536">There is insufficient memory to allocate a buffer for the returned string.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b790f-537">I/O 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-537">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b790f-538">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="b790f-538">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b790f-539">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="b790f-539">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b790f-540">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="b790f-540">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b790f-541">현재 위치부터 스트림 끝까지의 모든 문자를 비동기적으로 읽어서 이를 하나의 문자열로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-541">Reads all characters from the current position to the end of the stream asynchronously and returns them as one string.</span></span></summary>
        <returns><span data-ttu-id="b790f-542">비동기 읽기 작업을 나타내는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-542">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="b790f-543"><paramref name="TResult" /> 매개 변수의 값은 현재 위치에서 스트림 끝까지의 문자로 이루어진 문자열을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-543">The value of the <paramref name="TResult" /> parameter contains a string with the characters from the current position to the end of the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b790f-544">다음 예제에 사용 하 여 파일의 콘텐츠를 읽는 방법을 보여 줍니다는 <xref:System.IO.StreamReader.ReadToEndAsync> 메서드.</span><span class="sxs-lookup"><span data-stu-id="b790f-544">The following example shows how to read the contents of a file by using the <xref:System.IO.StreamReader.ReadToEndAsync> method.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b790f-545">문자 수가 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-545">The number of characters is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b790f-546">스트림이 삭제되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-546">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b790f-547">판독기가 현재 이전 읽기 작업에서 사용 중입니다.</span><span class="sxs-lookup"><span data-stu-id="b790f-547">The reader is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>