<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d6d2cd6f31cc97089037cf8c47853b3dd6d37d7e" /><Meta Name="ms.sourcegitcommit" Value="3efce15f3841385ee3ba24bd71ff0c0cf9a47815" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/03/2019" /><Meta Name="ms.locfileid" Value="58875582" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="cbc67-101"><see cref="T:System.Reflection.Emit.ILGenerator" /> 같은 <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> 클래스 멤버를 사용한 내보내기 작업에 사용되는 MSIL(Microsoft Intermediate Language) 명령의 필드 표현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-102">에 대 한 자세한 설명은 멤버 opcode 공용 언어 인프라 (CLI) 설명서를 특히 참조 "파티션 III: CIL Instruction Set"및" 파티션 II: 메타 데이터 정 및 의미 체계 "입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="cbc67-103">이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="cbc67-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cbc67-104">다음 예제에서는 사용 하 여 동적 메서드 생성을 방법을 보여 줍니다 <xref:System.Reflection.Emit.ILGenerator> 내보낼 `OpCodes` 에 <xref:System.Reflection.Emit.MethodBuilder>합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-105">두 개 값을 더하여 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-105">Adds two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-106">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-107">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-107">Format</span></span>|<span data-ttu-id="cbc67-108">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-108">Assembly Format</span></span>|<span data-ttu-id="cbc67-109">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-110">58</span><span class="sxs-lookup"><span data-stu-id="cbc67-110">58</span></span>|<span data-ttu-id="cbc67-111">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-111">add</span></span>|<span data-ttu-id="cbc67-112">새 숫자 값을 반환 하는 두 숫자 값을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="cbc67-113">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-114">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-114">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-115">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-115">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-116">및 `value1` 스택에서 팝 되 고 `value1` 추가할 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-116">and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="cbc67-117">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-118">정수 연산에 오버플로 인식 되지 않습니다 (적절 한 오버플로 처리를 참조 하세요. <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="cbc67-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="cbc67-119">정수 추가 포화 되지 않고 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="cbc67-120">예를 들어, 8 비트 정수를 가정 하 고 여기서 `value1` 255 자로 설정 됩니다 및 `value2` 설정 되어 1로 래핑된 결과 256이 아닌 0입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="cbc67-121">부동 소수점 오버플로 반환 `+inf` (`PositiveInfinity`) 또는 `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="cbc67-122">아래 표에 가능한 피연산자 형식 및 해당 결과 데이터 형식을 나열 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="cbc67-123">특정 형식 조합에 대 한 항목이 없을 경우 (예를 들어 `int32` 고 `float`; `int32` 고 `int64`)에 잘못 된 중간 언어 (MSIL (Microsoft) 이며 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="cbc67-124">피연산자</span><span class="sxs-lookup"><span data-stu-id="cbc67-124">operand</span></span>|<span data-ttu-id="cbc67-125">value1 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-125">value1 type</span></span>|<span data-ttu-id="cbc67-126">value2 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-126">value2 type</span></span>|<span data-ttu-id="cbc67-127">결과 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="cbc67-128">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="cbc67-129">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="cbc67-130">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="cbc67-131">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="cbc67-132">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="cbc67-133">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="cbc67-134">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="cbc67-135">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="cbc67-136">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="cbc67-137">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="cbc67-138">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="cbc67-139">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="cbc67-140">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="cbc67-141">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="cbc67-142">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `add` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-143">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-144">두 정수를 더하고 오버플로를 검사하여 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-145">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-146">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-146">Format</span></span>|<span data-ttu-id="cbc67-147">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-147">Assembly Format</span></span>|<span data-ttu-id="cbc67-148">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-149">D6</span><span class="sxs-lookup"><span data-stu-id="cbc67-149">D6</span></span>|<span data-ttu-id="cbc67-150">add.ovf</span><span class="sxs-lookup"><span data-stu-id="cbc67-150">add.ovf</span></span>|<span data-ttu-id="cbc67-151">오버플로 검사 하는 부호 있는 정수 값을 두 개를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="cbc67-152">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-153">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-153">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-154">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-154">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-155">및 `value1` 스택에서 팝 되 고 `value1` 추가할 `value2` 오버플로 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-155">and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="cbc67-156">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-156">The result is pushed onto the stack.</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-157">결과 결과 형식에 표시 되지 않는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-157">is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-158">부호 있는 정수에 대 한이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="cbc67-159">부동 소수점 값을 사용 하 여 <xref:System.Reflection.Emit.OpCodes.Add>입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="cbc67-160">아래 표에 가능한 피연산자 형식 및 해당 결과 데이터 형식을 나열 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="cbc67-161">특정 형식 조합에 대 한 항목이 없을 경우 (예를 들어 `int32` 고 `float`; `int32` 고 `int64`), 잘못 된 Microsoft MSIL (Intermediate Language) 명령이 되 고 오류를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="cbc67-162">피연산자</span><span class="sxs-lookup"><span data-stu-id="cbc67-162">operand</span></span>|<span data-ttu-id="cbc67-163">value1 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-163">value1 type</span></span>|<span data-ttu-id="cbc67-164">value2 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-164">value2 type</span></span>|<span data-ttu-id="cbc67-165">결과 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="cbc67-166">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="cbc67-167">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="cbc67-168">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="cbc67-169">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="cbc67-170">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="cbc67-171">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="cbc67-172">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="cbc67-173">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="cbc67-174">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="cbc67-175">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="cbc67-176">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="cbc67-177">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="cbc67-178">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="cbc67-179">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="cbc67-180">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `add.ovf` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-181">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-182">부호 없는 두 정수 값을 더하고 오버플로를 검사하여 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-183">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-184">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-184">Format</span></span>|<span data-ttu-id="cbc67-185">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-185">Assembly Format</span></span>|<span data-ttu-id="cbc67-186">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-187">D7</span><span class="sxs-lookup"><span data-stu-id="cbc67-187">D7</span></span>|<span data-ttu-id="cbc67-188">add.ovf.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-188">add.ovf.un</span></span>|<span data-ttu-id="cbc67-189">오버플로 검사 하는 부호 없는 정수 값을 두 개를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="cbc67-190">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-191">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-191">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-192">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-192">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-193">및 `value1` 스택에서 팝 되 고 `value1` 추가할 `value2` 오버플로 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-193">and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="cbc67-194">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-194">The result is pushed onto the stack.</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-195">결과 결과 형식에 표시 되지 않는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-195">is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-196">부호 있는 정수에 대 한이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="cbc67-197">부동 소수점 값을 사용 하 여 <xref:System.Reflection.Emit.OpCodes.Add>입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="cbc67-198">아래 표에 가능한 피연산자 형식 및 해당 결과 데이터 형식을 나열 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="cbc67-199">특정 형식 조합에 대 한 항목이 없을 경우 (예를 들어 `int32` 고 `float`; `int32` 고 `int64`), 잘못 된 Microsoft MSIL (Intermediate Language) 명령이 되 고 오류를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="cbc67-200">피연산자</span><span class="sxs-lookup"><span data-stu-id="cbc67-200">operand</span></span>|<span data-ttu-id="cbc67-201">value1 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-201">value1 type</span></span>|<span data-ttu-id="cbc67-202">value2 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-202">value2 type</span></span>|<span data-ttu-id="cbc67-203">결과 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="cbc67-204">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="cbc67-205">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="cbc67-206">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="cbc67-207">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="cbc67-208">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="cbc67-209">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="cbc67-210">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="cbc67-211">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="cbc67-212">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="cbc67-213">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="cbc67-214">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="cbc67-215">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="cbc67-216">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="cbc67-217">add</span><span class="sxs-lookup"><span data-stu-id="cbc67-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="cbc67-218">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `add.ovf.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-219">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-220">두 값의 비트 AND를 계산하여 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-221">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-222">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-222">Format</span></span>|<span data-ttu-id="cbc67-223">명령</span><span class="sxs-lookup"><span data-stu-id="cbc67-223">Instruction</span></span>|<span data-ttu-id="cbc67-224">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="cbc67-225">5F</span><span class="sxs-lookup"><span data-stu-id="cbc67-225">5F</span></span>|<span data-ttu-id="cbc67-226">를 갖는</span><span class="sxs-lookup"><span data-stu-id="cbc67-226">and</span></span>|<span data-ttu-id="cbc67-227">두 정수 값의 비트 AND를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="cbc67-228">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-229">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-229">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-230">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-230">is pushed onto the stack.</span></span>  
  
3.  `value1` <span data-ttu-id="cbc67-231">및 `value2` 스택에서 팝 되 고 두 값의 비트 AND를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-231">and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="cbc67-232">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-233">`and` 명령 스택의 맨 위 두 값의 비트 AND를 계산 하 고 결과 스택에 남겨 둡니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 `And` <span data-ttu-id="cbc67-234">정수 관련 작업이입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-234">is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="cbc67-235">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `and` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-236">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-237">현재 메서드의 인수 목록에 대한 관리되지 않는 포인터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-237">Returns an unmanaged pointer to the argument list of the current method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-238">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-239">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-239">Format</span></span>|<span data-ttu-id="cbc67-240">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-240">Assembly Format</span></span>|<span data-ttu-id="cbc67-241">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="cbc67-242">FE 00</span></span>|<span data-ttu-id="cbc67-243">arglist</span><span class="sxs-lookup"><span data-stu-id="cbc67-243">arglist</span></span>|<span data-ttu-id="cbc67-244">현재 메서드의 인수 목록 핸들을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="cbc67-245">계산 스택 동작이 없습니다이 작업에 의해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="cbc67-246">합니다 `arglist` 불투명 핸들을 반환 하는 명령 (형식의 관리 되지 않는 포인터를 `native int`) 나타내는 현재 메서드의 인수 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="cbc67-247">이 핸들이 현재 메서드의 수명 동안에 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="cbc67-248">그러나 컨트롤의 스레드에서 현재 메서드는 다른 방법 핸들을 전달할 수에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="cbc67-249">실행할 수 있습니다는 `arglist` 가변 개수의 인수를 사용 하는 메서드 내에서 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="cbc67-250">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `arglist` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-252">두 값이 같으면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-252">Transfers control to a target instruction if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-253">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-254">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-254">Format</span></span>|<span data-ttu-id="cbc67-255">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-255">Assembly Format</span></span>|<span data-ttu-id="cbc67-256">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-257">3B < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-257">3B < `int32` ></span></span>|<span data-ttu-id="cbc67-258">beq</span><span class="sxs-lookup"><span data-stu-id="cbc67-258">beq</span></span> `target`|<span data-ttu-id="cbc67-259">오프셋 대상 명령으로 분기 `target` 두 값이 같으면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="cbc67-260">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-261">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-261">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-262">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-262">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-263">및 `value1` 경우 스택에서 팝 됩니다 `value1` 값과 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-263">and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-264">`beq` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 값과 같음 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="cbc67-265">효과 수행할 때 동일를 `ceq` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-266">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-267">가능한 피연산자 종류는 다음과 같이 캡슐화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="cbc67-268">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="cbc67-269">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다 (이러한 전송을 엄격 하 게 제한 되며 사용 해야 합니다는 <xref:System.Reflection.Emit.OpCodes.Leave> 명령 대신).</span><span class="sxs-lookup"><span data-stu-id="cbc67-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="cbc67-270">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `beq` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-271">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-272">두 값이 같으면 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-272">Transfers control to a target instruction (short form) if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-273">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-274">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-274">Format</span></span>|<span data-ttu-id="cbc67-275">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-275">Assembly Format</span></span>|<span data-ttu-id="cbc67-276">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-277">2E < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-277">2E < `int8` ></span></span>|<span data-ttu-id="cbc67-278">beq.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-278">beq.s</span></span> `target`|<span data-ttu-id="cbc67-279">오프셋 대상 명령으로 분기 `target` 같으면, 약식</span><span class="sxs-lookup"><span data-stu-id="cbc67-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="cbc67-280">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-281">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-281">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-282">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-282">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-283">및 `value1` 경우 스택에서 팝 됩니다 `value1` 값과 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-283">and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-284">`beq.s` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 값과 같음 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="cbc67-285">효과 수행할 때 동일를 `ceq` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-286">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-287">가능한 피연산자 종류는 다음과 같이 캡슐화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="cbc67-288">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="cbc67-289">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다 (이러한 전송을 엄격 하 게 제한 되며 사용 해야 합니다는 <xref:System.Reflection.Emit.OpCodes.Leave> 명령 대신).</span><span class="sxs-lookup"><span data-stu-id="cbc67-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="cbc67-290">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `beq.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-291">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-292">첫째 값이 둘째 값보다 크거나 같으면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-293">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-294">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-294">Format</span></span>|<span data-ttu-id="cbc67-295">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-295">Assembly Format</span></span>|<span data-ttu-id="cbc67-296">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-297">3C</span><span class="sxs-lookup"><span data-stu-id="cbc67-297">3C</span></span> `<int32>`|<span data-ttu-id="cbc67-298">bge</span><span class="sxs-lookup"><span data-stu-id="cbc67-298">bge</span></span> `target`|<span data-ttu-id="cbc67-299">첫 번째 값이 둘째 값 보다 크거나 같은 경우 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="cbc67-300">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-301">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-301">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-302">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-302">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-303">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 크거나 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-303">and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-304">합니다 `bge` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 보다 크거나 같음 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="cbc67-305">결과 동일 수행 하는 `clt.un` 명령 뒤에 `brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-306">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-307">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-308">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-309">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bge` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-310">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-311">첫째 값이 둘째 값보다 크거나 같으면 대상 명령(약식)으로 제어를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-312">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-313">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-313">Format</span></span>|<span data-ttu-id="cbc67-314">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-314">Assembly Format</span></span>|<span data-ttu-id="cbc67-315">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-316">2F</span><span class="sxs-lookup"><span data-stu-id="cbc67-316">2F</span></span> `<int8>`|<span data-ttu-id="cbc67-317">bge.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-317">bge.s</span></span> `target`|<span data-ttu-id="cbc67-318">첫 번째 값 보다 크거나 약식, 두 번째 값과 같은 경우 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-319">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-320">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-320">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-321">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-321">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-322">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 크거나 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-322">and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-323">합니다 `bge.s` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 보다 크거나 같음 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="cbc67-324">결과 동일 수행 하는 `clt.un` 명령 뒤에 `brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-325">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-326">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-327">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-328">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bge.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-329">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-330">부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값을 비교한 결과 첫째 값이 둘째 값보다 크면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-331">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-332">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-332">Format</span></span>|<span data-ttu-id="cbc67-333">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-333">Assembly Format</span></span>|<span data-ttu-id="cbc67-334">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-335">41</span><span class="sxs-lookup"><span data-stu-id="cbc67-335">41</span></span> `<int32>`|<span data-ttu-id="cbc67-336">bge.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-336">bge.un</span></span> `target`|<span data-ttu-id="cbc67-337">첫 번째 값이 둘째 값 (부호 없는 값) 보다 크거나 같은 경우 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="cbc67-338">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-339">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-339">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-340">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-340">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-341">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 크거나 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-341">and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-342">합니다 `bge.un` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 보다 크거나 같음 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-343">결과 동일 수행 하는 `clt` 명령 뒤에 `brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-344">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-345">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-346">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-347">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bge.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-348">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-349">부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값을 비교한 결과 첫째 값이 둘째 값보다 크면 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-350">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-351">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-351">Format</span></span>|<span data-ttu-id="cbc67-352">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-352">Assembly Format</span></span>|<span data-ttu-id="cbc67-353">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-354">34 < `int8` ></span></span>|<span data-ttu-id="cbc67-355">bge.un.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-355">bge.un.s</span></span> `target`|<span data-ttu-id="cbc67-356">첫 번째 값 보다 크거나 같은 약식 두 번째 값 (부호 없는 값) 이면 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="cbc67-357">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-358">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-358">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-359">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-359">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-360">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 크거나 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-360">and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-361">합니다 `bge.un.s` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 보다 크거나 같음 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-362">결과 동일 수행 하는 `clt` 명령 뒤에 `brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-363">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-364">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-365">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-366">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bge.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-367">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-368">첫째 값이 둘째 값보다 크면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-368">Transfers control to a target instruction if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-369">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-370">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-370">Format</span></span>|<span data-ttu-id="cbc67-371">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-371">Assembly Format</span></span>|<span data-ttu-id="cbc67-372">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-373">3D < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-373">3D < `int32` ></span></span>|<span data-ttu-id="cbc67-374">bgt</span><span class="sxs-lookup"><span data-stu-id="cbc67-374">bgt</span></span> `target`|<span data-ttu-id="cbc67-375">첫 번째 값이 둘째 값 보다 크면 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="cbc67-376">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-377">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-377">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-378">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-378">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-379">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 크면 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-379">and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-380">합니다 `bgt` 명령이 지정 된 대상 명령으로 제어 하는 경우 전달 `value1` 보다 크면 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="cbc67-381">결과 동일 수행 하는 `cgt` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-382">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-383">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-384">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-385">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bgt` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-386">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-387">첫째 값이 둘째 값보다 크면 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-388">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-389">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-389">Format</span></span>|<span data-ttu-id="cbc67-390">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-390">Assembly Format</span></span>|<span data-ttu-id="cbc67-391">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-392">30 < `int8` ></span></span>|<span data-ttu-id="cbc67-393">bgt.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-393">bgt.s</span></span> `target`|<span data-ttu-id="cbc67-394">첫째 값이 두 번째 값 (약식) 보다 큰 경우 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-395">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-396">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-396">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-397">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-397">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-398">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 크면 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-398">and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-399">합니다 `bgt.s` 명령이 지정 된 대상 명령으로 제어 하는 경우 전달 `value1` 보다 크면 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="cbc67-400">결과 동일 수행 하는 `cgt` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-401">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-402">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-403">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-404">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bgt.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-405">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-406">부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값을 비교한 결과 첫째 값이 둘째 값보다 크면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-407">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-408">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-408">Format</span></span>|<span data-ttu-id="cbc67-409">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-409">Assembly Format</span></span>|<span data-ttu-id="cbc67-410">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-411">42 < `int32` ></span></span>|<span data-ttu-id="cbc67-412">bgt.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-412">bgt.un</span></span> `target`|<span data-ttu-id="cbc67-413">첫 번째 값이 둘째 값 (부호 없는 값) 보다 크면 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="cbc67-414">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-415">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-415">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-416">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-416">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-417">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 크면 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-417">and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-418">합니다 `bgt.un` 명령이 지정 된 대상 명령으로 제어 하는 경우 전달 `value1` 보다 크면 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-419">결과 동일 수행 하는 `cgt.un` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-420">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-421">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-422">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-423">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bgt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-424">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-425">부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값을 비교한 결과 첫째 값이 둘째 값보다 크면 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-426">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-427">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-427">Format</span></span>|<span data-ttu-id="cbc67-428">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-428">Assembly Format</span></span>|<span data-ttu-id="cbc67-429">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-430">35 < `int8` ></span></span>|<span data-ttu-id="cbc67-431">bgt.un.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-431">bgt.un.s</span></span> `target`|<span data-ttu-id="cbc67-432">첫 번째 값 약식 두 번째 값 (부호 없는 값) 보다 큰 경우 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="cbc67-433">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-434">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-434">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-435">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-435">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-436">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 크면 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-436">and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-437">합니다 `bgt.un.s` 명령이 지정 된 대상 명령으로 제어 하는 경우 전달 `value1` 보다 크면 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-438">결과 동일 수행 하는 `cgt.un` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-439">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-440">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-441">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-442">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bgt.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-443">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-444">첫째 값이 둘째 값보다 작거나 같으면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-445">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-446">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-446">Format</span></span>|<span data-ttu-id="cbc67-447">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-447">Assembly Format</span></span>|<span data-ttu-id="cbc67-448">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-449">3E</span><span class="sxs-lookup"><span data-stu-id="cbc67-449">3E</span></span> `<int32>`|<span data-ttu-id="cbc67-450">ble</span><span class="sxs-lookup"><span data-stu-id="cbc67-450">ble</span></span> `target`|<span data-ttu-id="cbc67-451">첫 번째 값이 둘째 값 보다 작거나 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="cbc67-452">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-453">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-453">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-454">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-454">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-455">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 작거나 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-455">and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-456">합니다 `ble` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 보다 작거나 같음 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="cbc67-457">결과 동일 수행 하는 `cgt` 명령 (`cgt.un` 부동 소수점 수에 대 한) 뒤에 `brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-458">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-459">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-460">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-461">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ble` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-462">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-463">첫째 값이 둘째 값보다 작거나 같으면 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-464">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-465">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-465">Format</span></span>|<span data-ttu-id="cbc67-466">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-466">Assembly Format</span></span>|<span data-ttu-id="cbc67-467">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-468">31</span><span class="sxs-lookup"><span data-stu-id="cbc67-468">31</span></span> `<int8>`|<span data-ttu-id="cbc67-469">ble.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-469">ble.s</span></span> `target`|<span data-ttu-id="cbc67-470">첫 번째 값 보다 작거나 약식, 두 번째 값과 같은 경우 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-471">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-472">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-472">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-473">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-473">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-474">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 작거나 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-474">and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-475">합니다 `ble.s` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 보다 작거나 같음 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="cbc67-476">결과 동일 수행 하는 `cgt` 명령 (`cgt.un` 부동 소수점 수에 대 한) 명령 뒤에`brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-477">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-478">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-479">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-480">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ble.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-481">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-482">부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값을 비교한 결과 첫째 값이 둘째 값보다 작거나 같으면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-483">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-484">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-484">Format</span></span>|<span data-ttu-id="cbc67-485">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-485">Assembly Format</span></span>|<span data-ttu-id="cbc67-486">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-487">43</span><span class="sxs-lookup"><span data-stu-id="cbc67-487">43</span></span> `<int32>`|<span data-ttu-id="cbc67-488">ble.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-488">ble.un</span></span> `target`|<span data-ttu-id="cbc67-489">첫 번째 값이 둘째 값 (부호 없는 값) 보다 작거나 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="cbc67-490">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-491">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-491">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-492">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-492">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-493">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 작거나 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-493">and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-494">합니다 `ble.un` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 보다 작거나 같음 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-495">결과 동일 수행 하는 `cgt.un` 명령 (`cgt` 부동 소수점 수에 대 한) 뒤에 `brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-496">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-497">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-498">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-499">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ble.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-500">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-501">부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값을 비교한 결과 첫째 값이 둘째 값보다 작거나 같으면 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-502">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-503">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-503">Format</span></span>|<span data-ttu-id="cbc67-504">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-504">Assembly Format</span></span>|<span data-ttu-id="cbc67-505">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-506">36</span><span class="sxs-lookup"><span data-stu-id="cbc67-506">36</span></span> `<int8>`|<span data-ttu-id="cbc67-507">ble.un.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-507">ble.un.s</span></span> `target`|<span data-ttu-id="cbc67-508">첫 번째 값 보다 작거나 약식 두 번째 값 (부호 없는 값)과 같은 경우 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="cbc67-509">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-510">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-510">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-511">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-511">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-512">및 `value1` 경우 스택에서 팝 됩니다 `value1` 보다 작거나 같음 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-512">and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-513">합니다 `ble.un.s` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 보다 작거나 같음 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-514">결과 동일 수행 하는 `cgt.un` 명령 (`cgt` 부동 소수점 수에 대 한) 뒤에 `brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-515">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-516">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-517">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-518">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ble.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-519">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-520">첫째 값이 둘째 값보다 작으면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-520">Transfers control to a target instruction if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-521">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-522">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-522">Format</span></span>|<span data-ttu-id="cbc67-523">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-523">Assembly Format</span></span>|<span data-ttu-id="cbc67-524">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-525">3F < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-525">3F < `int32` ></span></span>|<span data-ttu-id="cbc67-526">blt</span><span class="sxs-lookup"><span data-stu-id="cbc67-526">blt</span></span> `target`|<span data-ttu-id="cbc67-527">두 번째 값 보다 작으면 첫 번째 값이 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="cbc67-528">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-529">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-529">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-530">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-530">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-531">및 `value1` 경우 스택에서 팝 됩니다 `value1` 는 보다 작은 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-531">and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-532">합니다 `blt` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 보다 작거나 같음 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="cbc67-533">결과 동일 수행 하는 `clt` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-534">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-535">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-536">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-537">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `blt` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-538">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-539">첫째 값이 둘째 값보다 작으면 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-540">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-541">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-541">Format</span></span>|<span data-ttu-id="cbc67-542">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-542">Assembly Format</span></span>|<span data-ttu-id="cbc67-543">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-544">32 < `int8` ></span></span>|<span data-ttu-id="cbc67-545">blt.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-545">blt.s</span></span> `target`|<span data-ttu-id="cbc67-546">약식 두 번째 값 보다 작으면 첫 번째 값이 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-547">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-548">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-548">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-549">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-549">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-550">및 `value1` 경우 스택에서 팝 됩니다 `value1` 는 보다 작은 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-550">and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-551">`blt.s` 명령이 지정 된 대상 명령으로 제어 하는 경우 전달 `value1` 는 보다 작은 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="cbc67-552">결과 동일 수행 하는 `clt` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-553">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-554">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-555">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-556">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `blt.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-557">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-558">부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값을 비교한 결과 첫째 값이 둘째 값보다 작으면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-559">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-560">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-560">Format</span></span>|<span data-ttu-id="cbc67-561">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-561">Assembly Format</span></span>|<span data-ttu-id="cbc67-562">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-563">44 < `int32` ></span></span>|<span data-ttu-id="cbc67-564">blt.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-564">blt.un</span></span> `target`|<span data-ttu-id="cbc67-565">두 번째 값 (부호 없는 값) 보다 작으면 첫 번째 값이 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="cbc67-566">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-567">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-567">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-568">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-568">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-569">및 `value1` 경우 스택에서 팝 됩니다 `value1` 는 보다 작은 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-569">and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-570">합니다 `blt.un` 명령이 지정 된 대상 명령으로 제어 하는 경우 전달 `value1` 는 보다 작은 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-571">결과 동일 수행 하는 `clt.un` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-572">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-573">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-574">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-575">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `blt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-576">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-577">부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값을 비교한 결과 첫째 값이 둘째 값보다 작으면 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-578">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-579">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-579">Format</span></span>|<span data-ttu-id="cbc67-580">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-580">Assembly Format</span></span>|<span data-ttu-id="cbc67-581">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-582">37 < `int8` ></span></span>|<span data-ttu-id="cbc67-583">blt.un.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-583">blt.un.s</span></span> `target`|<span data-ttu-id="cbc67-584">약식 두 번째 값 (부호 없는 값) 보다 작으면 첫 번째 값이 지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="cbc67-585">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-586">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-586">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-587">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-587">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-588">및 `value1` 경우 스택에서 팝 됩니다 `value1` 는 보다 작은 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-588">and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-589">합니다 `blt.un` 명령이 지정 된 대상 명령으로 제어 하는 경우 전달 `value1` 는 보다 작은 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-590">결과 동일 수행 하는 `clt.un` 명령 뒤에 `brtrue` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-591">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-592">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-593">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-594">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `blt.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-595">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-596">두 개의 부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값이 서로 다르면 대상 명령으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-597">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-598">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-598">Format</span></span>|<span data-ttu-id="cbc67-599">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-599">Assembly Format</span></span>|<span data-ttu-id="cbc67-600">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-601">40 < `int32` ></span></span>|<span data-ttu-id="cbc67-602">bne.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-602">bne.un</span></span> `target`|<span data-ttu-id="cbc67-603">분기 대상 명령에 지정된 된 오프셋 두 개의 부호 없는 정수 값 (부호 없는 값)과 같지 않은 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="cbc67-604">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-605">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-605">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-606">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-606">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-607">및 `value1` 경우 스택에서 팝 됩니다 `value1` 와 같지 않은 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-607">and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-608">`bne.un` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 같지 않은 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-609">결과 동일 수행 하는 `ceq` 명령 뒤에 `brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-610">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-611">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-612">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-613">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bne.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-614">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-615">두 개의 부호 없는 정수 값 또는 순서가 지정되지 않은 부동 소수점 값이 서로 다르면 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-616">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-617">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-617">Format</span></span>|<span data-ttu-id="cbc67-618">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-618">Assembly Format</span></span>|<span data-ttu-id="cbc67-619">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-620">33 < `int8` ></span></span>|<span data-ttu-id="cbc67-621">bne.un.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-621">bne.un.s</span></span> `target`|<span data-ttu-id="cbc67-622">분기 대상 명령에 지정된 된 오프셋 두 개의 부호 없는 정수 값은 같은 (부호 없는 값), 약식 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="cbc67-623">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-624">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-624">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-625">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-625">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-626">및 `value1` 경우 스택에서 팝 됩니다 `value1` 와 같지 않은 `value2`, 분기 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-626">and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="cbc67-627">`bne.un` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value1` 같지 않은 `value2`부호 없는 정수 또는 부동 소수점 값을 사용 하 여 비교 했을 때.</span><span class="sxs-lookup"><span data-stu-id="cbc67-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="cbc67-628">결과 동일 수행 하는 `ceq` 명령 뒤에 `brfalse` 특정 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="cbc67-629">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-630">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-631">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-632">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `bne.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-633">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-634">값 형식을 개체 참조(<see langword="O" /> 형식)로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-634">Converts a value type to an object reference (type <see langword="O" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-635">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-636">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-636">Format</span></span>|<span data-ttu-id="cbc67-637">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-637">Assembly Format</span></span>|<span data-ttu-id="cbc67-638">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-639">8C < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-639">8C < `T` ></span></span>|<span data-ttu-id="cbc67-640">상자</span><span class="sxs-lookup"><span data-stu-id="cbc67-640">box</span></span> `valTypeToken`|<span data-ttu-id="cbc67-641">값 형식 변환 (에서 지정 된 형식의 `valTypeToken`)는 true 개체 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="cbc67-642">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-643">값 형식으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-644">값 형식은 스택에서 팝 되 `box` 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="cbc67-645">결과 "boxed" 값 형식에 대 한 개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-646">값 형식에 별도 두 가지 표현이 공용 언어 인프라 (CLI) 내에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="cbc67-647">스택의 다른 개체 또는 값 형식이 포함 된 경우 사용 된 '원시' 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="cbc67-648">값 형식에서 데이터 줄 바꿈되는 위치 (boxed) 개체에 독립적인 엔터티로 존재할 수 있는 'boxed' 폼입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="cbc67-649">합니다 `box` 명령 개체 참조 '원시' unboxed 값 형식 변환 (형식 `O`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="cbc67-650">새 개체를 만들고 새로 할당 된 개체에 값 형식에서 데이터를 복사 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> `valTypeToken` <span data-ttu-id="cbc67-651">스택에 값 형식의 있음을 나타내는 메타 데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-651">is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <xref:System.OutOfMemoryException> <span data-ttu-id="cbc67-652">메모리가 부족 하 여 요청을 충족할 수 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-652">is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <xref:System.TypeLoadException> <span data-ttu-id="cbc67-653">클래스를 찾을 수 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-653">is thrown if the class cannot be found.</span></span> <span data-ttu-id="cbc67-654">이 일반적으로 언어 MSIL (Microsoft Intermediate) 런타임이 아닌 네이티브 코드로 변환 될 때 감지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-655">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `box` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-656">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-657">조건에 상관 없이 대상 명령으로 제어를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-657">Unconditionally transfers control to a target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-658">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-659">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-659">Format</span></span>|<span data-ttu-id="cbc67-660">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-660">Assembly Format</span></span>|<span data-ttu-id="cbc67-661">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-662">38 < `int32` ></span></span>|<span data-ttu-id="cbc67-663">br</span><span class="sxs-lookup"><span data-stu-id="cbc67-663">br</span></span> `target`|<span data-ttu-id="cbc67-664">지정된 된 오프셋에서 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="cbc67-665">계산 스택 동작이 없습니다이 작업에 의해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="cbc67-666">`br` 명령이 조건에 관계 없이 대상 명령으로 제어를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="cbc67-667">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-668">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-669">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-670">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `br` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-671">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-672">조건에 상관 없이 대상 명령(약식)으로 제어를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-672">Unconditionally transfers control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-673">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-674">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-674">Format</span></span>|<span data-ttu-id="cbc67-675">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-675">Assembly Format</span></span>|<span data-ttu-id="cbc67-676">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-677">2B < `int8` ></span></span>|<span data-ttu-id="cbc67-678">br.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-678">br.s</span></span> `target`|<span data-ttu-id="cbc67-679">지정 된 오프셋 약식 대상 명령으로 분기 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-680">계산 스택 동작이 없습니다이 작업에 의해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="cbc67-681">`br.s` 명령이 조건에 관계 없이 대상 명령으로 제어를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="cbc67-682">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-683">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-684">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-685">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `br.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-686">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-687">중단점이 설정되었음을 디버거에 알리기 위해 CLI(공용 언어 인프라)에 신호를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-688">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-689">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-689">Format</span></span>|<span data-ttu-id="cbc67-690">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-690">Assembly Format</span></span>|<span data-ttu-id="cbc67-691">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-692">01</span><span class="sxs-lookup"><span data-stu-id="cbc67-692">01</span></span>|<span data-ttu-id="cbc67-693">break</span><span class="sxs-lookup"><span data-stu-id="cbc67-693">break</span></span>|<span data-ttu-id="cbc67-694">중단점에 도달 했음을 디버거에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="cbc67-695">계산 스택 동작이 없습니다이 작업에 의해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="cbc67-696">`break` 명령 디버깅 지원입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="cbc67-697">중단점이 설정 되었음을 디버거에 알리기 위해 CLI 신호를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="cbc67-698">있기 인터프리터 상태에 다른 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="cbc67-699">`break` 명령에는 가장 작은 크기 사용 하도록 설정 하면 코드 중단점을 사용 하 여 패치를 가능한 주변 코드에 주는 영향을 최소화할 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="cbc67-700">`break` 명령 디버거에 포착, 아무 작업도 수행 하거나, 보안 예외를 발생 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="cbc67-701">정확한 동작은 구현 시 정의 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="cbc67-702">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `break` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-703">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-704"><paramref name="value" />가 <see langword="false" />, null 참조(Visual Basic에서는 <see langword="Nothing" />) 또는 0인 경우 대상 명령으로 제어를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-705">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-706">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-706">Format</span></span>|<span data-ttu-id="cbc67-707">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-707">Assembly Format</span></span>|<span data-ttu-id="cbc67-708">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-709">39 < `int32` ></span></span>|<span data-ttu-id="cbc67-710">brfalse</span><span class="sxs-lookup"><span data-stu-id="cbc67-710">brfalse</span></span> `target`<br /><br /> <span data-ttu-id="cbc67-711">brnull</span><span class="sxs-lookup"><span data-stu-id="cbc67-711">brnull</span></span> `target`<br /><br /> <span data-ttu-id="cbc67-712">brzero</span><span class="sxs-lookup"><span data-stu-id="cbc67-712">brzero</span></span> `target`|<span data-ttu-id="cbc67-713">이면 지정된 된 오프셋된에서 대상 명령으로 분기 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="cbc67-714">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-715">이 이전 작업으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-715">is pushed onto the stack by a previous operation.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-716">스택에서 팝 되 하는 경우 `value` 됩니다 `false`, 분기 `target`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-716">is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="cbc67-717">`brfalse` 명령 (및 해당 별칭 `brnull` 및 `brzero`) 하는 경우 지정된 된 대상 명령으로 제어가 `value` (형식의 `int32`, `int64`, 개체 참조 `O`관리 되는 포인터 `&`, 임시 포인터 `*`를 `native int`)은 0 (`false`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="cbc67-718">하는 경우 `value` 0이 아닌 (`true`) 다음 명령을 계속 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="cbc67-719">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-720">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-721">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-722">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `brfalse` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-723">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-724"><paramref name="value" />가 <see langword="false" />, null 참조 또는 0인 경우 대상 명령으로 제어를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-725">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-726">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-726">Format</span></span>|<span data-ttu-id="cbc67-727">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-727">Assembly Format</span></span>|<span data-ttu-id="cbc67-728">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-729">2C <`int8` ></span></span>|<span data-ttu-id="cbc67-730">brfalse.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-730">brfalse.s</span></span> `target`<br /><br /> <span data-ttu-id="cbc67-731">brnull.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-731">brnull.s</span></span> `target`<br /><br /> <span data-ttu-id="cbc67-732">brzero.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-732">brzero.s</span></span> `target`|<span data-ttu-id="cbc67-733">이면 지정된 된 오프셋된에서 대상 명령으로 분기 `false`, 약식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-734">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-735">이 이전 작업으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-735">is pushed onto the stack by a previous operation.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-736">스택에서 팝 되 하는 경우 `value` 됩니다 `false`, 분기 `target`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-736">is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="cbc67-737">`brfalse.s` 명령 (및 해당 별칭 `brnull` 및 `brzero`) 하는 경우 지정된 된 대상 명령으로 제어가 `value` (형식의 `int32`, `int64`, 개체 참조 `O`관리 되는 포인터 `&`, 임시 포인터 `*`를 `native int`)은 0 (`false`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="cbc67-738">하는 경우 `value` 0이 아닌 (`true`) 다음 명령을 계속 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="cbc67-739">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-740">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-741">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-742">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `brfalse.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-743">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-744"><paramref name="value" />가 <see langword="true" />이거나 null이 아니거나 0이 아닌 경우 대상 명령으로 제어를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-745">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-746">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-746">Format</span></span>|<span data-ttu-id="cbc67-747">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-747">Assembly Format</span></span>|<span data-ttu-id="cbc67-748">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-749">3A < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-749">3A < `int32` ></span></span>|<span data-ttu-id="cbc67-750">brtrue</span><span class="sxs-lookup"><span data-stu-id="cbc67-750">brtrue</span></span> `target`<br /><br /> <span data-ttu-id="cbc67-751">brinst</span><span class="sxs-lookup"><span data-stu-id="cbc67-751">brinst</span></span> `target`|<span data-ttu-id="cbc67-752">0이 아닌 경우 지정된 된 오프셋에서 대상 명령으로 분기 (`true`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="cbc67-753">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-754">이 이전 작업으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-754">is pushed onto the stack by a previous operation.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-755">스택에서 팝 되 하는 경우 `value` 됩니다 `true`, 분기 `target`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-755">is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="cbc67-756">`brtrue` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value` (형식 `native int`)가 0이 아닌 (`true`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="cbc67-757">하는 경우 `value` 가 0 (`false`) 다음 명령을 계속 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="cbc67-758">경우 `value` 개체 참조 (형식 `O`) 한 다음 `brinst` (별칭 `brtrue`) 개체의 인스턴스를 나타내는 경우 제어를 전송 (없으면 null 개체 참조를 참조 하는 예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="cbc67-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="cbc67-759">대상 명령이 현재 명령 다음에 오는 명령의 4 바이트 부호 있는 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-760">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-761">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-762">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `brtrue` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-763">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-764"><paramref name="value" />가 <see langword="true" />이거나 null이 아니거나 0이 아닌 경우 대상 명령(약식)으로 제어를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-765">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-766">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-766">Format</span></span>|<span data-ttu-id="cbc67-767">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-767">Assembly Format</span></span>|<span data-ttu-id="cbc67-768">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-769">2D < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-769">2D < `int8` ></span></span>|<span data-ttu-id="cbc67-770">brtrue.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-770">brtrue.s</span></span> `target`<br /><br /> <span data-ttu-id="cbc67-771">brinst.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-771">brinst.s</span></span> `target`|<span data-ttu-id="cbc67-772">0이 아닌 경우 지정된 된 오프셋에서 대상 명령으로 분기 (`true`), 약식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="cbc67-773">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-774">이 이전 작업으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-774">is pushed onto the stack by a previous operation.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-775">스택에서 팝 되 하는 경우 `value` 됩니다 `true`, 분기 `target`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-775">is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="cbc67-776">`brtrue.s` 명령이 지정한 대상 명령으로 제어 하는 경우 전달 `value` (형식 `native int`)가 0이 아닌 (`true`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="cbc67-777">하는 경우 `value` 가 0 (`false`) 다음 명령을 계속 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="cbc67-778">경우 `value` 개체 참조 (형식 `O`) 한 다음 `brinst` (별칭 `brtrue`) 개체의 인스턴스를 나타내는 경우 제어를 전송 (없으면 null 개체 참조를 참조 하는 예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="cbc67-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="cbc67-779">대상 명령이 현재 명령 다음에 오는 명령의 시작 부분에서 부호 있는 1 바이트 오프셋으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-780">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="cbc67-781">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-782">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `brtrue.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-783">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-784">전송된 메서드 설명자가 나타내는 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-784">Calls the method indicated by the passed method descriptor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-785">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-786">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-786">Format</span></span>|<span data-ttu-id="cbc67-787">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-787">Assembly Format</span></span>|<span data-ttu-id="cbc67-788">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-789">28 < `T` ></span></span>|<span data-ttu-id="cbc67-790">call</span><span class="sxs-lookup"><span data-stu-id="cbc67-790">call</span></span> `methodDesc`|<span data-ttu-id="cbc67-791">에 설명 된 메서드를 호출 `methodDesc`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="cbc67-792">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-793">메서드 인수 `arg1` 를 통해 `argN` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-794">메서드 인수 `arg1` 를 통해 `argN` 스택에서 팝 되 고 이러한 인수를 사용 하는 메서드가 호출 되 고 메서드 설명자가 참조 하는 메서드로 제어가 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="cbc67-795">완료 되 면 반환 값 수신자 메서드입니다에서 생성 되 고 호출자에 게 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="cbc67-796">반환 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-797">`call` 명령 지침을 사용 하 여 전달 된 메서드 설명자가 나타내는 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="cbc67-798">메서드 설명자는 메서드 호출 및 개수, 형식 및 호출 규칙을 사용할 뿐만 아니라 해당 메서드에 전달할 스택에 배치 된 인수의 순서를 나타내는 메타 데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="cbc67-799">`call` 명령 바로 앞에 나와야를 `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) 접두사 명령을 제어를 전송 하기 전에 현재 메서드가 상태 해제 되어야 함을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="cbc67-800">원본 방법 보다 신뢰도 높은 방법 제어를 전송 하는 호출을 하는 경우에 스택 프레임 해제 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="cbc67-801">대신 실행이 자동으로 계속 처럼는 `tail` 이 제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="cbc67-802">정적 메서드, 인스턴스 메서드, 가상 메서드 또는 전역 함수 호출 되는지 확인 하려면 충분 한 정보를 전달 하는 메타 데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="cbc67-803">이러한 모든 경우에 대상 주소 메서드 설명자에서 전적으로 결정 됩니다 (이 <xref:System.Reflection.Emit.OpCodes.Callvirt> 대상 주소가 또한 인스턴스의 런타임 유형에 따라 결정 가상 메서드를 호출 하는 것에 대 한 지침 참조 하기 전에 푸시를 <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span><span class="sxs-lookup"><span data-stu-id="cbc67-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="cbc67-804">인수는 스택의 왼쪽에서 오른쪽 순서로 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="cbc67-805">즉, 첫 번째 인수 계산 하 고 모든 필요한 인수를 내림차순 스택의 맨 위에 있을 때까지 스택의 두 번째 인수를 차례로 세 번째에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="cbc67-806">다음 세 가지 중요 한 특별 한 경우:</span><span class="sxs-lookup"><span data-stu-id="cbc67-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="cbc67-807">호출 (또는 가상) 인스턴스에 메서드 전에 사용자에 게 표시 되는 인수의 참조 하는 인스턴스를 푸시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="cbc67-808">인스턴스 참조를 null 참조일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="cbc67-809">메타 데이터에 전달 되는 시그니처에 대 한 매개 변수 목록에 항목이 없습니다 합니다 `this` 포인터 대신 사용 하 여 잠시 메서드에 전달 해야 하는지 여부를 나타내는 `this` 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="cbc67-810">사용 하 여 가상 메서드를 호출 하는 것이 유효 `call` (대신 `callvirt`); 메서드가 호출 되는 개체에서 동적으로 지정 하는 것이 아니라 메서드를 지정 하는 클래스를 사용 하 여 확인할 임을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="cbc67-811">대리자의 `Invoke` 메서드를 사용 하 여 호출할 수는 `call` 또는 `callvirt` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <xref:System.Security.SecurityException> <span data-ttu-id="cbc67-812">시스템 보안 호출 된 메서드에 호출자에 게 액세스를 부여 하지 않습니다 하는 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-812">may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="cbc67-813">중간 언어 (MSIL (Microsoft) 지침 런타임이 아닌 네이티브 코드로 변환 됩니다 보안 검사가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cbc67-814">값 형식에 System.Object의 메서드를 호출 하는 경우 사용을 고려 합니다 `constrained` 접두사로 사용 하 여 합니다 `callvirt` 명령을 내보내는 대신는 `call` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="cbc67-815">이 버전 관리 문제가 방지 값 형식에서 메서드를 재정의 하는 여부에 따라 다른 IL 내보낼 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="cbc67-816">사용을 고려 합니다 `constrained` 인터페이스 메서드를 구현 하는 값 형식 메서드 값 형식에 대해 인터페이스 메서드를 이후에 호출 하는 경우 접두사를 사용 하 여 변경할 수 있습니다를 `MethodImpl`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="cbc67-817">이러한 문제에 자세히 설명 되어는 <xref:System.Reflection.Emit.OpCodes.Constrained> opcode입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="cbc67-818">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `call` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-819">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="cbc67-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="cbc67-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cbc67-821">합니다 <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> 에 대 한 메서드가 제공 됩니다 `varargs` 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="cbc67-822">사용 된 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 일반 호출에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="cbc67-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-823">호출 규칙에서 설명하는 인수를 사용하여 계산 스택에 표시된 메서드를 진입점에 대한 포인터로 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-824">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-825">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-825">Format</span></span>|<span data-ttu-id="cbc67-826">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-826">Assembly Format</span></span>|<span data-ttu-id="cbc67-827">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-828">29 < `T` ></span></span>|<span data-ttu-id="cbc67-829">calli</span><span class="sxs-lookup"><span data-stu-id="cbc67-829">calli</span></span> `callSiteDescr`|<span data-ttu-id="cbc67-830">호출 규칙을 통해 설명 하는 인수를 사용 하 여 가리키는 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="cbc67-831">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-832">메서드 인수 `arg1` 를 통해 `argN` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-833">메서드 진입점으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-834">메서드 인수 `arg1` 를 통해 `argN` 메서드 항목 포인터는 스택에서 팝 하 고 메서드 호출이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="cbc67-835">완료 되 면 반환 값 수신자 메서드입니다에서 생성 되 고 호출자에 게 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="cbc67-836">반환 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-837">합니다 `calli` 명령 호출 인수를 사용 하 여 메서드 진입점 `arg1` 를 통해 `argN`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="cbc67-838">이러한 인수의 형식 특정 호출 규칙을 통해 설명 되어 있습니다 (`callSiteDesc`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="cbc67-839">합니다 `calli` 명령에서 바로 뒤를 `tail` 접두사 (<xref:System.Reflection.Emit.OpCodes.Tailcall>) 제어를 전송 하기 전에 현재 메서드가 상태 해제 되어야 함을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="cbc67-840">호출이 전달 스택 프레임 원본 메서드보다 더 높은 신뢰 메서드로 제어를 해제 하지는; 대신 계속 실행 됩니다 자동으로 처럼는 `tail` 이 제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="cbc67-841">메서드 진입점 (대상 컴퓨터)의 호출 규칙 (독립 실행형 서명에 대 한 메타 데이터 토큰)을 통해 설명 하는 인수를 사용 하 여 합법적인 방식으로 호출할 수 있는 네이티브 코드에 특정 대 한 포인터로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="cbc67-842">이러한 포인터를 사용 하 여 만들 수 있습니다는 <xref:System.Reflection.Emit.OpCodes.Ldftn> 또는 <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> 내용은 네이티브 코드에서 전달 된 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="cbc67-843">호출 규칙을 동적으로 선택 하지 않으면, 따라서 사용 하는 코드는 `calli` 대상 지정된 된 호출 규칙을 실제로 사용 하지 않는 경우 명령이 제대로 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="cbc67-844">인수는 스택의 왼쪽에서 오른쪽 순서로 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="cbc67-845">즉, 첫 번째 인수 계산 하 고 모든 필요한 인수를 내림차순 스택의 맨 위에 있을 때까지 스택의 두 번째 인수를 차례로 세 번째에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="cbc67-846">인스턴스 또는 가상 메서드를 인수 빌드 코드 시퀀스 전에 사용자에 게 표시 되는 인수의 (null 참조를 이어야 함)는 해당 인스턴스 참조를 푸시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <xref:System.Security.SecurityException> <span data-ttu-id="cbc67-847">시스템 보안 호출 된 메서드에 호출자에 게 액세스를 부여 하지 않습니다 하는 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-847">may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="cbc67-848">보안 검사는 Microsoft 중간 언어 (MSIL) 명령을 런타임이 아닌 네이티브 코드로 변환 될 때 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-849">다음 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> 메서드를 사용 하 여을 수행할 수 있습니다는 `calli` 스택에 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="cbc67-850">유의 `calli` 를 통해 호출 해야는 메서드를 사용 하지 않고 아래는 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 스택에 직접 명령을 배치 하는 클래스.</span><span class="sxs-lookup"><span data-stu-id="cbc67-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="cbc67-851">ILGenerator.EmitCalli (Opcode, CallingConventions, 형식, Type, 관리 되는 호출 규칙을 사용 하 여 호출에 대 한 Type[]) 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="cbc67-852">ILGenerator.EmitCalli (Opcode는 관리 되지 않는 호출 규칙을 사용 하 여 호출에 대 한 Type[]) CallingConvention, 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-853">개체에서 런타임에 바인딩된 메서드를 호출하고 반환 값을 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-854">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-855">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-855">Format</span></span>|<span data-ttu-id="cbc67-856">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-856">Assembly Format</span></span>|<span data-ttu-id="cbc67-857">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-858">6F < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-858">6F < `T` ></span></span>|<span data-ttu-id="cbc67-859">callvirt</span><span class="sxs-lookup"><span data-stu-id="cbc67-859">callvirt</span></span> `method`|<span data-ttu-id="cbc67-860">연결 된 특정 메서드를 호출 `obj`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="cbc67-861">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-862">개체 참조 `obj` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-863">메서드 인수 `arg1` 를 통해 `argN` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-864">메서드 인수 `arg1` 를 통해 `argN` 및 개체 참조 `obj` 스택에서 팝 되 고 이러한 인수를 사용 하는 메서드가 호출 되 고 메서드에 제어가 `obj` 메서드에서 참조 메타 데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="cbc67-865">완료 되 면 반환 값 수신자 메서드입니다에서 생성 되 고 호출자에 게 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="cbc67-866">반환 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-867">`callvirt` 명령 개체에 런타임에 바인딩된 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="cbc67-868">즉, 메서드가의 런타임 형식에 따라 선택 됩니다 `obj` 메서드 포인터에 표시 되는 컴파일 타임 클래스 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> `Callvirt` <span data-ttu-id="cbc67-869">가상 호출 모두 인스턴스 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-869">can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="cbc67-870">합니다 `callvirt` 명령에서 바로 뒤를 `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) 제어를 전송 하기 전에 현재 스택 프레임 해제 되어야 함을 지정 하는 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="cbc67-871">전달 호출 스택 프레임을 원래 메서드보다 더 높은 신뢰 메서드로 제어를 하지 릴리스됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="cbc67-872">메서드 메타 데이터 토큰에는 이름, 클래스 및 서명의 호출할 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="cbc67-873">관련 된 클래스 `obj` 클래스 인스턴스는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="cbc67-874">표시 된 메서드 이름 및 서명 일치 하는 비정적 메서드를 정의 하는 클래스,이 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="cbc67-875">그렇지 않으면이 클래스의 기본 클래스 체인의 모든 클래스는 순서 대로 검사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="cbc67-876">메서드가 없는 경우 오류를입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-876">It is an error if no method is found.</span></span>  
  
 `Callvirt` <span data-ttu-id="cbc67-877">메서드를 호출 하기 전에 개체 및 관련 된 인수를 계산 스택에서 팝 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-877">pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="cbc67-878">메서드 반환 값이 있으면 메서드가 완료 될 때 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="cbc67-879">호출 수신자 쪽 합니다 `obj` 매개 변수 인수 0으로 액세스할 `arg1` 인수 1 등과 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="cbc67-880">인수는 스택의 왼쪽에서 오른쪽 순서로 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="cbc67-881">즉, 첫 번째 인수 계산 하 고 모든 필요한 인수를 내림차순 스택의 맨 위에 있을 때까지 스택의 두 번째 인수를 차례로 세 번째에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="cbc67-882">인스턴스 참조 `obj` (항상 필요한 `callvirt`) 전에 사용자에 게 표시 되는 인수의 푸시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="cbc67-883">(메타 데이터 토큰에서 수행) 서명이에 대 한 매개 변수 목록의 항목을 포함할 필요가 대 한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="cbc67-884">가상 메서드를 호출할 수도 있습니다를 사용 하 여 확인 된 <xref:System.Reflection.Emit.OpCodes.Call> 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <xref:System.MissingMethodException> <span data-ttu-id="cbc67-885">관련 된 클래스에 표시 된 이름 및 서명을 사용 하 여 비정적 메서드를 찾을 수 없는 경우 throw 되 `obj` 또는 해당 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-885">is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="cbc67-886">이 일반적으로 언어 MSIL (Microsoft Intermediate) 명령이 런타임이 아닌 네이티브 코드로 변환 될 때 감지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-887">obj null 이면 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-887">is thrown if obj is null.</span></span>  
  
 <xref:System.Security.SecurityException> <span data-ttu-id="cbc67-888">시스템 보안 호출 된 메서드에 호출자에 게 액세스를 부여 하지 않는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-888">is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="cbc67-889">보안 검사를 CIL이 런타임이 아닌 네이티브 코드로 변환 될 때 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cbc67-890">값 형식에 System.Object의 메서드를 호출 하는 경우 사용을 고려 합니다 `constrained` 접두사로 사용 하 여는 `callvirt` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="cbc67-891">이 버전 관리 문제가 방지 값 형식에서 메서드를 재정의 하는 여부에 따라 다른 IL 내보낼 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="cbc67-892">사용을 고려 합니다 `constrained` 인터페이스 메서드를 구현 하는 값 형식 메서드 값 형식에 대해 인터페이스 메서드를 이후에 호출 하는 경우 접두사를 사용 하 여 변경할 수 있습니다를 `MethodImpl`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="cbc67-893">이러한 문제에 자세히 설명 되어는 <xref:System.Reflection.Emit.OpCodes.Constrained> opcode입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="cbc67-894">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `callvirt` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-895">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="cbc67-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="cbc67-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-897">참조로 전송된 개체를 지정된 클래스로 캐스팅하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-897">Attempts to cast an object passed by reference to the specified class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-898">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-899">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-899">Format</span></span>|<span data-ttu-id="cbc67-900">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-900">Assembly Format</span></span>|<span data-ttu-id="cbc67-901">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-902">74 < `T` ></span></span>|<span data-ttu-id="cbc67-903">castclass</span><span class="sxs-lookup"><span data-stu-id="cbc67-903">castclass</span></span> `class`|<span data-ttu-id="cbc67-904">형식의 새 개체를 캐스팅 `class`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="cbc67-905">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-906">개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-907">개체 참조는 스택에서 팝 되 참조 된 개체 캐스팅 되는 지정 된 대로 `class`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="cbc67-908">성공 하면 새 개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-909">`castclass` 명령 개체 참조를 캐스팅을 시도 하며 (형식 `O`) 지정된 된 클래스를 스택의 맨 위에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="cbc67-910">새 클래스는 원하는 클래스를 나타내는 메타 데이터 토큰에 의해 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="cbc67-911">스택의 맨 위에 개체의 클래스 (새 클래스는 인터페이스를 가정) 새 클래스를 구현 하지 않습니다 하 고 새 클래스의 파생된 클래스가 없는 경우는 <xref:System.InvalidCastException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="cbc67-912">개체 참조가 null 참조 이면 `castclass` 성공 하 고 새 개체는 null 참조를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <xref:System.InvalidCastException> <span data-ttu-id="cbc67-913">obj 클래스 캐스팅할 수 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-913">is thrown if obj cannot be cast to class.</span></span>  
  
 <xref:System.TypeLoadException> <span data-ttu-id="cbc67-914">클래스를 찾을 수 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-914">is thrown if class cannot be found.</span></span> <span data-ttu-id="cbc67-915">이 상황은 중간 MSIL (Microsoft Language) 명령 런타임이 아닌 네이티브 코드로 변환 될 때 일반적으로 발견 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-915">This is typically detected when a Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-916">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `castclass` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-917">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-918">두 값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-918">Compares two values.</span></span> <span data-ttu-id="cbc67-919">두 값이 같으면 정수 값 1(<see langword="(int32" />)이 계산 스택으로 푸시되고, 그렇지 않으면 0(<see langword="int32" />)이 계산 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-920">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-921">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-921">Format</span></span>|<span data-ttu-id="cbc67-922">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-922">Assembly Format</span></span>|<span data-ttu-id="cbc67-923">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="cbc67-924">FE 01</span></span>|<span data-ttu-id="cbc67-925">ceq</span><span class="sxs-lookup"><span data-stu-id="cbc67-925">ceq</span></span>|<span data-ttu-id="cbc67-926">하는 경우 1을 푸시합니다 `value1` equals `value2`고, 그렇지 않으면 0을 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="cbc67-927">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-928">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-928">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-929">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-929">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-930">및 `value1` 스택에서 팝 되 고 `value1` 비교할 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-930">and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="cbc67-931">하는 경우 `value1` 값과 같음 `value2`, 1은 스택에; 그렇지 않으면 0이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-932">합니다 `ceq` 명령 비교 `value1` 고 `value2`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="cbc67-933">하는 경우 `value1` 값과 같음 `value2`, 다음 1 (형식의 `int32`) 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="cbc67-934">그렇지 않으면 0 (형식의 `int32`) 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-935">부동 소수점 숫자에 대 한 `ceq` 숫자 순서가 지정 된 경우 0을 반환 합니다 (하나 또는 둘 모두가 NaN).</span><span class="sxs-lookup"><span data-stu-id="cbc67-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="cbc67-936">무한 한 값은 자기 자신과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="cbc67-937">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ceq` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-939">두 값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-939">Compares two values.</span></span> <span data-ttu-id="cbc67-940">첫째 값이 둘째 값보다 크면 정수 값 1(<see langword="(int32" />)이 계산 스택으로 푸시되고, 그렇지 않으면 0(<see langword="int32" />)이 계산 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-941">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-942">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-942">Format</span></span>|<span data-ttu-id="cbc67-943">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-943">Assembly Format</span></span>|<span data-ttu-id="cbc67-944">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="cbc67-945">FE 02</span></span>|<span data-ttu-id="cbc67-946">cgt</span><span class="sxs-lookup"><span data-stu-id="cbc67-946">cgt</span></span>|<span data-ttu-id="cbc67-947">하는 경우 1을 푸시합니다 `value1` 보다 크면 `value2`고, 그렇지 않으면 0을 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="cbc67-948">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-949">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-949">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-950">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-950">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-951">및 `value1` 스택에서 팝 되 고 `cgt` 테스트 `value1` 보다 크면 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-951">and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="cbc67-952">하는 경우 `value1` 보다 크면 `value2`, 1이 스택에 푸시됩니다; 그렇지 않으면 0이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-953">합니다 `cgt` 명령 비교 `value1` 고 `value2`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="cbc67-954">하는 경우 `value1` 보다 엄격 하 게 크면 `value2`에 `int32` 1의 값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="cbc67-955">그렇지 않은 경우는 `int32` 0의 값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="cbc67-956">부동 소수점 숫자에 대 한 `cgt` 경우 (즉, 경우 인수 중 하나 이상이 NaN) 숫자 순서가 없으면 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="cbc67-957">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `cgt` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-958">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-959">부호가 없거나 순서가 없는 두 값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-959">Compares two unsigned or unordered values.</span></span> <span data-ttu-id="cbc67-960">첫째 값이 둘째 값보다 크면 정수 값 1(<see langword="(int32" />)이 계산 스택으로 푸시되고, 그렇지 않으면 0(<see langword="int32" />)이 계산 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-961">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-962">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-962">Format</span></span>|<span data-ttu-id="cbc67-963">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-963">Assembly Format</span></span>|<span data-ttu-id="cbc67-964">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="cbc67-965">FE 03</span></span>|<span data-ttu-id="cbc67-966">cgt.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-966">cgt.un</span></span>|<span data-ttu-id="cbc67-967">하는 경우 1을 푸시합니다 `value1` 보다 크면 `value2`고, 그렇지 않으면 0 (부호 없는 값)를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="cbc67-968">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-969">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-969">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-970">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-970">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-971">및 `value1` 스택에서 팝 되 고 `cgt.un` 테스트 `value1` 보다 크면 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-971">and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="cbc67-972">하는 경우 `value1` 보다 크면 `value2`, 1이 스택에 푸시됩니다; 그렇지 않으면 0이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-973">`int32` 1의 값이 다음 중 하나라도 스택에 푸시됩니다 `true` :</span><span class="sxs-lookup"><span data-stu-id="cbc67-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="cbc67-974">부동 소수점 `value1` 기준으로 정렬 되지 않은 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="cbc67-975">정수 값에 대 한 `value1` 보다 엄격 하 게 크면 `value2` 부호 없는 숫자로 간주 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="cbc67-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="cbc67-976">그렇지 않은 경우는 `int32` 0의 값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-977">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `cgt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-978">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-979">값이 유한 값이 아니면 <see cref="T:System.ArithmeticException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-980">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-981">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-981">Format</span></span>|<span data-ttu-id="cbc67-982">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-982">Assembly Format</span></span>|<span data-ttu-id="cbc67-983">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-984">C3</span><span class="sxs-lookup"><span data-stu-id="cbc67-984">C3</span></span>|<span data-ttu-id="cbc67-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="cbc67-985">ckfinite</span></span>|<span data-ttu-id="cbc67-986">throw <xref:System.ArithmeticException> 값이 유한 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="cbc67-987">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-988">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-988">is pushed onto the stack.</span></span> 
  
2.  `value` <span data-ttu-id="cbc67-989">스택에서 팝 되 고 `ckfinite` 명령에 대해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-989">is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  `value` <span data-ttu-id="cbc67-990">스택에 다시 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-990">is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-991">합니다 `ckfinite instruction` throw <xref:System.ArithmeticException> 하는 경우 `value` (부동 소수점 숫자)입니다는 "숫자가 아님" 값 (NaN) 또는 `+-` 무한대 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> `Ckfinite` <span data-ttu-id="cbc67-992">예외가 throw 되 면 스택의 값을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-992">leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="cbc67-993">실행 지정 되지 경우 `value` 부동 소수점 숫자가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <xref:System.ArithmeticException> <span data-ttu-id="cbc67-994">이 throw `value` 'normal' 숫자가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-994">is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="cbc67-995">특별 한 예외 또는 파생된 클래스의 <xref:System.ArithmeticException> 알맞은 예외 처리기에 잘못 된 값을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="cbc67-996">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ckfinite` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-997">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-998">두 값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-998">Compares two values.</span></span> <span data-ttu-id="cbc67-999">첫째 값이 둘째 값보다 작으면 정수 값 1(<see langword="(int32" />)이 계산 스택으로 푸시되고, 그렇지 않으면 0(<see langword="int32" />)이 계산 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1000">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1001">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1001">Format</span></span>|<span data-ttu-id="cbc67-1002">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1002">Assembly Format</span></span>|<span data-ttu-id="cbc67-1003">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="cbc67-1004">FE 04</span></span>|<span data-ttu-id="cbc67-1005">clt</span><span class="sxs-lookup"><span data-stu-id="cbc67-1005">clt</span></span>|<span data-ttu-id="cbc67-1006">경우 1을 푸시합니다 `value1` 는 보다 작은 `value2`고, 그렇지 않으면 0을 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="cbc67-1007">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1007">The stack transitional behavior, in sequential order, is:</span></span> 

1.  `value1` <span data-ttu-id="cbc67-1008">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1008">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-1009">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1009">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-1010">및 `value1` 스택에서 팝 되 고 `clt` 테스트 `value1` 는 보다 작은 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1010">and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="cbc67-1011">하는 경우 `value1` 는 보다 작은 `value2`, 1이 스택에 푸시됩니다; 그렇지 않으면 0이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1011">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1012">합니다 `clt` 명령 비교 `value1` 고 `value2`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1012">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="cbc67-1013">하는 경우 `value1` 는 보다 작아야 `value2`에 `int32` 1의 값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1013">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="cbc67-1014">그렇지 않은 경우는 `int32` 0의 값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1014">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="cbc67-1015">부동 소수점 숫자에 대 한 `clt` 경우 (즉, 경우 인수 중 하나 이상이 NaN) 숫자 순서가 없으면 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1015">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="cbc67-1016">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `clt` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1016">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1017">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1017">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1018">부호가 없거나 순서가 없는 <paramref name="value1" />과 <paramref name="value2" />를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1018">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span></span> <span data-ttu-id="cbc67-1019"><paramref name="value1" />이 <paramref name="value2" />보다 작으면 정수 값 1(<see langword="(int32" />)이 계산 스택으로 푸시되고, 그렇지 않으면 0(<see langword="int32" />)이 계산 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1019">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1020">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1021">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1021">Format</span></span>|<span data-ttu-id="cbc67-1022">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1022">Assembly Format</span></span>|<span data-ttu-id="cbc67-1023">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1024">FE 05</span><span class="sxs-lookup"><span data-stu-id="cbc67-1024">FE 05</span></span>|<span data-ttu-id="cbc67-1025">clt.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1025">clt.un</span></span>|<span data-ttu-id="cbc67-1026">하는 경우 1을 푸시합니다 `value1` 는 보다 작은 `value2`고, 그렇지 않으면 0 (부호 없는 값)를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1026">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="cbc67-1027">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-1028">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1028">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-1029">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1029">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-1030">및 `value1` 스택에서 팝 되 고 `clt.un` 테스트 `value1` 는 보다 작은 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1030">and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="cbc67-1031">하는 경우 `value1` 는 보다 작은 `value2`, 1이 스택에 푸시됩니다; 그렇지 않으면 0이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1031">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1032">합니다 `clt.un` 명령 비교 `value1` 고 `value2`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1032">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="cbc67-1033">`int32` 다음 중 하나라도 true 값이 1 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1033">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   `value1` <span data-ttu-id="cbc67-1034">보다 작아야 `value2` (으로 `clt`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1034">is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="cbc67-1035">부동 소수점 `value1` 기준으로 정렬 되지 않은 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1035">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="cbc67-1036">정수 값에 대 한 `value1` 는 보다 작아야 `value2` 부호 없는 숫자로 간주 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1036">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="cbc67-1037">그렇지 않은 경우는 `int32` 0의 값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1037">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1038">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `clt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1038">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1039">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1039">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1040">가상 메서드가 호출되는 형식을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1040">Constrains the type on which a virtual method call is made.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1041">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 Microsoft 중간 언어 (MSIL) 어셈블리 형식으로 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1041">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1042">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1042">Format</span></span>|<span data-ttu-id="cbc67-1043">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1043">Assembly Format</span></span>|<span data-ttu-id="cbc67-1044">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1044">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1045">FE 16 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-1045">FE 16 < `T` ></span></span>|<span data-ttu-id="cbc67-1046">제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1046">constrained.</span></span> `thisType`|<span data-ttu-id="cbc67-1047">형식으로 제한 된 형식에서 가상 메서드 호출 `T`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1047">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="cbc67-1048">`constrained` 접두사의 경우에 허용 되는 `callvirt` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1048">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="cbc67-1049">이 시점에서 MSIL 스택의 상태는 다음과 같이 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1049">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="cbc67-1050">관리 되는 포인터 `ptr`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1050">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="cbc67-1051">유형의 `ptr` 관리 되는 포인터 여야 합니다 (`&`)를 `thisType`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1051">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="cbc67-1052">이 접두사가 없는 경우 다른입니다 `callvirt` 명령에 대 한 참조를 필요한 `thisType`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1052">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="cbc67-1053">메서드 인수 `arg1` 를 통해 `argN` 에서 마찬가지로 접두사가 없는 스택으로 푸시됩니다 `callvirt` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1053">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="cbc67-1054">합니다 `constrained` 접두사를 허용 하도록 되어 `callvirt` 가능 하도록 일관 된 방식 인지에 관계 없이 지침 `thisType` 값 형식 이거나 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1054">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="cbc67-1055">경우는 `callvirt` `method` 명령에 접두사로 `constrained` `thisType`, 명령을 다음과 같이 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1055">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="cbc67-1056">경우 `thisType` 참조 형식 (달리 값 형식) 이면 `ptr` 역참조 되며 'this'이 포인터를 변수로 전달 합니다 `callvirt` 의 `method`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1056">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="cbc67-1057">경우 `thisType` 값 형식인 및 `thisType` 구현 `method` 한 다음 `ptr` 'this' 대이 한 포인터로 수정 되지 않은 상태로 전달 됩니다는 `call` `method` 구현에 대 한 지침 `method` 여`thisType`.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1057">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="cbc67-1058">경우 `thisType` 값 형식인 및 `thisType` 를 구현 하지 않습니다 `method` 한 다음 `ptr` 역참조, box 및 'this'이 포인터를 변수로 전달 되는 `callvirt` `method` 명령.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1058">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="cbc67-1059">이 마지막 경우 경우에만 `method` 에 정의 된 <xref:System.Object>, <xref:System.ValueType>, 또는 <xref:System.Enum> 으로 재정의 되지 않은 `thisType`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1059">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="cbc67-1060">이 경우 boxing 하면 되도록 원래 개체의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1060">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="cbc67-1061">그러나 있으므로의 메서드 <xref:System.Object>, <xref:System.ValueType>, 및 <xref:System.Enum> 상태를 수정할 개체의이 팩트를 검색할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1061">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="cbc67-1062">`constrained` 접두사 IL 생성기 제네릭 코드 만들기를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1062">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="cbc67-1063">일반적으로 `callvirt` 명령 값 형식에 대해 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1063">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="cbc67-1064">대신 IL 컴파일러의 형식에 따라 컴파일 타임에 위에서 설명한 'this'이 변환을 효과적으로 수행 하는 `ptr` 및 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1064">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="cbc67-1065">그러나 경우 `ptr` 컴파일 타임에 알 수 없는 제네릭 형식이 컴파일 타임에이 변환을 수행할 수 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1065">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="cbc67-1066">합니다 `constrained` opcode를 사용 하면 호출을 수행할 수는 가상 함수에 일관 된 방식 인지에 관계 없이 IL 컴파일러 `ptr` 값 형식 이거나 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1066">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="cbc67-1067">경우에 대 한 것 이지만 여기서 `thisType` 은 제네릭 형식 변수는 `constrained` 작동 제네릭이 아닌 형식에도 접두사 및 값 형식 간의 차이 숨기는 언어의 가상 호출을 생성 하는 복잡성을 줄일 수 및 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1067">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="cbc67-1068">사용 하 여 `constrained` 접두사 값 형식 버전 관리 문제가 발생할 가능성을 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1068">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="cbc67-1069">경우는 `constrained` 접두사가 사용 되지 않으면, 값 형식이 System.Object의 메서드를 재정의 하는 여부에 따라 다양 한 IL을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1069">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="cbc67-1070">예를 들어, 값 형식 `V` object.tostring () 메서드를 재정의 하는 `call` `V.ToString()` 명령을 내보냅니다; 하지 않는 경우는 `box` 명령 및 `callvirt` `Object.ToString()` 명령을 내보내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1070">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="cbc67-1071">재정의 나중에 추가 되 면 버전 관리 문제는 후자의 경우 나중에 재정의 제거 하는 경우 전자의 경우에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1071">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="cbc67-1072">합니다 `constrained` 접두사 사용할 수도 있습니다 값 형식에 대해 인터페이스 메서드 호출에 대 한 인터페이스 메서드를 구현 하는 값 형식 메서드를 사용 하 여 변경할 수 있으므로 `MethodImpl`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1072">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="cbc67-1073">경우는 `constrained` 접두사가 사용 되지 않으면, 컴파일러는 값의 컴파일 타임에 바인딩할 형식의 메서드를 선택 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1073">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="cbc67-1074">사용 하는 `constrained` 접두사 MSIL 컴파일 시간이 아닌 런타임에 인터페이스 메서드를 구현 하는 메서드에 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1074">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="cbc67-1075">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `constrained` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1075">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1076">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1076">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1077">계산 스택 맨 위에 있는 값을 <see langword="native int" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1077">Converts the value on top of the evaluation stack to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1078">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1078">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1079">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1079">Format</span></span>|<span data-ttu-id="cbc67-1080">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1080">Assembly Format</span></span>|<span data-ttu-id="cbc67-1081">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1081">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1082">D3</span><span class="sxs-lookup"><span data-stu-id="cbc67-1082">D3</span></span>|<span data-ttu-id="cbc67-1083">conv.i</span><span class="sxs-lookup"><span data-stu-id="cbc67-1083">conv.i</span></span>|<span data-ttu-id="cbc67-1084">변환할 `native int`푸싱, `native int` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1084">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1085">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1085">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1086">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1086">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1087">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1087">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1088">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1088">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1089">합니다 `conv.i` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1089">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1090">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1090">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1091">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1091">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1092">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1092">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1093">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1093">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1094">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1094">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1095">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1095">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1096">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1096">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1097">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1097">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1098">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1098">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1099">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1099">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1100">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1100">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1101">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1101">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1102">계산 스택 맨 위에 있는 값을 <see langword="int8" />으로 변환하여 <see langword="int32" />로 확장합니다(채웁니다).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1102">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1103">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1103">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1104">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1104">Format</span></span>|<span data-ttu-id="cbc67-1105">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1105">Assembly Format</span></span>|<span data-ttu-id="cbc67-1106">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1106">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1107">67</span><span class="sxs-lookup"><span data-stu-id="cbc67-1107">67</span></span>|<span data-ttu-id="cbc67-1108">conv.i1</span><span class="sxs-lookup"><span data-stu-id="cbc67-1108">conv.i1</span></span>|<span data-ttu-id="cbc67-1109">변환할 `int8`푸싱, `int32` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1109">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1110">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1110">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1111">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1111">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1112">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1112">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1113">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1113">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1114">합니다 `conv.i1` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1114">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1115">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1115">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1116">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1116">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1117">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1117">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1118">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1118">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1119">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1119">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1120">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1120">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1121">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1121">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1122">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1122">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1123">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1123">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1124">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1124">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1125">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1125">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1126">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1126">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1127">계산 스택 맨 위에 있는 값을 <see langword="int16" />으로 변환하여 <see langword="int32" />로 확장합니다(채웁니다).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1127">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1128">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1128">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1129">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1129">Format</span></span>|<span data-ttu-id="cbc67-1130">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1130">Assembly Format</span></span>|<span data-ttu-id="cbc67-1131">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1131">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1132">68</span><span class="sxs-lookup"><span data-stu-id="cbc67-1132">68</span></span>|<span data-ttu-id="cbc67-1133">conv.i2</span><span class="sxs-lookup"><span data-stu-id="cbc67-1133">conv.i2</span></span>|<span data-ttu-id="cbc67-1134">변환할 `int16`푸싱, `int32` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1134">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1135">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1135">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1136">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1136">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1137">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1137">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1138">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1138">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1139">합니다 `conv.i2` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1139">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1140">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1140">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1141">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1141">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1142">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1142">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1143">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1143">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1144">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1144">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1145">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1145">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1146">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1146">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1147">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1147">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1148">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1148">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1149">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1149">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1150">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1150">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1151">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1151">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1152">계산 스택 맨 위에 있는 값을 <see langword="int32" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1152">Converts the value on top of the evaluation stack to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1153">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1153">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1154">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1154">Format</span></span>|<span data-ttu-id="cbc67-1155">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1155">Assembly Format</span></span>|<span data-ttu-id="cbc67-1156">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1156">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1157">69</span><span class="sxs-lookup"><span data-stu-id="cbc67-1157">69</span></span>|<span data-ttu-id="cbc67-1158">conv.i4</span><span class="sxs-lookup"><span data-stu-id="cbc67-1158">conv.i4</span></span>|<span data-ttu-id="cbc67-1159">변환할 `int32`푸싱, `int32` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1159">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1160">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1160">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1161">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1161">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1162">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1162">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1163">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1163">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1164">합니다 `conv.i4` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1164">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1165">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1165">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1166">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1166">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1167">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1167">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1168">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1168">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1169">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1169">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1170">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1170">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1171">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1171">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1172">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1172">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1173">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1173">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1174">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1174">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1175">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1176">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1176">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1177">계산 스택 맨 위에 있는 값을 <see langword="int64" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1177">Converts the value on top of the evaluation stack to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1178">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1179">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1179">Format</span></span>|<span data-ttu-id="cbc67-1180">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1180">Assembly Format</span></span>|<span data-ttu-id="cbc67-1181">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1182">6A</span><span class="sxs-lookup"><span data-stu-id="cbc67-1182">6A</span></span>|<span data-ttu-id="cbc67-1183">conv.i8</span><span class="sxs-lookup"><span data-stu-id="cbc67-1183">conv.i8</span></span>|<span data-ttu-id="cbc67-1184">변환할 `int64`푸싱, `int64` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1184">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1185">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1186">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1186">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1187">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1187">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1188">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1188">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1189">합니다 `conv.i8` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1189">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1190">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1190">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1191">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1191">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1192">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1192">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1193">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1193">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1194">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1194">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1195">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1195">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1196">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1196">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1197">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1197">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1198">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1198">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1199">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1199">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1200">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1202">계산 스택 맨 위에 있는 부호 있는 값을 부호 있는 <see langword="native int" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1202">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1203">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1204">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1204">Format</span></span>|<span data-ttu-id="cbc67-1205">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1205">Assembly Format</span></span>|<span data-ttu-id="cbc67-1206">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1207">D4</span><span class="sxs-lookup"><span data-stu-id="cbc67-1207">D4</span></span>|<span data-ttu-id="cbc67-1208">conv.ovf.i</span><span class="sxs-lookup"><span data-stu-id="cbc67-1208">conv.ovf.i</span></span>|<span data-ttu-id="cbc67-1209">변환할를 `native int` (스택에 `native int`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1209">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1210">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1211">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1211">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1212">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1212">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1213">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1213">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1214">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1214">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1215">합니다 `conv.ovf.i` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1215">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1216">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1216">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1217">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1217">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1218">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1218">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1219">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1219">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1220">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1220">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1221">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1221">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1222">계산 스택 맨 위에 있는 부호 없는 값을 부호 있는 <see langword="native int" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1222">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1223">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1223">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1224">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1224">Format</span></span>|<span data-ttu-id="cbc67-1225">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1225">Assembly Format</span></span>|<span data-ttu-id="cbc67-1226">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1226">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1227">8A</span><span class="sxs-lookup"><span data-stu-id="cbc67-1227">8A</span></span>|<span data-ttu-id="cbc67-1228">conv.ovf.i.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1228">conv.ovf.i.un</span></span>|<span data-ttu-id="cbc67-1229">부호 없는 값으로 변환 합니다는 `native int` (스택에 `native int`) 오버플로 대 한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1229">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1230">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1230">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1231">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1231">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1232">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1232">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1233">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1233">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1234">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1234">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1235">합니다 `conv.ovf.i.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1235">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1236">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1236">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1237">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1237">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1238">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1238">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1239">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1239">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1240">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1241">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1241">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1242">계산 스택 맨 위에 있는 부호 있는 값을 부호 있는 <see langword="int8" />로 변환하고 <see langword="int32" />로 확장하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1242">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1243">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1243">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1244">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1244">Format</span></span>|<span data-ttu-id="cbc67-1245">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1245">Assembly Format</span></span>|<span data-ttu-id="cbc67-1246">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1246">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1247">B3</span><span class="sxs-lookup"><span data-stu-id="cbc67-1247">B3</span></span>|<span data-ttu-id="cbc67-1248">conv.ovf.i1</span><span class="sxs-lookup"><span data-stu-id="cbc67-1248">conv.ovf.i1</span></span>|<span data-ttu-id="cbc67-1249">변환할를 `int8` (스택에 `int32`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1249">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1250">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1250">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1251">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1251">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1252">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1252">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1253">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1253">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1254">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1254">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1255">합니다 `conv.ovf.i1` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1255">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1256">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1256">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1257">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1257">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1258">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1258">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1259">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1259">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1260">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1260">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1261">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1261">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1262">계산 스택 맨 위에 있는 부호 없는 값을 부호 있는 <see langword="int8" />로 변환하고 <see langword="int32" />로 확장하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1262">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1263">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1263">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1264">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1264">Format</span></span>|<span data-ttu-id="cbc67-1265">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1265">Assembly Format</span></span>|<span data-ttu-id="cbc67-1266">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1266">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1267">82</span><span class="sxs-lookup"><span data-stu-id="cbc67-1267">82</span></span>|<span data-ttu-id="cbc67-1268">conv.ovf.i1.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1268">conv.ovf.i1.un</span></span>|<span data-ttu-id="cbc67-1269">부호 없는 값으로 변환 합니다는 `int8` (스택에 `int32`) 오버플로 대 한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1269">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1270">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1270">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1271">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1271">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1272">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1272">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1273">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1273">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1274">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1274">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1275">합니다 `conv.ovf.i1.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1275">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1276">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1276">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1277">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1277">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1278">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1278">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1279">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1279">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1280">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i1.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1280">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1281">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1281">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1282">계산 스택 맨 위에 있는 부호 있는 값을 부호 있는 <see langword="int16" />으로 변환하고 <see langword="int32" />로 확장하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1282">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1283">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1283">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1284">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1284">Format</span></span>|<span data-ttu-id="cbc67-1285">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1285">Assembly Format</span></span>|<span data-ttu-id="cbc67-1286">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1286">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1287">B5</span><span class="sxs-lookup"><span data-stu-id="cbc67-1287">B5</span></span>|<span data-ttu-id="cbc67-1288">conv.ovf.i2</span><span class="sxs-lookup"><span data-stu-id="cbc67-1288">conv.ovf.i2</span></span>|<span data-ttu-id="cbc67-1289">변환할를 `int16` (스택에 `int32`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1289">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1290">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1290">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1291">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1291">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1292">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1292">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1293">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1293">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1294">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1294">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1295">합니다 `conv.ovf.i2` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1295">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1296">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1296">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1297">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1297">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1298">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1298">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1299">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1299">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1300">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1300">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1301">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1301">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1302">계산 스택 맨 위에 있는 부호 없는 값을 부호 있는 <see langword="int16" />로 변환하고 <see langword="int32" />로 확장하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1302">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1303">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1303">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1304">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1304">Format</span></span>|<span data-ttu-id="cbc67-1305">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1305">Assembly Format</span></span>|<span data-ttu-id="cbc67-1306">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1306">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1307">83</span><span class="sxs-lookup"><span data-stu-id="cbc67-1307">83</span></span>|<span data-ttu-id="cbc67-1308">conv.ovf.i2.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1308">conv.ovf.i2.un</span></span>|<span data-ttu-id="cbc67-1309">부호 없는 값으로 변환 합니다는 `int16` (스택에 `int32`) 오버플로 대 한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1309">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1310">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1310">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1311">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1311">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1312">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1312">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1313">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1313">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1314">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1314">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1315">합니다 `conv.ovf.i2.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1315">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1316">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1316">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1317">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1317">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1318">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1318">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1319">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1319">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1320">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i2.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1322">계산 스택 맨 위에 있는 부호 있는 값을 부호 있는 <see langword="int32" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1322">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1323">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1324">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1324">Format</span></span>|<span data-ttu-id="cbc67-1325">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1325">Assembly Format</span></span>|<span data-ttu-id="cbc67-1326">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1327">B7</span><span class="sxs-lookup"><span data-stu-id="cbc67-1327">B7</span></span>|<span data-ttu-id="cbc67-1328">conv.ovf.i4</span><span class="sxs-lookup"><span data-stu-id="cbc67-1328">conv.ovf.i4</span></span>|<span data-ttu-id="cbc67-1329">변환할를 `int32` (스택에 `int32`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1329">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1330">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1331">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1331">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1332">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1332">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1333">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1333">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1334">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1334">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1335">합니다 `conv.ovf.i4` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1335">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1336">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1336">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1337">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1337">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1338">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1338">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1339">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1339">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1340">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1340">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1341">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1341">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1342">계산 스택 맨 위에 있는 부호 없는 값을 부호 있는 <see langword="int32" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1342">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1343">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1343">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1344">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1344">Format</span></span>|<span data-ttu-id="cbc67-1345">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1345">Assembly Format</span></span>|<span data-ttu-id="cbc67-1346">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1346">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1347">84</span><span class="sxs-lookup"><span data-stu-id="cbc67-1347">84</span></span>|<span data-ttu-id="cbc67-1348">conv.ovf.i4.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1348">conv.ovf.i4.un</span></span>|<span data-ttu-id="cbc67-1349">부호 없는 값으로 변환 합니다는 `int32` (스택에 `int32`) 오버플로 대 한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1349">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1350">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1350">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1351">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1351">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1352">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1352">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1353">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1353">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1354">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1354">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1355">합니다 `conv.ovf.i4.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1355">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1356">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1356">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1357">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1357">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1358">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1358">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1359">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1359">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1360">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i4.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1361">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1361">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1362">계산 스택 맨 위에 있는 부호 있는 값을 부호 있는 <see langword="int64" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1362">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1363">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1364">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1364">Format</span></span>|<span data-ttu-id="cbc67-1365">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1365">Assembly Format</span></span>|<span data-ttu-id="cbc67-1366">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1367">B9</span><span class="sxs-lookup"><span data-stu-id="cbc67-1367">B9</span></span>|<span data-ttu-id="cbc67-1368">conv.ovf.i8</span><span class="sxs-lookup"><span data-stu-id="cbc67-1368">conv.ovf.i8</span></span>|<span data-ttu-id="cbc67-1369">변환할를 `int64` (스택에 `int64`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1369">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1370">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1371">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1371">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1372">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1372">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1373">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1373">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1374">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1374">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1375">합니다 `conv.ovf.i8` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1375">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1376">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1376">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1377">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1377">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1378">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1378">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1379">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1379">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1380">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1380">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1381">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1381">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1382">계산 스택 맨 위에 있는 부호 없는 값을 부호 있는 <see langword="int64" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1382">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1383">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1383">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1384">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1384">Format</span></span>|<span data-ttu-id="cbc67-1385">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1385">Assembly Format</span></span>|<span data-ttu-id="cbc67-1386">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1386">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1387">85</span><span class="sxs-lookup"><span data-stu-id="cbc67-1387">85</span></span>|<span data-ttu-id="cbc67-1388">conv.ovf.i8.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1388">conv.ovf.i8.un</span></span>|<span data-ttu-id="cbc67-1389">부호 없는 값으로 변환 합니다는 `int64` (스택에 `int64`) 오버플로 대 한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1389">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1390">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1390">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1391">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1391">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1392">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1392">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1393">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1393">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1394">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1394">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1395">합니다 `conv.ovf.i8.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1395">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1396">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1396">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1397">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1397">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1398">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1398">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1399">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1399">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1400">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.i8.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1400">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1401">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1401">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1402">계산 스택 맨 위에 있는 부호 있는 값을 <see langword="unsigned native int" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1402">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1403">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1403">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1404">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1404">Format</span></span>|<span data-ttu-id="cbc67-1405">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1405">Assembly Format</span></span>|<span data-ttu-id="cbc67-1406">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1406">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1407">D5</span><span class="sxs-lookup"><span data-stu-id="cbc67-1407">D5</span></span>|<span data-ttu-id="cbc67-1408">conv.ovf.u</span><span class="sxs-lookup"><span data-stu-id="cbc67-1408">conv.ovf.u</span></span>|<span data-ttu-id="cbc67-1409">변환할를 `unsigned native int` (스택에 `native int`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1409">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1410">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1410">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1411">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1411">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1412">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1412">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1413">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1413">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1414">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1414">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1415">합니다 `conv.ovf.u` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1415">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1416">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1416">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1417">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1417">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1418">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1418">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1419">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1419">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1420">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.u` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1420">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1421">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1421">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1422">계산 스택 맨 위에 있는 부호 없는 값을 <see langword="unsigned native int" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1422">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1423">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1423">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1424">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1424">Format</span></span>|<span data-ttu-id="cbc67-1425">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1425">Assembly Format</span></span>|<span data-ttu-id="cbc67-1426">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1426">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1427">8B</span><span class="sxs-lookup"><span data-stu-id="cbc67-1427">8B</span></span>|<span data-ttu-id="cbc67-1428">conv.ovf.u.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1428">conv.ovf.u.un</span></span>|<span data-ttu-id="cbc67-1429">값을 부호는 `unsigned native int` (스택에 `native int`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1429">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1430">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1430">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1431">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1431">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1432">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1432">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1433">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1433">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1434">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1434">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1435">합니다 `conv.ovf.u.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1435">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1436">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1436">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1437">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1437">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1438">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1438">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1439">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1439">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1440">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.uvf.u.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1440">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1441">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1441">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1442">계산 스택 맨 위에 있는 부호 있는 값을 <see langword="unsigned int8" />로 변환하고 <see langword="int32" />로 확장하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1442">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1443">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1443">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1444">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1444">Format</span></span>|<span data-ttu-id="cbc67-1445">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1445">Assembly Format</span></span>|<span data-ttu-id="cbc67-1446">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1446">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1447">B4</span><span class="sxs-lookup"><span data-stu-id="cbc67-1447">B4</span></span>|<span data-ttu-id="cbc67-1448">conv.ovf.u1</span><span class="sxs-lookup"><span data-stu-id="cbc67-1448">conv.ovf.u1</span></span>|<span data-ttu-id="cbc67-1449">변환할를 `unsigned int8` (스택에 `int32`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1449">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1450">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1450">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1451">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1451">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1452">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1452">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1453">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1453">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1454">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1454">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1455">합니다 `conv.ovf.u1` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1455">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1456">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1456">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1457">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1457">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1458">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1458">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1459">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1459">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1460">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1460">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1461">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1461">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1462">계산 스택 맨 위에 있는 부호 없는 값을 <see langword="unsigned int8" />로 변환하고 <see langword="int32" />로 확장하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1462">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1463">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1463">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1464">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1464">Format</span></span>|<span data-ttu-id="cbc67-1465">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1465">Assembly Format</span></span>|<span data-ttu-id="cbc67-1466">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1466">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1467">86</span><span class="sxs-lookup"><span data-stu-id="cbc67-1467">86</span></span>|<span data-ttu-id="cbc67-1468">conv.ovf.u1.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1468">conv.ovf.u1.un</span></span>|<span data-ttu-id="cbc67-1469">부호 없는 값으로 변환 합니다는 `unsigned int8` (스택에 `int32`) 오버플로 대 한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1469">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1470">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1470">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1471">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1471">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1472">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1472">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1473">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1473">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1474">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1474">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1475">합니다 `conv.ovf.u1.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1475">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1476">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1476">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1477">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1477">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1478">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1478">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1479">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1479">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1480">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.u1.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1482">계산 스택 맨 위에 있는 부호 있는 값을 <see langword="unsigned int16" />로 변환하고 <see langword="int32" />로 확장하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1482">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1483">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1484">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1484">Format</span></span>|<span data-ttu-id="cbc67-1485">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1485">Assembly Format</span></span>|<span data-ttu-id="cbc67-1486">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1487">B6</span><span class="sxs-lookup"><span data-stu-id="cbc67-1487">B6</span></span>|<span data-ttu-id="cbc67-1488">conv.ovf.u2</span><span class="sxs-lookup"><span data-stu-id="cbc67-1488">conv.ovf.u2</span></span>|<span data-ttu-id="cbc67-1489">변환할를 `unsigned int16` (스택에 `int32`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1489">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1490">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1491">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1491">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1492">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1492">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1493">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1493">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1494">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1494">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1495">합니다 `conv.ovf.u2` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1495">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1496">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1496">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1497">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1497">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1498">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1498">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1499">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1499">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1500">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1500">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1501">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1501">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1502">계산 스택 맨 위에 있는 부호 없는 값을 <see langword="unsigned int16" />로 변환하고 <see langword="int32" />로 확장하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1502">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1503">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1503">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1504">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1504">Format</span></span>|<span data-ttu-id="cbc67-1505">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1505">Assembly Format</span></span>|<span data-ttu-id="cbc67-1506">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1506">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1507">87</span><span class="sxs-lookup"><span data-stu-id="cbc67-1507">87</span></span>|<span data-ttu-id="cbc67-1508">conv.ovf.u2.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1508">conv.ovf.u2.un</span></span>|<span data-ttu-id="cbc67-1509">부호 없는 값으로 변환 합니다는 `unsigned int16` (스택에 `int32`) 오버플로 대 한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1509">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1510">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1510">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1511">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1511">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1512">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1512">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1513">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1513">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1514">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1514">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1515">합니다 `conv.ovf.u2.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1515">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1516">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1516">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1517">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1517">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1518">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1518">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1519">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1519">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1520">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.u2.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1520">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1521">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1521">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1522">계산 스택 맨 위에 있는 부호 있는 값을 <see langword="unsigned int32" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1522">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1523">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1523">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1524">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1524">Format</span></span>|<span data-ttu-id="cbc67-1525">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1525">Assembly Format</span></span>|<span data-ttu-id="cbc67-1526">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1526">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1527">B8</span><span class="sxs-lookup"><span data-stu-id="cbc67-1527">B8</span></span>|<span data-ttu-id="cbc67-1528">conv.ovf.u4</span><span class="sxs-lookup"><span data-stu-id="cbc67-1528">conv.ovf.u4</span></span>|<span data-ttu-id="cbc67-1529">변환할를 `unsigned int32` (스택에 `int32`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1529">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1530">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1530">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1531">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1531">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1532">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1532">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1533">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1533">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1534">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1534">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1535">합니다 `conv.ovf.u4` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1535">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1536">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1536">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1537">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1537">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1538">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1538">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1539">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1539">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1540">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1540">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1541">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1541">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1542">계산 스택 맨 위에 있는 부호 없는 값을 <see langword="unsigned int32" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1542">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1543">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1543">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1544">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1544">Format</span></span>|<span data-ttu-id="cbc67-1545">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1545">Assembly Format</span></span>|<span data-ttu-id="cbc67-1546">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1546">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1547">88</span><span class="sxs-lookup"><span data-stu-id="cbc67-1547">88</span></span>|<span data-ttu-id="cbc67-1548">conv.ovf.u4.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1548">conv.ovf.u4.un</span></span>|<span data-ttu-id="cbc67-1549">부호 없는 값으로 변환 합니다는 `unsigned int32` (스택에 `int32`) 오버플로 대 한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1549">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1550">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1550">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1551">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1551">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1552">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1552">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1553">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1553">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1554">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1554">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1555">합니다 `conv.ovf.u4.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1555">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1556">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1556">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1557">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1557">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1558">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1558">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1559">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1559">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1560">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.u4.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1560">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1561">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1561">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1562">계산 스택 맨 위에 있는 부호 있는 값을 <see langword="unsigned int64" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1562">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1563">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1563">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1564">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1564">Format</span></span>|<span data-ttu-id="cbc67-1565">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1565">Assembly Format</span></span>|<span data-ttu-id="cbc67-1566">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1566">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1567">BA</span><span class="sxs-lookup"><span data-stu-id="cbc67-1567">BA</span></span>|<span data-ttu-id="cbc67-1568">conv.ovf.u8</span><span class="sxs-lookup"><span data-stu-id="cbc67-1568">conv.ovf.u8</span></span>|<span data-ttu-id="cbc67-1569">변환할를 `unsigned int64` (스택에 `int64`) 오버플로 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1569">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1570">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1570">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1571">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1571">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1572">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1572">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1573">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1573">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1574">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1574">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1575">합니다 `conv.ovf.u8` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1575">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1576">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1576">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1577">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1577">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1578">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1578">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1579">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1579">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1580">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.u8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1580">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1581">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1581">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1582">계산 스택 맨 위에 있는 부호 없는 값을 <see langword="unsigned int64" />로 변환하고, 오버플로에 대한 <see cref="T:System.OverflowException" />을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1582">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1583">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1583">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1584">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1584">Format</span></span>|<span data-ttu-id="cbc67-1585">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1585">Assembly Format</span></span>|<span data-ttu-id="cbc67-1586">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1586">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1587">89</span><span class="sxs-lookup"><span data-stu-id="cbc67-1587">89</span></span>|<span data-ttu-id="cbc67-1588">conv.ovf.u8.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1588">conv.ovf.u8.un</span></span>|<span data-ttu-id="cbc67-1589">부호 없는 값으로 변환 합니다는 `unsigned int64` (스택에 `int64`) 오버플로 대 한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1589">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="cbc67-1590">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1590">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1591">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1591">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1592">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1592">is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="cbc67-1593">오버플로가 발생 하면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1593">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="cbc67-1594">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1594">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1595">합니다 `conv.ovf.u8.un` opcode 변환는 `value` opcode 및 스택의 맨 위에 값을 변환 하는 위치를 지정 된 형식에 대 한 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1595">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1596">값이 너무 크거나 너무 작아서 대상 형식으로 나타낼 수, 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1596">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="cbc67-1597">부동 소수점 숫자에서 정수 값으로의 변환을 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1597">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="cbc67-1598">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.ovf.i` 또는 `conv.ovf.u` 를 사용 하는 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1598">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-1599">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1599">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-1600">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.ovf.u8.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1600">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1601">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1601">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1602">계산 스택 맨 위에 있는 부호 없는 정수 값을 <see langword="float32" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1602">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1603">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1603">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1604">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1604">Format</span></span>|<span data-ttu-id="cbc67-1605">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1605">Assembly Format</span></span>|<span data-ttu-id="cbc67-1606">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1606">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1607">76</span><span class="sxs-lookup"><span data-stu-id="cbc67-1607">76</span></span>|<span data-ttu-id="cbc67-1608">conv.r.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1608">conv.r.un</span></span>|<span data-ttu-id="cbc67-1609">Convert 부호 없는 정수를 부동 소수점, 푸시 `F` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1609">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1610">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1610">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1611">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1611">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1612">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1612">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1613">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1613">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1614">합니다 `conv.r.un` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1614">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1615">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1615">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1616">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1616">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1617">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1617">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1618">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1618">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1619">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1619">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1620">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1620">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1621">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1621">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1622">오버플로가 발생 하는 정수 부동 소수점 형식으로 변환 하는 경우는 `result` 반환 되는 지정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1622">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="cbc67-1623">`conv.r.un` 는 정수를 팝 합니다, 서명 되지 않은,으로 해석 및 정수를 나타내는 부동 소수점 숫자를 사용 하 여 대체 작업: 중 하나는 `float32`정밀도의 손실 없이 정수를 나타내는 데 넓게 또는 다른 경우, `float64`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1623">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="cbc67-1624">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1624">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="cbc67-1625">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.r.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1627">계산 스택 맨 위에 있는 값을 <see langword="float32" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1627">Converts the value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1628">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1629">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1629">Format</span></span>|<span data-ttu-id="cbc67-1630">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1630">Assembly Format</span></span>|<span data-ttu-id="cbc67-1631">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1632">6B</span><span class="sxs-lookup"><span data-stu-id="cbc67-1632">6B</span></span>|<span data-ttu-id="cbc67-1633">conv.r4</span><span class="sxs-lookup"><span data-stu-id="cbc67-1633">conv.r4</span></span>|<span data-ttu-id="cbc67-1634">변환할 `float32`푸싱, `F` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1634">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1635">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1636">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1636">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1637">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1637">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1638">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1638">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1639">합니다 `conv.r4` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1639">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1640">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1640">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1641">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1641">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1642">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1642">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1643">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1643">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1644">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1644">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1645">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1645">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1646">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1646">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1647">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1647">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1648">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1648">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="cbc67-1649">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1649">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1650">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1650">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1651">계산 스택 맨 위에 있는 값을 <see langword="float64" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1651">Converts the value on top of the evaluation stack to <see langword="float64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1652">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1652">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1653">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1653">Format</span></span>|<span data-ttu-id="cbc67-1654">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1654">Assembly Format</span></span>|<span data-ttu-id="cbc67-1655">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1655">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1656">6C</span><span class="sxs-lookup"><span data-stu-id="cbc67-1656">6C</span></span>|<span data-ttu-id="cbc67-1657">conv.r8</span><span class="sxs-lookup"><span data-stu-id="cbc67-1657">conv.r8</span></span>|<span data-ttu-id="cbc67-1658">변환할 `float64`푸싱, `F` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1658">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1659">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1659">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1660">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1660">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1661">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1661">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1662">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1662">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1663">합니다 `conv.r8` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1663">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1664">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1664">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1665">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1665">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1666">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1666">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1667">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1667">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1668">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1668">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1669">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1669">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1670">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1670">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1671">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1671">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1672">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1672">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="cbc67-1673">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1673">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1674">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1674">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1675">계산 스택 맨 위에 있는 값을 <see langword="unsigned native int" />로 변환하고 <see langword="native int" />로 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1675">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1676">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1676">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1677">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1677">Format</span></span>|<span data-ttu-id="cbc67-1678">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1678">Assembly Format</span></span>|<span data-ttu-id="cbc67-1679">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1679">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1680">E0</span><span class="sxs-lookup"><span data-stu-id="cbc67-1680">E0</span></span>|<span data-ttu-id="cbc67-1681">conv.u</span><span class="sxs-lookup"><span data-stu-id="cbc67-1681">conv.u</span></span>|<span data-ttu-id="cbc67-1682">변환할 `unsigned native int`푸싱, `native int` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1682">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1683">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1683">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1684">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1684">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1685">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1685">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1686">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1686">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1687">합니다 `conv.u` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1687">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1688">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1688">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1689">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1689">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1690">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1690">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1691">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1691">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1692">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1692">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1693">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1693">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1694">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1694">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1695">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1695">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1696">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1696">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1697">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1697">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1698">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.u` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1700">계산 스택 맨 위에 있는 값을 <see langword="unsigned int8" />로 변환하고 <see langword="int32" />로 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1700">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1701">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1702">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1702">Format</span></span>|<span data-ttu-id="cbc67-1703">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1703">Assembly Format</span></span>|<span data-ttu-id="cbc67-1704">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1705">D2</span><span class="sxs-lookup"><span data-stu-id="cbc67-1705">D2</span></span>|<span data-ttu-id="cbc67-1706">conv.u1</span><span class="sxs-lookup"><span data-stu-id="cbc67-1706">conv.u1</span></span>|<span data-ttu-id="cbc67-1707">변환할 `int8`푸싱, `int32` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1707">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1708">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1709">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1709">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1710">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1710">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1711">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1711">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1712">합니다 `conv.u1` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1712">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1713">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1713">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1714">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1714">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1715">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1715">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1716">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1716">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1717">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1717">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1718">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1718">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1719">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1719">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1720">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1720">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1721">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1721">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1722">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1722">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1723">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1723">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1724">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1724">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1725">계산 스택 맨 위에 있는 값을 <see langword="unsigned int16" />로 변환하고 <see langword="int32" />로 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1725">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1726">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1726">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1727">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1727">Format</span></span>|<span data-ttu-id="cbc67-1728">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1728">Assembly Format</span></span>|<span data-ttu-id="cbc67-1729">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1729">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1730">D1</span><span class="sxs-lookup"><span data-stu-id="cbc67-1730">D1</span></span>|<span data-ttu-id="cbc67-1731">conv.u2</span><span class="sxs-lookup"><span data-stu-id="cbc67-1731">conv.u2</span></span>|<span data-ttu-id="cbc67-1732">변환할 `int16`푸싱, `int32` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1732">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1733">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1733">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1734">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1734">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1735">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1735">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1736">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1736">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1737">합니다 `conv.u2` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1737">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1738">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1738">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1739">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1739">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1740">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1740">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1741">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1741">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1742">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1742">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1743">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1743">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1744">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1744">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1745">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1745">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1746">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1746">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1747">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1747">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1748">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1748">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1749">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1749">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1750">계산 스택 맨 위에 있는 값을 <see langword="unsigned int32" />로 변환하고 <see langword="int32" />로 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1750">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1751">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1751">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1752">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1752">Format</span></span>|<span data-ttu-id="cbc67-1753">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1753">Assembly Format</span></span>|<span data-ttu-id="cbc67-1754">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1754">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1755">6D</span><span class="sxs-lookup"><span data-stu-id="cbc67-1755">6D</span></span>|<span data-ttu-id="cbc67-1756">conv.u4</span><span class="sxs-lookup"><span data-stu-id="cbc67-1756">conv.u4</span></span>|<span data-ttu-id="cbc67-1757">변환할 `unsigned int32`푸싱, `int32` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1757">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1758">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1758">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1759">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1759">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1760">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1760">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1761">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1761">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1762">합니다 `conv.u4` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1762">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1763">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1763">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1764">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1764">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1765">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1765">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1766">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1766">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1767">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1767">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1768">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1768">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1769">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1769">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1770">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1770">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1771">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1771">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1772">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1772">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1773">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1773">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1774">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1774">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1775">계산 스택 맨 위에 있는 값을 <see langword="unsigned int64" />로 변환하고 <see langword="int64" />로 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1775">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1776">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1776">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1777">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1777">Format</span></span>|<span data-ttu-id="cbc67-1778">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1778">Assembly Format</span></span>|<span data-ttu-id="cbc67-1779">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1779">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1780">6E</span><span class="sxs-lookup"><span data-stu-id="cbc67-1780">6E</span></span>|<span data-ttu-id="cbc67-1781">conv.u8</span><span class="sxs-lookup"><span data-stu-id="cbc67-1781">conv.u8</span></span>|<span data-ttu-id="cbc67-1782">변환할 `int64`푸싱, `int64` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1782">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1783">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1783">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1784">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1784">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1785">팝 되 고 변환 작업을 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1785">is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="cbc67-1786">변환이 성공한 경우에 결과 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1786">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1787">합니다 `conv.u8` opcode 변환는 `value` 스택의 맨 위에 값을 변환 하는 두고 opcode에 지정 된 형식으로 스택 맨 위에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1787">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="cbc67-1788">4 바이트 보다 작은 정수 값은 확장 `int32` 를 계산 스택으로 로드 되 면 (경우가 아니면 `conv.i` 또는 `conv.u` 를 사용할 경우 결과 또한 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1788">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="cbc67-1789">부동 소수점 값으로 변환 되는 `F` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1789">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="cbc67-1790">정수 값으로 변환 부동 소수점 숫자에서 소수점을 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1790">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="cbc67-1791">변환 하는 경우는 `float64` 에 `float32`, 전체 자릿수 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1791">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="cbc67-1792">경우 `value` 에 맞게 너무 커서를 `float32 (F)`, 양의 무한대 (경우 `value` 양수 이면) 음의 무한대 또는 (경우 `value` 음수인) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1792">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="cbc67-1793">오버플로가 변환 정수 형식과 다른 경우 상위 비트가 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1793">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="cbc67-1794">결과 보다 작은 경우는 `int32`, 값이 슬롯에 맞게 부호 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1794">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="cbc67-1795">오버플로가 발생 하는 경우 지정 된로 값을 반환 하는 정수를 부동 소수점 형식을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1795">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="cbc67-1796">이 필드를 사용 하는 경우 예외가 throw 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1796">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="cbc67-1797">참조 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> 고 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> 결과 형식은 결과 값을 올바르게 나타낼 수 있습니다 하는 경우 예외를 throw 하는 동일한 명령에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1797">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="cbc67-1798">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `conv.u8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1798">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1799">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1799">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1800">지정된 수의 바이트를 소스 주소에서 대상 주소로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1800">Copies a specified number bytes from a source address to a destination address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1801">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1801">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1802">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1802">Format</span></span>|<span data-ttu-id="cbc67-1803">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1803">Assembly Format</span></span>|<span data-ttu-id="cbc67-1804">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1804">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1805">FE 17</span><span class="sxs-lookup"><span data-stu-id="cbc67-1805">FE 17</span></span>|<span data-ttu-id="cbc67-1806">cpblk</span><span class="sxs-lookup"><span data-stu-id="cbc67-1806">cpblk</span></span>|<span data-ttu-id="cbc67-1807">다른 메모리 블록에서 데이터를 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1807">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="cbc67-1808">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1808">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-1809">대상 주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1809">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-1810">원본 주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1810">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-1811">복사할 바이트 수를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1811">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-1812">스택에서 팝 되 고 바이트, 원본 주소 및 대상 주소 수 바이트 수를 지정 된 원본 주소에서 대상 주소로 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1812">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="cbc67-1813">합니다 `cpblk` 번호를 복사 하는 명령 (형식 `unsigned int32`) 원본 주소에서 바이트 (형식의 `*`, `native int`, 또는 `&`) 대상 주소에 대 (형식의 `*`를 `native int`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1813">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="cbc67-1814">동작 `cpblk` 소스 및 대상 영역이 겹치는 경우에 지정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1814">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 `cpblk` <span data-ttu-id="cbc67-1815">원본 및 해결 하는 대상 컴퓨터의 원래 크기에 정렬 되어 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1815">assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="cbc67-1816">합니다 `cpblk` 명령 바로 앞에 나와야 합니다 `unaligned.<prefix>` 명령 원본 또는 대상 정렬 임을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1816">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="cbc67-1817">작업은 `cpblk` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1817">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-1818">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1818">may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-1819">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `cpblk` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1819">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1820">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1820">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1821">개체(<see langword="&amp;" />, <see langword="*" /> 또는 <see langword="native int" /> 형식)의 주소에 있는 값 형식을 대상 개체(<see langword="&amp;" />, <see langword="*" /> 또는 <see langword="native int" /> 형식)의 주소로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1821">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1822">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1822">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1823">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1823">Format</span></span>|<span data-ttu-id="cbc67-1824">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1824">Assembly Format</span></span>|<span data-ttu-id="cbc67-1825">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1825">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1826">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-1826">70 < `T` ></span></span>|<span data-ttu-id="cbc67-1827">cpobj</span><span class="sxs-lookup"><span data-stu-id="cbc67-1827">cpobj</span></span> `classTok`|<span data-ttu-id="cbc67-1828">값 복사 원본 개체에서 대상 개체를 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1828">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="cbc67-1829">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1829">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-1830">대상 개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1830">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-1831">소스 개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1831">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-1832">스택에서 팝 되 고 두 개체 참조 원본 개체의 주소 값 형식은 대상 개체의 주소로 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1832">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="cbc67-1833">동작 `cpobj` 원본 및 대상 개체 참조 클래스 토큰을 나타내는 클래스의 인스턴스에 대 한 포인터가 아닌 경우에 지정 되지 않습니다 `classTok` (을 `typeref` 또는 `typedef`), 또는 경우 `classTok` 나타내지 않는 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1833">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-1834">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1834">may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-1835">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `cpobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1835">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1836">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1836">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1837">두 값을 나누고 결과를 부동 소수점(<see langword="F" /> 형식)이나 몫(<see langword="int32" /> 형식)으로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1837">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1838">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1838">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1839">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1839">Format</span></span>|<span data-ttu-id="cbc67-1840">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1840">Assembly Format</span></span>|<span data-ttu-id="cbc67-1841">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1841">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1842">5B</span><span class="sxs-lookup"><span data-stu-id="cbc67-1842">5B</span></span>|<span data-ttu-id="cbc67-1843">div</span><span class="sxs-lookup"><span data-stu-id="cbc67-1843">div</span></span>|<span data-ttu-id="cbc67-1844">부동 소수점 결과 몫을 반환 하려면 두 값을 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1844">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="cbc67-1845">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1845">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-1846">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1846">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-1847">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1847">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-1848">및 `value1` 스택에서 팝 되 고 `value1` 나눈 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1848">and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="cbc67-1849">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1849">The result is pushed onto the stack.</span></span>  
  
 `result`<span data-ttu-id="cbc67-1850"> = `value1` div value2에는 다음 조건을 충족 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1850"> = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="cbc67-1851">&#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, 및:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1851">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="cbc67-1852">기호 (`result`) = +, 로그인 하는 경우 (`value1`) 기호 = (`value2`), 또는 경우 기호 (`value1`) ~ 기호 = (`value2`)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1852">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="cbc67-1853">`div` 명령이 결과 계산 합니다를 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1853">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1854">정수 나누기를 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1854">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="cbc67-1855">유한 숫자를 0으로 나누기는 무한 올바르게 지정 된 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1855">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="cbc67-1856">NaN (Not A Number) 값을 0으로 0 또는 무한대에서 무한대 생성을 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1856">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="cbc67-1857">무한대로 나눈 수는 0 값을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1857">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="cbc67-1858">정수 계열 작업 <xref:System.ArithmeticException> 결과 형식으로 결과 표현할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1858">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="cbc67-1859">이 경우에 발생할 수 있습니다 `value1` 최대 음수 값, 및 `value2` 가-1입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1859">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="cbc67-1860">정수 계열 작업 throw <xref:System.DivideByZeroException> 경우 `value2` 0입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1860">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="cbc67-1861">Intel 기반 플랫폼에서 유의 <xref:System.OverflowException> (minint div-1)을 계산 하는 경우에 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1861">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="cbc67-1862">부동 소수점 연산 (생성 무한대 또는 Nan 대신) 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1862">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="cbc67-1863">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `div` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1863">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1864">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1864">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1865">두 개의 부호 없는 정수를 나누고 결과(<see langword="int32" />)를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1865">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1866">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1866">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1867">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1867">Format</span></span>|<span data-ttu-id="cbc67-1868">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1868">Assembly Format</span></span>|<span data-ttu-id="cbc67-1869">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1869">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1870">5C</span><span class="sxs-lookup"><span data-stu-id="cbc67-1870">5C</span></span>|<span data-ttu-id="cbc67-1871">div.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-1871">div.un</span></span>|<span data-ttu-id="cbc67-1872">두 값을 나눕니다 unsigned, 몫을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1872">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="cbc67-1873">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1873">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-1874">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1874">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-1875">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1875">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-1876">및 `value1` 스택에서 팝 되 고 `value1` 나눈 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1876">and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="cbc67-1877">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1877">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1878">`div.un` 명령 계산 `value1` 나눈 `value2`, 부호 없는 정수 및 푸시를 그대로 둘 다를 `result` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1878">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1879">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `div.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1879">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1880">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1880">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1881">현재 계산 스택 맨 위에 있는 값을 복사하여 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1881">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1882">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1882">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1883">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1883">Format</span></span>|<span data-ttu-id="cbc67-1884">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1884">Assembly Format</span></span>|<span data-ttu-id="cbc67-1885">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1885">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1886">25</span><span class="sxs-lookup"><span data-stu-id="cbc67-1886">25</span></span>|<span data-ttu-id="cbc67-1887">dup</span><span class="sxs-lookup"><span data-stu-id="cbc67-1887">dup</span></span>|<span data-ttu-id="cbc67-1888">스택의 맨 위에 값을 복제합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1888">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-1889">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1889">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1890">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1890">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1891">복제용 스택에서 팝 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1891">is popped off of the stack for duplication.</span></span>  
  
3.  `value` <span data-ttu-id="cbc67-1892">이 스택에 다시 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1892">is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-1893">중복 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1893">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-1894">`dup` 명령 스택의 맨 위에 있는 요소를 복제 하 고 맨 위에 두 개의 동일한 값을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1894">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="cbc67-1895">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `dup` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1895">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1896">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1896">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1897">예외의 <see langword="filter" /> 절에서 CLI(공용 언어 인프라) 예외 처리기로 다시 제어를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1897">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1898">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1899">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1899">Format</span></span>|<span data-ttu-id="cbc67-1900">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1900">Assembly Format</span></span>|<span data-ttu-id="cbc67-1901">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1902">FE 11</span><span class="sxs-lookup"><span data-stu-id="cbc67-1902">FE 11</span></span>|<span data-ttu-id="cbc67-1903">endfilter</span><span class="sxs-lookup"><span data-stu-id="cbc67-1903">endfilter</span></span>|<span data-ttu-id="cbc67-1904">SEH 예외 처리의 최종 필터 절입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1904">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="cbc67-1905">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-1906">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1906">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-1907">스택에서 팝 되 `endfilter` 실행 되 고 예외 처리기로 제어가 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1907">is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 `Value` <span data-ttu-id="cbc67-1908">(형식 이어야 합니다는 `int32` 값의 특정 집합 중 하나입니다) 필터 절에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1908">(which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="cbc67-1909">하나 여야 함:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1909">It should be one of:</span></span>  
  
-   `exception_continue_search` <span data-ttu-id="cbc67-1910">(`value` = 0) 예외 처리기 검색을 계속 하려면</span><span class="sxs-lookup"><span data-stu-id="cbc67-1910">(`value` = 0) to continue searching for an exception handler</span></span>  
  
-   `exception_execute_handler` <span data-ttu-id="cbc67-1911">(`value` = 1)를 두 번째 시작 예외 처리는 finally 블록이 실행 되는 처리기가 필터 절이에 연관 될 때까지 단계의 위치한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1911">(`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="cbc67-1912">검색 시 처리기가 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1912">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="cbc67-1913">다른 정수 값에는 지정 되지 않은 결과가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1913">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="cbc67-1914">필터의 진입점 메서드의 예외 표에 나와 있는 것 처럼 필터의 코드 블록에 있는 첫 번째 명령 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1914">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="cbc67-1915">합니다 `endfilter` 명령에는 필터의 코드 블록에 있는 마지막 명령 이어야 합니다 (따라서 하나만 있을 수 있습니다 하나 `endfilter` 단일 필터 블록에 대 한).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1915">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="cbc67-1916">실행 한 후의 `endfilter` 명령 컨트롤 CLI 예외 처리 메커니즘으로 논리적으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1916">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="cbc67-1917">예외 메커니즘을 통해 제외 하 고 필터 블록으로 제어를 전송할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1917">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="cbc67-1918">컨트롤을 사용 하 여 제외 필터 블록 외부로 전송할 수 없습니다는 `throw` 명령 또는 최종을 실행 하 여 `endfilter` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1918">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="cbc67-1919">포함할 수 없습니다는 `try` 내에서 블록을 `filter` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1919">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="cbc67-1920">내부 예외가 발생 하는 경우는 `filter` 블록을 가로채는 0 값 (`exception_continue_search`) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1920">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="cbc67-1921">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `endfilter` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1921">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1922">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1922">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1923">예외 블록의 <see langword="fault" /> 절이나 <see langword="finally" /> 절에서 CLI(공용 언어 인프라) 예외 처리기로 다시 제어를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1923">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1924">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1924">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1925">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1925">Format</span></span>|<span data-ttu-id="cbc67-1926">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1926">Assembly Format</span></span>|<span data-ttu-id="cbc67-1927">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1927">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1928">DC</span><span class="sxs-lookup"><span data-stu-id="cbc67-1928">DC</span></span>|<span data-ttu-id="cbc67-1929">가</span><span class="sxs-lookup"><span data-stu-id="cbc67-1929">endfinally</span></span><br /><br /> <span data-ttu-id="cbc67-1930">endfault</span><span class="sxs-lookup"><span data-stu-id="cbc67-1930">endfault</span></span>|<span data-ttu-id="cbc67-1931">종료 합니다 `finally` 또는 `fault` 예외 블록의 절.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1931">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="cbc67-1932">이 명령에 대 한 전환 동작 없음 스택이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1932">There are no stack transition behaviors for this instruction.</span></span>  
  
 `Endfinally` <span data-ttu-id="cbc67-1933">및 `endfault` 의 끝을 표시 합니다 `finally` 또는 `fault` 절 때문 예외 처리기가 호출 될 때까지 계속 진행할 수는 스택 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1933">and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="cbc67-1934">합니다 `endfinally` 또는 `endfault` 명령이 CLI 예외 메커니즘으로 제어를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1934">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="cbc67-1935">메커니즘을 다음에 대 한 검색 `finally` leave 명령을 사용 하 여 보호 된 블록 종료 된 경우 체인의 절.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1935">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="cbc67-1936">보호 된 블록을 끝난 경우 예외가 발생 하 여 CLI가 다음을 검색할 `finally` 또는 `fault`, 또는 예외 처리의 첫 번째 단계 동안 선택한 예외 처리기를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1936">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="cbc67-1937">`endfinally` 명령 내 어휘만 나타날 수 있습니다는 `finally` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1937">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="cbc67-1938">와 달리 합니다 `endfilter` 명령 블록 끝나는 않아도 `endfinally` 명령과 만큼 있을 수 있는 `endfinally` 필요에 따라 블록 내에서 지침.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1938">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="cbc67-1939">이러한도 동일한 제한이 적용 된 `endfault` 명령 및 `fault` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1939">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="cbc67-1940">컨트롤에 전송할 수 없습니다는 `finally` (또는 `fault`) 예외 메커니즘을 통해 제외 하 고 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1940">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="cbc67-1941">제어를 전송할 수 없습니다는 `finally` (또는 `fault`) 사용 하 여 제외 하 고 차단를 `throw` 명령 또는 실행 합니다 `endfinally` (또는 `endfault`) 명령.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1941">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="cbc67-1942">특히 떨어질 수 없습니다"out"의 `finally` (또는 `fault`) 블록 또는 실행 하는 <xref:System.Reflection.Emit.OpCodes.Ret> 또는 <xref:System.Reflection.Emit.OpCodes.Leave> 명령 내에서 `finally` (또는 `fault`) 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1942">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="cbc67-1943">유의 합니다 `endfault` 및 `endfinally` 지침은 별칭-동일한 opcode에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1943">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="cbc67-1944">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `endfinally` (`endfault`) opcode 뿐만 `ILGenerator` 메서드 <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1944">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="cbc67-1945">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1945">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="cbc67-1946">ILGenerator.EndExceptionBlock()</span><span class="sxs-lookup"><span data-stu-id="cbc67-1946">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1947">특정 주소에 지정된 메모리 블록을 주어진 크기와 초기 값으로 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1947">Initializes a specified block of memory at a specific address to a given size and initial value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1948">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1948">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1949">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1949">Format</span></span>|<span data-ttu-id="cbc67-1950">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1950">Assembly Format</span></span>|<span data-ttu-id="cbc67-1951">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1951">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1952">FE 18</span><span class="sxs-lookup"><span data-stu-id="cbc67-1952">FE 18</span></span>|<span data-ttu-id="cbc67-1953">initblk</span><span class="sxs-lookup"><span data-stu-id="cbc67-1953">initblk</span></span>|<span data-ttu-id="cbc67-1954">지정된 된 값을 메모리 블록의 각 위치를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1954">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="cbc67-1955">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1955">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-1956">시작 주소를 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1956">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-1957">초기화 값을 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1957">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-1958">초기화할 바이트 수를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1958">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-1959">스택에서 팝 되 고 바이트, 초기화 값 및 시작 주소 수 및 해당 값에 따라 초기화가 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1959">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="cbc67-1960">합니다 `initblk` 수를 설정 하는 명령 (`unsigned int32`) 지정된 된 주소에서 시작 하는 바이트 (형식의 `native int`를 `&`, 또는 `*`) 초기화 값 (형식의 `unsigned int8`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-1960">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> `initblk` <span data-ttu-id="cbc67-1961">시작 주소를 컴퓨터의 원래 크기에 맞추도록 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1961">assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="cbc67-1962">작업은 `initblk` 바로 앞에서 지침을 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1962">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-1963">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1963">may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-1964">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `initblk` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1964">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1965">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1965">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1966">지정된 주소에서 값 형식의 각 필드를 null 참조 또는 적절한 기본 형식의 0으로 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1966">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1967">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1967">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1968">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1968">Format</span></span>|<span data-ttu-id="cbc67-1969">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1969">Assembly Format</span></span>|<span data-ttu-id="cbc67-1970">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1970">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1971">FE 15 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-1971">FE 15 < `T` ></span></span>|`initobj` `typeTok`|<span data-ttu-id="cbc67-1972">값 형식을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1972">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="cbc67-1973">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1973">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-1974">초기화 값 형식의 주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1974">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-1975">스택에서 팝 되는 주소 형식으로 지정된 된 주소에서 값 형식이 초기화 되는지 `typeTok`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1975">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="cbc67-1976">합니다 `initobj` 푸시된 주소로 지정 된 값 형식의 각 필드를 초기화 하는 명령 (형식의 `native int`, `&`, 또는 `*`) null 참조 또는 해당 기본 형식의 0입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1976">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="cbc67-1977">이 메서드는 인스턴스 생성자 메서드를 호출할 준비가 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1977">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="cbc67-1978">하는 경우 `typeTok` 참조 형식이 면이 명령은 것과 동일한 효과가 `ldnull` 뒤에 `stind.ref`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1978">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="cbc67-1979">와 달리 <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` constructor 메서드를 호출 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1979">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> `Initobj` <span data-ttu-id="cbc67-1980">값 형식 초기화를 위한 동안 `newobj` 할당 및 개체를 초기화 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1980">is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="cbc67-1981">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `initobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-1982">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-1982">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-1983">개체 참조(<see langword="O" /> 형식)가 특정 클래스의 인스턴스인지 여부를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1983">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-1984">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-1984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-1985">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1985">Format</span></span>|<span data-ttu-id="cbc67-1986">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-1986">Assembly Format</span></span>|<span data-ttu-id="cbc67-1987">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-1987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-1988">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-1988">75 < `T` ></span></span>|<span data-ttu-id="cbc67-1989">isinst</span><span class="sxs-lookup"><span data-stu-id="cbc67-1989">isinst</span></span> `class`|<span data-ttu-id="cbc67-1990">개체 참조의 인스턴스인지 여부를 테스트 `class`인터페이스, null 참조 또는 해당 클래스의 인스턴스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1990">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="cbc67-1991">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-1992">개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1992">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-1993">개체 참조가 스택에서 팝 하 고 전달 된 클래스의 인스턴스인 경우 확인 하기 위해 테스트 `class`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1993">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="cbc67-1994">(개체 참조 또는 null 참조일) 결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1994">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 `Class` <span data-ttu-id="cbc67-1995">메타 데이터 토큰은 필요한 클래스를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1995">is a metadata token indicating the desired class.</span></span> <span data-ttu-id="cbc67-1996">스택의 맨 위에 개체의 클래스를 구현 하는 경우 `class` (경우 `class` 인터페이스)의 파생된 클래스 인지 또는 `class` (경우 `class` 일반 클래스는) 형식으로 캐스팅 되 `class` 고 결과 스택에 푸시됩니다. 정확 하 게 처럼 <xref:System.Reflection.Emit.OpCodes.Castclass> 호출한 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1996">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="cbc67-1997">그렇지 않으면 null 참조 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1997">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="cbc67-1998">개체 참조 자체가 null 참조 `isinst` 마찬가지로 null 참조를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1998">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <xref:System.TypeLoadException> <span data-ttu-id="cbc67-1999">클래스를 찾을 수 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-1999">is thrown if class cannot be found.</span></span> <span data-ttu-id="cbc67-2000">이 일반적으로 언어 MSIL (Microsoft Intermediate) 지침 런타임이 아닌 네이티브 코드로 변환 될 때 감지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2000">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-2001">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `isinst` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2002">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2002">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2003">현재 메서드를 종료하고 지정된 메서드로 점프합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2003">Exits current method and jumps to specified method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2004">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2005">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2005">Format</span></span>|<span data-ttu-id="cbc67-2006">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2006">Assembly Format</span></span>|<span data-ttu-id="cbc67-2007">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2008">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2008">27 < `T` ></span></span>|<span data-ttu-id="cbc67-2009">jmp</span><span class="sxs-lookup"><span data-stu-id="cbc67-2009">jmp</span></span> `method`|<span data-ttu-id="cbc67-2010">현재 메서드를 종료 하 고 지정 된 메서드로 점프 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2010">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="cbc67-2011">이 명령에 대 한 전환 동작 없음 스택이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2011">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-2012">`jmp` (이동) 명령으로 제어를 전송으로 지정한 메서드의 `method`, 메서드 참조에 대 한 메타 데이터 토큰 인 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2012">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="cbc67-2013">현재 인수를 대상 메서드에 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2013">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="cbc67-2014">이 명령이 실행 될 때 계산 스택으로 비어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2014">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="cbc67-2015">호출 규칙, 수 및 대상 주소에 대 한 인수의 형식에는 현재 메서드에 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2015">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="cbc67-2016">합니다 `jmp` 밖으로 제어를 전송 하는 명령을 사용할 수 없습니다를 `try`, `filter`, `catch`, 또는 `finally` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2016">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="cbc67-2017">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `jmp` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2017">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2018">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2018">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2019">지정된 인덱스 값이 참조하는 인수를 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2019">Loads an argument (referenced by a specified index value) onto the stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2020">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2021">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2021">Format</span></span>|<span data-ttu-id="cbc67-2022">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2022">Assembly Format</span></span>|<span data-ttu-id="cbc67-2023">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2024">FE 09 < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2024">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="cbc67-2025">ldarg</span><span class="sxs-lookup"><span data-stu-id="cbc67-2025">ldarg</span></span> `index`|<span data-ttu-id="cbc67-2026">에 있는 인수 로드 `index` 스택으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2026">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2027">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2028">에 있는 인수 값 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2028">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2029">합니다 `ldarg` 명령에 인덱싱된 인수에서 푸시하 `index`스택으로 인수 0부터 인덱싱된 위치, 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2029">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2030">`ldarg` 명령을 사용 하 여 들어오는 인수에서 복사 하 여 값 형식 또는 스택에 기본 값을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2030">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="cbc67-2031">인수 값의 형식이 현재 메서드의 시그니처에 하 여 지정 된 인수의 형식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2031">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="cbc67-2032">가변 길이 인수 목록을 사용 하는 절차는 `ldarg` 명령 고정 인수 서명의 변수 부분에서 초기에 대해서만 사용할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Arglist> 명령에 대 한 자세한).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2032">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="cbc67-2033">4 바이트 보다 작은 정수 값을 갖는 인수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2033">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-2034">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2034">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-2035">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldarg` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2035">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2036">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2036">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2037">인덱스 0에 있는 인수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2037">Loads the argument at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2038">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2038">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2039">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2039">Format</span></span>|<span data-ttu-id="cbc67-2040">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2040">Assembly Format</span></span>|<span data-ttu-id="cbc67-2041">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2041">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2042">02</span><span class="sxs-lookup"><span data-stu-id="cbc67-2042">02</span></span>|<span data-ttu-id="cbc67-2043">ldarg.0</span><span class="sxs-lookup"><span data-stu-id="cbc67-2043">ldarg.0</span></span>|<span data-ttu-id="cbc67-2044">0 인수를 스택으로 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2044">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="cbc67-2045">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2045">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2046">인덱스 0에 있는 인수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2046">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2047">`ldarg.0` 명령은 인덱스 0에 있는 인수 값을 로드 하기 위한 효율적인 인코딩할입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2047">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="cbc67-2048">`ldarg.0` 스택으로 0 인덱싱된 인수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2048">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2049">`ldarg.0` 명령을 사용 하 여 들어오는 인수에서 복사 하 여 값 형식 또는 스택에 기본 값을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2049">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="cbc67-2050">인수 값의 형식이 현재 메서드의 시그니처에 하 여 지정 된 인수의 형식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2050">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="cbc67-2051">4 바이트 보다 작은 정수 값을 갖는 인수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2051">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-2052">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2052">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-2053">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldarg.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2053">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2054">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2054">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2055">인덱스 1에 있는 인수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2055">Loads the argument at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2056">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2056">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2057">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2057">Format</span></span>|<span data-ttu-id="cbc67-2058">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2058">Assembly Format</span></span>|<span data-ttu-id="cbc67-2059">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2059">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2060">03</span><span class="sxs-lookup"><span data-stu-id="cbc67-2060">03</span></span>|<span data-ttu-id="cbc67-2061">ldarg.1</span><span class="sxs-lookup"><span data-stu-id="cbc67-2061">ldarg.1</span></span>|<span data-ttu-id="cbc67-2062">1 인수를 스택으로 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2062">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2063">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2063">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2064">인덱스 1에 있는 인수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2064">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2065">`ldarg.1` 명령은 인덱스 1에 있는 인수 값을 로드 하기 위한 효율적인 인코딩할입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2065">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="cbc67-2066">`ldarg.1` 1를 계산 스택으로에 인덱싱된 인수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2066">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2067">`ldarg.1` 명령을 사용 하 여 들어오는 인수에서 복사 하 여 값 형식 또는 스택에 기본 값을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2067">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="cbc67-2068">인수 값의 형식이 현재 메서드의 시그니처에 하 여 지정 된 인수의 형식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2068">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="cbc67-2069">4 바이트 보다 작은 정수 값을 갖는 인수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2069">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-2070">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2070">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-2071">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldarg.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2071">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2072">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2072">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2073">인덱스 2에 있는 인수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2073">Loads the argument at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2074">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2074">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2075">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2075">Format</span></span>|<span data-ttu-id="cbc67-2076">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2076">Assembly Format</span></span>|<span data-ttu-id="cbc67-2077">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2077">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2078">04</span><span class="sxs-lookup"><span data-stu-id="cbc67-2078">04</span></span>|<span data-ttu-id="cbc67-2079">ldarg.2</span><span class="sxs-lookup"><span data-stu-id="cbc67-2079">ldarg.2</span></span>|<span data-ttu-id="cbc67-2080">인수 2를 스택으로 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2080">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2081">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2081">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2082">인덱스 2에 있는 인수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2082">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2083">`ldarg.2` 명령은 인덱스 2에 있는 인수 값을 로드 하기 위한 효율적인 인코딩할입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2083">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="cbc67-2084">`ldarg.2` 스택으로 2에 인덱싱된 인수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2084">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2085">`ldarg.2` 명령을 사용 하 여 들어오는 인수에서 복사 하 여 값 형식 또는 스택에 기본 값을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2085">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="cbc67-2086">인수 값의 형식이 현재 메서드의 시그니처에 하 여 지정 된 인수의 형식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2086">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="cbc67-2087">4 바이트 보다 작은 정수 값을 갖는 인수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2087">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-2088">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2088">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-2089">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldarg.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2089">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2090">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2090">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2091">인덱스 3에 있는 인수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2091">Loads the argument at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2092">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2092">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2093">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2093">Format</span></span>|<span data-ttu-id="cbc67-2094">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2094">Assembly Format</span></span>|<span data-ttu-id="cbc67-2095">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2095">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2096">05</span><span class="sxs-lookup"><span data-stu-id="cbc67-2096">05</span></span>|<span data-ttu-id="cbc67-2097">ldarg.3</span><span class="sxs-lookup"><span data-stu-id="cbc67-2097">ldarg.3</span></span>|<span data-ttu-id="cbc67-2098">인수 3를 스택으로 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2098">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2099">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2099">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2100">인덱스 3에 있는 인수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2100">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2101">`ldarg.3` 명령은 인덱스 3에 있는 인수 값을 로드 하는 것에 대 한 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2101">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="cbc67-2102">`ldarg.3` 스택으로 3에 인덱싱된 인수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2102">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2103">`ldarg.3` 명령을 사용 하 여 들어오는 인수에서 복사 하 여 값 형식 또는 스택에 기본 값을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2103">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="cbc67-2104">인수 값의 형식이 현재 메서드의 시그니처에 하 여 지정 된 인수의 형식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2104">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="cbc67-2105">4 바이트 보다 작은 정수 값을 갖는 인수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2105">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-2106">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2106">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-2107">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldarg.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2107">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2108">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2108">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2109">지정된 약식 인덱스가 참조하는 인수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2109">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2110">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2111">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2111">Format</span></span>|<span data-ttu-id="cbc67-2112">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2112">Assembly Format</span></span>|<span data-ttu-id="cbc67-2113">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2114">0E < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2114">0E < `unsigned int8` ></span></span>|<span data-ttu-id="cbc67-2115">ldarg.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-2115">ldarg.s</span></span> `index`|<span data-ttu-id="cbc67-2116">에 있는 인수 로드 `index` 스택에 약식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2116">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-2117">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2118">에 있는 인수 값 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2118">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2119">`ldarg.s` 명령은 4에서 255 사이의 인덱싱된 인수 로드에 대 한 효율적인 인코딩할입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2119">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="cbc67-2120">합니다 `ldarg.s` 명령에 인덱싱된 인수에서 푸시하 `index`스택으로 인수 0부터 인덱싱된 위치, 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2120">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2121">`ldarg.s` 명령을 사용 하 여 들어오는 인수에서 복사 하 여 값 형식 또는 스택에 기본 값을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2121">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="cbc67-2122">인수 값의 형식이 현재 메서드의 시그니처에 하 여 지정 된 인수의 형식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2122">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="cbc67-2123">가변 길이 인수 목록을 사용 하는 절차는 `ldarg.s` 명령 고정 인수 서명의 변수 부분에서 초기에 대해서만 사용할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Arglist> 명령에 대 한 자세한).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2123">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="cbc67-2124">4 바이트 보다 작은 정수 값을 갖는 인수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2124">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-2125">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2125">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-2126">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldarg.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2127">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2127">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2128">인수 주소를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2128">Load an argument address onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2129">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2130">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2130">Format</span></span>|<span data-ttu-id="cbc67-2131">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2131">Assembly Format</span></span>|<span data-ttu-id="cbc67-2132">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2133">FE 0A &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2133">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="cbc67-2134">ldarga</span><span class="sxs-lookup"><span data-stu-id="cbc67-2134">ldarga</span></span> `index`|<span data-ttu-id="cbc67-2135">인수에 의해 인덱싱된의 주소를 가져올 `index`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2135">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="cbc67-2136">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2137">주소 `addr` 인수에 의해 인덱싱된 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2137">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2138">`ldarga` 주소를 가져오는 명령 (형식의 `*`)로 인덱싱된 인수의 `index`인수 0 이상에서 인덱싱되는 위치, 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2138">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="cbc67-2139">주소 `addr` 는 항상 대상 컴퓨터에는 자연 경계에 맞춰집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2139">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="cbc67-2140">가변 길이 인수 목록을 사용 하는 절차는 `ldarga` 명령 고정 인수 서명의 변수 부분에서 초기에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2140">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 `ldarga` <span data-ttu-id="cbc67-2141">참조로 매개 변수 전달에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2141">is used for by-ref parameter passing.</span></span> <span data-ttu-id="cbc67-2142">다른 경우에 대 한 <xref:System.Reflection.Emit.OpCodes.Ldarg> 고 <xref:System.Reflection.Emit.OpCodes.Starg> 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2142">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="cbc67-2143">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldarga` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2143">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2144">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2144">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2145">인수 주소를 계산 스택에 약식으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2145">Load an argument address, in short form, onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2146">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2146">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2147">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2147">Format</span></span>|<span data-ttu-id="cbc67-2148">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2148">Assembly Format</span></span>|<span data-ttu-id="cbc67-2149">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2149">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2150">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2150">0F < `unsigned int8` ></span></span>|<span data-ttu-id="cbc67-2151">ldarga.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-2151">ldarga.s</span></span> `index`|<span data-ttu-id="cbc67-2152">인수에 의해 인덱싱된의 주소를 가져올 `index`, 약식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2152">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-2153">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2153">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2154">주소 `addr` 인수에 의해 인덱싱된 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2154">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 `ldarga.s` <span data-ttu-id="cbc67-2155">(의 약식 형태 `ldarga`) 인수 번호 0에서 255를 사용 해야 하며 보다 효율적인 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2155">(the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="cbc67-2156">`ldarga.s` 주소를 가져오는 명령 (형식의`*`)로 인덱싱된 인수의 `index`인수 0 이상에서 인덱싱되는 위치, 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2156">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="cbc67-2157">주소 `addr` 는 항상 대상 컴퓨터에는 자연 경계에 맞춰집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2157">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="cbc67-2158">가변 길이 인수 목록을 사용 하는 절차는 `ldarga.s` 명령 고정 인수 서명의 변수 부분에서 초기에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2158">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 `ldarga.s` <span data-ttu-id="cbc67-2159">참조로 매개 변수 전달에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2159">is used for by-ref parameter passing.</span></span> <span data-ttu-id="cbc67-2160">다른 경우에 대 한 <xref:System.Reflection.Emit.OpCodes.Ldarg_S> 고 <xref:System.Reflection.Emit.OpCodes.Starg_S> 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2160">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="cbc67-2161">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldarga.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2161">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2162">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2162">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2163"><see langword="int32" /> 형식의 주어진 값을 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2163">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2164">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2164">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2165">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2165">Format</span></span>|<span data-ttu-id="cbc67-2166">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2166">Assembly Format</span></span>|<span data-ttu-id="cbc67-2167">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2167">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2168">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2168">20 < `int32` ></span></span>|<span data-ttu-id="cbc67-2169">ldc.i4</span><span class="sxs-lookup"><span data-stu-id="cbc67-2169">ldc.i4</span></span> `num`|<span data-ttu-id="cbc67-2170">값을 푸시합니다 `num` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2170">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2171">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2171">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2172">값 `num` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2172">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2173">-1에서 8에 대 한 특히 짧고 127, 인코딩을 통해-128에서 정수에 대 한 특별 한 짧은 (및 따라서 보다 효율적인) 인코딩을 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2173">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="cbc67-2174">모든 짧은 인코딩으로 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2174">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="cbc67-2175">8 바이트 정수 4 및 8 바이트 부동 소수점 숫자와 및 짧은 형식으로 표시할 수 없는 4 바이트 값에 대 한 긴 인코딩이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2175">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="cbc67-2176">8 바이트 정수 상수를 스택에 푸시하는 방법은 세 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2176">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="cbc67-2177">사용 된 <xref:System.Reflection.Emit.OpCodes.Ldc_I8> 32 비트 이상 나타내야 하는 상수에 대 한 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2177">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="cbc67-2178">사용 합니다 <xref:System.Reflection.Emit.OpCodes.Ldc_I4> 명령 뒤에 <xref:System.Reflection.Emit.OpCodes.Conv_I8> 9 ~ 32 비트를 필요로 하는 상수에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="cbc67-2179">뒤에 약식 명령 사용을 <xref:System.Reflection.Emit.OpCodes.Conv_I8> 비트 8 이하로 표현할 수 있는 상수에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2179">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="cbc67-2180">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2181">ILGenerator.Emit (OpCode, int)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2181">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2182">정수 값 0을 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2182">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2183">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2184">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2184">Format</span></span>|<span data-ttu-id="cbc67-2185">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2185">Assembly Format</span></span>|<span data-ttu-id="cbc67-2186">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2187">16</span><span class="sxs-lookup"><span data-stu-id="cbc67-2187">16</span></span>|<span data-ttu-id="cbc67-2188">ldc.i4.0</span><span class="sxs-lookup"><span data-stu-id="cbc67-2188">ldc.i4.0</span></span>|<span data-ttu-id="cbc67-2189">0을 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2189">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2190">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2191">값 0으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2191">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2192">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2192">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2193">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2193">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2194">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2194">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2195">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2195">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2196">정수 값 1을 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2196">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2197">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2197">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2198">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2198">Format</span></span>|<span data-ttu-id="cbc67-2199">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2199">Assembly Format</span></span>|<span data-ttu-id="cbc67-2200">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2200">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2201">17</span><span class="sxs-lookup"><span data-stu-id="cbc67-2201">17</span></span>|<span data-ttu-id="cbc67-2202">ldc.i4.1</span><span class="sxs-lookup"><span data-stu-id="cbc67-2202">ldc.i4.1</span></span>|<span data-ttu-id="cbc67-2203">1을 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2203">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2204">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2204">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2205">1이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2205">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2206">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2206">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2207">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2207">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2208">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2209">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2209">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2210">정수 값 2를 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2210">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2211">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2212">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2212">Format</span></span>|<span data-ttu-id="cbc67-2213">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2213">Assembly Format</span></span>|<span data-ttu-id="cbc67-2214">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2215">18</span><span class="sxs-lookup"><span data-stu-id="cbc67-2215">18</span></span>|<span data-ttu-id="cbc67-2216">ldc.i4.2</span><span class="sxs-lookup"><span data-stu-id="cbc67-2216">ldc.i4.2</span></span>|<span data-ttu-id="cbc67-2217">2를 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2217">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2218">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2219">값 2를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2219">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2220">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2220">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2221">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2221">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2222">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2222">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2223">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2223">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2224">정수 값 3을 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2224">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2225">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2225">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2226">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2226">Format</span></span>|<span data-ttu-id="cbc67-2227">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2227">Assembly Format</span></span>|<span data-ttu-id="cbc67-2228">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2228">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2229">19</span><span class="sxs-lookup"><span data-stu-id="cbc67-2229">19</span></span>|<span data-ttu-id="cbc67-2230">ldc.i4.3</span><span class="sxs-lookup"><span data-stu-id="cbc67-2230">ldc.i4.3</span></span>|<span data-ttu-id="cbc67-2231">3을 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2231">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2232">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2232">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2233">값 3으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2233">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2234">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2234">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2235">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2235">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2236">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2236">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2237">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2237">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2238">정수 값 4를 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2238">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2239">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2239">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2240">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2240">Format</span></span>|<span data-ttu-id="cbc67-2241">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2241">Assembly Format</span></span>|<span data-ttu-id="cbc67-2242">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2242">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2243">1A</span><span class="sxs-lookup"><span data-stu-id="cbc67-2243">1A</span></span>|<span data-ttu-id="cbc67-2244">ldc.i4.4</span><span class="sxs-lookup"><span data-stu-id="cbc67-2244">ldc.i4.4</span></span>|<span data-ttu-id="cbc67-2245">4를 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2245">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2246">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2246">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2247">값 4를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2247">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2248">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2248">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2249">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2249">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2250">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2252">정수 값 5를 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2252">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2253">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2254">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2254">Format</span></span>|<span data-ttu-id="cbc67-2255">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2255">Assembly Format</span></span>|<span data-ttu-id="cbc67-2256">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2257">1B</span><span class="sxs-lookup"><span data-stu-id="cbc67-2257">1B</span></span>|<span data-ttu-id="cbc67-2258">ldc.i4.5</span><span class="sxs-lookup"><span data-stu-id="cbc67-2258">ldc.i4.5</span></span>|<span data-ttu-id="cbc67-2259">5를 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2259">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2260">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2261">값 5를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2261">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2262">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2262">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2263">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2263">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2264">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.5` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2264">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2265">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2265">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2266">정수 값 6을 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2266">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2267">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2267">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2268">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2268">Format</span></span>|<span data-ttu-id="cbc67-2269">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2269">Assembly Format</span></span>|<span data-ttu-id="cbc67-2270">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2270">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2271">1C</span><span class="sxs-lookup"><span data-stu-id="cbc67-2271">1C</span></span>|<span data-ttu-id="cbc67-2272">ldc.i4.6</span><span class="sxs-lookup"><span data-stu-id="cbc67-2272">ldc.i4.6</span></span>|<span data-ttu-id="cbc67-2273">6을 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2273">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2274">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2274">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2275">6이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2275">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2276">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2276">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2277">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2277">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2278">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.6` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2278">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2279">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2279">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2280">정수 값 7을 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2280">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2281">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2281">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2282">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2282">Format</span></span>|<span data-ttu-id="cbc67-2283">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2283">Assembly Format</span></span>|<span data-ttu-id="cbc67-2284">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2284">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2285">1D</span><span class="sxs-lookup"><span data-stu-id="cbc67-2285">1D</span></span>|<span data-ttu-id="cbc67-2286">ldc.i4.7</span><span class="sxs-lookup"><span data-stu-id="cbc67-2286">ldc.i4.7</span></span>|<span data-ttu-id="cbc67-2287">7 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2287">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2288">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2288">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2289">7이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2289">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2290">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2290">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2291">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2291">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2292">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.7` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2293">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2293">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2294">정수 값 8을 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2294">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2295">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2296">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2296">Format</span></span>|<span data-ttu-id="cbc67-2297">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2297">Assembly Format</span></span>|<span data-ttu-id="cbc67-2298">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2299">1E</span><span class="sxs-lookup"><span data-stu-id="cbc67-2299">1E</span></span>|<span data-ttu-id="cbc67-2300">ldc.i4.8</span><span class="sxs-lookup"><span data-stu-id="cbc67-2300">ldc.i4.8</span></span>|<span data-ttu-id="cbc67-2301">8를 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2301">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2302">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2303">8이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2303">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2304">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2304">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2305">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2305">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2306">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2306">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2307">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2307">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2308">정수 값 -1을 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2308">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2309">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2309">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2310">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2310">Format</span></span>|<span data-ttu-id="cbc67-2311">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2311">Assembly Format</span></span>|<span data-ttu-id="cbc67-2312">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2312">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2313">15</span><span class="sxs-lookup"><span data-stu-id="cbc67-2313">15</span></span>|<span data-ttu-id="cbc67-2314">ldc.i4.m1</span><span class="sxs-lookup"><span data-stu-id="cbc67-2314">ldc.i4.m1</span></span>|<span data-ttu-id="cbc67-2315">-1을 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2315">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2316">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2316">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2317">-1이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2317">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2318">이 정수 값 0의 푸시에 대 한 특별 한 짧은 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2318">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="cbc67-2319">모든 특수 한 짧은 인코딩을 스택에 4 바이트 정수를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2319">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2320">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.m1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2322">주어진 <see langword="int8" /> 값을 약식인 <see langword="int32" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2322">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2323">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2324">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2324">Format</span></span>|<span data-ttu-id="cbc67-2325">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2325">Assembly Format</span></span>|<span data-ttu-id="cbc67-2326">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2327">1F < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2327">1F < `int8` ></span></span>|<span data-ttu-id="cbc67-2328">ldc.i4.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-2328">ldc.i4.s</span></span> `num`|<span data-ttu-id="cbc67-2329">푸시합니다 `num` 로 스택에 `int32`, 약식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2329">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-2330">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2331">값 `num` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2331">The value `num` is pushed onto the stack.</span></span>  
  
 `ldc.i4.s` <span data-ttu-id="cbc67-2332">스택으로 정수는-128에서 127 푸시에 대 한 보다 효율적인 인코딩이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2332">is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2333">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i4.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2333">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2334">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2334">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2335"><see langword="int64" /> 형식의 주어진 값을 <see langword="int64" />로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2335">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2336">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2336">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2337">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2337">Format</span></span>|<span data-ttu-id="cbc67-2338">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2338">Assembly Format</span></span>|<span data-ttu-id="cbc67-2339">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2339">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2340">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2340">21 < `int64` ></span></span>|<span data-ttu-id="cbc67-2341">ldc.i8</span><span class="sxs-lookup"><span data-stu-id="cbc67-2341">ldc.i8</span></span> `num`|<span data-ttu-id="cbc67-2342">푸시합니다 `num` 로 스택에 `int64`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2342">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="cbc67-2343">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2343">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2344">값 `num` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2344">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2345">이 인코딩은 푸시를 `int64` 스택에 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2345">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2346">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2346">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2347">ILGenerator.Emit(OpCode, long)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2347">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2348"><see langword="float32" /> 형식의 주어진 값을 <see langword="F" /> 형식(부동 소수점)으로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2348">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2349">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2349">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2350">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2350">Format</span></span>|<span data-ttu-id="cbc67-2351">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2351">Assembly Format</span></span>|<span data-ttu-id="cbc67-2352">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2352">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2353">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2353">22 < `float32` ></span></span>|<span data-ttu-id="cbc67-2354">ldc.r4</span><span class="sxs-lookup"><span data-stu-id="cbc67-2354">ldc.r4</span></span> `num`|<span data-ttu-id="cbc67-2355">푸시합니다 `num` 로 스택에 `F`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2355">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="cbc67-2356">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2356">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2357">값 `num` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2357">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2358">이 인코딩은 푸시를 `float32` 스택에 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2358">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2359">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2360">ILGenerator.Emit (OpCode 단일)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2360">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2361"><see langword="float64" /> 형식의 주어진 값을 <see langword="F" /> 형식(부동 소수점)으로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2361">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2362">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2363">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2363">Format</span></span>|<span data-ttu-id="cbc67-2364">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2364">Assembly Format</span></span>|<span data-ttu-id="cbc67-2365">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2366">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2366">23 < `float64` ></span></span>|<span data-ttu-id="cbc67-2367">ldc.r8</span><span class="sxs-lookup"><span data-stu-id="cbc67-2367">ldc.r8</span></span> `num`|<span data-ttu-id="cbc67-2368">푸시합니다 `num` 로 스택에 `F`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2368">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="cbc67-2369">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2370">값 `num` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2370">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2371">이 인코딩은 푸시를 `float64` 스택에 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2371">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2372">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldc.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2373">ILGenerator.Emit (OpCode, double)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2373">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2374">지정된 배열 인덱스에 있는 요소를 이 명령에 지정된 형식으로 계산 스택 맨 위에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2374">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2375">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 Microsoft 중간 언어 (MSIL) 어셈블리 형식으로 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2375">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2376">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2376">Format</span></span>|<span data-ttu-id="cbc67-2377">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2377">Assembly Format</span></span>|<span data-ttu-id="cbc67-2378">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2379">A3 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2379">A3 < `T` ></span></span>|<span data-ttu-id="cbc67-2380">ldelem</span><span class="sxs-lookup"><span data-stu-id="cbc67-2380">ldelem</span></span> `typeTok`|<span data-ttu-id="cbc67-2381">에 있는 요소를 로드 `index` 형식으로 스택 맨 위에 `typeTok`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2381">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="cbc67-2382">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2383">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2383">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2384">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2384">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2385">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2385">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2386">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2386">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2387">합니다 `ldelem` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2387">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2388">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2388">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2389">토큰을 변수로 지정 된 반환 값의 형식 `typeTok` 명령에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2389">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2390">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2390">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2391">이 throw `index` 가 음수 이거나의 상한 보다 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2391">is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2392">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2392">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2393">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2393">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2394">지정된 배열 인덱스에서 <see langword="native int" /> 형식을 갖는 요소를 계산 스택 위에 <see langword="native int" />로서 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2394">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2395">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2395">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2396">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2396">Format</span></span>|<span data-ttu-id="cbc67-2397">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2397">Assembly Format</span></span>|<span data-ttu-id="cbc67-2398">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2398">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2399">97</span><span class="sxs-lookup"><span data-stu-id="cbc67-2399">97</span></span>|<span data-ttu-id="cbc67-2400">ldelem.i</span><span class="sxs-lookup"><span data-stu-id="cbc67-2400">ldelem.i</span></span>|<span data-ttu-id="cbc67-2401">형식을 사용 하 여 요소를 로드 `native int` 시 `index` 으로 스택 맨 위에 `native int`.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2401">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="cbc67-2402">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2402">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2403">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2403">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2404">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2404">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2405">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2405">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2406">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2406">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2407">합니다 `ldelem.i` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2407">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2408">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2408">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2409">반환 값 `ldelem.i` 는 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2409">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="cbc67-2410">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2410">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2411">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2411">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2412">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2412">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2413">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2413">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2414">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2414">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2415">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2415">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2416">지정된 배열 인덱스의 <see langword="int8" /> 형식을 갖는 요소를 계산 스택 맨 위에 <see langword="int32" />로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2416">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2417">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2417">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2418">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2418">Format</span></span>|<span data-ttu-id="cbc67-2419">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2419">Assembly Format</span></span>|<span data-ttu-id="cbc67-2420">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2420">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2421">90</span><span class="sxs-lookup"><span data-stu-id="cbc67-2421">90</span></span>|<span data-ttu-id="cbc67-2422">ldelem.i1</span><span class="sxs-lookup"><span data-stu-id="cbc67-2422">ldelem.i1</span></span>|<span data-ttu-id="cbc67-2423">형식을 사용 하 여 요소를 로드 `int8` 시 `index` 으로 스택 맨 위에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2423">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2424">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2424">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2425">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2425">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2426">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2426">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2427">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2427">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2428">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2428">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2429">합니다 `ldelem.i1` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2429">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2430">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2430">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2431">반환 값 `ldelem.i1` 는 `int8`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2431">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="cbc67-2432">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2432">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2433">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2433">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2434">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2434">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2435">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2435">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2436">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2436">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2437">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2437">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2438">지정된 배열 인덱스의 <see langword="int16" /> 형식을 갖는 요소를 계산 스택 맨 위에 <see langword="int32" />로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2438">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2439">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2439">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2440">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2440">Format</span></span>|<span data-ttu-id="cbc67-2441">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2441">Assembly Format</span></span>|<span data-ttu-id="cbc67-2442">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2442">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2443">92</span><span class="sxs-lookup"><span data-stu-id="cbc67-2443">92</span></span>|<span data-ttu-id="cbc67-2444">ldelem.i2</span><span class="sxs-lookup"><span data-stu-id="cbc67-2444">ldelem.i2</span></span>|<span data-ttu-id="cbc67-2445">형식을 사용 하 여 요소를 로드 `int16` 시 `index` 으로 스택 맨 위에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2445">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2446">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2446">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2447">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2447">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2448">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2448">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2449">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2449">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2450">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2450">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2451">합니다 `ldelem.i2` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2451">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2452">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2452">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2453">반환 값 `ldelem.i2` 는 `int16`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2453">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="cbc67-2454">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2454">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2455">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2455">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2456">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2456">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2457">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2457">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2458">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2459">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2459">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2460">지정된 배열 인덱스의 <see langword="int32" /> 형식을 갖는 요소를 계산 스택 맨 위에 <see langword="int32" />로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2460">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2461">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2461">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2462">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2462">Format</span></span>|<span data-ttu-id="cbc67-2463">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2463">Assembly Format</span></span>|<span data-ttu-id="cbc67-2464">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2465">94</span><span class="sxs-lookup"><span data-stu-id="cbc67-2465">94</span></span>|<span data-ttu-id="cbc67-2466">ldelem.i4</span><span class="sxs-lookup"><span data-stu-id="cbc67-2466">ldelem.i4</span></span>|<span data-ttu-id="cbc67-2467">형식을 사용 하 여 요소를 로드 `int32` 시 `index` 으로 스택 맨 위에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2467">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2468">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2469">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2469">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2470">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2470">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2471">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2471">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2472">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2472">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2473">합니다 `ldelem.i4` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2473">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2474">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2474">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2475">반환 값 `ldelem.i4` 는 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2475">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="cbc67-2476">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2476">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2477">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2477">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2478">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2478">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2479">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2479">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2480">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2482">지정된 배열 인덱스의 <see langword="int64" /> 형식을 갖는 요소를 계산 스택 맨 위에 <see langword="int64" />로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2482">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2483">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2484">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2484">Format</span></span>|<span data-ttu-id="cbc67-2485">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2485">Assembly Format</span></span>|<span data-ttu-id="cbc67-2486">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2487">96</span><span class="sxs-lookup"><span data-stu-id="cbc67-2487">96</span></span>|<span data-ttu-id="cbc67-2488">ldelem.i8</span><span class="sxs-lookup"><span data-stu-id="cbc67-2488">ldelem.i8</span></span>|<span data-ttu-id="cbc67-2489">형식을 사용 하 여 요소를 로드 `int64` 시 `index` 으로 스택 맨 위에 `int64`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2489">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="cbc67-2490">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2491">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2491">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2492">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2492">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2493">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2493">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2494">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2494">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2495">합니다 `ldelem.i8` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2495">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2496">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2496">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2497">반환 값 `ldelem.i8` 는 `int64`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2497">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="cbc67-2498">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2498">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2499">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2499">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2500">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2500">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2501">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2501">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2502">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2502">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2503">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2503">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2504">지정된 배열 인덱스에서 <see langword="float32" /> 형식을 갖는 요소를 계산 스택 맨 위에 <see langword="F" />형식(부동 소수점)으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2504">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2505">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2505">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2506">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2506">Format</span></span>|<span data-ttu-id="cbc67-2507">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2507">Assembly Format</span></span>|<span data-ttu-id="cbc67-2508">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2508">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2509">98</span><span class="sxs-lookup"><span data-stu-id="cbc67-2509">98</span></span>|<span data-ttu-id="cbc67-2510">ldelem.r4</span><span class="sxs-lookup"><span data-stu-id="cbc67-2510">ldelem.r4</span></span>|<span data-ttu-id="cbc67-2511">형식을 사용 하 여 요소를 로드 `float32` 언제 `index` 형식으로 스택의 맨 위에 `F`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2511">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="cbc67-2512">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2512">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2513">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2513">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2514">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2514">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2515">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2515">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2516">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2516">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2517">합니다 `ldelem.r4` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2517">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2518">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2518">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2519">반환 값 `ldelem.r4` 는 `float32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2519">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="cbc67-2520">부동 소수점 값 형식으로 변환 됩니다 `F` 를 계산 스택으로 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2520">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2521">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2521">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2522">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2522">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2523">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2523">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2524">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2524">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2525">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2525">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2526">지정된 배열 인덱스에서 <see langword="float64" /> 형식을 갖는 요소를 계산 스택 맨 위에 <see langword="F" />형식(부동 소수점)으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2526">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2527">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2527">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2528">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2528">Format</span></span>|<span data-ttu-id="cbc67-2529">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2529">Assembly Format</span></span>|<span data-ttu-id="cbc67-2530">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2530">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2531">99</span><span class="sxs-lookup"><span data-stu-id="cbc67-2531">99</span></span>|<span data-ttu-id="cbc67-2532">ldelem.r8</span><span class="sxs-lookup"><span data-stu-id="cbc67-2532">ldelem.r8</span></span>|<span data-ttu-id="cbc67-2533">형식을 사용 하 여 요소를 로드 `float64` 언제 `index` 형식으로 스택 맨 위에 `F`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2533">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="cbc67-2534">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2534">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2535">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2535">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2536">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2536">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2537">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2537">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2538">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2538">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2539">합니다 `ldelem.r8` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2539">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2540">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2540">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2541">반환 값 `ldelem.r8` 는 `float64`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2541">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="cbc67-2542">부동 소수점 값 형식으로 변환 됩니다 `F` 를 계산 스택으로 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2542">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2543">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2543">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2544">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2544">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2545">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2545">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2546">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2546">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2547">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2547">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2548">지정된 배열 인덱스에서 개체 참조를 포함하는 요소를 <see langword="O" /> 형식(개체 참조)으로 계산 스택 맨 위에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2548">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2549">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2549">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2550">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2550">Format</span></span>|<span data-ttu-id="cbc67-2551">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2551">Assembly Format</span></span>|<span data-ttu-id="cbc67-2552">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2552">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2553">9A</span><span class="sxs-lookup"><span data-stu-id="cbc67-2553">9A</span></span>|<span data-ttu-id="cbc67-2554">ldelem.ref</span><span class="sxs-lookup"><span data-stu-id="cbc67-2554">ldelem.ref</span></span>|<span data-ttu-id="cbc67-2555">개체 참조를 사용 하 여 요소를 로드 `index` 형식으로 스택 맨 위에 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2555">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="cbc67-2556">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2556">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2557">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2557">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2558">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2558">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2559">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2559">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2560">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2560">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2561">합니다 `ldelem.ref` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2561">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2562">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2562">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2563">반환 값 `ldelem.ref` 형식이 `O` (개체 참조).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2563">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2564">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2564">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2565">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2565">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2566">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2566">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2567">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2567">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2568">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2568">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2569">지정된 배열 인덱스의 <see langword="unsigned int8" /> 형식을 갖는 요소를 계산 스택 맨 위에 <see langword="int32" />로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2569">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2570">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2570">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2571">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2571">Format</span></span>|<span data-ttu-id="cbc67-2572">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2572">Assembly Format</span></span>|<span data-ttu-id="cbc67-2573">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2573">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2574">91</span><span class="sxs-lookup"><span data-stu-id="cbc67-2574">91</span></span>|<span data-ttu-id="cbc67-2575">ldelem.u1</span><span class="sxs-lookup"><span data-stu-id="cbc67-2575">ldelem.u1</span></span>|<span data-ttu-id="cbc67-2576">형식을 사용 하 여 요소를 로드 `unsigned int8` 시 `index` 으로 스택 맨 위에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2576">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2577">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2577">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2578">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2578">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2579">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2579">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2580">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2580">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2581">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2581">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2582">합니다 `ldelem.u1` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2582">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2583">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2583">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2584">반환 값 `ldelem.u1` 는 `int8`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2584">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="cbc67-2585">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2585">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2586">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2586">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2587">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2587">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2588">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2588">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2589">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2589">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2590">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2590">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2591">지정된 배열 인덱스의 <see langword="unsigned int16" /> 형식을 갖는 요소를 계산 스택 맨 위에 <see langword="int32" />로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2591">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2592">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2592">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2593">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2593">Format</span></span>|<span data-ttu-id="cbc67-2594">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2594">Assembly Format</span></span>|<span data-ttu-id="cbc67-2595">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2595">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2596">93</span><span class="sxs-lookup"><span data-stu-id="cbc67-2596">93</span></span>|<span data-ttu-id="cbc67-2597">ldelem.u2</span><span class="sxs-lookup"><span data-stu-id="cbc67-2597">ldelem.u2</span></span>|<span data-ttu-id="cbc67-2598">형식을 사용 하 여 요소를 로드 `unsigned int16` 으로 스택 맨 위에 있는 인덱스는 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2598">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2599">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2599">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2600">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2600">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2601">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2601">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2602">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2602">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2603">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2603">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2604">합니다 `ldelem.u2` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2604">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2605">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2605">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2606">반환 값 `ldelem.u2` 는 `int16`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2606">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="cbc67-2607">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2607">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2608">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2608">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2609">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2609">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2610">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2610">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2611">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2611">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2612">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2612">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2613">지정된 배열 인덱스의 <see langword="unsigned int32" /> 형식을 갖는 요소를 계산 스택 맨 위에 <see langword="int32" />로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2613">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2614">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2614">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2615">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2615">Format</span></span>|<span data-ttu-id="cbc67-2616">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2616">Assembly Format</span></span>|<span data-ttu-id="cbc67-2617">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2617">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2618">95</span><span class="sxs-lookup"><span data-stu-id="cbc67-2618">95</span></span>|<span data-ttu-id="cbc67-2619">ldelem.u4</span><span class="sxs-lookup"><span data-stu-id="cbc67-2619">ldelem.u4</span></span>|<span data-ttu-id="cbc67-2620">형식을 사용 하 여 요소를 로드 `unsigned int32` 으로 스택 맨 위에 있는 인덱스는 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2620">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2621">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2621">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2622">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2622">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2623">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2623">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2624">및 `array` 스택에서 팝 되 고 위치에 저장 된 값 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2624">and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2625">값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2625">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2626">합니다 `ldelem.u4` 인덱스를 사용 하 여 요소의 값을 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2626">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2627">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2627">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2628">반환 값 `ldelem.u4` 는 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2628">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="cbc67-2629">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2629">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2630">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2630">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2631">배열 요소의 필수 형식 보유 하지 않는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2631">is thrown if array does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2632">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2632">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2633">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelem.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2633">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2634">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2634">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2635">지정된 배열 인덱스에 있는 배열 요소의 주소를 <see langword="&amp;" /> 형식(관리되는 포인터)으로 계산 스택 맨 위에 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2635">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2636">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2636">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2637">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2637">Format</span></span>|<span data-ttu-id="cbc67-2638">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2638">Assembly Format</span></span>|<span data-ttu-id="cbc67-2639">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2639">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2640">8F < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2640">8F < `T` ></span></span>|<span data-ttu-id="cbc67-2641">ldelema</span><span class="sxs-lookup"><span data-stu-id="cbc67-2641">ldelema</span></span> `class`|<span data-ttu-id="cbc67-2642">에 있는 배열 요소의 주소를 로드 `index` 형식으로 계산 스택 맨 위에 `&` (관리 되는 포인터).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2642">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="cbc67-2643">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2643">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2644">개체 참조 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2644">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2645">인덱스 값을 `index` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2645">An index value `index` is pushed onto the stack.</span></span>  
  
3.  `index` <span data-ttu-id="cbc67-2646">및 `array` 스택에서 팝 되 고 위치에 저장 된 주소의 `index` 에서 `array` 조회 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2646">and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="cbc67-2647">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2647">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2648">합니다 `ldelema` 개체의 배열에서 특정 인덱스에서 개체의 주소를 검색 하는 데 사용 됩니다 (형식의 `class`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2648">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="cbc67-2649">합니다 `ldelema` 인덱스에 있는 값의 주소를 로드 하는 명령 `index` (형식 `native int`) 0부터 시작 하는 1 차원 배열에서 `array` 스택의 맨 위에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2649">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="cbc67-2650">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2650">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-2651">값 형식 이어야 합니다 `class` 명령으로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2651">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="cbc67-2652">반환 값 `ldelema` 관리 되는 포인터 (형식 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2652">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="cbc67-2653">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2653">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2654">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2654">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-2655">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2655">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-2656">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2656">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="cbc67-2657">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldelema` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2657">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2658">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2658">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2659">현재 계산 스택에 참조가 있는 개체에서 필드의 값을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2659">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2660">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2660">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2661">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2661">Format</span></span>|<span data-ttu-id="cbc67-2662">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2662">Assembly Format</span></span>|<span data-ttu-id="cbc67-2663">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2663">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2664">7B < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2664">7B < `T` ></span></span>|<span data-ttu-id="cbc67-2665">ldfld</span><span class="sxs-lookup"><span data-stu-id="cbc67-2665">ldfld</span></span> `field`|<span data-ttu-id="cbc67-2666">지정된 된 개체를 스택에 있는 필드의 값을 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2666">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2667">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2667">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2668">개체 참조 (또는 포인터)를 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2668">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2669">개체 참조 (또는 포인터)이 스택에서 팝 합니다. 개체에 지정된 된 필드의 값은 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2669">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="cbc67-2670">필드에 저장 된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2670">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2671">`ldfld` 명령이 스택에 개체에 있는 필드의 값을 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2671">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="cbc67-2672">개체는 개체 참조 스택에 있어야 합니다. (유형 `O`)를 관리 되는 포인터 (형식 `&`), 관리 되지 않는 포인터를 (형식 `native int`), 임시 포인터 (형식 `*`), 또는 값 형식의 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2672">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="cbc67-2673">관리 되지 않는 포인터를 사용 검증할 수 있는 코드에서 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2673">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="cbc67-2674">개체의 필드를 필드 멤버를 참조 하는 메타 데이터 토큰에 의해 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2674">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="cbc67-2675">반환 형식은 필드와 연결 된 것과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2675">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="cbc67-2676">인스턴스 필드 (이 경우 개체 아니어야 null 참조) 또는 정적 필드는 필드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2676">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="cbc67-2677">합니다 `ldfld` 명령 중 하나 또는 모두 뒤에 올 수 있습니다 합니다 <xref:System.Reflection.Emit.OpCodes.Unaligned> 및 <xref:System.Reflection.Emit.OpCodes.Volatile> 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2677">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2678">개체가 null 인 고 필드가 static이 아닌 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2678">is thrown if the object is null and the field is not static.</span></span>  
  
 <xref:System.MissingFieldException> <span data-ttu-id="cbc67-2679">지정된 된 필드 메타 데이터에 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2679">is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="cbc67-2680">이 값은 런타임에 하지 언어 MSIL (Microsoft Intermediate) 명령이 네이티브 코드로 변환 될 때 일반적으로 검사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2680">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="cbc67-2681">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2681">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2682">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2682">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2683">현재 계산 스택에 참조가 있는 개체에서 필드의 주소를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2683">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2684">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2684">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2685">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2685">Format</span></span>|<span data-ttu-id="cbc67-2686">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2686">Assembly Format</span></span>|<span data-ttu-id="cbc67-2687">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2687">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2688">7C < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2688">7C < `T` ></span></span>|<span data-ttu-id="cbc67-2689">ldflda</span><span class="sxs-lookup"><span data-stu-id="cbc67-2689">ldflda</span></span> `field`|<span data-ttu-id="cbc67-2690">주소의 푸시 `field` 스택에 지정한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2690">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2691">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2691">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2692">개체 참조 (또는 포인터)를 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2692">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2693">개체 참조 (또는 포인터)이 스택에서 팝 합니다. 개체에 지정된 된 필드의 주소를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2693">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="cbc67-2694">지정된 된 필드의 주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2694">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2695">`ldflda` 스택에 개체에 있는 필드의 주소를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2695">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="cbc67-2696">개체는 개체 참조 스택에 있어야 합니다. (유형 `O`)를 관리 되는 포인터 (형식 `&`), 관리 되지 않는 포인터를 (형식 `native int`), 임시 포인터 (형식 `*`), 또는 값 형식의 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2696">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="cbc67-2697">관리 되지 않는 포인터를 사용 검증할 수 있는 코드에서 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2697">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="cbc67-2698">개체의 필드를 필드 멤버를 참조 하는 메타 데이터 토큰에 의해 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2698">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="cbc67-2699">반환 된 값 `ldflda` 관리 되는 포인터 (형식 `&`)로 관리 되지 않는 포인터를 스택에 밀어넣어 개체, 경우에서 반송 주소 이기도 관리 되지 않는 포인터를 (형식 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2699">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="cbc67-2700">합니다 `ldflda` 명령 중 하나 또는 모두 뒤에 올 수 있습니다 합니다 <xref:System.Reflection.Emit.OpCodes.Unaligned> 및 <xref:System.Reflection.Emit.OpCodes.Volatile> 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2700">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <xref:System.InvalidOperationException> <span data-ttu-id="cbc67-2701">개체를 액세스 하는 응용 프로그램 도메인 내에서 없으면 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2701">is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="cbc67-2702">에 액세스 하는 응용 프로그램 도메인 내에서 포함 되지 않는 필드의 주소를 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2702">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2703">개체가 null 인 고 필드가 static이 아닌 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2703">is thrown if the object is null and the field is not static.</span></span>  
  
 <xref:System.MissingFieldException> <span data-ttu-id="cbc67-2704">지정된 된 필드 메타 데이터에 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2704">is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="cbc67-2705">이 값은 런타임에 하지 언어 MSIL (Microsoft Intermediate) 명령이 네이티브 코드로 변환 될 때 일반적으로 검사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2705">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="cbc67-2706">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldflda` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2706">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2707">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2707">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2708">특정 메서드를 구현하는 네이티브 코드에 대한 관리되지 않는 포인터(<see langword="native int" /> 형식)를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2708">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2709">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2709">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2710">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2710">Format</span></span>|<span data-ttu-id="cbc67-2711">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2711">Assembly Format</span></span>|<span data-ttu-id="cbc67-2712">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2712">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2713">FE 06 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-2713">FE 06 < `T` ></span></span>|<span data-ttu-id="cbc67-2714">ldftn</span><span class="sxs-lookup"><span data-stu-id="cbc67-2714">ldftn</span></span> `method`|<span data-ttu-id="cbc67-2715">가 참조 하는 메서드에 대 한 포인터를 푸시 `method` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2715">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2716">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2716">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2717">특정 메서드를 관리 되지 않는 포인터를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2717">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2718">특정 메서드 (`method`)를 사용 하 여 호출할 수는 <xref:System.Reflection.Emit.OpCodes.Calli> 관리 되는 메서드 (또는 비관리 코드에 관리 코드에서 전환 하는 스텁을) 참조 하는 경우 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2718">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="cbc67-2719">CLR 호출 규칙을 사용 하 여 네이티브 코드로 반환 되는 값을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2719">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="cbc67-2720">이 메서드에 대 한 포인터를 콜백 루틴으로 관리 되지 않는 네이티브 코드에 전달 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2720">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="cbc67-2721">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldftn` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2721">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2722">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2722">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2723"><see langword="native int" /> 형식의 값을 <see langword="native int" /> 형식으로 계산 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2723">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2724">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2724">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2725">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2725">Format</span></span>|<span data-ttu-id="cbc67-2726">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2726">Assembly Format</span></span>|<span data-ttu-id="cbc67-2727">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2727">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2728">4D</span><span class="sxs-lookup"><span data-stu-id="cbc67-2728">4D</span></span>|<span data-ttu-id="cbc67-2729">ldind.i</span><span class="sxs-lookup"><span data-stu-id="cbc67-2729">ldind.i</span></span>|<span data-ttu-id="cbc67-2730">로드 된 `native int` 주소의 값 `addr` 로 스택에 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2730">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="cbc67-2731">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2731">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2732">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2732">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2733">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2733">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2734">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2734">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2735">합니다 `ldind.i` 명령 간접적으로 로드를 `native int` 지정된 된 주소에서 값 (형식의 `native int`, `&`, 또는 \*)로 스택에 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2735">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="cbc67-2736">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2736">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2737">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2737">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2738">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2738">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2739">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2739">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2740">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2740">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2741">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2741">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2742">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2742">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2743">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2743">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2744">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2744">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2745">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2745">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2746">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2746">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2747"><see langword="int8" /> 형식의 값을 <see langword="int32" />로 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2747">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2748">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2748">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2749">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2749">Format</span></span>|<span data-ttu-id="cbc67-2750">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2750">Assembly Format</span></span>|<span data-ttu-id="cbc67-2751">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2751">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2752">46</span><span class="sxs-lookup"><span data-stu-id="cbc67-2752">46</span></span>|<span data-ttu-id="cbc67-2753">ldind.i1</span><span class="sxs-lookup"><span data-stu-id="cbc67-2753">ldind.i1</span></span>|<span data-ttu-id="cbc67-2754">로드 된 `int8` 주소의 값 `addr` 로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2754">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2755">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2755">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2756">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2756">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2757">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2757">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2758">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2758">The fetched value is pushed onto the stack.</span></span> 
  
 <span data-ttu-id="cbc67-2759">합니다 `ldind.i1` 명령 간접적으로 로드를 `int8` 지정된 된 주소에서 값 (형식의 `native int`를 `&`, 또는 \*)로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2759">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="cbc67-2760">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2760">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2761">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2761">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2762">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2762">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2763">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2763">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2764">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2764">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2765">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2765">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2766">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2766">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2767">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2767">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2768">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2768">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2769">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2770">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2770">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2771"><see langword="int16" /> 형식의 값을 <see langword="int32" />로 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2771">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2772">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2773">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2773">Format</span></span>|<span data-ttu-id="cbc67-2774">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2774">Assembly Format</span></span>|<span data-ttu-id="cbc67-2775">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2776">48</span><span class="sxs-lookup"><span data-stu-id="cbc67-2776">48</span></span>|<span data-ttu-id="cbc67-2777">ldind.i2</span><span class="sxs-lookup"><span data-stu-id="cbc67-2777">ldind.i2</span></span>|<span data-ttu-id="cbc67-2778">로드 된 `int16` 주소의 값 `addr` 로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2778">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2779">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2780">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2780">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2781">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2781">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2782">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2782">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2783">합니다 `ldind.i2` 명령 간접적으로 로드를 `int16` 지정된 된 주소에서 값 (형식의 `native int`를 `&`, 또는 \*)로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2783">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="cbc67-2784">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2784">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2785">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2785">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2786">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2786">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2787">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2787">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2788">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2788">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2789">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2789">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2790">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2790">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2791">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2791">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2792">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2792">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2793">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2793">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2794">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2794">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2795"><see langword="int32" /> 형식의 값을 <see langword="int32" />로 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2795">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2796">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2796">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2797">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2797">Format</span></span>|<span data-ttu-id="cbc67-2798">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2798">Assembly Format</span></span>|<span data-ttu-id="cbc67-2799">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2799">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2800">4A</span><span class="sxs-lookup"><span data-stu-id="cbc67-2800">4A</span></span>|<span data-ttu-id="cbc67-2801">ldind.i4</span><span class="sxs-lookup"><span data-stu-id="cbc67-2801">ldind.i4</span></span>|<span data-ttu-id="cbc67-2802">로드 된 `int32` 주소의 값 `addr` 로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2802">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2803">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2803">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2804">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2804">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2805">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2805">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2806">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2806">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2807">합니다 `ldind.i4` 명령 간접적으로 로드를 `int32` 지정된 된 주소에서 값 (형식의 `native int`를 `&`, 또는 \*)로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2807">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="cbc67-2808">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2808">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2809">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2809">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2810">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2810">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2811">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2811">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2812">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2812">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2813">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2813">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2814">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2814">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2815">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2815">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2816">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2816">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2817">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2817">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2818">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2818">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2819"><see langword="int64" /> 형식의 값을 <see langword="int64" />로 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2819">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2820">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2820">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2821">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2821">Format</span></span>|<span data-ttu-id="cbc67-2822">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2822">Assembly Format</span></span>|<span data-ttu-id="cbc67-2823">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2823">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2824">4C</span><span class="sxs-lookup"><span data-stu-id="cbc67-2824">4C</span></span>|<span data-ttu-id="cbc67-2825">ldind.i8</span><span class="sxs-lookup"><span data-stu-id="cbc67-2825">ldind.i8</span></span>|<span data-ttu-id="cbc67-2826">로드 된 `int64` 주소의 값 `addr` 로 스택에 `int64`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2826">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="cbc67-2827">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2827">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2828">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2828">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2829">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2829">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2830">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2830">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2831">합니다 `ldind.i8` 명령 간접적으로 로드를 `int64` 지정된 된 주소에서 값 (형식의 `native int`를 `&`, 또는 \*)로 스택에 `int64`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2831">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="cbc67-2832">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2832">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2833">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2833">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2834">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2834">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2835">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2835">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2836">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2836">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2837">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2837">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2838">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2838">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2839">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2839">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2840">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2840">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2841">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2841">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2842">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2842">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2843"><see langword="float32" /> 형식의 값을 <see langword="F" /> 형식(부동 소수점)으로 계산 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2843">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2844">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2844">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2845">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2845">Format</span></span>|<span data-ttu-id="cbc67-2846">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2846">Assembly Format</span></span>|<span data-ttu-id="cbc67-2847">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2847">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2848">4E</span><span class="sxs-lookup"><span data-stu-id="cbc67-2848">4E</span></span>|<span data-ttu-id="cbc67-2849">ldind.r4</span><span class="sxs-lookup"><span data-stu-id="cbc67-2849">ldind.r4</span></span>|<span data-ttu-id="cbc67-2850">로드 된 `float32` 주소의 값 `addr` 형식으로 스택에 `F`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2850">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="cbc67-2851">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2851">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2852">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2852">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2853">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2853">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2854">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2854">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2855">합니다 `ldind.r4` 명령 간접적으로 로드를 `float32` 지정된 된 주소에서 값 (형식의 `native int`를 `&`, 또는 \*) 형식으로 스택에 `F`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2855">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="cbc67-2856">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2856">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2857">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2857">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2858">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2858">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2859">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2859">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2860">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2860">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2861">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2861">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2862">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2862">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2863">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2863">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2864">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2864">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2865">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2865">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2866">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2866">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2867"><see langword="float64" /> 형식의 값을 <see langword="F" /> 형식(부동 소수점)으로 계산 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2867">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2868">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2868">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2869">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2869">Format</span></span>|<span data-ttu-id="cbc67-2870">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2870">Assembly Format</span></span>|<span data-ttu-id="cbc67-2871">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2871">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2872">4F</span><span class="sxs-lookup"><span data-stu-id="cbc67-2872">4F</span></span>|<span data-ttu-id="cbc67-2873">ldind.r8</span><span class="sxs-lookup"><span data-stu-id="cbc67-2873">ldind.r8</span></span>|<span data-ttu-id="cbc67-2874">로드 된 `float64` 주소의 값 `addr` 형식으로 스택에 `F`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2874">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="cbc67-2875">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2875">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2876">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2876">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2877">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2877">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2878">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2878">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2879">합니다 `ldind.r8` 명령 간접적으로 로드를 `float64` 지정된 된 주소에서 값 (형식의 `native int`, `&`, 또는 \*)로 스택에 `float64`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2879">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="cbc67-2880">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2880">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2881">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2881">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2882">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2882">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2883">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2883">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2884">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2884">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2885">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2885">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2886">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2886">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2887">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2887">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2888">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2888">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2889">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2889">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2890">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2890">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2891">개체 참조를 <see langword="O" /> 형식(개체 참조)으로 계산 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2891">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2892">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2892">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2893">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2893">Format</span></span>|<span data-ttu-id="cbc67-2894">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2894">Assembly Format</span></span>|<span data-ttu-id="cbc67-2895">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2895">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2896">50</span><span class="sxs-lookup"><span data-stu-id="cbc67-2896">50</span></span>|<span data-ttu-id="cbc67-2897">ldind.ref</span><span class="sxs-lookup"><span data-stu-id="cbc67-2897">ldind.ref</span></span>|<span data-ttu-id="cbc67-2898">주소에 있는 개체 참조를 로드 `addr` 형식으로 스택에</span><span class="sxs-lookup"><span data-stu-id="cbc67-2898">Loads the object reference at address `addr` onto the stack as a type</span></span> `O`|  
  
 <span data-ttu-id="cbc67-2899">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2899">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2900">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2900">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2901">스택에서 팝 되는 주소 주소에 있는 개체 참조를 인출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2901">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2902">페치된 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2902">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2903">합니다 `ldind.ref` 명령 간접적으로 로드 한 개체 참조에 지정된 된 주소 (형식의 `native int`를 `&`, 또는 \*) 형식으로 스택에 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2903">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="cbc67-2904">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2904">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2905">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2905">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2906">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2906">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2907">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2907">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2908">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2908">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2909">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2909">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2910">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2910">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2911">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2911">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2912">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2912">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2913">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2915"><see langword="unsigned int8" /> 형식의 값을 <see langword="int32" />로 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2915">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2916">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2917">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2917">Format</span></span>|<span data-ttu-id="cbc67-2918">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2918">Assembly Format</span></span>|<span data-ttu-id="cbc67-2919">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2920">47</span><span class="sxs-lookup"><span data-stu-id="cbc67-2920">47</span></span>|<span data-ttu-id="cbc67-2921">ldind.u1</span><span class="sxs-lookup"><span data-stu-id="cbc67-2921">ldind.u1</span></span>|<span data-ttu-id="cbc67-2922">로드 된 `unsigned int8` 주소의 값 `addr` 로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2922">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2923">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2924">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2924">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2925">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2925">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2926">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2926">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2927">합니다 `ldind.u1` 명령 간접적으로 로드를 `unsigned int8` 지정된 된 주소에서 값 (형식의`native int`를 `&`, 또는 \*)로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2927">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="cbc67-2928">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2928">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2929">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2929">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2930">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2930">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2931">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2931">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2932">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2932">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2933">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2933">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2934">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2934">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2935">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2935">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2936">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2936">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2937">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2939"><see langword="unsigned int16" /> 형식의 값을 <see langword="int32" />로 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2939">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2940">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2940">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2941">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2941">Format</span></span>|<span data-ttu-id="cbc67-2942">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2942">Assembly Format</span></span>|<span data-ttu-id="cbc67-2943">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2943">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2944">49</span><span class="sxs-lookup"><span data-stu-id="cbc67-2944">49</span></span>|<span data-ttu-id="cbc67-2945">ldind.u2</span><span class="sxs-lookup"><span data-stu-id="cbc67-2945">ldind.u2</span></span>|<span data-ttu-id="cbc67-2946">로드 된 `unsigned int16` 주소의 값 `addr` 로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2946">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2947">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2947">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2948">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2948">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2949">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2949">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2950">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2950">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2951">합니다 `ldind.u2` 명령 간접적으로 로드를 `unsigned int16` 지정된 된 주소에서 값 (형식의 `native int`를 `&`, 또는 \*)로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2951">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="cbc67-2952">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2952">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2953">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2953">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2954">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2954">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2955">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2955">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2956">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2956">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2957">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2957">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2958">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2958">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2959">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2959">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2960">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2960">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2961">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2961">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2962">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2962">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2963"><see langword="unsigned int32" /> 형식의 값을 <see langword="int32" />로 스택에 간접적으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2963">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2964">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2964">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2965">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2965">Format</span></span>|<span data-ttu-id="cbc67-2966">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2966">Assembly Format</span></span>|<span data-ttu-id="cbc67-2967">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2967">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2968">4B</span><span class="sxs-lookup"><span data-stu-id="cbc67-2968">4B</span></span>|<span data-ttu-id="cbc67-2969">ldind.u4</span><span class="sxs-lookup"><span data-stu-id="cbc67-2969">ldind.u4</span></span>|<span data-ttu-id="cbc67-2970">로드 된 `unsigned int32` 주소의 값 `addr` 로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2970">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-2971">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2971">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2972">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2972">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2973">스택에서 팝 되는 주소 주소에 있는 값이 페치됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2973">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="cbc67-2974">페치된 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2974">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2975">합니다 `ldind.u4` 명령 간접적으로 로드를 `unsigned int32` 지정된 된 주소에서 값 (형식의 `native int`를 `&`, 또는 \*)로 스택에 `int32`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2975">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="cbc67-2976">모든 합니다 `ldind` 지침은 대 한 바로 가기는 <xref:System.Reflection.Emit.OpCodes.Ldobj> 해당 기본 제공 값 클래스를 지정 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2976">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="cbc67-2977">4 바이트 보다 작은 정수 값에 확장 됩니다 `int32` (없습니다 `native int`)를 계산 스택으로 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2977">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="cbc67-2978">부동 소수점 값으로 변환 됩니다 `F` 를 계산 스택으로 로드 하는 경우 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2978">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-2979">올바른 형식으로 중간 언어 (MSIL (Microsoft)가 되도록는 `ldind` 지침 포인터의 형식을 사용 하 여 일관 된 방식으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2979">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="cbc67-2980">처음으로 스택에 푸시됩니다 주소 컴퓨터에 있는 개체의 원래 크기에 맞춰야 또는 <xref:System.NullReferenceException> 발생할 수 있습니다 (참조는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 예방 조치에 대 한 지침을 접두사).</span><span class="sxs-lookup"><span data-stu-id="cbc67-2980">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="cbc67-2981">주소를 반환 하는 모든 MSIL 명령의 결과는 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloca> 고 <xref:System.Reflection.Emit.OpCodes.Ldarga>) 안전 하 게 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2981">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="cbc67-2982">데이터 형식 1 바이트 보다 큰 경우 바이트 순서는 대상 CPU에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2982">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="cbc67-2983">모든 플랫폼에서 바이트 순서에 종속 된 코드가 실행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2983">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-2984">잘못 된 주소 검색 된 경우에 throw 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2984">can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="cbc67-2985">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldind.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2985">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-2986">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-2986">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-2987">0부터 시작하는 1차원 배열의 요소 수를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2987">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-2988">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-2988">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-2989">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2989">Format</span></span>|<span data-ttu-id="cbc67-2990">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-2990">Assembly Format</span></span>|<span data-ttu-id="cbc67-2991">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-2991">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-2992">8E</span><span class="sxs-lookup"><span data-stu-id="cbc67-2992">8E</span></span>|<span data-ttu-id="cbc67-2993">ldlen</span><span class="sxs-lookup"><span data-stu-id="cbc67-2993">ldlen</span></span>|<span data-ttu-id="cbc67-2994">길이 푸시 (형식의 `natural unsigned int`) 스택의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2994">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-2995">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2995">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-2996">배열에 대 한 개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2996">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-2997">배열 참조는 스택에서 팝 되 고 길이가 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2997">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="cbc67-2998">길이를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2998">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-2999">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-2999">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3000">길이는 `natural unsigned int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3000">The length is returned as a `natural unsigned int`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3001">배열 참조가 null 참조 인 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3001">is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="cbc67-3002">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldlen` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3003">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3003">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3004">특정 인덱스에 있는 지역 변수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3004">Loads the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3005">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3006">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3006">Format</span></span>|<span data-ttu-id="cbc67-3007">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3007">Assembly Format</span></span>|<span data-ttu-id="cbc67-3008">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3009">FE 0C < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3009">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="cbc67-3010">ldloc</span><span class="sxs-lookup"><span data-stu-id="cbc67-3010">ldloc</span></span> `index`|<span data-ttu-id="cbc67-3011">인덱스에 있는 지역 변수를 로드 `index` 스택으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3011">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3012">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3012">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3013">지정된 된 인덱스에 있는 지역 변수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3013">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3014">`ldloc` 명령 푸시 내용의 로컬 변수 수를 계산 스택으로 전달된 된 인덱스에 있는 로컬 변수가 번호가 0부터.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3014">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="cbc67-3015">지역 변수는 메서드는 initialize 플래그가 true 인 경우에 메서드를 입력 하기 전에 0으로 초기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3015">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="cbc67-3016">65,535 가지 (2 ^16-1) 로컬 변수 수 (0-65534)입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3016">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="cbc67-3017">인덱스 65,535 구현 하는 2 바이트 정수를 사용 하 여 두 지역의 인덱스를 지정된 된 메서드에 대 한 지역 총 수와 함께 추적 하기 때문에 잘못 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3017">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="cbc67-3018">인덱스 65535 되었습니다가 유효한 경우 하는 경우 이러한 메서드의 지역 변수 개수를 추적 하는 광범위 한 정수를 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3018">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="cbc67-3019">합니다 `ldloc.0`, `ldloc.1`를 `ldloc.2`, 및 `ldloc.3` 지침 제공 처음 네 개의 로컬 변수에 액세스 하는 것에 대 한 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3019">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="cbc67-3020">값 형식의 메서드 헤더에 지정 된 로컬 변수의 형식을와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3020">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="cbc67-3021">4 바이트 형식으로 확장 됩니다 보다 작은 파티션이 9. 지역 변수를 볼 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3021">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-3022">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3022">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-3023">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldloc` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3023">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="cbc67-3025">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3025">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3026">인덱스 0의 지역 변수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3026">Loads the local variable at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3027">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3027">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3028">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3028">Format</span></span>|<span data-ttu-id="cbc67-3029">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3029">Assembly Format</span></span>|<span data-ttu-id="cbc67-3030">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3030">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3031">06</span><span class="sxs-lookup"><span data-stu-id="cbc67-3031">06</span></span>|<span data-ttu-id="cbc67-3032">ldloc.0</span><span class="sxs-lookup"><span data-stu-id="cbc67-3032">ldloc.0</span></span>|<span data-ttu-id="cbc67-3033">인덱스 0의 지역 변수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3033">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3034">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3034">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3035">인덱스 0에 있는 지역 변수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3035">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 `ldloc.0` <span data-ttu-id="cbc67-3036">에 대 한 효과적인 인코딩이 <xref:System.Reflection.Emit.OpCodes.Ldloc>를 인덱스 0에 있는 지역 변수에 대 한 액세스를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3036">is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="cbc67-3037">값 형식의 메서드 헤더에 지정 된 로컬 변수의 형식을와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3037">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="cbc67-3038">4 바이트 보다 작은 로컬 변수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3038">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-3039">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3039">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-3040">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldloc.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3040">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3041">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3041">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3042">인덱스 1의 지역 변수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3042">Loads the local variable at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3043">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3043">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3044">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3044">Format</span></span>|<span data-ttu-id="cbc67-3045">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3045">Assembly Format</span></span>|<span data-ttu-id="cbc67-3046">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3046">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3047">07</span><span class="sxs-lookup"><span data-stu-id="cbc67-3047">07</span></span>|<span data-ttu-id="cbc67-3048">ldloc.1은</span><span class="sxs-lookup"><span data-stu-id="cbc67-3048">ldloc.1</span></span>|<span data-ttu-id="cbc67-3049">인덱스 1의 지역 변수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3049">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3050">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3050">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3051">인덱스 1에 있는 지역 변수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3051">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 `ldloc.1` <span data-ttu-id="cbc67-3052">에 대 한 효과적인 인코딩이 <xref:System.Reflection.Emit.OpCodes.Ldloc>을 인덱스 1에 있는 지역 변수에 대 한 액세스를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3052">is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="cbc67-3053">값 형식의 메서드 헤더에 지정 된 로컬 변수의 형식을와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3053">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="cbc67-3054">4 바이트 보다 작은 로컬 변수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3054">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-3055">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3055">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-3056">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldloc.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3056">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3057">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3057">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3058">인덱스 2의 지역 변수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3058">Loads the local variable at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3059">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3059">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3060">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3060">Format</span></span>|<span data-ttu-id="cbc67-3061">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3061">Assembly Format</span></span>|<span data-ttu-id="cbc67-3062">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3062">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3063">08</span><span class="sxs-lookup"><span data-stu-id="cbc67-3063">08</span></span>|<span data-ttu-id="cbc67-3064">ldloc.2</span><span class="sxs-lookup"><span data-stu-id="cbc67-3064">ldloc.2</span></span>|<span data-ttu-id="cbc67-3065">인덱스 2의 지역 변수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3065">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3066">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3066">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3067">인덱스 2에 있는 지역 변수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3067">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 `ldloc.2` <span data-ttu-id="cbc67-3068">에 대 한 효과적인 인코딩이 <xref:System.Reflection.Emit.OpCodes.Ldloc>를 인덱스 2에 있는 지역 변수에 대 한 액세스를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3068">is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="cbc67-3069">값 형식의 메서드 헤더에 지정 된 로컬 변수의 형식을와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3069">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="cbc67-3070">4 바이트 보다 작은 로컬 변수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3070">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-3071">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-3072">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldloc.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3074">인덱스 3의 지역 변수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3074">Loads the local variable at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3075">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3076">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3076">Format</span></span>|<span data-ttu-id="cbc67-3077">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3077">Assembly Format</span></span>|<span data-ttu-id="cbc67-3078">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3079">09</span><span class="sxs-lookup"><span data-stu-id="cbc67-3079">09</span></span>|<span data-ttu-id="cbc67-3080">ldloc.3</span><span class="sxs-lookup"><span data-stu-id="cbc67-3080">ldloc.3</span></span>|<span data-ttu-id="cbc67-3081">인덱스 3의 지역 변수를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3081">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3082">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3083">인덱스 3에 있는 지역 변수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3083">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 `ldloc.3` <span data-ttu-id="cbc67-3084">에 대 한 효과적인 인코딩이 <xref:System.Reflection.Emit.OpCodes.Ldloc>, 인덱스 3에 있는 지역 변수에 대 한 액세스를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3084">is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="cbc67-3085">값 형식의 메서드 헤더에 지정 된 로컬 변수의 형식을와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3085">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="cbc67-3086">4 바이트 보다 작은 로컬 변수 형식으로 확장 됩니다 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3086">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-3087">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3087">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-3088">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldloc.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3088">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3089">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3089">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3090">특정 인덱스에 있는 지역 변수를 계산 스택에 약식으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3090">Loads the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3091">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3091">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3092">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3092">Format</span></span>|<span data-ttu-id="cbc67-3093">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3093">Assembly Format</span></span>|<span data-ttu-id="cbc67-3094">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3094">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3095">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3095">11 < `unsigned int8` ></span></span>|<span data-ttu-id="cbc67-3096">ldloc.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-3096">ldloc.s</span></span> `index`|<span data-ttu-id="cbc67-3097">인덱스에 있는 지역 변수를 로드 `index` 스택에 약식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3097">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-3098">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3098">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3099">지정된 된 인덱스에 있는 지역 변수 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3099">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3100">`ldloc.s` 명령 푸시 내용의 로컬 변수 수를 계산 스택으로 전달된 된 인덱스에 있는 로컬 변수가 번호가 0부터.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3100">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="cbc67-3101">지역 변수는 메서드는 initialize 플래그가 true 인 경우 메서드를 입력 하기 전에 0으로 초기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3101">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="cbc67-3102">256 가지 (2 ^8) 사용 가능한 지역 변수 (0-255) 약식으로 보다 더 효율적으로 인코딩 되 `ldloc`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3102">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="cbc67-3103">값 형식의 메서드 헤더에 지정 된 로컬 변수의 형식을와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3103">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="cbc67-3104">4 바이트 형식으로 확장 됩니다 보다 작은 파티션이 9. 지역 변수를 볼 `int32` 스택에 로드 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3104">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="cbc67-3105">부동 소수점 값은 기본 크기로 확장 됩니다 (형식 `F`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3105">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="cbc67-3106">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldloc.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3106">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="cbc67-3108">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3108">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3109">특정 인덱스에 있는 지역 변수의 주소를 계산 스택으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3109">Loads the address of the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3110">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3111">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3111">Format</span></span>|<span data-ttu-id="cbc67-3112">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3112">Assembly Format</span></span>|<span data-ttu-id="cbc67-3113">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3114">FE OD &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3114">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="cbc67-3115">ldloca</span><span class="sxs-lookup"><span data-stu-id="cbc67-3115">ldloca</span></span> `index`|<span data-ttu-id="cbc67-3116">에 있는 로컬 변수의 주소를 로드 `index` 스택으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3116">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3117">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3118">지정된 된 인덱스에서 지역 변수에 저장 된 주소의 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3118">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3119">`ldloca` 주소를 푸시합니다 로컬 변수 개수를 스택으로 전달된 된 인덱스에 있는 지역 변수는 번호가 매겨진된 0 이상입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3119">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="cbc67-3120">스택에 푸시할 값은 이미 올바르게 정렬 용도로 같은 명령 <xref:System.Reflection.Emit.OpCodes.Ldind_I> 고 <xref:System.Reflection.Emit.OpCodes.Stind_I>입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3120">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="cbc67-3121">결과 임시 포인터 (형식 `*`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3121">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="cbc67-3122">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldloca` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3122">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3123">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3123">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3124">특정 인덱스에 있는 지역 변수의 주소를 계산 스택에 약식으로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3124">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3125">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3125">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3126">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3126">Format</span></span>|<span data-ttu-id="cbc67-3127">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3127">Assembly Format</span></span>|<span data-ttu-id="cbc67-3128">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3128">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3129">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3129">12 < `unsigned int8` ></span></span>|<span data-ttu-id="cbc67-3130">ldloca.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-3130">ldloca.s</span></span> `index`|<span data-ttu-id="cbc67-3131">에 있는 로컬 변수의 주소를 로드 `index` 계산 스택에 약식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3131">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-3132">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3132">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3133">지정된 된 인덱스에서 지역 변수에 저장 된 주소의 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3133">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3134">`ldloca.s` 주소를 푸시합니다 로컬 변수 개수를 스택으로 전달된 된 인덱스에 있는 지역 변수는 번호가 매겨진된 0 이상입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3134">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="cbc67-3135">스택에 푸시할 값은 이미 올바르게 정렬 용도로 같은 명령 <xref:System.Reflection.Emit.OpCodes.Ldind_I> 고 <xref:System.Reflection.Emit.OpCodes.Stind_I>입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3135">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="cbc67-3136">결과 임시 포인터 (형식 `*`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3136">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="cbc67-3137">`ldloca.s` 명령은 0에서 255 지역 변수 사용에 대 한 효율적인 인코딩을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3137">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="cbc67-3138">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldloca.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3138">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3139">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3139">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3140">null 참조(<see langword="O" /> 형식)를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3140">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3141">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3141">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3142">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3142">Format</span></span>|<span data-ttu-id="cbc67-3143">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3143">Assembly Format</span></span>|<span data-ttu-id="cbc67-3144">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3144">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3145">14</span><span class="sxs-lookup"><span data-stu-id="cbc67-3145">14</span></span>|<span data-ttu-id="cbc67-3146">수</span><span class="sxs-lookup"><span data-stu-id="cbc67-3146">ldnull</span></span>|<span data-ttu-id="cbc67-3147">null 참조를 스택으로 푸시</span><span class="sxs-lookup"><span data-stu-id="cbc67-3147">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="cbc67-3148">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3148">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3149">Null 개체 참조를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3149">A null object reference is pushed onto the stack.</span></span>  
  
 `ldnull` <span data-ttu-id="cbc67-3150">null 참조를 푸시합니다 (형식 `O`) 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3150">pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="cbc67-3151">이 위치를 초기화 데이터로 채워지기 전에 또는 사용 되지 않을 때 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3151">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 `ldnull` <span data-ttu-id="cbc67-3152">크기에 관계 없이 null 참조를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3152">provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="cbc67-3153">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldnull` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3153">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3154">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3154">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3155">주소가 가리키는 값 형식 개체를 계산 스택 맨 위로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3155">Copies the value type object pointed to by an address to the top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3156">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3156">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3157">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3157">Format</span></span>|<span data-ttu-id="cbc67-3158">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3158">Assembly Format</span></span>|<span data-ttu-id="cbc67-3159">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3159">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3160">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3160">71 < `T` ></span></span>|<span data-ttu-id="cbc67-3161">ldobj</span><span class="sxs-lookup"><span data-stu-id="cbc67-3161">ldobj</span></span> `class`|<span data-ttu-id="cbc67-3162">값 형식 복사 인스턴스 `class` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3162">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3163">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3163">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3164">값 형식 개체의 주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3164">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3165">스택에서 팝 되는 주소 및 특정 주소에서 인스턴스는 조회 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3165">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="cbc67-3166">해당 주소에 저장 된 개체의 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3166">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3167">`ldobj` 명령을 사용 하는 값 형식 매개 변수로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3167">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="cbc67-3168">합니다 `ldobj` 가리키는 값을 복사 하는 명령 `addrOfValObj` (형식의 `&`, `*`, 또는 `native int`) 스택의 맨 위로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3168">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="cbc67-3169">클래스의 크기에 따라 복사 된 바이트 수 (지정 된 대로 `class` 매개 변수).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3169">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="cbc67-3170">`class` 매개 변수는 값 형식을 나타내는 메타 데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3170">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="cbc67-3171">작업은 `ldobj` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3171">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.TypeLoadException> <span data-ttu-id="cbc67-3172">클래스를 찾을 수 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3172">is thrown if class cannot be found.</span></span> <span data-ttu-id="cbc67-3173">이 상황은 중간 MSIL (Microsoft Language) 명령 런타임이 아닌 네이티브 코드로 변환 될 때 일반적으로 발견 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3173">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-3174">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3175">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3175">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3176">정적 필드의 값을 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3176">Pushes the value of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3177">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3178">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3178">Format</span></span>|<span data-ttu-id="cbc67-3179">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3179">Assembly Format</span></span>|<span data-ttu-id="cbc67-3180">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3181">7E < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3181">7E < `T` ></span></span>|<span data-ttu-id="cbc67-3182">ldsfld</span><span class="sxs-lookup"><span data-stu-id="cbc67-3182">ldsfld</span></span> `field`|<span data-ttu-id="cbc67-3183">값을 푸시 `field` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3183">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3184">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3185">특정 필드의 값으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3185">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3186">`ldsfld` 푸시합니다 (클래스의 모든 인스턴스 간에 공유 됨) 정적 값 스택에 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3186">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="cbc67-3187">반환 형식이 전달 된 메타 데이터 토큰을 사용 하 여 연결 `field`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3187">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="cbc67-3188">합니다 `ldsfld` 명령 수를 <xref:System.Reflection.Emit.OpCodes.Volatile> 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3188">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="cbc67-3189">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldsfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3189">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3190">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3190">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3191">정적 필드의 주소를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3191">Pushes the address of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3192">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3192">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3193">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3193">Format</span></span>|<span data-ttu-id="cbc67-3194">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3194">Assembly Format</span></span>|<span data-ttu-id="cbc67-3195">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3195">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3196">7F < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3196">7F < `T` ></span></span>|<span data-ttu-id="cbc67-3197">ldsflda</span><span class="sxs-lookup"><span data-stu-id="cbc67-3197">ldsflda</span></span> `field`|<span data-ttu-id="cbc67-3198">주소의 푸시 `field` 스택에</span><span class="sxs-lookup"><span data-stu-id="cbc67-3198">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="cbc67-3199">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3199">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3200">특정 필드의 주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3200">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3201">`ldsflda` 푸시합니다 (클래스의 모든 인스턴스 간에 공유 됨) 정적 주소 스택에 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3201">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="cbc67-3202">일시적인 포인터 주소를 나타낼 수 있습니다 (유형 `*`) 하는 경우 메타 데이터 토큰 `field` 메모리 관리 되는 형식을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3202">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="cbc67-3203">그렇지 않은 경우 관리 되지 않는 포인터를 해당 (형식 `native int`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3203">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="cbc67-3204">`field` 정적 할당 된 상대 가상 주소 (필드는 오프셋)를 사용 하 여 전역 않을 메모리 관리 되지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3204">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="cbc67-3205">합니다 `ldsflda` 명령 수를 <xref:System.Reflection.Emit.OpCodes.Volatile> 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3205">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <xref:System.MissingFieldException> <span data-ttu-id="cbc67-3206">필드 메타 데이터에 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3206">is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="cbc67-3207">이 상황은 일반적으로 언어 MSIL (Microsoft Intermediate) 명령이 런타임 시가 아니라 네이티브 코드로 변환 될 때 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3207">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-3208">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldsflda` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3209">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3209">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3210">새 개체 참조를 메타데이터에 저장된 문자열 리터럴로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3210">Pushes a new object reference to a string literal stored in the metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3211">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3212">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3212">Format</span></span>|<span data-ttu-id="cbc67-3213">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3213">Assembly Format</span></span>|<span data-ttu-id="cbc67-3214">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3215">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3215">72 < `T` ></span></span>|<span data-ttu-id="cbc67-3216">ldstr</span><span class="sxs-lookup"><span data-stu-id="cbc67-3216">ldstr</span></span> `mdToken`|<span data-ttu-id="cbc67-3217">메타 데이터 문자열 토큰에 대 한 문자열 개체를 푸시 `mdToken`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3217">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="cbc67-3218">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3219">문자열에 대 한 개체 참조를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3219">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3220">합니다 `ldstr` 명령에서 개체 참조를 푸시하 (형식 `O`) 메타 데이터에 저장 된 특정 문자열 리터럴을 나타내는 새 문자열 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3220">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="cbc67-3221">`ldstr` 명령은 필요한 메모리 양을 할당 하 고 런타임 시 필요한 문자열 형식 파일에 사용 되는 형식에서 리터럴 문자열을 변환 하는 데 필요한 형식 변환을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3221">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-3222">공용 언어 인프라 (CLI) 보장 두 `ldstr` 지침은 두 메타 데이터 토큰을 동일한 문자 시퀀스 개체를 반환 동일한 문자열 ("문자열 인터닝"로 알려진 프로세스).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3222">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="cbc67-3223">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldstr` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3224">ILGenerator.Emit (OpCode 문자열)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3224">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3225">메타데이터 토큰을 런타임 표현으로 변환하여 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3225">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3226">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3227">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3227">Format</span></span>|<span data-ttu-id="cbc67-3228">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3228">Assembly Format</span></span>|<span data-ttu-id="cbc67-3229">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3230">D0 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3230">D0 < `T` ></span></span>|<span data-ttu-id="cbc67-3231">ldtoken</span><span class="sxs-lookup"><span data-stu-id="cbc67-3231">ldtoken</span></span> `token`|<span data-ttu-id="cbc67-3232">메타 데이터 토큰을 런타임 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3232">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="cbc67-3233">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3234">전달 된 토큰으로 변환할는 `RuntimeHandle` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3234">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3235">합니다 `ldtoken` 명령 푸시를 `RuntimeHandle` 지정 된 메타 데이터 토큰에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3235">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="cbc67-3236">A `RuntimeHandle` 수는 `fieldref/fielddef`, `methodref/methoddef`, 또는 `typeref/typedef`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3236">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="cbc67-3237">스택에 푸시할 값에 대 한 호출에서 수 `Reflection` 시스템 클래스 라이브러리의 메서드.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3237">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="cbc67-3238">런타임 핸들에 대 한 자세한 내용은 다음 클래스를 참조 하십시오: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, 및 <xref:System.RuntimeMethodHandle>.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3238">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="cbc67-3239">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldtoken` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3240">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3240">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="cbc67-3241">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3241">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="cbc67-3242">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3242">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3243">지정된 개체와 관련된 특정 가상 메서드를 구현하는 네이티브 코드에 대한 관리되지 않는 포인터(<see langword="native int" /> 형식)를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3243">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3244">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3244">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3245">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3245">Format</span></span>|<span data-ttu-id="cbc67-3246">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3246">Assembly Format</span></span>|<span data-ttu-id="cbc67-3247">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3247">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3248">FE 07 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3248">FE 07 < `T` ></span></span>|<span data-ttu-id="cbc67-3249">ldvirtftn</span><span class="sxs-lookup"><span data-stu-id="cbc67-3249">ldvirtftn</span></span> `method`|<span data-ttu-id="cbc67-3250">개체의 가상 메서드에 대 한 포인터 푸시 `method` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3250">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3251">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3251">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3252">개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3252">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3253">메서드에 스택 및 진입점의 주소에서 개체 참조를 팝 되 (메타 데이터 토큰이 지정 된 대로 `method`)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3253">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="cbc67-3254">에 대 한 포인터 `method` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3254">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3255">결과 관리 되지 않는 포인터 스택에 의해 합니다 `ldvirtftn` 명령을 사용 하 여 호출할 수 있습니다를 <xref:System.Reflection.Emit.OpCodes.Calli> 관리 되는 메서드 (또는 비관리 코드에 관리 코드에서 전환 하는 스텁을) 참조 하는 경우 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3255">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="cbc67-3256">관리 되지 않는 포인터 CLR 호출 규칙을 사용 하 여 네이티브 코드를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3256">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="cbc67-3257">이 메서드에 대 한 포인터를 콜백 루틴으로 관리 되지 않는 네이티브 코드에 전달 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3257">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="cbc67-3258">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ldvirtftn` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3258">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3259">ILGenerator.Emit (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3259">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3260">조건에 관계없이 특정 대상 명령으로 제어를 전송하여 보호되는 코드 영역을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3260">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3261">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3261">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3262">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3262">Format</span></span>|<span data-ttu-id="cbc67-3263">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3263">Assembly Format</span></span>|<span data-ttu-id="cbc67-3264">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3264">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3265">DD < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3265">DD < `int32` ></span></span>|<span data-ttu-id="cbc67-3266">나가기</span><span class="sxs-lookup"><span data-stu-id="cbc67-3266">leave</span></span> `target`|<span data-ttu-id="cbc67-3267">보호 된 코드 영역을 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3267">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="cbc67-3268">이 명령에 지정 된 스택 전환 동작은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3268">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3269">`leave` 명령이 현재 명령 다음의 시작 부분에서 4 바이트 부호 있는 오프셋으로 표시 되는 특정 대상 명령으로를 무조건 제어를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3269">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3270">`leave` 비슷하지만 합니다 `br` 명령과 종료 하려면 사용할 수는 `try`, `filter`, 또는 `catch` 일반 분기 지침만 사용할 수 해당 블록 내에서 컨트롤을 전송 하는 반면 블록 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3270">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="cbc67-3271">합니다 `leave` 명령 계산 스택으로 비워지고 적절 한 주변 되도록 `finally` 블록이 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3271">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="cbc67-3272">사용할 수 없습니다는 `leave` 종료 명령을 `finally` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3272">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="cbc67-3273">쉽게 사용 하는 catch 블록 내에서 유효한 예외 처리기에 대 한 코드 생성에는 `leave` 에 있는 연결된 된 명령 제어를 전송 하는 명령 `try` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3273">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="cbc67-3274">명령에 하나 이상의 접두사 코드가 있으면 컨트롤 수만 전송할 첫 번째 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3274">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="cbc67-3275">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `leave` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3275">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3276">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3276">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3277">조건에 관계없이 대상 명령(약식)으로 제어를 전달하여 보호되는 코드 영역을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3277">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3278">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3278">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3279">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3279">Format</span></span>|<span data-ttu-id="cbc67-3280">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3280">Assembly Format</span></span>|<span data-ttu-id="cbc67-3281">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3281">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3282">DE < `int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3282">DE < `int8` ></span></span>|<span data-ttu-id="cbc67-3283">leave.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-3283">leave.s</span></span> `target`|<span data-ttu-id="cbc67-3284">보호 된 영역 코드를 약식을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3284">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-3285">이 명령에 지정 된 스택 전환 동작은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3285">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3286">`leave.s` 명령이 현재 명령 다음의 시작 부분에서 1 바이트 부호 있는 오프셋으로 표시 되는 전달 된 대상 명령으로를 무조건 제어를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3286">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3287">`leave.s` 비슷하지만 합니다 `br` 명령과 종료 하려면 사용할 수는 `try`, `filter`, 또는 `catch` 일반 분기 지침만 사용할 수 해당 블록 내에서 컨트롤을 전송 하는 반면 블록 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3287">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="cbc67-3288">합니다 `leave.s` 명령 계산 스택으로 비워지고 적절 한 주변 되도록 `finally` 블록이 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3288">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="cbc67-3289">사용할 수 없습니다는 `leave.s` 종료 명령을 `finally` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3289">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="cbc67-3290">쉽게 사용 하는 catch 블록 내에서 유효한 예외 처리기에 대 한 코드 생성에는 `leave.s` 에 있는 연결된 된 명령 제어를 전송 하는 명령 `try` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3290">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="cbc67-3291">명령에 하나 이상의 접두사 코드가 있으면 컨트롤 수만 전송할 첫 번째 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3291">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="cbc67-3292">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `leave.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3293">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3293">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3294">로컬 동적 메모리 풀에서 특정 바이트 수를 할당하고 처음 할당된 바이트의 주소(임시 포인터, <see langword="*" /> 형식)를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3294">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3295">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3296">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3296">Format</span></span>|<span data-ttu-id="cbc67-3297">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3297">Assembly Format</span></span>|<span data-ttu-id="cbc67-3298">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3299">FE 0F</span><span class="sxs-lookup"><span data-stu-id="cbc67-3299">FE 0F</span></span>|<span data-ttu-id="cbc67-3300">localloc</span><span class="sxs-lookup"><span data-stu-id="cbc67-3300">localloc</span></span>|<span data-ttu-id="cbc67-3301">로컬 힙에서 공간을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3301">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="cbc67-3302">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3303">할당할 바이트 수를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3303">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3304">바이트 수를 스택에서 팝 되 크기에 해당 하는 메모리 양은 로컬 힙에서 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3304">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="cbc67-3305">할당된 된 메모리의 첫 번째 바이트에 대 한 포인터를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3305">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3306">합니다 `localloc` 명령 할당 `size` (형식 `natural unsigned int`) 로컬 동적 메모리의 바이트 풀 및 주소를 반환 합니다 (임시 포인터, 형식 `*`) 처음 할당 된 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3306">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="cbc67-3307">메모리 블록에 경우에 메서드 초기화 플래그가 0으로 초기화 됩니다 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3307">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="cbc67-3308">현재 메서드가 실행 하는 경우는 <xref:System.Reflection.Emit.OpCodes.Ret>, 로컬 메모리 풀을 다시 사용할 수 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3308">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="cbc67-3309">만들어진 주소는 기본 데이터 형식일 수 저장할 수 있도록 있습니다를 사용 하 여 정렬 되는 `stind` 지침 (같은 <xref:System.Reflection.Emit.OpCodes.Stind_I4>) 사용 하 여 로드 하 고는 `ldind` 지침 (같은 <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3309">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="cbc67-3310">합니다 `localloc` 명령 내에서 발생할 수 없습니다는 `filter`를 `catch`, `finally`, 또는 `fault` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3310">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <xref:System.StackOverflowException> <span data-ttu-id="cbc67-3311">요청을 서비스에 메모리가 부족 한 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3311">is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="cbc67-3312">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `localloc` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3312">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3313">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3313">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3314">특정 형식의 인스턴스에 대한 형식화된 참조를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3314">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3315">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3315">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3316">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3316">Format</span></span>|<span data-ttu-id="cbc67-3317">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3317">Assembly Format</span></span>|<span data-ttu-id="cbc67-3318">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3318">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3319">C6 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3319">C6 < `T` ></span></span>|<span data-ttu-id="cbc67-3320">mkrefany</span><span class="sxs-lookup"><span data-stu-id="cbc67-3320">mkrefany</span></span> `class`|<span data-ttu-id="cbc67-3321">형식화 된 참조 형식의 푸시 `class` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3321">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3322">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3322">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3323">에 대 한 포인터 데이터를 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3323">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3324">이 포인터 팝 되 고 형식화 된 참조 형식으로 변환할 `class`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3324">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="cbc67-3325">형식화 된 참조를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3325">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3326">`mkrefany` 명령에 동적으로 형식화 된 참조를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3326">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="cbc67-3327">포인터 형식 이어야 합니다 `&`, `*`, 또는 `native int`, 데이터의 유효한 주소를 보유 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3327">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> `Class` <span data-ttu-id="cbc67-3328">클래스 토큰 포인터에서 참조 데이터의 형식을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3328">is the class token describing the type of the data referenced by the pointer.</span></span> `Mkrefany` <span data-ttu-id="cbc67-3329">형식화 된 참조를 포인터 형식과의 불투명 설명자 제공를 스택에 푸시합니다 `class`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3329">pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="cbc67-3330">유효한 형식화 된 참조 시 허용 작업이 매개 변수로 형식화 된 참조를 사용 하는 메서드에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3330">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="cbc67-3331">호출 수신자가 사용 하 여 수를 <xref:System.Reflection.Emit.OpCodes.Refanytype> 및 <xref:System.Reflection.Emit.OpCodes.Refanyval> 유형 (클래스) 및 주소를 각각 검색 하는 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3331">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <xref:System.TypeLoadException> <span data-ttu-id="cbc67-3332">이 throw `class` 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3332">is thrown if `class` cannot be found.</span></span> <span data-ttu-id="cbc67-3333">이 일반적으로 언어 MSIL (Microsoft Intermediate) 명령이 런타임이 아닌 네이티브 코드로 변환 될 때 감지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3333">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-3334">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `mkrefany` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3335">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3335">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3336">두 값을 곱하여 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3336">Multiplies two values and pushes the result on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3337">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3338">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3338">Format</span></span>|<span data-ttu-id="cbc67-3339">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3339">Assembly Format</span></span>|<span data-ttu-id="cbc67-3340">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3341">5A</span><span class="sxs-lookup"><span data-stu-id="cbc67-3341">5A</span></span>|<span data-ttu-id="cbc67-3342">mul</span><span class="sxs-lookup"><span data-stu-id="cbc67-3342">mul</span></span>|<span data-ttu-id="cbc67-3343">스택의 두 값을 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3343">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3344">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-3345">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3345">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-3346">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3346">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-3347">및 `value1` 스택에서 팝 되 고 `value1` 곱하고 `value2`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3347">and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="cbc67-3348">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3348">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3349">합니다 `mul` 명령 곱합니다 `value1` 여 `value2` 고 결과 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3349">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="cbc67-3350">정수 연산 오버플로에 상위 비트를 자동으로 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3350">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="cbc67-3351">참조 <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> 곱하기 연산 오버플로 처리에는 정수 관련에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3351">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="cbc67-3352">부동 소수점 형식의 경우 0 \* 무한대 = NaN입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3352">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="cbc67-3353">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `mul` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3353">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3354">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3354">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3355">두 정수 값을 곱하고 오버플로를 검사하여 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3355">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3356">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3356">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3357">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3357">Format</span></span>|<span data-ttu-id="cbc67-3358">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3358">Assembly Format</span></span>|<span data-ttu-id="cbc67-3359">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3359">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3360">D8</span><span class="sxs-lookup"><span data-stu-id="cbc67-3360">D8</span></span>|<span data-ttu-id="cbc67-3361">mul.ovf</span><span class="sxs-lookup"><span data-stu-id="cbc67-3361">mul.ovf</span></span>|<span data-ttu-id="cbc67-3362">오버플로 검사를 사용 하 여 스택의 두 정수 값을 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3362">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="cbc67-3363">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3363">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-3364">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3364">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-3365">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3365">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-3366">및 `value1` 스택에서 팝 되 고 `value1` 곱하고 `value2`, 오버플로 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3366">and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="cbc67-3367">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3367">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3368">합니다 `mul.ovf` 명령 정수를 곱합니다 `value1` 정수로 `value2` 고 결과 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3368">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="cbc67-3369">결과 결과 형식에 적합 하지 않은 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3369">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-3370">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3370">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-3371">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `mul.ovf` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3371">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3372">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3372">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3373">부호 없는 두 정수 값을 곱하고 오버플로를 검사한 후 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3373">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3374">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3374">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3375">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3375">Format</span></span>|<span data-ttu-id="cbc67-3376">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3376">Assembly Format</span></span>|<span data-ttu-id="cbc67-3377">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3377">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3378">D9</span><span class="sxs-lookup"><span data-stu-id="cbc67-3378">D9</span></span>|<span data-ttu-id="cbc67-3379">mul.ovf.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-3379">mul.ovf.un</span></span>|<span data-ttu-id="cbc67-3380">스택 오버플로 검사를 사용 하 여 두 개의 부호 없는 값을 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3380">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="cbc67-3381">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3381">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-3382">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3382">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-3383">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3383">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-3384">및 `value1` 스택에서 팝 되 고 `value1` 곱하고 `value2`, 오버플로 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3384">and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="cbc67-3385">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3385">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3386">합니다 `mul.ovf.un` 명령 부호 없는 정수를 곱합니다 `value1` 부호 없는 정수로 `value2` 고 결과 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3386">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="cbc67-3387">결과 결과 형식에 적합 하지 않은 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3387">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-3388">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3388">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-3389">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `mul.ovf.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3389">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3390">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3390">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3391">값을 음수로 만들고 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3391">Negates a value and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3392">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3392">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3393">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3393">Format</span></span>|<span data-ttu-id="cbc67-3394">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3394">Assembly Format</span></span>|<span data-ttu-id="cbc67-3395">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3395">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3396">65</span><span class="sxs-lookup"><span data-stu-id="cbc67-3396">65</span></span>|<span data-ttu-id="cbc67-3397">neg</span><span class="sxs-lookup"><span data-stu-id="cbc67-3397">neg</span></span>|<span data-ttu-id="cbc67-3398">스택의 맨 위에 있는 현재 값을 부정합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3398">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3399">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3399">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3400">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3400">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3401">값이 스택에서 팝 되 고 부정 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3401">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="cbc67-3402">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3402">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3403">`neg` 명령 값을 부정 하 고 스택 맨 위에 결과 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3403">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="cbc67-3404">반환 형식은 피연산자 형식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3404">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="cbc67-3405">정수 계열 값의 부정은 표준 2의 보수 부정 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3405">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="cbc67-3406">특히, 부정 (없는 양의 누구) 가장 음수가 가장 음수를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3406">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="cbc67-3407">이 오버플로 사용을 감지 하 여 <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> 명령 대신 (즉, 0에서 빼기).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3407">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="cbc67-3408">부동 소수점 숫자 부정, 오버플로가 발생 하 고 NaN 부정 NaN을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3408">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="cbc67-3409">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `neg` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3409">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3410">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3410">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3411">0부터 시작하고 요소가 특정 형식인 새 1차원 배열에 대한 개체 참조를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3411">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3412">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3412">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3413">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3413">Format</span></span>|<span data-ttu-id="cbc67-3414">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3414">Assembly Format</span></span>|<span data-ttu-id="cbc67-3415">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3415">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3416">8D < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3416">8D < `T` ></span></span>|<span data-ttu-id="cbc67-3417">newarr</span><span class="sxs-lookup"><span data-stu-id="cbc67-3417">newarr</span></span> `etype`|<span data-ttu-id="cbc67-3418">형식의 요소를 사용 하 여 새 배열을 만듭니다 `etype`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3418">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="cbc67-3419">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3419">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3420">배열의 요소 수를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3420">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3421">요소의 수는 스택에서 팝 하 고 배열 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3421">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="cbc67-3422">새 배열에 개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3422">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3423">합니다 `newarr` 명령에서 개체 참조를 푸시하 (형식 `O`) 형식의 요소가 들어 있는 새 차원 배열에 `etype` (종류를 설명 하는 메타 데이터 토큰).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3423">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="cbc67-3424">새 배열의 요소 수로 지정 해야는 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3424">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="cbc67-3425">유효한 배열 인덱스 범위는 0에서 1을 뺀 요소의 최대 수입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3425">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="cbc67-3426">배열 요소에는 값 형식을 비롯 한 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3426">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="cbc67-3427">적절 한 값 형식을 참조 하는 메타 데이터 토큰을 사용 하 여 숫자 차원 배열을 생성 됩니다 (<xref:System.Int32>등).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3427">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="cbc67-3428">배열의 요소는 적절 한 형식의 0으로 초기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3428">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="cbc67-3429">0부터 1 차원 배열과 다차원 배열을 사용 하 여 생성 됩니다 <xref:System.Reflection.Emit.OpCodes.Newobj> 대신 `newarr`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3429">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="cbc67-3430">메서드를 사용 하 여 만들어진 하는 일반적으로 <xref:System.Array> .NET Framework의 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3430">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <xref:System.OutOfMemoryException> <span data-ttu-id="cbc67-3431">메모리가 부족 하 여 요청을 충족할 수 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3431">is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-3432">이 throw `numElems` 0 보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3432">is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="cbc67-3433">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `newarr` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3434">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3434">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3435">개체 참조(<see langword="O" /> 형식)를 계산 스택으로 푸시하여 값 형식의 새 개체나 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3435">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3436">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3437">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3437">Format</span></span>|<span data-ttu-id="cbc67-3438">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3438">Assembly Format</span></span>|<span data-ttu-id="cbc67-3439">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3440">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3440">73 < `T` ></span></span>|<span data-ttu-id="cbc67-3441">newobj</span><span class="sxs-lookup"><span data-stu-id="cbc67-3441">newobj</span></span> `ctor`|<span data-ttu-id="cbc67-3442">초기화 되지 않은 개체 또는 값 형식을 할당 하 고 constructor 메서드를 호출 `ctor`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3442">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="cbc67-3443">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3444">인수 `arg1` 를 통해 `argn` 순서로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3444">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="cbc67-3445">인수 `argn` 를 통해 `arg1` 스택에서 팝 되며 전달할 `ctor` 개체를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3445">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="cbc67-3446">새 개체에 대 한 참조를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3446">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3447">`newobj` 명령은 새 개체 또는 값 형식의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3447">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> `Ctor` <span data-ttu-id="cbc67-3448">메타 데이터 토큰 (을 `methodref` 또는 `methoddef` 생성자로 표시 되어야 합니다) 이름, 클래스 및 생성자 호출의 시그니처를 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3448">is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="cbc67-3449">합니다 `newobj` 명령에 연결 된 클래스의 새 인스턴스를 할당 `ctor` 모든 필드 (올바른 형식의)는 0 또는 null 참조로 적절 한 새 인스턴스를 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3449">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="cbc67-3450">그런 다음 생성자를 호출 `ctor` 새로 생성된 된 인스턴스와 함께 지정 된 인수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3450">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="cbc67-3451">개체 참조 초기화 된 생성자가 호출 된 후 (형식 `O`) 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3451">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3452">생성자의 관점에서 초기화 되지 않은 개체는 인수 0 및 newobj 전달 되는 다른 인수를 순서 대로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3452">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="cbc67-3453">모든 차원 배열을 사용 하 여 만들어집니다 <xref:System.Reflection.Emit.OpCodes.Newarr>이 아니라 `newobj`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3453">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="cbc67-3454">반면에 다른 모든 배열 (자세한 내용은 하나, 또는 않는 차원 하지 0부터 시작)를 사용 하 여 생성 됩니다 `newobj`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3454">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="cbc67-3455">값 형식은 일반적으로 만들어지지 않습니다를 사용 하 여 `newobj`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3455">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="cbc67-3456">인수 또는 지역 변수를 사용 하 여 일반적으로 할당 된 `newarr` (0부터 시작 하는 1 차원 배열의 경우)을 용 또는 개체의 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3456">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="cbc67-3457">할당 된 후 사용 하 여 초기화 된다고 <xref:System.Reflection.Emit.OpCodes.Initobj>합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3457">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="cbc67-3458">그러나는 `newobj` 명령에 저장 된 로컬에 인수로 전달 될 수 있는 스택의 값 형식의 새 인스턴스를 만드는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3458">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <xref:System.OutOfMemoryException> <span data-ttu-id="cbc67-3459">메모리가 부족 하 여 요청을 충족할 수 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3459">is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <xref:System.MissingMethodException> <span data-ttu-id="cbc67-3460">생성자 메서드에 throw 되 `ctor` 표시 이름을 사용 하 여 클래스 및 서명을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3460">is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="cbc67-3461">이 일반적으로 언어 MSIL (Microsoft Intermediate) 명령이 런타임이 아닌 네이티브 코드로 변환 될 때 감지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3461">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-3462">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `newobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3462">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3463">ILGenerator.Emit (OpCode, ConstructorInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3464">opcode가 패치되면 공간을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3464">Fills space if opcodes are patched.</span></span> <span data-ttu-id="cbc67-3465">처리 사이클이 사용되더라도 의미 있는 연산이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3465">No meaningful operation is performed although a processing cycle can be consumed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3466">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3466">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3467">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3467">Format</span></span>|<span data-ttu-id="cbc67-3468">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3468">Assembly Format</span></span>|<span data-ttu-id="cbc67-3469">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3469">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3470">00</span><span class="sxs-lookup"><span data-stu-id="cbc67-3470">00</span></span>|<span data-ttu-id="cbc67-3471">nop</span><span class="sxs-lookup"><span data-stu-id="cbc67-3471">nop</span></span>|<span data-ttu-id="cbc67-3472">동작 없이 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3472">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="cbc67-3473">이 명령에 대해 정의 된 스택 전환 동작이 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3473">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3474">`nop` 연산은 아무 작업도 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3474">The `nop` operation does nothing.</span></span> <span data-ttu-id="cbc67-3475">Opcode가 패치 되는 경우 공간에 맞게 것입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3475">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="cbc67-3476">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `nop` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3476">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3477">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3477">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3478">스택 맨 위에 있는 정수 값의 비트 보수를 계산하고 결과를 같은 형식으로 계산 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3478">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3479">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3479">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3480">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3480">Format</span></span>|<span data-ttu-id="cbc67-3481">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3481">Assembly Format</span></span>|<span data-ttu-id="cbc67-3482">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3482">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3483">66</span><span class="sxs-lookup"><span data-stu-id="cbc67-3483">66</span></span>|<span data-ttu-id="cbc67-3484">not</span><span class="sxs-lookup"><span data-stu-id="cbc67-3484">not</span></span>|<span data-ttu-id="cbc67-3485">값의 비트 보수를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3485">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="cbc67-3486">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3486">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value` <span data-ttu-id="cbc67-3487">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3487">is pushed onto the stack.</span></span>  
  
2.  `value` <span data-ttu-id="cbc67-3488">스택 및 해당 비트에서 제공 됩니다 보수를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3488">is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="cbc67-3489">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3489">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3490">`not` 명령 정수 값의 비트 보수를 계산 하 고 결과 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3490">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="cbc67-3491">반환 형식은 피연산자 형식과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3491">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="cbc67-3492">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `not` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3492">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3493">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3493">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3494">스택 맨 위에 있는 두 정수 값의 비트 보수를 계산하고 결과를 컴퓨팅 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3494">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3495">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3495">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3496">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3496">Format</span></span>|<span data-ttu-id="cbc67-3497">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3497">Assembly Format</span></span>|<span data-ttu-id="cbc67-3498">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3498">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3499">60</span><span class="sxs-lookup"><span data-stu-id="cbc67-3499">60</span></span>|<span data-ttu-id="cbc67-3500">또는</span><span class="sxs-lookup"><span data-stu-id="cbc67-3500">or</span></span>|<span data-ttu-id="cbc67-3501">비트를 계산 하거나 두 정수 값의 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3501">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="cbc67-3502">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3502">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-3503">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3503">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-3504">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3504">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-3505">및 `value1` 팝 되 고 스택 비트 OR를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3505">and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="cbc67-3506">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3506">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3507">`or` 명령이 결과를 스택으로 푸시하여 스택의 맨 위에 있는 두 값의 비트 OR를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3507">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 `Or` <span data-ttu-id="cbc67-3508">정수 관련 작업이입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3508">is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="cbc67-3509">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `or` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3509">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3510">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3510">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3511">현재 계산 스택 맨 위에 있는 값을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3511">Removes the value currently on top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3512">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3512">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3513">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3513">Format</span></span>|<span data-ttu-id="cbc67-3514">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3514">Assembly Format</span></span>|<span data-ttu-id="cbc67-3515">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3515">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3516">26</span><span class="sxs-lookup"><span data-stu-id="cbc67-3516">26</span></span>|<span data-ttu-id="cbc67-3517">pop</span><span class="sxs-lookup"><span data-stu-id="cbc67-3517">pop</span></span>|<span data-ttu-id="cbc67-3518">스택의 맨 위에 있는 값을 팝합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3518">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3519">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3519">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3520">맨 위에 있는 값은 스택에서 팝 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3520">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3521">`pop` 명령 스택에서 맨 위에 있는 요소를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3521">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3522">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `pop` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3522">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3523">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3523">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3524">이 명령은 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3524">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3525">이 명령은 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3525">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3526">이 명령은 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3526">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3527">이 명령은 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3527">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3528">이 명령은 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3528">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3529">이 명령은 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3529">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3530">이 명령은 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3530">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3531">이 명령은 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3531">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3532">후속 배열 주소 연산에서 런타임에 형식 검사를 수행하지 않고 가변성이 제한된 관리되는 포인터를 반환하도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3532">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3533">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 Microsoft 중간 언어 (MSIL) 어셈블리 형식으로 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3533">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3534">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3534">Format</span></span>|<span data-ttu-id="cbc67-3535">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3535">Assembly Format</span></span>|<span data-ttu-id="cbc67-3536">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3536">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3537">FE 1E</span><span class="sxs-lookup"><span data-stu-id="cbc67-3537">FE 1E</span></span>|<span data-ttu-id="cbc67-3538">읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3538">readonly.</span></span>|<span data-ttu-id="cbc67-3539">후속 배열 주소 연산에서 런타임에 형식 검사를 수행 하 고 가변성이 제한 된 관리 되는 포인터를 반환 하는지 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3539">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="cbc67-3540">이 접두사만 바로 앞 나타날 수 있습니다 합니다 `ldelema` 명령 및 특수 호출 `Address` 배열 메서드.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3540">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="cbc67-3541">후속 작업에 대 한 효과</span><span class="sxs-lookup"><span data-stu-id="cbc67-3541">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="cbc67-3542">런타임 시 형식 검사 작업도 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3542">At run time, no type check operation is performed.</span></span> <span data-ttu-id="cbc67-3543">에 대 한 암시적 형식 검사를 일반적으로 있다는 점에 주의 합니다 `ldelema` 및 `stelem` 지침 참조에 사용 될 경우 형식 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3543">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="cbc67-3544">되지 않습니다 값 클래스에 대 한 런타임 형식 검사를 따라서 `readonly` 경우 no-op 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3544">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="cbc67-3545">확인자는 가변성이 제한 된 관리 되는 포인터 주소 연산의 결과 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3545">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="cbc67-3546">포인터를 정의 하는 형식 값을 변경할 수 있는지 여부를 제어 하므로 가변성이 제한 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3546">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="cbc67-3547">공용 필드 또는 제 위치에서 값을 업데이트 하는 메서드를 노출 하는 값 클래스에 대 한 포인터는 읽기 전용 (따라서 이름 접두사입니다).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3547">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="cbc67-3548">특히 기본 형식 (예를 들어, System.Int32)를 나타내는 클래스를 노출 하지 않고 변경자 (mutator) 되므로 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3548">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="cbc67-3549">이 방식으로 제한 된 관리 되는 포인터는 다음과 같은 방식 으로만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3549">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="cbc67-3550">로 `object` 에 대 한 매개 변수를 `ldfld`, `ldflda`, `stfld`를 `call`, 또는`constrained callvirt` 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3550">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="cbc67-3551">으로 `pointer` 매개 변수를 `ldobj` 명령 또는 중 하나에 `ldind` 지침.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3551">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="cbc67-3552">로 `source` 매개 변수는 `cpobj` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3552">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3553">기타 허용 되지 않는 비롯 한 모든 작업을 `stobj`, `initobj`, 또는 `mkrefany` 작업 또는 `stind` 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3553">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="cbc67-3554">용도 `readonly` 접두사 제네릭 코드의 배열에서 요소를 인출할 때 형식 검사를 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3554">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="cbc67-3555">예를 들어 식 `arr[i].m()`, 여기서 요소는 배열 형식의 `arr` 메서드를 사용 하 여 인터페이스를 제한 된 제네릭 형식인 `m`, 다음 MSIL로 컴파일할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3555">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="cbc67-3556">없이 합니다 `readonly` 접두사를 `ldelema` 명령에서는 형식 검사를 수행 위치! 0이 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3556">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="cbc67-3557">형식 확인이 비효율적 할 뿐만 아니라 의미 체계가 올바르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3557">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="cbc67-3558">에 대 한 형식 검사 `ldelema` 너무 강 되는 정확히 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3558">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="cbc67-3559">배열 형식의 하위 클래스를 보유 하는 경우! 0 위의 코드는 형식 검사를 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3559">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="cbc67-3560">배열 요소의 주소를 가져올 때 요소 자체 대신에 대 한 핸들을 가지려면 `arr[i]` 모두에 대해 작동 값 형식과 참조 형식을 따라서에 전달할 수는 `constrained callvirt` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3560">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3561">일반적는 것은 안전 배열 참조 형식의 요소를 보유 하는 경우 런타임 검사를 건너뛰도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3561">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="cbc67-3562">안전 하 게 하려면 수정 없이 배열에는이 포인터를 통해 수 있도록 하는 데 필요한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3562">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="cbc67-3563">검증 규칙은이 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3563">The verifier rules ensure this.</span></span> <span data-ttu-id="cbc67-3564">있지 엄밀히 말해 값 형식에 대 한 읽기 전용 이지만 값 형식에 대 한 형식 안전 문제가 없습니다 하므로 인스턴스 메서드 호출의 개체로 제한 된 관리 되는 포인터를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3564">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="cbc67-3565">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `readonly` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3565">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3566">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3566">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3567">형식화된 참조에 포함된 형식 토큰을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3567">Retrieves the type token embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3568">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3568">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3569">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3569">Format</span></span>|<span data-ttu-id="cbc67-3570">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3570">Assembly Format</span></span>|<span data-ttu-id="cbc67-3571">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3571">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3572">FE 1D</span><span class="sxs-lookup"><span data-stu-id="cbc67-3572">FE 1D</span></span>|<span data-ttu-id="cbc67-3573">refanytype</span><span class="sxs-lookup"><span data-stu-id="cbc67-3573">refanytype</span></span>|<span data-ttu-id="cbc67-3574">형식화 된 참조에 저장 된 형식 토큰을 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3574">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="cbc67-3575">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3575">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3576">값 형식 참조를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3576">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3577">형식화 된 참조는 스택에서 팝 되 고 해당 형식 토큰이 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3577">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="cbc67-3578">형식 토큰으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3578">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3579">형식화 된 참조 형식 토큰 및 주소 개체 인스턴스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3579">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="cbc67-3580">`refanytype` 명령 형식화 된 참조에 포함 된 형식 토큰을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3580">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="cbc67-3581">참조 된 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 명령 만들기에 대 한 정보에 대 한 참조를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3581">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="cbc67-3582">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `refanytype` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3582">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3583">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3583">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3584">형식화된 참조에 포함된 주소(<see langword="&amp;" /> 형식)를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3584">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3585">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3585">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3586">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3586">Format</span></span>|<span data-ttu-id="cbc67-3587">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3587">Assembly Format</span></span>|<span data-ttu-id="cbc67-3588">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3588">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3589">C2 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3589">C2 < `T` ></span></span>|<span data-ttu-id="cbc67-3590">refanyval</span><span class="sxs-lookup"><span data-stu-id="cbc67-3590">refanyval</span></span> `type`|<span data-ttu-id="cbc67-3591">형식화 된 참조에 저장 된 주소의 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3591">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="cbc67-3592">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3592">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3593">값 형식 참조를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3593">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3594">형식화 된 참조는 스택에서 팝 되 고 해당 주소를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3594">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="cbc67-3595">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3595">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3596">형식화 된 참조 형식 토큰 및 주소 개체 인스턴스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3596">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="cbc67-3597">`refanyval` 명령에 포함 된 주소 검색을 형식화 된 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3597">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="cbc67-3598">스택에서 제공 하는 형식화 된 참조에 포함 된 형식으로 지정 된 형식과 일치 해야 `type` (메타 데이터 토큰는 `typedef` 또는 `typeref`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3598">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="cbc67-3599">참조 된 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 관련된 내용에 대 한 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3599">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <xref:System.InvalidCastException> <span data-ttu-id="cbc67-3600">경우 throw 되 `type` 형식 참조를 저장 된 형식에 일치 하지 않습니다 (이 경우 `type` 에 제공 되는 클래스는 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 생성 명령 있다고 형식화 된 참조).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3600">is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <xref:System.TypeLoadException> <span data-ttu-id="cbc67-3601">이 throw `type` 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3601">is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="cbc67-3602">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `refanyval` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3602">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3603">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3603">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3604">두 값을 나누어 나머지를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3604">Divides two values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3605">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3605">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3606">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3606">Format</span></span>|<span data-ttu-id="cbc67-3607">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3607">Assembly Format</span></span>|<span data-ttu-id="cbc67-3608">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3608">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3609">5D</span><span class="sxs-lookup"><span data-stu-id="cbc67-3609">5D</span></span>|<span data-ttu-id="cbc67-3610">rem</span><span class="sxs-lookup"><span data-stu-id="cbc67-3610">rem</span></span>|<span data-ttu-id="cbc67-3611">나눈 나머지를 푸시 `value1` 여 `value2` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3611">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
  
 <span data-ttu-id="cbc67-3612">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3612">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3613">`value1` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3613">A `value1` is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-3614">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3614">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-3615">및 `value1` 팝 되 고 스택 및 나머지 `value1` `div` `value2` 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3615">and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="cbc67-3616">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3616">The result is pushed onto the stack.</span></span>  
  
 `result`<span data-ttu-id="cbc67-3617"> = `value1` `rem` `value2` 다음 조건을 충족 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3617"> = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 `result`<span data-ttu-id="cbc67-3618"> = `value1` - `value2` `×` (`value1` `div` `value2\`), 및:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3618"> = `value1` - `value2` `×` (`value1` `div` `value2\`), and:</span></span>  
  
 <span data-ttu-id="cbc67-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;, 기호 (`result`) 기호 = (`value1`) 여기서 `div` 자르는 나누기 명령 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="cbc67-3620">하는 경우 `value2` 0 또는 `value1` 무한대 결과 NaN이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3620">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="cbc67-3621">하는 경우 `value2` 무한대는 결과가 `value1` (에 대 한 부정 `-infinity`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3621">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="cbc67-3622">정수 계열 작업 throw <xref:System.DivideByZeroException> 경우 `value2` 0입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3622">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="cbc67-3623">Intel 기반 플랫폼에서 확인 하는 <xref:System.OverflowException> 계산할 때 throw 됩니다 (minint `rem` -1).</span><span class="sxs-lookup"><span data-stu-id="cbc67-3623">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="cbc67-3624">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `rem` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3624">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3625">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3625">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3626">부호 없는 두 값을 나누어 나머지를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3626">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3627">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3627">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3628">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3628">Format</span></span>|<span data-ttu-id="cbc67-3629">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3629">Assembly Format</span></span>|<span data-ttu-id="cbc67-3630">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3630">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3631">5E</span><span class="sxs-lookup"><span data-stu-id="cbc67-3631">5E</span></span>|<span data-ttu-id="cbc67-3632">rem.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-3632">rem.un</span></span>|<span data-ttu-id="cbc67-3633">나눈 나머지를 부호 없는 푸시 `value1` 부호 없는 여 `value2` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3633">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3634">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3634">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-3635">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3635">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-3636">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3636">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-3637">및 `value1` 팝 되 고 스택 및 나머지 `value1` `div` `value2` 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3637">and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="cbc67-3638">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3638">The result is pushed onto the stack.</span></span>  
  
 `result`<span data-ttu-id="cbc67-3639"> = `value1` `rem.un` `value2` 다음 조건을 충족 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3639"> = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 `result`<span data-ttu-id="cbc67-3640"> = `value1` - `value2` x (`value1` `div.un` `value2\`), 및:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3640"> = `value1` - `value2` x(`value1` `div.un` `value2\`), and:</span></span>  
  
 <span data-ttu-id="cbc67-3641">0 = `result`  <  `value2`여기서 `div.un` 부호 없는 나누기 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3641">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3642">합니다 `rem.un` 명령 계산 `result` 를 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3642">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> `Rem.un` <span data-ttu-id="cbc67-3643">부호 없는 정수를 해당 인수를 처리 하는 동안 <xref:System.Reflection.Emit.OpCodes.Rem> 부호 있는 정수로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3643">treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 `Rem.un` <span data-ttu-id="cbc67-3644">부동 소수점 숫자에 지정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3644">is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="cbc67-3645">정수 계열 작업 throw <xref:System.DivideByZeroException> 경우 `value2` 0입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3645">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="cbc67-3646">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `rem.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3646">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3647">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3647">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3648">현재 메서드에서 제어를 반환하고 반환 값이 있을 경우 호출 수신자의 계산 스택에서 호출자의 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3648">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3649">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3649">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3650">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3650">Format</span></span>|<span data-ttu-id="cbc67-3651">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3651">Assembly Format</span></span>|<span data-ttu-id="cbc67-3652">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3652">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3653">2A</span><span class="sxs-lookup"><span data-stu-id="cbc67-3653">2A</span></span>|<span data-ttu-id="cbc67-3654">ret</span><span class="sxs-lookup"><span data-stu-id="cbc67-3654">ret</span></span>|<span data-ttu-id="cbc67-3655">가능한 값을 반환 하는 메서드의 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3655">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="cbc67-3656">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3656">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3657">반환 값은 호출 수신자 계산 스택에서 팝 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3657">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3658">1 단계에서 얻은 반환 값이 호출자에 게 계산 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3658">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="cbc67-3659">반환 값이 호출 수신자 계산 스택에 없는 경우 값 없음 (호출 수신자 또는 호출자가 메서드에 대 한 없는 스택 전환 동작) 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3659">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="cbc67-3660">반환 값 유형의 경우 현재 메서드가 결정 스택의 맨 위 및 현재 메서드를 호출한 메서드의 스택에 복사에서 인출할 값의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3660">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="cbc67-3661">현재 메서드에 대 한 계산 스택으로 반환 될 값을 제외 하 고 비어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3661">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="cbc67-3662">`ret` 밖으로 제어를 전송할 명령을 사용할 수는`try`, `filter`, `catch`, 또는 `finally` 블록.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3662">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="cbc67-3663">내에서 `try` 또는 `catch`를 사용 합니다 <xref:System.Reflection.Emit.OpCodes.Leave> 의 대상 사용 하 여 명령을 `ret` 모든 바깥쪽 예외 블록 외부에 있는 명령.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3663">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="cbc67-3664">때문에 합니다 `filter` 및 `finally` 올바르게 생성 된 중간 MSIL (Microsoft Language) 명령 내에서 반환 되는 메서드를 수행 하지 않습니다, 블록은 예외 처리 및 해당 코드는 포함 된 메서드가 아닌 논리적으로 `filter` 또는 `finally`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3664">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="cbc67-3665">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `ret` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3665">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3666">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3666">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3667">현재 예외를 다시 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3667">Rethrows the current exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3668">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3668">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3669">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3669">Format</span></span>|<span data-ttu-id="cbc67-3670">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3670">Assembly Format</span></span>|<span data-ttu-id="cbc67-3671">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3671">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3672">FE 1A</span><span class="sxs-lookup"><span data-stu-id="cbc67-3672">FE 1A</span></span>|<span data-ttu-id="cbc67-3673">다시 throw</span><span class="sxs-lookup"><span data-stu-id="cbc67-3673">rethrow</span></span>|<span data-ttu-id="cbc67-3674">현재 예외를 다시 throw</span><span class="sxs-lookup"><span data-stu-id="cbc67-3674">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="cbc67-3675">이 명령에 대 한 스택 전환 동작이 없습니다 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3675">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3676">합니다 `rethrow` 명령은 본문 내 에서만 허용 됩니다.는 `catch` 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3676">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="cbc67-3677">이 처리기가 발견 되었습니다는 동일한 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3677">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="cbc67-3678">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `rethrow` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3678">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3679">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3679">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3680">결과를 계산 스택으로 푸시하여 지정된 비트 수만큼 정수 값을 0에서 왼쪽으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3680">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3681">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3681">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3682">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3682">Format</span></span>|<span data-ttu-id="cbc67-3683">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3683">Assembly Format</span></span>|<span data-ttu-id="cbc67-3684">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3684">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3685">62</span><span class="sxs-lookup"><span data-stu-id="cbc67-3685">62</span></span>|<span data-ttu-id="cbc67-3686">shl</span><span class="sxs-lookup"><span data-stu-id="cbc67-3686">shl</span></span>|<span data-ttu-id="cbc67-3687">정수 (0으로 시프트) 왼쪽으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3687">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="cbc67-3688">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3688">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3689">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3689">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3690">이동할 비트 양은 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3690">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3691">이동할 비트 수와 값을 스택에서 팝 되 고 값을 지정 된 비트 수가 왼쪽 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3691">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="cbc67-3692">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3692">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3693">합니다 `shl` 명령 이동 값 (형식 `int32`, `int64` 또는 `native int`) 지정 된 비트 수 만큼 왼쪽으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3693">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="cbc67-3694">비트 수가 형식 값인 `int32` 또는 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3694">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="cbc67-3695">이동할 비트 수 (비트)의 너비는 제공 된 값 보다 크거나 이면 반환 값은 지정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3695">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 `Shl` <span data-ttu-id="cbc67-3696">각 교대조의 가장 낮은 위치에 0 비트를 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3696">inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="cbc67-3697">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `shl` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3697">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3698">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3698">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3699">결과를 계산 스택으로 푸시하여 부호 안에 있는 정수 값을 지정된 비트 수만큼 오른쪽으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3699">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3700">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3700">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3701">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3701">Format</span></span>|<span data-ttu-id="cbc67-3702">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3702">Assembly Format</span></span>|<span data-ttu-id="cbc67-3703">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3703">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3704">63</span><span class="sxs-lookup"><span data-stu-id="cbc67-3704">63</span></span>|<span data-ttu-id="cbc67-3705">shr</span><span class="sxs-lookup"><span data-stu-id="cbc67-3705">shr</span></span>|<span data-ttu-id="cbc67-3706">정수 (부호 안에서 이동) 오른쪽으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3706">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="cbc67-3707">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3707">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3708">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3708">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3709">이동할 비트 양은 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3709">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3710">이동할 비트 수와 값을 스택에서 팝 되 고 값은 비트의 지정된 된 수 만큼 오른쪽으로 시프트 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3710">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="cbc67-3711">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3711">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3712">`shr.un` 명령 이동 값 (형식 `int32`, `int64` 또는 `native int`) 지정 된 비트 수가 오른쪽으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3712">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="cbc67-3713">비트 수가 형식 값인 `int32` 또는 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3713">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="cbc67-3714">이동할 비트 수 (비트)의 너비는 제공 된 값 보다 크거나 이면 반환 값은 지정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3714">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 `Shr` <span data-ttu-id="cbc67-3715">복제의 원래 값의 부호를 보존 하는 각 교대조에에 상위 비트는 `result`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3715">replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="cbc67-3716">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `shr` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3716">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3717">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3717">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3718">결과를 계산 스택으로 푸시하여 부호 없는 정수 값을 지정된 비트 수만큼 0에서 오른쪽으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3718">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3719">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3719">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3720">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3720">Format</span></span>|<span data-ttu-id="cbc67-3721">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3721">Assembly Format</span></span>|<span data-ttu-id="cbc67-3722">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3722">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3723">64</span><span class="sxs-lookup"><span data-stu-id="cbc67-3723">64</span></span>|<span data-ttu-id="cbc67-3724">shr.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-3724">shr.un</span></span>|<span data-ttu-id="cbc67-3725">정수 (0에서 이동) 오른쪽으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3725">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="cbc67-3726">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3726">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3727">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3727">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3728">이동할 비트 양은 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3728">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3729">이동할 비트 수와 값을 스택에서 팝 되 고 값은 비트의 지정된 된 수 만큼 오른쪽으로 시프트 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3729">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="cbc67-3730">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3730">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3731">`shr.un` 명령 이동 값 (형식 `int32`, `int64` 또는 `native int`) 지정 된 비트 수가 오른쪽으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3731">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="cbc67-3732">비트 수가 형식 값인 `int32`, `int64` 또는 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3732">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="cbc67-3733">이동할 비트 수 (비트)의 너비는 제공 된 값 보다 크거나 이면 반환 값은 지정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3733">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 `Shr.un` <span data-ttu-id="cbc67-3734">각 교대조의 가장 높은 위치에 0 비트를 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3734">inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="cbc67-3735">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `shr.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3735">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3736">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3736">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3737">주어진 값 형식의 크기(바이트)를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3737">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3738">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3738">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3739">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3739">Format</span></span>|<span data-ttu-id="cbc67-3740">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3740">Assembly Format</span></span>|<span data-ttu-id="cbc67-3741">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3741">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3742">FE 1C < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3742">FE 1C < `T` ></span></span>|<span data-ttu-id="cbc67-3743">sizeof</span><span class="sxs-lookup"><span data-stu-id="cbc67-3743">sizeof</span></span> `valType`|<span data-ttu-id="cbc67-3744">크기 (바이트)는 값 형식으로 푸시를 `unsigned int32`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3744">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="cbc67-3745">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3745">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3746">제공 된 값 형식의 크기 (메가바이트) (`valType`) 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3746">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 `valType` <span data-ttu-id="cbc67-3747">메타 데이터 토큰 이어야 합니다 (한 `typeref` 또는 `typedef`) 값 형식, 참조 형식 또는 제네릭 형식 매개 변수를 지정 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3747">must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="cbc67-3748">참조 형식에 대 한 반환 되는 크기는 해당 참조 값의 크기 (32 비트 시스템에서 4 바이트)를 참조 값에서 참조 하는 개체에 저장 된 데이터의 크기가 아니라 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3748">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="cbc67-3749">제네릭 형식 매개 변수 형식 또는 메서드 정의 본문에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3749">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="cbc67-3750">해당 형식 또는 메서드를 인스턴스화할 때 제네릭 형식 매개 변수 값 형식 또는 참조 형식으로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3750">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="cbc67-3751">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `sizeof` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3751">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3752">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3752">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3753">지정된 인덱스에 있는 인수 슬롯에 계산 스택 맨 위에 있는 값을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3753">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3754">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3754">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3755">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3755">Format</span></span>|<span data-ttu-id="cbc67-3756">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3756">Assembly Format</span></span>|<span data-ttu-id="cbc67-3757">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3757">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3758">FE 0B &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3758">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="cbc67-3759">starg</span><span class="sxs-lookup"><span data-stu-id="cbc67-3759">starg</span></span> `num`|<span data-ttu-id="cbc67-3760">스택의 맨 위에 있는 값을 팝 하 고 인수 슬롯에 저장 `num`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3760">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="cbc67-3761">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3761">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3762">스택의 맨 위에 있는 현재 값이 팝 되 고 인수 슬롯에 배치 `num`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3762">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="cbc67-3763">합니다 `starg` 명령은 스택에서 값을 팝 하 고 인수 슬롯에 배치 `num`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3763">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="cbc67-3764">값의 형식을 현재 메서드의 시그니처에 지정 된 인수의 형식과 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3764">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="cbc67-3765">가변 인수 목록을 사용 하는 절차는 `starg` 명령 고정 인수 서명의 변수 부분에서 초기에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3765">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="cbc67-3766">인수는 스택에서 이동할 때 값을 잘립니다 4 바이트 보다 작은 정수 값을 포함 하는 인수는 저장소를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3766">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="cbc67-3767">부동 소수점 값은 기본 크기에서 반올림 됩니다 (형식 `F`) 크기 인수를 사용 하 여 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3767">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="cbc67-3768">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `starg` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3768">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3769">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3769">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3770">계산 스택 맨 위의 값을 약식인 지정된 인덱스의 인수 슬롯에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3770">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3771">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3771">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3772">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3772">Format</span></span>|<span data-ttu-id="cbc67-3773">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3773">Assembly Format</span></span>|<span data-ttu-id="cbc67-3774">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3774">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3775">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3775">10 < `unsigned int8` ></span></span>|<span data-ttu-id="cbc67-3776">starg.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-3776">starg.s</span></span> `num`|<span data-ttu-id="cbc67-3777">스택의 맨 위에 있는 값을 팝 하 고 인수 슬롯에 저장 `num`, 약식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3777">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-3778">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3778">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3779">스택의 맨 위에 있는 현재 값이 팝 되 고 인수 슬롯에 배치 `num`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3779">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="cbc67-3780">합니다 `starg.s` 명령은 스택에서 값을 팝 하 고 인수 슬롯에 배치 `num`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3780">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="cbc67-3781">값의 형식을 현재 메서드의 시그니처에 지정 된 인수의 형식과 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3781">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="cbc67-3782">`starg.s` 명령은 제공 처음 256 인수에 사용할 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3782">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="cbc67-3783">가변 인수 목록을 사용 하는 절차는 `starg.s` 명령 고정 인수 서명의 변수 부분에서 초기에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3783">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="cbc67-3784">인수는 스택에서 이동할 때 값을 잘립니다 4 바이트 보다 작은 정수 값을 포함 하는 인수는 저장소를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3784">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="cbc67-3785">부동 소수점 값은 기본 크기에서 반올림 됩니다 (형식 `F`) 크기 인수를 사용 하 여 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3785">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="cbc67-3786">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `starg.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3786">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3787">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3787">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3788">지정된 인덱스에 있는 배열 요소를 명령에 지정된 형식을 갖는 계산 스택의 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3788">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3789">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 Microsoft 중간 언어 (MSIL) 어셈블리 형식으로 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3789">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3790">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3790">Format</span></span>|<span data-ttu-id="cbc67-3791">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3791">Assembly Format</span></span>|<span data-ttu-id="cbc67-3792">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3792">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3793">A4 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3793">A4 < `T` ></span></span>|<span data-ttu-id="cbc67-3794">stelem</span><span class="sxs-lookup"><span data-stu-id="cbc67-3794">stelem</span></span> `typeTok`|<span data-ttu-id="cbc67-3795">지정된 된 인덱스에 있는 배열 요소 형식의 값을 사용 하 여 대체 `typeTok` 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3795">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3796">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3796">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3797">배열에 대 한 개체 참조 `array`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3797">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3798">인덱스 값을 `index`에 있는 요소를 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3798">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3799">명령에 지정 된 형식의 값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3799">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-3800">스택에서 팝 되 고 값, 인덱스 및 배열 참조 값은 지정된 된 인덱스에 있는 배열 요소에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3800">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="cbc67-3801">합니다 `stelem` 명령의 제공 된 인덱스는 1 차원 배열의 요소 값을 바꿉니다 `array` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3801">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="cbc67-3802">값이 토큰에 의해 지정 된 형식의 `typeTok` 명령에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3802">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="cbc67-3803">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3803">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3804">인덱스 형식이 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3804">The index is type `native int`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3805">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3805">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-3806">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3806">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-3807">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3807">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="cbc67-3808">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stelem` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3808">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3809">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3809">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3810">주어진 인덱스에 있는 배열 요소를 계산 스택에 있는 <see langword="native int" /> 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3810">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3811">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3811">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3812">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3812">Format</span></span>|<span data-ttu-id="cbc67-3813">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3813">Assembly Format</span></span>|<span data-ttu-id="cbc67-3814">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3814">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3815">9B</span><span class="sxs-lookup"><span data-stu-id="cbc67-3815">9B</span></span>|<span data-ttu-id="cbc67-3816">stelem.i</span><span class="sxs-lookup"><span data-stu-id="cbc67-3816">stelem.i</span></span>|<span data-ttu-id="cbc67-3817">사용 하 여 지정된 된 인덱스에 있는 배열 요소는 `native int` 스택의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3817">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3818">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3818">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3819">배열에 대 한 개체 참조 `array`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3819">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3820">요소에 유효한 인덱스가 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3820">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3821">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3821">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-3822">스택에서 팝 되 고 값, 인덱스 및 배열 참조 값은 지정된 된 인덱스에 있는 배열 요소에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3822">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="cbc67-3823">`stelem.i` 명령 요소 값을 바꿉니다 `index` 1 차원 배열에서 `array` 사용 하 여는 `native int` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3823">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3824">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3824">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3825">인덱스 형식이 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3825">The index is type `native int`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3826">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3826">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-3827">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3827">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-3828">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3828">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="cbc67-3829">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stelem.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3829">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3830">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3830">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3831">주어진 인덱스에 있는 배열 요소를 계산 스택에 있는 <see langword="int8" /> 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3831">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3832">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3832">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3833">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3833">Format</span></span>|<span data-ttu-id="cbc67-3834">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3834">Assembly Format</span></span>|<span data-ttu-id="cbc67-3835">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3835">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3836">9C</span><span class="sxs-lookup"><span data-stu-id="cbc67-3836">9C</span></span>|<span data-ttu-id="cbc67-3837">stelem.i1</span><span class="sxs-lookup"><span data-stu-id="cbc67-3837">stelem.i1</span></span>|<span data-ttu-id="cbc67-3838">사용 하 여 지정된 된 인덱스에 있는 배열 요소는 `int8` 스택의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3838">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3839">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3839">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3840">배열에 대 한 개체 참조 `array`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3840">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3841">요소에 유효한 인덱스가 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3841">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3842">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3842">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-3843">스택에서 팝 되 고 값, 인덱스 및 배열 참조 값은 지정된 된 인덱스에 있는 배열 요소에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3843">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="cbc67-3844">`stelem.i1` 명령 요소 값을 바꿉니다 `index` 1 차원 배열에서 `array` 사용 하 여는 `int8` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3844">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3845">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3845">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3846">인덱스 형식이 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3846">The index is type `native int`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3847">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3847">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-3848">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3848">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-3849">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3849">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="cbc67-3850">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stelem.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3850">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3851">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3851">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3852">주어진 인덱스에 있는 배열 요소를 계산 스택에 있는 <see langword="int16" /> 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3852">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3853">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3853">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3854">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3854">Format</span></span>|<span data-ttu-id="cbc67-3855">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3855">Assembly Format</span></span>|<span data-ttu-id="cbc67-3856">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3856">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3857">9D</span><span class="sxs-lookup"><span data-stu-id="cbc67-3857">9D</span></span>|<span data-ttu-id="cbc67-3858">stelem.i2</span><span class="sxs-lookup"><span data-stu-id="cbc67-3858">stelem.i2</span></span>|<span data-ttu-id="cbc67-3859">사용 하 여 지정된 된 인덱스에 있는 배열 요소는 `int16` 스택의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3859">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3860">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3860">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3861">배열에 대 한 개체 참조 `array`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3861">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3862">요소에 유효한 인덱스가 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3862">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3863">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3863">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-3864">스택에서 팝 되 고 값, 인덱스 및 배열 참조 값은 지정된 된 인덱스에 있는 배열 요소에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3864">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="cbc67-3865">`stelem.i2` 명령 요소 값을 바꿉니다 `index` 1 차원 배열에서 `array` 사용 하 여는 `int16` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3865">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3866">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3866">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3867">인덱스 형식이 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3867">The index is type `native int`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3868">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3868">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-3869">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3869">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-3870">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3870">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="cbc67-3871">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stelem.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3871">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3872">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3872">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3873">주어진 인덱스에 있는 배열 요소를 계산 스택에 있는 <see langword="int32" /> 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3873">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3874">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3874">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3875">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3875">Format</span></span>|<span data-ttu-id="cbc67-3876">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3876">Assembly Format</span></span>|<span data-ttu-id="cbc67-3877">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3877">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3878">9E</span><span class="sxs-lookup"><span data-stu-id="cbc67-3878">9E</span></span>|<span data-ttu-id="cbc67-3879">stelem.i4</span><span class="sxs-lookup"><span data-stu-id="cbc67-3879">stelem.i4</span></span>|<span data-ttu-id="cbc67-3880">사용 하 여 지정된 된 인덱스에 있는 배열 요소는 `int32` 스택의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3880">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3881">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3881">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3882">배열에 대 한 개체 참조 `array`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3882">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3883">요소에 유효한 인덱스가 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3883">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3884">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3884">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-3885">스택에서 팝 되 고 값, 인덱스 및 배열 참조 값은 지정된 된 인덱스에 있는 배열 요소에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3885">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="cbc67-3886">`stelem.i4` 명령 요소 값을 바꿉니다 `index` 1 차원 배열에서 `array` 사용 하 여는 `int32` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3886">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3887">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3887">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3888">인덱스 형식이 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3888">The index is type `native int`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3889">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3889">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-3890">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3890">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-3891">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3891">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="cbc67-3892">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stelem.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3892">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3893">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3893">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3894">주어진 인덱스에 있는 배열 요소를 계산 스택에 있는 <see langword="int64" /> 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3894">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3895">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3895">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3896">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3896">Format</span></span>|<span data-ttu-id="cbc67-3897">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3897">Assembly Format</span></span>|<span data-ttu-id="cbc67-3898">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3898">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3899">9F</span><span class="sxs-lookup"><span data-stu-id="cbc67-3899">9F</span></span>|<span data-ttu-id="cbc67-3900">stelem.i8</span><span class="sxs-lookup"><span data-stu-id="cbc67-3900">stelem.i8</span></span>|<span data-ttu-id="cbc67-3901">사용 하 여 지정된 된 인덱스에 있는 배열 요소는 `int64` 스택의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3901">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3902">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3902">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3903">배열에 대 한 개체 참조 `array`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3903">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3904">요소에 유효한 인덱스가 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3904">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3905">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3905">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-3906">스택에서 팝 되 고 값, 인덱스 및 배열 참조 값은 지정된 된 인덱스에 있는 배열 요소에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3906">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="cbc67-3907">`stelem.i8` 명령 요소 값을 바꿉니다 `index` 1 차원 배열에서 `array` 사용 하 여는 `int64` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3907">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3908">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3908">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3909">인덱스 형식이 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3909">The index is type `native int`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3910">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3910">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-3911">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3911">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-3912">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3912">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="cbc67-3913">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stelem.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3915">주어진 인덱스에 있는 배열 요소를 계산 스택에 있는 <see langword="float32" /> 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3915">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3916">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3917">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3917">Format</span></span>|<span data-ttu-id="cbc67-3918">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3918">Assembly Format</span></span>|<span data-ttu-id="cbc67-3919">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3920">A0</span><span class="sxs-lookup"><span data-stu-id="cbc67-3920">A0</span></span>|<span data-ttu-id="cbc67-3921">stelem.r4</span><span class="sxs-lookup"><span data-stu-id="cbc67-3921">stelem.r4</span></span>|<span data-ttu-id="cbc67-3922">사용 하 여 지정된 된 인덱스에 있는 배열 요소는 `float32` 스택의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3922">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3923">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3924">배열에 대 한 개체 참조 `array`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3924">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3925">요소에 유효한 인덱스가 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3925">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3926">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3926">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-3927">스택에서 팝 되 고 값, 인덱스 및 배열 참조 값은 지정된 된 인덱스에 있는 배열 요소에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3927">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="cbc67-3928">`stelem.r4` 명령 요소 값을 바꿉니다 `index` 1 차원 배열에서 `array` 사용 하 여는 `float32` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3928">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3929">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3929">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3930">인덱스 형식이 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3930">The index is type `native int`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3931">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3931">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-3932">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3932">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-3933">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3933">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="cbc67-3934">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stelem.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3934">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3935">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3935">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3936">주어진 인덱스에 있는 배열 요소를 계산 스택에 있는 <see langword="float64" /> 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3936">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3937">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3937">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3938">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3938">Format</span></span>|<span data-ttu-id="cbc67-3939">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3939">Assembly Format</span></span>|<span data-ttu-id="cbc67-3940">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3940">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3941">A1</span><span class="sxs-lookup"><span data-stu-id="cbc67-3941">A1</span></span>|<span data-ttu-id="cbc67-3942">stelem.r8</span><span class="sxs-lookup"><span data-stu-id="cbc67-3942">stelem.r8</span></span>|<span data-ttu-id="cbc67-3943">사용 하 여 지정된 된 인덱스에 있는 배열 요소는 `float64` 스택의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3943">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3944">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3944">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3945">배열에 대 한 개체 참조 `array`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3945">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3946">요소에 유효한 인덱스가 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3946">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3947">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3947">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-3948">스택에서 팝 되 고 값, 인덱스 및 배열 참조 값은 지정된 된 인덱스에 있는 배열 요소에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3948">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="cbc67-3949">`stelem.r8` 명령 요소 값을 바꿉니다 `index` 1 차원 배열에서 `array` 사용 하 여는 `float64` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3949">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3950">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3950">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3951">인덱스 형식이 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3951">The index is type `native int`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3952">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3952">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-3953">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3953">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-3954">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3954">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="cbc67-3955">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stelem.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3955">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3956">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3956">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3957">주어진 인덱스에 있는 배열 요소를 계산 스택에 있는 개체 참조 값(<see langword="O" /> 형식)으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3957">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3958">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3958">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3959">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3959">Format</span></span>|<span data-ttu-id="cbc67-3960">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3960">Assembly Format</span></span>|<span data-ttu-id="cbc67-3961">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3961">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3962">A2</span><span class="sxs-lookup"><span data-stu-id="cbc67-3962">A2</span></span>|<span data-ttu-id="cbc67-3963">stelem.ref</span><span class="sxs-lookup"><span data-stu-id="cbc67-3963">stelem.ref</span></span>|<span data-ttu-id="cbc67-3964">사용 하 여 지정된 된 인덱스에 있는 배열 요소를 `ref` 값 (형식 `O`) 스택에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3964">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="cbc67-3965">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3965">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3966">배열에 대 한 개체 참조 `array`를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3966">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3967">요소에 유효한 인덱스가 `array` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3967">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3968">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3968">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="cbc67-3969">스택에서 팝 되 고 값, 인덱스 및 배열 참조 값은 지정된 된 인덱스에 있는 배열 요소에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3969">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="cbc67-3970">`stelem.ref` 명령 1 차원 배열에 지정된 된 인덱스에 요소 값을 바꿉니다 `array` 사용 하 여 합니다 `ref` (형식 `O`) 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3970">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-3971">배열 개체 및 형식의 값으로 표현 되므로 `O`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3971">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="cbc67-3972">인덱스 형식이 `native int`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3972">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="cbc67-3973">사실은 `stelem.ref` 제공된 된 값의 요소 형식으로 암시적으로 캐스팅 `array` 배열 요소에 값을 할당 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3973">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="cbc67-3974">이 캐스트 확인 된 코드에 대해서도 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3974">This cast can fail, even for verified code.</span></span> <span data-ttu-id="cbc67-3975">따라서 합니다 `stelem.ref` 명령에서 throw 할 수 있습니다 <xref:System.InvalidCastException>합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3975">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="cbc67-3976">0부터 시작 하지는 1 차원 배열이 나 다차원 배열에는 <xref:System.Array> 클래스를 제공는 <xref:System.Array.SetValue%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3976">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3977">이 throw `array` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3977">is thrown if `array` is a null reference.</span></span>  
  
 <xref:System.IndexOutOfRangeException> <span data-ttu-id="cbc67-3978">이 throw `index` 가 음수 이거나의 범위 보다 더 큰 `array`입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3978">is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <xref:System.ArrayTypeMismatchException> <span data-ttu-id="cbc67-3979">이 throw `array` 필요한 형식의 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3979">is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="cbc67-3980">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stelem.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3980">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-3981">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-3981">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-3982">개체 참조나 포인터의 필드에 저장된 값을 새 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3982">Replaces the value stored in the field of an object reference or pointer with a new value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-3983">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-3983">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-3984">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3984">Format</span></span>|<span data-ttu-id="cbc67-3985">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-3985">Assembly Format</span></span>|<span data-ttu-id="cbc67-3986">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-3986">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-3987">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-3987">7D < `T` ></span></span>|<span data-ttu-id="cbc67-3988">stfld</span><span class="sxs-lookup"><span data-stu-id="cbc67-3988">stfld</span></span> `field`|<span data-ttu-id="cbc67-3989">값을 바꿉니다 `field` 새 값을 가진 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3989">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="cbc67-3990">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3990">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-3991">개체 참조 또는 포인터를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3991">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-3992">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3992">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-3993">값 및 개체 참조 포인터가 스택에서 팝 되 고 변수의 `field` 개체에 제공 된 값으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3993">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="cbc67-3994">합니다 `stfld` 명령 개체의 필드 값을 바꿉니다 (형식 `O`) 또는 포인터를 통해 (형식 `native int`를 `&`, 또는 `*`) 지정된 된 값으로.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3994">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> `Field` <span data-ttu-id="cbc67-3995">참조 필드 멤버를 참조 하는 메타 데이터 토큰이입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3995">is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="cbc67-3996">합니다 `stfld` 명령 중 하나 또는 모두의 접두사를 가질 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Unaligned> 고 <xref:System.Reflection.Emit.OpCodes.Volatile>입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3996">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-3997">개체 참조 또는 포인터는 null 참조 및 정적 필드가 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3997">is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <xref:System.MissingFieldException> <span data-ttu-id="cbc67-3998">이 throw `field` 메타 데이터에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3998">is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="cbc67-3999">이 값은 Microsoft MSIL (Intermediate Language) 명령으로 런타임 시가 아니라 네이티브 코드로 변환할 때 일반적으로 검사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-3999">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-4000">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4000">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4001">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4001">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4002">주어진 주소에 <see langword="native int" /> 형식의 값을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4002">Stores a value of type <see langword="native int" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4003">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4003">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4004">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4004">Format</span></span>|<span data-ttu-id="cbc67-4005">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4005">Assembly Format</span></span>|<span data-ttu-id="cbc67-4006">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4006">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4007">DF</span><span class="sxs-lookup"><span data-stu-id="cbc67-4007">DF</span></span>|<span data-ttu-id="cbc67-4008">stind.i</span><span class="sxs-lookup"><span data-stu-id="cbc67-4008">stind.i</span></span>|<span data-ttu-id="cbc67-4009">저장소는 `native int` 주어진된 주소에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4009">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="cbc67-4010">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4010">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4011">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4011">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4012">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4012">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-4013">스택에서 팝 되 고 값 및 주소 값 주소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4013">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="cbc67-4014">합니다 `stind.i` 명령 저장소를 `native int` 주어진된 주소에 대 한 값 (형식 `native int`, `*`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4014">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="cbc67-4015">형식 안전 하 게 작업 해야 합니다 `stind.i` 명령 포인터의 형식을 사용 하 여 일관 된 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4015">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="cbc67-4016">작업은 `stind.i` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4016">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4017">이 throw `addr` 명령 접미사 사용 권한에 포함 된 인수 형식에 대 한 자연스럽 게 정렬 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4017">is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="cbc67-4018">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stind.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4019">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4019">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4020">주어진 주소에 <see langword="int8" /> 형식의 값을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4020">Stores a value of type <see langword="int8" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4021">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4022">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4022">Format</span></span>|<span data-ttu-id="cbc67-4023">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4023">Assembly Format</span></span>|<span data-ttu-id="cbc67-4024">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4025">52</span><span class="sxs-lookup"><span data-stu-id="cbc67-4025">52</span></span>|<span data-ttu-id="cbc67-4026">stind.i1</span><span class="sxs-lookup"><span data-stu-id="cbc67-4026">stind.i1</span></span>|<span data-ttu-id="cbc67-4027">저장소는 `int8` 주어진된 주소에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4027">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="cbc67-4028">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4029">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4029">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4030">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4030">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-4031">스택에서 팝 되 고 값 및 주소 값 주소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4031">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="cbc67-4032">합니다 `stind.i1` 명령 저장소는 `int8` 주어진된 주소에 대 한 값 (형식 `native int`, `*`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4032">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="cbc67-4033">형식 안전 하 게 작업 해야 합니다 `stind.i1` 명령 포인터의 형식을 사용 하 여 일관 된 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4033">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="cbc67-4034">작업은 `stind.i1` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4034">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4035">이 throw `addr` 명령 접미사 사용 권한에 포함 된 인수 형식에 대 한 자연스럽 게 정렬 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4035">is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="cbc67-4036">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stind.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4037">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4037">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4038">주어진 주소에 <see langword="int16" /> 형식의 값을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4038">Stores a value of type <see langword="int16" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4039">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4040">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4040">Format</span></span>|<span data-ttu-id="cbc67-4041">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4041">Assembly Format</span></span>|<span data-ttu-id="cbc67-4042">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4043">53</span><span class="sxs-lookup"><span data-stu-id="cbc67-4043">53</span></span>|<span data-ttu-id="cbc67-4044">stind.i2</span><span class="sxs-lookup"><span data-stu-id="cbc67-4044">stind.i2</span></span>|<span data-ttu-id="cbc67-4045">저장소는 `int16` 주어진된 주소에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4045">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="cbc67-4046">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4047">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4047">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4048">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4048">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-4049">스택에서 팝 되 고 값 및 주소 값 주소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4049">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="cbc67-4050">합니다 `stind.i2` 명령 저장소는 `int16` 주어진된 주소에 대 한 값 (형식 `native int`, `*`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4050">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="cbc67-4051">형식 안전 하 게 작업 해야 합니다 `stind.2i` 명령 포인터의 형식을 사용 하 여 일관 된 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4051">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="cbc67-4052">작업은 `stind.i2` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4052">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4053">이 throw `addr` 명령 접미사 사용 권한에 포함 된 인수 형식에 대 한 자연스럽 게 정렬 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4053">is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="cbc67-4054">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stind.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4055">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4056">주어진 주소에 <see langword="int32" /> 형식의 값을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4056">Stores a value of type <see langword="int32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4057">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4058">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4058">Format</span></span>|<span data-ttu-id="cbc67-4059">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4059">Assembly Format</span></span>|<span data-ttu-id="cbc67-4060">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4061">54</span><span class="sxs-lookup"><span data-stu-id="cbc67-4061">54</span></span>|<span data-ttu-id="cbc67-4062">stind.i4</span><span class="sxs-lookup"><span data-stu-id="cbc67-4062">stind.i4</span></span>|<span data-ttu-id="cbc67-4063">저장소는 `int32` 주어진된 주소에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4063">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="cbc67-4064">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4065">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4065">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4066">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4066">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-4067">스택에서 팝 되 고 값 및 주소 값 주소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4067">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="cbc67-4068">합니다 `stind.i4` 명령 저장소는 `int32` 주어진된 주소에 대 한 값 (형식 `native int`, `*`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4068">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="cbc67-4069">형식 안전 하 게 작업 해야 합니다 `stind.i4` 명령 포인터의 형식을 사용 하 여 일관 된 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4069">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="cbc67-4070">작업은 `stind.i4` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4070">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4071">이 throw `addr` 명령 접미사 사용 권한에 포함 된 인수 형식에 대 한 자연스럽 게 정렬 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4071">is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="cbc67-4072">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stind.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4074">주어진 주소에 <see langword="int64" /> 형식의 값을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4074">Stores a value of type <see langword="int64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4075">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4076">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4076">Format</span></span>|<span data-ttu-id="cbc67-4077">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4077">Assembly Format</span></span>|<span data-ttu-id="cbc67-4078">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4079">55</span><span class="sxs-lookup"><span data-stu-id="cbc67-4079">55</span></span>|<span data-ttu-id="cbc67-4080">stind.i8</span><span class="sxs-lookup"><span data-stu-id="cbc67-4080">stind.i8</span></span>|<span data-ttu-id="cbc67-4081">저장소는 `int64` 주어진된 주소에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4081">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="cbc67-4082">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4083">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4083">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4084">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4084">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-4085">스택에서 팝 되 고 값 및 주소 값 주소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4085">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="cbc67-4086">합니다 `stind.i8` 명령 저장소는 `int64` 주어진된 주소에 대 한 값 (형식 `native int`, `*`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4086">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="cbc67-4087">형식 안전 하 게 작업 해야 합니다 `stind.i8` 명령 포인터의 형식을 사용 하 여 일관 된 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4087">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="cbc67-4088">작업은 `stind.i` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4088">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4089">이 throw `addr` 명령 접미사 사용 권한에 포함 된 인수 형식에 대 한 자연스럽 게 정렬 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4089">is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="cbc67-4090">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stind.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4091">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4092">주어진 주소에 <see langword="float32" /> 형식의 값을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4092">Stores a value of type <see langword="float32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4093">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4094">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4094">Format</span></span>|<span data-ttu-id="cbc67-4095">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4095">Assembly Format</span></span>|<span data-ttu-id="cbc67-4096">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4097">56</span><span class="sxs-lookup"><span data-stu-id="cbc67-4097">56</span></span>|<span data-ttu-id="cbc67-4098">stind.r4</span><span class="sxs-lookup"><span data-stu-id="cbc67-4098">stind.r4</span></span>|<span data-ttu-id="cbc67-4099">저장소는 `float32` 주어진된 주소에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4099">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="cbc67-4100">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4101">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4101">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4102">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4102">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-4103">스택에서 팝 되 고 값 및 주소 값 주소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4103">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="cbc67-4104">합니다 `stind.r4` 명령 저장소를 `float32` 주어진된 주소에 대 한 값 (형식 `native int`, `*`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4104">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="cbc67-4105">형식 안전 하 게 작업 해야 합니다 `stind.r4` 명령 포인터의 형식을 사용 하 여 일관 된 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4105">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="cbc67-4106">작업은 `stind.r4` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4106">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4107">이 throw `addr` 명령 접미사 사용 권한에 포함 된 인수 형식에 대 한 자연스럽 게 정렬 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4107">is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="cbc67-4108">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stind.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4109">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4110">주어진 주소에 <see langword="float64" /> 형식의 값을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4110">Stores a value of type <see langword="float64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4111">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4112">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4112">Format</span></span>|<span data-ttu-id="cbc67-4113">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4113">Assembly Format</span></span>|<span data-ttu-id="cbc67-4114">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4115">57</span><span class="sxs-lookup"><span data-stu-id="cbc67-4115">57</span></span>|<span data-ttu-id="cbc67-4116">stind.r8</span><span class="sxs-lookup"><span data-stu-id="cbc67-4116">stind.r8</span></span>|<span data-ttu-id="cbc67-4117">저장소는 `float64` 주어진된 주소에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4117">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="cbc67-4118">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4119">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4119">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4120">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4120">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-4121">스택에서 팝 되 고 값 및 주소 값 주소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4121">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="cbc67-4122">합니다 `stind.r8` 명령 저장소를 `float64` 주어진된 주소에 대 한 값 (형식 `native int`, `*`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4122">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="cbc67-4123">형식 안전 하 게 작업 해야 합니다 `stind.r8` 명령 포인터의 형식을 사용 하 여 일관 된 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4123">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="cbc67-4124">작업은 `stind.r8` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4124">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4125">이 throw `addr` 명령 접미사 사용 권한에 포함 된 인수 형식에 대 한 자연스럽 게 정렬 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4125">is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="cbc67-4126">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stind.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4127">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4127">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4128">주어진 주소에 개체 참조 값을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4128">Stores a object reference value at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4129">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4130">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4130">Format</span></span>|<span data-ttu-id="cbc67-4131">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4131">Assembly Format</span></span>|<span data-ttu-id="cbc67-4132">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4133">51</span><span class="sxs-lookup"><span data-stu-id="cbc67-4133">51</span></span>|<span data-ttu-id="cbc67-4134">stind.ref</span><span class="sxs-lookup"><span data-stu-id="cbc67-4134">stind.ref</span></span>|<span data-ttu-id="cbc67-4135">개체 참조를 저장 (형식 `O`) 주어진된 주소에는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4135">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="cbc67-4136">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4137">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4137">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4138">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4138">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-4139">스택에서 팝 되 고 값 및 주소 값 주소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4139">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="cbc67-4140">합니다 `stind.ref` 주어진된 주소에 개체 참조 값을 저장 하는 명령 (형식 `native int`를 `*`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4140">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="cbc67-4141">형식 안전 하 게 작업 해야 합니다 `stind.ref` 명령 포인터의 형식을 사용 하 여 일관 된 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4141">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="cbc67-4142">작업은 `stind.ref` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4142">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4143">이 throw `addr` 명령 접미사 사용 권한에 포함 된 인수 형식에 대 한 자연스럽 게 정렬 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4143">is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="cbc67-4144">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stind.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4145">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4145">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4146">계산 스택 맨 위에서 현재 값을 팝하고 지정된 인덱스에 있는 지역 변수 목록에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4146">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4147">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4148">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4148">Format</span></span>|<span data-ttu-id="cbc67-4149">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4149">Assembly Format</span></span>|<span data-ttu-id="cbc67-4150">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4151">FE 0E &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-4151">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="cbc67-4152">stloc</span><span class="sxs-lookup"><span data-stu-id="cbc67-4152">stloc</span></span> `index`|<span data-ttu-id="cbc67-4153">스택에서 값을 팝 하 고 로컬 변수에 저장 `index`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4153">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="cbc67-4154">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4155">값이 스택에서 팝 되 고 로컬 변수에 배치 `index`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4155">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="cbc67-4156">`stloc` 명령 계산 스택에서 상위 값을 팝 하 고 로컬 변수 수로 이동 `index`있는 지역 변수는 번호가 매겨진된 0 이상입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4156">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="cbc67-4157">값의 형식에는 현재 메서드의 로컬 시그니처에 지정 된 로컬 변수의 형식이 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4157">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="cbc67-4158">4 바이트 보다 작은 정수 값을 포함 하는 지역에 저장 지역 변수가 스택에서 이동할 때 값을 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4158">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="cbc67-4159">부동 소수점 값은 기본 크기에서 반올림 됩니다 (형식 `F`) 크기 인수를 사용 하 여 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4159">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="cbc67-4160">올바른 언어 MSIL (Microsoft Intermediate) 지침에서는 `index` 유효한 로컬 인덱스 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4160">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="cbc67-4161">에 대 한 합니다 `stloc` 명령, `index` 포괄 0 ~ 65534 범위 내에서에 있어야 합니다 (특히 65535 잘못 되었습니다.).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4161">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="cbc67-4162">65535 제외는 pragmatic: 구현 하는 2 바이트 정수를 사용 하 여으로 지역 변수의 인덱스를 지정된 된 메서드에 대 한 지역의 총 수를 추적 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4162">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="cbc67-4163">인덱스 65535 되었습니다가 유효한 경우 하는 경우 이러한 메서드의 지역 변수 개수를 추적 하는 광범위 한 정수를 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4163">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="cbc67-4164">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stloc` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4164">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4165">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4165">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="cbc67-4166">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4166">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4167">계산 스택 맨 위에서 현재 값을 팝하여 인덱스 0에 있는 지역 변수 목록에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4167">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4168">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4168">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4169">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4169">Format</span></span>|<span data-ttu-id="cbc67-4170">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4170">Assembly Format</span></span>|<span data-ttu-id="cbc67-4171">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4171">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4172">0A</span><span class="sxs-lookup"><span data-stu-id="cbc67-4172">0A</span></span>|<span data-ttu-id="cbc67-4173">stloc.0</span><span class="sxs-lookup"><span data-stu-id="cbc67-4173">stloc.0</span></span>|<span data-ttu-id="cbc67-4174">0 지역 변수로 스택에서 값을 팝합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4174">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="cbc67-4175">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4175">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4176">값이 스택에서 팝 되 고 0으로 인덱싱된 로컬 변수에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4176">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="cbc67-4177">`stloc.0` 명령 계산 스택에서 상위 값을 팝 하 고 0으로 인덱싱된 로컬 변수로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4177">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="cbc67-4178">값의 형식에는 현재 메서드의 로컬 시그니처에 지정 된 로컬 변수의 형식이 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4178">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 `stloc.0` <span data-ttu-id="cbc67-4179">로컬 변수 0에에서 값을 저장 하기 위한 효과적인 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4179">is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="cbc67-4180">4 바이트 보다 작은 정수 값을 포함 하는 지역에 저장 지역 변수가 스택에서 이동할 때 값을 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4180">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="cbc67-4181">부동 소수점 값은 기본 크기에서 반올림 됩니다 (형식 `F`) 크기 인수를 사용 하 여 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4181">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="cbc67-4182">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stloc.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4182">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4183">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4183">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4184">계산 스택 맨 위에서 현재 값을 팝하여 인덱스 1에 있는 지역 변수 목록에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4184">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4185">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4185">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4186">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4186">Format</span></span>|<span data-ttu-id="cbc67-4187">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4187">Assembly Format</span></span>|<span data-ttu-id="cbc67-4188">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4188">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4189">0B</span><span class="sxs-lookup"><span data-stu-id="cbc67-4189">0B</span></span>|<span data-ttu-id="cbc67-4190">stloc.1</span><span class="sxs-lookup"><span data-stu-id="cbc67-4190">stloc.1</span></span>|<span data-ttu-id="cbc67-4191">지역 변수 1로 스택에서 값을 팝합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4191">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="cbc67-4192">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4192">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4193">값이 스택에서 팝 되 고 1로 인덱싱된 로컬 변수에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4193">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="cbc67-4194">`stloc.1` 최고 값을 계산 스택에서 명령과 1만 인덱싱된 로컬 변수로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4194">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="cbc67-4195">값의 형식에는 현재 메서드의 로컬 시그니처에 지정 된 로컬 변수의 형식이 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4195">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 `stloc.1` <span data-ttu-id="cbc67-4196">로컬 변수 1에에서 값을 저장 하기 위한 효과적인 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4196">is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="cbc67-4197">4 바이트 보다 작은 정수 값을 포함 하는 지역에 저장 지역 변수가 스택에서 이동할 때 값을 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4197">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="cbc67-4198">부동 소수점 값은 기본 크기에서 반올림 됩니다 (형식 `F`) 크기 인수를 사용 하 여 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4198">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="cbc67-4199">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stloc.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4199">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4200">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4200">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4201">계산 스택 맨 위에서 현재 값을 팝하여 인덱스 2에 있는 지역 변수 목록에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4201">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4202">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4202">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4203">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4203">Format</span></span>|<span data-ttu-id="cbc67-4204">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4204">Assembly Format</span></span>|<span data-ttu-id="cbc67-4205">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4205">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4206">0C</span><span class="sxs-lookup"><span data-stu-id="cbc67-4206">0C</span></span>|<span data-ttu-id="cbc67-4207">stloc.2</span><span class="sxs-lookup"><span data-stu-id="cbc67-4207">stloc.2</span></span>|<span data-ttu-id="cbc67-4208">지역 변수 2로 스택에서 값을 팝합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4208">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="cbc67-4209">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4209">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4210">값이 스택에서 팝 되 고 2로 인덱싱된 로컬 변수에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4210">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="cbc67-4211">`stloc.2` 지침 최고 값을 계산 스택 및 2에 의해 인덱싱된 로컬 변수로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4211">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="cbc67-4212">값의 형식에는 현재 메서드의 로컬 시그니처에 지정 된 로컬 변수의 형식이 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4212">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 `stloc.2` <span data-ttu-id="cbc67-4213">로컬 변수 2에에서 값을 저장 하기 위한 효과적인 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4213">is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="cbc67-4214">4 바이트 보다 작은 정수 값을 포함 하는 지역에 저장 지역 변수가 스택에서 이동할 때 값을 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4214">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="cbc67-4215">부동 소수점 값은 기본 크기에서 반올림 됩니다 (형식 `F`) 크기 인수를 사용 하 여 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4215">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="cbc67-4216">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stloc.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4216">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4217">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4217">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4218">계산 스택 맨 위에서 현재 값을 팝하여 인덱스 3에 있는 지역 변수 목록에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4218">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4219">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4219">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4220">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4220">Format</span></span>|<span data-ttu-id="cbc67-4221">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4221">Assembly Format</span></span>|<span data-ttu-id="cbc67-4222">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4222">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4223">0D</span><span class="sxs-lookup"><span data-stu-id="cbc67-4223">0D</span></span>|<span data-ttu-id="cbc67-4224">stloc.3</span><span class="sxs-lookup"><span data-stu-id="cbc67-4224">stloc.3</span></span>|<span data-ttu-id="cbc67-4225">로컬 변수 3으로 스택에서 값을 팝합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4225">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="cbc67-4226">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4226">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4227">값이 스택에서 팝 되 고 로컬 변수 3으로 인덱싱된에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4227">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="cbc67-4228">`stloc.3` 명령 계산 스택에서 상위 값을 팝 하 고 로컬 변수 3으로 인덱싱된로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4228">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="cbc67-4229">값의 형식에는 현재 메서드의 로컬 시그니처에 지정 된 로컬 변수의 형식이 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4229">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 `stloc.3` <span data-ttu-id="cbc67-4230">로컬 변수 3에에서 값을 저장 하기 위한 효과적인 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4230">is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="cbc67-4231">4 바이트 보다 작은 정수 값을 포함 하는 지역에 저장 지역 변수가 스택에서 이동할 때 값을 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4231">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="cbc67-4232">부동 소수점 값은 기본 크기에서 반올림 됩니다 (형식 `F`) 크기 인수를 사용 하 여 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4232">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="cbc67-4233">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stloc.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4233">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4234">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4234">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4235">계산 스택 맨 위에서 현재 값을 팝하여 <paramref name="index" />(약식)의 지역 변수 목록에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4235">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4236">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4236">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4237">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4237">Format</span></span>|<span data-ttu-id="cbc67-4238">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4238">Assembly Format</span></span>|<span data-ttu-id="cbc67-4239">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4239">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4240">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-4240">13 < `unsigned int8` ></span></span>|<span data-ttu-id="cbc67-4241">stloc.s</span><span class="sxs-lookup"><span data-stu-id="cbc67-4241">stloc.s</span></span> `index`|<span data-ttu-id="cbc67-4242">스택에서 값을 팝 하 고 로컬 변수에 저장 `index`, 약식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4242">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="cbc67-4243">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4243">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4244">값이 스택에서 팝 되 고 로컬 변수에 배치 `index`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4244">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="cbc67-4245">`stloc.s` 명령 계산 스택에서 상위 값을 팝 하 고 로컬 변수 수로 이동 `index`있는 지역 변수는 번호가 매겨진된 0 이상입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4245">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="cbc67-4246">값의 형식에는 현재 메서드의 로컬 시그니처에 지정 된 로컬 변수의 형식이 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4246">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="cbc67-4247">`stloc.s` 명령은 지역 변수의 0부터 255 효율적인 인코딩을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4247">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="cbc67-4248">4 바이트 보다 작은 정수 값을 포함 하는 지역에 저장 지역 변수가 스택에서 이동할 때 값을 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4248">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="cbc67-4249">부동 소수점 값은 기본 크기에서 반올림 됩니다 (형식 `F`) 크기 인수를 사용 하 여 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4249">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="cbc67-4250">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stloc.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4251">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4251">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="cbc67-4252">ILGenerator.Emit (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4252">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4253">지정된 형식의 값을 계산 스택에서 주어진 메모리 주소로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4253">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4254">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4255">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4255">Format</span></span>|<span data-ttu-id="cbc67-4256">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4256">Assembly Format</span></span>|<span data-ttu-id="cbc67-4257">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4258">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-4258">81 < `T` ></span></span>|<span data-ttu-id="cbc67-4259">stobj</span><span class="sxs-lookup"><span data-stu-id="cbc67-4259">stobj</span></span> `class`|<span data-ttu-id="cbc67-4260">형식의 값을 저장 `class` 메모리로 스택에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4260">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="cbc67-4261">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4262">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4262">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4263">형식의 값 형식 개체 `class` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4263">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="cbc67-4264">스택에서 팝 되 고 개체 및 주소 값 형식 개체의 주소에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4264">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="cbc67-4265">합니다 `stobj` 주소로 지정 된 주소를 값 형식 개체를 복사 하는 명령 (형식의 포인터 `native int`를 `*`, 또는 `&`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4265">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="cbc67-4266">복사 된 바이트 수를 나타내는 클래스의 크기에 따라 달라 집니다 `class`값 형식을 나타내는 메타 데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4266">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="cbc67-4267">작업은 `stobj` 명령 바로 앞에서 변경할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Volatile> 또는 <xref:System.Reflection.Emit.OpCodes.Unaligned> 접두사 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4267">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <xref:System.TypeLoadException> <span data-ttu-id="cbc67-4268">클래스를 찾을 수 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4268">is thrown if class cannot be found.</span></span> <span data-ttu-id="cbc67-4269">이 일반적으로 언어 MSIL (Microsoft Intermediate) 명령이 런타임이 아닌 네이티브 코드로 변환 될 때 감지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4269">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="cbc67-4270">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4271">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4271">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4272">정적 필드의 값을 계산 스택에 있는 값으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4272">Replaces the value of a static field with a value from the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4273">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4274">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4274">Format</span></span>|<span data-ttu-id="cbc67-4275">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4275">Assembly Format</span></span>|<span data-ttu-id="cbc67-4276">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4277">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-4277">80 < `T` ></span></span>|<span data-ttu-id="cbc67-4278">stsfld</span><span class="sxs-lookup"><span data-stu-id="cbc67-4278">stsfld</span></span> `field`|<span data-ttu-id="cbc67-4279">값을 대체 `field` 제공 된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4279">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="cbc67-4280">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4281">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4281">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4282">값이 스택에서 팝 되 고 저장 `field`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4282">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="cbc67-4283">`stsfld` 명령 스택에서 값을 사용 하 여 정적 필드의 값을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4283">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> `field` <span data-ttu-id="cbc67-4284">정적 필드 멤버를 참조 하는 메타 데이터 토큰이입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4284">is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="cbc67-4285">합니다 `stsfld` 명령 접두사로 붙을 수 <xref:System.Reflection.Emit.OpCodes.Volatile>입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4285">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <xref:System.MissingFieldException> <span data-ttu-id="cbc67-4286">필드 메타 데이터에 없는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4286">is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="cbc67-4287">이 값은 런타임에 하지 언어 MSIL (Microsoft Intermediate) 명령이 네이티브 코드로 변환 될 때 일반적으로 검사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4287">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="cbc67-4288">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `stsfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4288">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4289">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4289">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4290">값에서 다른 값을 빼고 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4290">Subtracts one value from another and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4291">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4291">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4292">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4292">Format</span></span>|<span data-ttu-id="cbc67-4293">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4293">Assembly Format</span></span>|<span data-ttu-id="cbc67-4294">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4294">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4295">59</span><span class="sxs-lookup"><span data-stu-id="cbc67-4295">59</span></span>|<span data-ttu-id="cbc67-4296">sub</span><span class="sxs-lookup"><span data-stu-id="cbc67-4296">sub</span></span>|<span data-ttu-id="cbc67-4297">다른 새 숫자 값을 반환 하는 하나의 값을 뺍니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4297">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="cbc67-4298">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4298">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-4299">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4299">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-4300">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4300">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-4301">및 `value1` 스택에서 팝 되 고 `value2` 에서 뺍니다 `value1`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4301">and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="cbc67-4302">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4302">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-4303">정수 연산에 오버플로 인식 되지 않습니다 (적절 한 오버플로 처리를 참조 하세요. <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4303">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="cbc67-4304">정수 빼기 포화 되지 않고 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4304">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="cbc67-4305">예를 들어: 8 비트 정수의 위치 `value1` 0으로 설정 되어 및 `value2` 설정할지 1, "래핑된" 결과 255 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4305">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="cbc67-4306">부동 소수점 오버플로 반환 `+inf` (`PositiveInfinity`) 또는 `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4306">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="cbc67-4307">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `sub` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4308">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4309">정수 값에서 다른 정수 값을 빼고 오버플로를 검사하여 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4309">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4310">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4311">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4311">Format</span></span>|<span data-ttu-id="cbc67-4312">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4312">Assembly Format</span></span>|<span data-ttu-id="cbc67-4313">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4314">DA</span><span class="sxs-lookup"><span data-stu-id="cbc67-4314">DA</span></span>|<span data-ttu-id="cbc67-4315">sub.ovf</span><span class="sxs-lookup"><span data-stu-id="cbc67-4315">sub.ovf</span></span>|<span data-ttu-id="cbc67-4316">오버플로 검사를 사용 하 여 다른 하나의 정수 값을 뺍니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4316">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="cbc67-4317">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-4318">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4318">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-4319">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4319">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-4320">및 `value1` 스택에서 팝 되 고 `value2` 에서 뺍니다 `value1` 오버플로 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4320">and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="cbc67-4321">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4321">The result is pushed onto the stack.</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-4322">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4322">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-4323">부호 있는 정수입니다;이 작업을 수행 부동 소수점 값을 사용 하 여 <xref:System.Reflection.Emit.OpCodes.Sub>입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4323">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="cbc67-4324">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `sub.ovf` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4324">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4325">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4325">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4326">부호 있는 정수 값에서 다른 부호 있는 정수 값을 빼고 오버플로를 검사하여 결과를 계산 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4326">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4327">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4327">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4328">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4328">Format</span></span>|<span data-ttu-id="cbc67-4329">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4329">Assembly Format</span></span>|<span data-ttu-id="cbc67-4330">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4330">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4331">DB</span><span class="sxs-lookup"><span data-stu-id="cbc67-4331">DB</span></span>|<span data-ttu-id="cbc67-4332">sub.ovf.un</span><span class="sxs-lookup"><span data-stu-id="cbc67-4332">sub.ovf.un</span></span>|<span data-ttu-id="cbc67-4333">오버플로 검사를 사용 하 여 다른 하나의 부호 없는 정수 값을 뺍니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4333">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="cbc67-4334">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4334">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-4335">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4335">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-4336">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4336">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-4337">및 `value1` 스택에서 팝 되 고 `value2` 에서 뺍니다 `value1` 오버플로 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4337">and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="cbc67-4338">결과를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4338">The result is pushed onto the stack.</span></span>  
  
 <xref:System.OverflowException> <span data-ttu-id="cbc67-4339">결과 형식으로 결과 나타낼 수 있는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4339">is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="cbc67-4340">부호 있는 정수입니다;이 작업을 수행 부동 소수점 값을 사용 하 여 <xref:System.Reflection.Emit.OpCodes.Sub>입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4340">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="cbc67-4341">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `sub.ovf.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4341">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4342">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4342">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4343">점프 테이블을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4343">Implements a jump table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4344">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4344">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4345">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4345">Format</span></span>|<span data-ttu-id="cbc67-4346">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4346">Assembly Format</span></span>|<span data-ttu-id="cbc67-4347">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4347">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4348">45 < `unsigned int32` > < `int32` >... < `int32` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-4348">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="cbc67-4349">스위치 (`N`하십시오 `t1`, `t2`... `tN`)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4349">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="cbc67-4350">이동 중 `N` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4350">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="cbc67-4351">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4351">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4352">값이 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4352">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4353">값은 스택에서 팝 되 고 실행 값은 값으로 인덱싱된 오프셋에 명령으로 전달 됩니다 보다 작은 `N`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4353">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="cbc67-4354">`switch` 점프 테이블을 구현 하는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4354">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="cbc67-4355">명령 형식은 `unsigned int32` 대상의 수를 나타내는 `N`차례로 `N` 점프 대상을 지정 하는 int32 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4355">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="cbc67-4356">이러한 대상은 오프셋 (양수 또는 음수)이 다음에 오는 명령의 `switch` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4356">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="cbc67-4357">합니다 `switch` 스택에서 값을 팝 명령과 비교, 부호 없는 정수로 `N`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4357">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="cbc67-4358">값이 보다 작거나 `N`, 0에서 대상 위치 번호가 매겨집니다 실행 값으로 인덱싱된 대상으로 전송 됩니다 (예를 들어, 값 0은 첫 번째 대상, 값 1은 두 번째 대상 및 등).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4358">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="cbc67-4359">값 보다 크거나 같은 경우 `N`, 다음 명령 (이동) 하 여 계속 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4359">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="cbc67-4360">첫 번째에만 컨트롤을 전달 수 대상 명령 하나 이상의 접두사 코드가 있으면 이러한 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4360">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="cbc67-4361">컨트롤의 내부 및 외부로 전송 `try`, `catch`를 `filter`, 및 `finally` 블록을이 명령에서 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4361">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="cbc67-4362">(이러한 전송을 엄격 하 게 제한 되며 명령을 대신 사용 해야 합니다).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4362">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="cbc67-4363">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `switch` opcode입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4363">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="cbc67-4364">`Label[]` 인수가 레이블 32 비트 오프셋을 나타내는의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4364">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="cbc67-4365">ILGenerator.Emit(OpCode, Label[])</span><span class="sxs-lookup"><span data-stu-id="cbc67-4365">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cbc67-4366">다음 코드 샘플의 사용법을 보여 줍니다.는 `Switch` 배열을 사용 하 여 점프 테이블을 생성 하는 opcode <xref:System.Reflection.Emit.Label>합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4366">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4367">실제 호출 명령이 실행되기 전에 현재 메서드의 스택 프레임이 제거되도록 후위 메서드 호출 명령을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4367">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4368">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4368">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4369">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4369">Format</span></span>|<span data-ttu-id="cbc67-4370">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4370">Assembly Format</span></span>|<span data-ttu-id="cbc67-4371">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4371">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4372">FE 14</span><span class="sxs-lookup"><span data-stu-id="cbc67-4372">FE 14</span></span>|<span data-ttu-id="cbc67-4373">마무리 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4373">tail.</span></span>|<span data-ttu-id="cbc67-4374">현재 메서드를 종료 하는 후속 호출</span><span class="sxs-lookup"><span data-stu-id="cbc67-4374">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="cbc67-4375">이 명령에 대해 정의 된 스택 전환 동작은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4375">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="cbc67-4376">합니다 `tail` 접두사 명령 바로 앞에 나와야를 <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, 또는 <xref:System.Reflection.Emit.OpCodes.Callvirt> 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4376">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="cbc67-4377">호출 명령이 실행 되기 전에 현재 메서드의 스택 프레임을 제거 해야 한다는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4377">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="cbc67-4378">다음 호출에서 반환 값은 또한 현재 메서드에 의해 반환 되는 값을 호출 하므로 변환할 수 메서드 간 이동을 의미 하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4378">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="cbc67-4379">스택의 다음 호출에서 전송 되는 인수를 제외 하 고 비어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4379">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="cbc67-4380">호출 명령 다음에 ret 이어야 합니다. 따라서 올바른 코드 시퀀스는 `tail. call` (또는 `calli` 또는 `callvirt`).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4380">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="cbc67-4381">올바른 언어 MSIL (Microsoft Intermediate) 지침으로 분기할 해야 합니다 `call` 명령, 있지만 후속으로 분기할 수 있습니다 <xref:System.Reflection.Emit.OpCodes.Ret>합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4381">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="cbc67-4382">컨트롤에서에서 전송 될 때 신뢰할 수 없는 코드가 신뢰할 수 있는 코드를 코드 id의 보안을 위협할 수 있기 때문에 현재 프레임을 취소할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4382">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="cbc67-4383">.NET Framework 보안 검사를 따라서 발생할 수 있습니다 합니다 `tail` 무시 되 표준 두면 <xref:System.Reflection.Emit.OpCodes.Call> 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4383">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="cbc67-4384">마찬가지로, 하려면 호출이 반환 된 후 발생 하 여 동기화 된 영역 종료, `tail` 동기화 된 상태로 표시 되는 메서드를 종료 하는 데 사용 하는 경우 접두사는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4384">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="cbc67-4385">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `tail` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4386">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4386">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst"><span data-ttu-id="cbc67-4387">Opcode 개체의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4387">An instance of an Opcode object.</span></span></param>
        <summary><span data-ttu-id="cbc67-4388">주어진 opcode가 싱글바이트 인수를 사용할 경우 True나 false를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4388">Returns true or false if the supplied opcode takes a single byte argument.</span></span></summary>
        <returns><see langword="true" /> <span data-ttu-id="cbc67-4389"><see langword="false" />를 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4389">or <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4390">이 메서드는 MSIL opcode 최적화 된 코드에 대 한 "약식"을 사용 하기 위해를 찾는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4390">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 `TakesSingleByteArgument` <span data-ttu-id="cbc67-4391">반환 `true` 경우는 <xref:System.Reflection.Emit.OpCode> 인스턴스는 다음 경우에는 단일 바이트 인수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4391">returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="cbc67-4392">바이트 크기의 주소로 분기 명령을 수행 하는 opcode (예를 들어 <xref:System.Reflection.Emit.OpCodes.Br_S> 고 <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4392">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="cbc67-4393">Opcode는 바이트 값을 스택으로 푸시합니다 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4393">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="cbc67-4394">Opcode 참조 변수 또는 인수 바이트 크기의 "약식 형태"를 통해 (예를 들어 <xref:System.Reflection.Emit.OpCodes.Ldloc_S> 고 <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span><span class="sxs-lookup"><span data-stu-id="cbc67-4394">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="cbc67-4395">그 외의 경우 `false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4395">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="cbc67-4396">아래 예제에서는 사용을 보여 줍니다 `TakesSingleByteArgument` 에 반영 하는 `OpCodes` 클래스 및 테스트 하 여부를 각 `OpCode` 필드는 단일 바이트 인수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4396">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4397">현재 계산 스택에 있는 예외 개체를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4397">Throws the exception object currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4398">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4398">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4399">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4399">Format</span></span>|<span data-ttu-id="cbc67-4400">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4400">Assembly Format</span></span>|<span data-ttu-id="cbc67-4401">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4401">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4402">7A</span><span class="sxs-lookup"><span data-stu-id="cbc67-4402">7A</span></span>|<span data-ttu-id="cbc67-4403">throw</span><span class="sxs-lookup"><span data-stu-id="cbc67-4403">throw</span></span>|<span data-ttu-id="cbc67-4404">예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4404">Throws an exception.</span></span>|  
  
 <span data-ttu-id="cbc67-4405">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4405">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4406">(예외)에 대 한 개체 참조를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4406">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4407">스택 및 throw 된 예외에서 개체 참조를 팝 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4407">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="cbc67-4408">합니다 `throw` 예외 개체를 throw 하는 명령 (형식 `O`) 스택에 현재 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4408">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4409">개체 참조는 null 참조 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4409">is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="cbc67-4410">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `throw` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4410">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4411">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4411">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4412">현재 계산 스택의 맨 위에 있는 주소가 바로 다음에 오는 <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> 또는 <see langword="cpblk" /> 명령의 기본 크기에 따라 정렬될 수 없음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4412">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4413">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4413">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4414">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4414">Format</span></span>|<span data-ttu-id="cbc67-4415">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4415">Assembly Format</span></span>|<span data-ttu-id="cbc67-4416">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4416">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4417">FE 12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-4417">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="cbc67-4418">정렬 되지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4418">unaligned.</span></span> `alignment`|<span data-ttu-id="cbc67-4419">다음 포인터 명령이 정렬 되지 않는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4419">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="cbc67-4420">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4420">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4421">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4421">An address is pushed onto the stack.</span></span>  
  
 `Unaligned` <span data-ttu-id="cbc67-4422">지정 하는 주소 (관리 되지 않는 포인터를 `native int`) 스택에 맞춰지지 않을 수 바로 다음에 원래 크기에 `ldind`, `stind`, `ldfld`를 `stfld`를 `ldobj`, `stobj`, `initblk`, 또는 `cpblk` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4422">specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="cbc67-4423">즉,에 대 한는 <xref:System.Reflection.Emit.OpCodes.Ldind_I4> 명령 주소 맞춤은 4 바이트 경계에 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4423">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="cbc67-4424">에 대 한 `initblk` 고 `cpblk` 기본 맞춤은 아키텍처 종속 (4 바이트에서 cpu가 32 비트, 64 비트 Cpu에서 8 바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4424">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="cbc67-4425">32 비트 단어 크기에 해당 출력을 제한 하지 않는 코드 생성기를 사용 해야 `unaligned` 맞춤은 알 수 없는 경우 컴파일 타임에 8 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4425">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="cbc67-4426">맞춤 값 1, 2 또는 4 및 생성된 된 코드는 주소는 바이트, 더블 바이트 또는 각각 쿼드 바이트 맞춤을 가정해 야 함을 의미 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4426">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="cbc67-4427">일시적이 지를 확인 합니다. 포인터 (형식 `*`)는 항상 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4427">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="cbc67-4428">맞춤을 하는 동안는 `cpblk` 명령 (원본에 대해 하나) 및 대상에 대해 하나씩 두 개의 숫자를 위해서는 논리적으로, 낮은 번호가 지정 된 경우 성능에 거의 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4428">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="cbc67-4429">합니다 `unaligned` 고 `volatile` 어떤 순서로 든 접두사를 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4429">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="cbc67-4430">바로 앞에 나오기를 `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`를 `stobj`, `initblk`, 또는 `cpblk` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4430">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="cbc67-4431">만 <xref:System.Reflection.Emit.OpCodes.Volatile> 에 대 한 접두사를 사용할 수는 <xref:System.Reflection.Emit.OpCodes.Ldsfld> 고 <xref:System.Reflection.Emit.OpCodes.Stsfld> 지침.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4431">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="cbc67-4432">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `unaligned` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4432">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4433">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4433">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="cbc67-4434">ILGenerator.Emit (Opcode, Byte)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4434">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4435">boxed로 표시되는 값 형식을 unboxed 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4435">Converts the boxed representation of a value type to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4436">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4437">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4437">Format</span></span>|<span data-ttu-id="cbc67-4438">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4438">Assembly Format</span></span>|<span data-ttu-id="cbc67-4439">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4440">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-4440">79 < `T` ></span></span>|<span data-ttu-id="cbc67-4441">unbox</span><span class="sxs-lookup"><span data-stu-id="cbc67-4441">unbox</span></span> `valType`|<span data-ttu-id="cbc67-4442">값 형식 데이터를 추출 `obj`, 해당 boxed로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4442">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="cbc67-4443">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4444">개체 참조가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4444">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4445">개체 참조는 스택에서 팝 이며 unboxed 값 형식 포인터에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4445">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="cbc67-4446">값 형식 포인터가 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4446">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-4447">값 형식에 별도 두 가지 표현이 공용 언어 인프라 (CLI) 내에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4447">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="cbc67-4448">다른 개체 내에서 값 형식이 포함 된 경우 사용을 '원시' 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4448">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="cbc67-4449">값 형식에서 데이터 줄 바꿈되는 위치 (boxed) 개체에 독립적인 엔터티로 존재할 수 있는 'boxed' 폼입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4449">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="cbc67-4450">합니다 `unbox` 명령에는 개체 참조를 변환 합니다 (형식 `O`), 값 형식 포인터를 값 형식으로 표현한 boxed (관리 되는 포인터 형식 `&`), 해당 unboxed 형식인 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4450">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="cbc67-4451">제공 된 값 형식 (`valType`)은 값 형식의 boxed 개체 내에 포함 된 형식을 나타내는 메타 데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4451">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="cbc67-4452">와 달리 <xref:System.Reflection.Emit.OpCodes.Box>에 개체에서 사용 하는 값 형식 복사본을 만드는 데 필요한 `unbox` 개체에서 값 형식을 복사할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4452">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="cbc67-4453">일반적으로 간단히 이미 boxed 개체 안에 있는 값 형식의 주소를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4453">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <xref:System.InvalidCastException> <span data-ttu-id="cbc67-4454">개체와 boxed 하지 하는 경우 발생 하는 `valType`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4454">is thrown if the object is not boxed as `valType`.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4455">개체 참조는 null 참조 하는 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4455">is thrown if the object reference is a null reference.</span></span>  
  
 <xref:System.TypeLoadException> <span data-ttu-id="cbc67-4456">값을 입력 하는 경우 발생 하는 `valType` 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4456">is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="cbc67-4457">이 일반적으로 언어 MSIL (Microsoft Intermediate) 명령이 런타임이 아닌 네이티브 코드로 변환 될 때 감지 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4457">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="cbc67-4458">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `unbox` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4459">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4459">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4460">명령에 지정된 형식의 boxed 표현을 unboxed 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4460">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4461">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 Microsoft 중간 언어 (MSIL) 어셈블리 형식으로 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4461">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4462">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4462">Format</span></span>|<span data-ttu-id="cbc67-4463">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4463">Assembly Format</span></span>|<span data-ttu-id="cbc67-4464">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4465">A5 < `T` ></span><span class="sxs-lookup"><span data-stu-id="cbc67-4465">A5 < `T` ></span></span>|<span data-ttu-id="cbc67-4466">unbox.any</span><span class="sxs-lookup"><span data-stu-id="cbc67-4466">unbox.any</span></span> `typeTok`|<span data-ttu-id="cbc67-4467">데이터를 추출할 `obj`, 해당 boxed로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4467">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="cbc67-4468">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4469">개체 참조 `obj` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4469">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="cbc67-4470">개체 참조는 스택에서 팝 하 고 명령에 지정 된 형식과 unboxed.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4470">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="cbc67-4471">결과 개체 참조 또는 값 형식으로 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4471">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-4472">값 형식의 boxed 형식을 적용할 때를 `unbox.any` 명령에 포함 된 값을 추출 `obj` (형식의 `O`), 같음 되므로 `unbox` 뒤에 `ldobj`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4472">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="cbc67-4473">참조 형식에 적용 하는 경우는 `unbox.any` 명령 것과 동일한 효과가 `castclass` `typeTok`합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4473">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="cbc67-4474">경우 피연산자 `typeTok` 제네릭 형식 매개 변수를이 런타임 동작은 해당 제네릭 형식 매개 변수에 지정 된 형식에 의해 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4474">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <xref:System.InvalidCastException> <span data-ttu-id="cbc67-4475">이 throw `obj` boxed 형식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4475">is thrown if `obj` is not a boxed type.</span></span>  
  
 <xref:System.NullReferenceException> <span data-ttu-id="cbc67-4476">이 throw `obj` 가 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4476">is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="cbc67-4477">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `unbox.any` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4477">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4478">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4478">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4479">현재 계산 스택 맨 위에 있는 주소가 휘발성이고, 해당 위치를 읽은 결과가 캐시되지 않으며 이 위치에 여러 번 저장할 수 있음을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4479">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4480">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4480">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4481">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4481">Format</span></span>|<span data-ttu-id="cbc67-4482">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4482">Assembly Format</span></span>|<span data-ttu-id="cbc67-4483">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4483">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4484">FE 13</span><span class="sxs-lookup"><span data-stu-id="cbc67-4484">FE 13</span></span>|<span data-ttu-id="cbc67-4485">휘발성입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4485">volatile.</span></span>|<span data-ttu-id="cbc67-4486">후속 포인터가 참조 일시적 임을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4486">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="cbc67-4487">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4487">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="cbc67-4488">주소를 스택으로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4488">An address is pushed onto the stack.</span></span>  
  
 `volatile`<span data-ttu-id="cbc67-4489">.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4489">.</span></span> <span data-ttu-id="cbc67-4490">주소 volatile 주소를 지정 (즉, 참조 될 수 외부에서 실행의 현재 스레드에서) 및 결과가 읽기 위치를 캐시할 수 없는 또는 해당 위치에 여러 저장소는 표시 하지 않을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4490">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="cbc67-4491">표시로 액세스 `volatile` single 액세스는 영향을 줍니다 동일한 위치에 대 한 다른 액세스를 개별적으로 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4491">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="cbc67-4492">원자 단위로 volatile 위치에 대 한 액세스 필요 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4492">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="cbc67-4493">합니다 <xref:System.Reflection.Emit.OpCodes.Unaligned> 고 `volatile` 어떤 순서로 든 접두사를 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4493">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="cbc67-4494">바로 앞에 나오기를 `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`를 `stobj`, `initblk`, 또는 `cpblk` 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4494">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="cbc67-4495">만 `volatile` 에 대 한 접두사를 사용할 수는 <xref:System.Reflection.Emit.OpCodes.Ldsfld> 고 <xref:System.Reflection.Emit.OpCodes.Stsfld> 지침.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4495">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="cbc67-4496">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `volatile` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4496">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4497">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4497">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cbc67-4498">계산 스택 맨 위에 있는 두 값의 비트 배타적 OR를 계산하고 결과를 스택으로 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4498">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cbc67-4499">다음 표에서 명령의 16 진수 및 간략 한 참조 요약 정보와 함께 언어 MSIL (Microsoft Intermediate) 어셈블리 형식:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4499">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="cbc67-4500">서식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4500">Format</span></span>|<span data-ttu-id="cbc67-4501">어셈블리 형식</span><span class="sxs-lookup"><span data-stu-id="cbc67-4501">Assembly Format</span></span>|<span data-ttu-id="cbc67-4502">설명</span><span class="sxs-lookup"><span data-stu-id="cbc67-4502">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="cbc67-4503">61</span><span class="sxs-lookup"><span data-stu-id="cbc67-4503">61</span></span>|<span data-ttu-id="cbc67-4504">xor</span><span class="sxs-lookup"><span data-stu-id="cbc67-4504">xor</span></span>|<span data-ttu-id="cbc67-4505">두 정수 값의 비트 배타적 or를 계산 하 고 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4505">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="cbc67-4506">스택 전환 동작에 순차적으로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4506">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  `value1` <span data-ttu-id="cbc67-4507">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4507">is pushed onto the stack.</span></span>  
  
2.  `value2` <span data-ttu-id="cbc67-4508">스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4508">is pushed onto the stack.</span></span>  
  
3.  `value2` <span data-ttu-id="cbc67-4509">및 `value1` 팝 되 고 스택 및 해당 비트 XOR 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4509">and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="cbc67-4510">비트 XOR `value2` 고 `value1` 스택에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4510">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="cbc67-4511">`xor` 명령 계산의 두 가지 비트 XOR 스택에 값 및 결과 스택에 남겨 둡니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4511">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 `Xor` <span data-ttu-id="cbc67-4512">정수 관련 작업이입니다.</span><span class="sxs-lookup"><span data-stu-id="cbc67-4512">is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="cbc67-4513">다음 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 메서드 오버 로드를 사용할 수는 `xor` opcode:</span><span class="sxs-lookup"><span data-stu-id="cbc67-4513">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="cbc67-4514">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="cbc67-4514">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
