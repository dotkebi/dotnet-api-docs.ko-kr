<Type Name="MessageContractMemberAttribute" FullName="System.ServiceModel.MessageContractMemberAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2477fcde8a323ad416ab68adb712132f39a7029e" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56771181" /></Metadata><TypeSignature Language="C#" Value="public abstract class MessageContractMemberAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MessageContractMemberAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.MessageContractMemberAttribute" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MessageContractMemberAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageContractMemberAttribute abstract : Attribute" />
  <TypeSignature Language="F#" Value="type MessageContractMemberAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="91faa-101"><see cref="T:System.ServiceModel.MessageBodyMemberAttribute" /> 및 <see cref="T:System.ServiceModel.MessageHeaderAttribute" />에 대한 기본 멤버를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-101">Declares the base members for <see cref="T:System.ServiceModel.MessageBodyMemberAttribute" /> and <see cref="T:System.ServiceModel.MessageHeaderAttribute" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="91faa-102">이 클래스는 SOAP 메시지의 모든 부분에 공통인 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-102">This class contains properties common to all parts of a SOAP message.</span></span> <span data-ttu-id="91faa-103">예를 들어 모든 부분에 이름과 네임스페이스가 있으며, 보안 수준이 적용되었을 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-103">For example, all parts have a name and a namespace, and potentially a level of security applied.</span></span>  
  
 <span data-ttu-id="91faa-104">기본 SOAP 봉투 자체를 수정 하지 않고 SOAP 본문 내용의 serialization을 제어에 대 한 내용은 참조 하세요 <xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=nameWithType>, [Specifying Data Transfer in Service Contracts](~/docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md), 및 [데이터 사용 계약](~/docs/framework/wcf/feature-details/using-data-contracts.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-104">For information on controlling the serialization of the contents of a SOAP body without modifying the default SOAP envelope itself, see <xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=nameWithType>, [Specifying Data Transfer in Service Contracts](~/docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md), and [Using Data Contracts](~/docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="91faa-105">메시지 계약을 만드는 방법에 대 한 자세한 내용은 참조 하세요. [Using Message Contracts](~/docs/framework/wcf/feature-details/using-message-contracts.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-105">For more information about creating message contracts, see [Using Message Contracts](~/docs/framework/wcf/feature-details/using-message-contracts.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="91faa-106">다음 코드 예제에 사용 하는 사용자 지정 메시지 계약을 보여 줍니다 합니다 <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, 및 <xref:System.ServiceModel.MessageBodyMemberAttribute> 특성 (에서 상속 하는 모든 <xref:System.ServiceModel.MessageContractMemberAttribute>) 작업에서 사용 하는 사용자 지정 형식의 메시지를 만들려면.</span><span class="sxs-lookup"><span data-stu-id="91faa-106">The following code examples demonstrate a custom message contract that uses the <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes (which all inherit from <xref:System.ServiceModel.MessageContractMemberAttribute>) to create custom typed messages to use in operations.</span></span> <span data-ttu-id="91faa-107">이 경우 `sourceAccount`, `targetAccount`, 이름이 `amount`인 요소로 serialize되는 `transactionAmount` 값 등 세 개의 멤버가 SOAP 메시지의 본문 요소에 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-107">In this case, there are three members that are serialized into the body element of the SOAP message: `sourceAccount`, `targetAccount`, and the `amount` value, (which is serialized into an element with the name `transactionAmount`).</span></span> <span data-ttu-id="91faa-108">또한 `IsAudited` SOAP 헤더 요소는 `http://schemas.contosobank.com/auditing/2005` 네임스페이스에 있고, `sourceAccount`에 대해 암호화 및 디지털 서명이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-108">In addition, the `IsAudited` SOAP header element resides in the `http://schemas.contosobank.com/auditing/2005` namespace, and `sourceAccount` is encrypted and digitally signed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="91faa-109">`Operation` 및 `Account` 형식에는 데이터 계약이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-109">The `Operation` and `Account` types must have a data contract.</span></span>  
  
```csharp  
[MessageContract]  
public class BankingTransaction  
{  
  [MessageHeader]   
  public Operation operation;  
  [MessageHeader(Namespace="http://schemas.contosobank.com/auditing/2005")]   
  public bool IsAudited;  
  [MessageBody(ProtectionLevel=ProtectionLevel.EncryptAndSign)]   
  public Account sourceAccount;  
  [MessageBody]   
  public Account targetAccount;  
  [MessageBody(Name="transactionAmount")]   
  public int amount;  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MessageContractMemberAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.MessageContractMemberAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MessageContractMemberAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="91faa-110"><see cref="T:System.ServiceModel.MessageContractMemberAttribute" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-110">Initializes a new instance of the <see cref="T:System.ServiceModel.MessageContractMemberAttribute" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.MessageContractMemberAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="91faa-111">파생 클래스에서 재정의되면 멤버에 할당된 보호 수준이 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-111">When overridden in a derived class, gets a value that indicates whether the member has a protection level assigned.</span></span></summary>
        <value><span data-ttu-id="91faa-112">멤버에 보호 수준이 지정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-112"><see langword="true" /> if the member has a protection level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.MessageContractMemberAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="91faa-113">이 멤버에 해당하는 요소의 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-113">Specifies the name of the element that corresponds to this member.</span></span></summary>
        <value><span data-ttu-id="91faa-114">이 멤버에 해당하는 요소의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-114">The name of the element that corresponds to this member.</span></span> <span data-ttu-id="91faa-115">이 문자열은 올바른 XML 요소 이름이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-115">This string must be a valid XML element name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="91faa-116">다음 코드 예제에서는 매개 변수로 사용할 강력한 형식의 사용자 지정 메시지를 만들기 위해 <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute> 및 <xref:System.ServiceModel.MessageBodyMemberAttribute> 특성을 사용하는 사용자 지정 메시지 계약을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-116">The following code examples demonstrate a custom message contract that uses the <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes to create custom, strongly-typed messages to use as parameters.</span></span> <span data-ttu-id="91faa-117">이 경우 `sourceAccount`, `targetAccount` 및 이름이 `amount`인 요소로 serialize되는 `transactionAmount` 값 등 SOAP 메시지의 본문 요소로 serialize되는 세 개의 데이터 멤버가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-117">In this case, there are three data members that are serialized into the body element of the SOAP message: `sourceAccount`, `targetAccount`, and the `amount` value, (which is serialized into an element with the name `transactionAmount`).</span></span> <span data-ttu-id="91faa-118">또한 `IsAudited` SOAP 헤더 요소가 `http://schemas.contosobank.com/auditing/2005` 네임스페이스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-118">In addition, the `IsAudited` SOAP header element resides in the `http://schemas.contosobank.com/auditing/2005` namespace.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="91faa-119">`Operation` 및 `Account` 형식에는 데이터 계약도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-119">The `Operation` and `Account` types must also have a data contract.</span></span>  
  
```csharp  
[MessageContract]  
public class BankingTransaction  
{  
  [MessageHeader] public Operation operation;  
  [MessageHeader(Namespace="http://schemas.contosobank.com/auditing/2005")] public bool IsAudited;  
  [MessageBody] public Account sourceAccount;  
  [MessageBody] public Account targetAccount;  
  [MessageBody(Name="transactionAmount")] public int amount;  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.MessageContractMemberAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="91faa-120">이 멤버에 해당하는 요소의 네임스페이스를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-120">Specifies the namespace of the element that corresponds to this member.</span></span></summary>
        <value><span data-ttu-id="91faa-121">이 멤버에 해당하는 요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-121">A namespace URI of the element that corresponds to this member.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="91faa-122">다음 코드 예제에 사용 하는 사용자 지정 메시지 계약을 보여 줍니다 합니다 <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, 및 <xref:System.ServiceModel.MessageBodyMemberAttribute> 특성 (에서 상속 하는 모든 <xref:System.ServiceModel.MessageContractMemberAttribute>) 작업에서 사용 하는 사용자 지정 형식의 메시지를 만들려면.</span><span class="sxs-lookup"><span data-stu-id="91faa-122">The following code examples demonstrate a custom message contract that uses the <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes (which all inherit from <xref:System.ServiceModel.MessageContractMemberAttribute>) to create custom typed messages to use in operations.</span></span> <span data-ttu-id="91faa-123">이 경우 `sourceAccount`, `targetAccount`, 이름이 `amount`인 요소로 serialize되는 `transactionAmount` 값 등 세 개의 멤버가 SOAP 메시지의 본문 요소에 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-123">In this case, there are three members that are serialized into the body element of the SOAP message: `sourceAccount`, `targetAccount`, and the `amount` value, (which is serialized into an element with the name `transactionAmount`).</span></span> <span data-ttu-id="91faa-124">또한 `IsAudited` SOAP 헤더 요소는 `http://schemas.contosobank.com/auditing/2005` 네임스페이스에 있고, `sourceAccount`에 대해 암호화 및 디지털 서명이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-124">In addition, the `IsAudited` SOAP header element resides in the `http://schemas.contosobank.com/auditing/2005` namespace, and `sourceAccount` is encrypted and digitally signed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="91faa-125">`Operation` 및 `Account` 형식에는 데이터 계약이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-125">The `Operation` and `Account` types must have a data contract.</span></span>  
  
```csharp  
[MessageContract]  
public class BankingTransaction  
{  
  [MessageHeader] public Operation operation;  
  [MessageHeader(Namespace="http://schemas.contosobank.com/auditing/2005")] public bool IsAudited;  
  [MessageBody] public Account sourceAccount;  
  [MessageBody] public Account targetAccount;  
  [MessageBody(Name="transactionAmount")] public int amount;  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="91faa-126">멤버를 현재 상태로 전송할지, 서명한 상태로 전송할지, 서명하고 암호화한 상태로 전송할지를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-126">Specifies whether the member is to be transmitted as-is, signed, or signed and encrypted.</span></span></summary>
        <value><span data-ttu-id="91faa-127"><see cref="T:System.Net.Security.ProtectionLevel" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-127">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values.</span></span> <span data-ttu-id="91faa-128">기본값은 <see cref="F:System.Net.Security.ProtectionLevel.None" />입니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-128">The default is <see cref="F:System.Net.Security.ProtectionLevel.None" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="91faa-129"><xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> 또는 <xref:System.ServiceModel.MessageHeaderAttribute> 특성에서 <xref:System.ServiceModel.MessageBodyMemberAttribute> 속성을 사용하려면 바인딩 및 동작을 제대로 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-129">To make use of the <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> property in either the <xref:System.ServiceModel.MessageHeaderAttribute> or <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes you must properly configure the binding and behaviors.</span></span> <span data-ttu-id="91faa-130">예를 들어 보안 자격 증명을 제공하지 않고 메시지 부분과 함께 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>을 사용하는 등 이러한 보안 기능을 제대로 구성하지 않고 사용하면 런타임에 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-130">If these security features are used without a proper configuration (for example, using <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType> with a message part without supplying security credentials) an exception is thrown at run time.</span></span>  
  
 <span data-ttu-id="91faa-131">또한 각 헤더에 대해 개별적으로 보호 수준이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-131">In addition, the protection level is determined for each header individually.</span></span> <span data-ttu-id="91faa-132">그러나 SOAP 본문에는 본문 부분의 수에 상관없이 하나의 보호 수준만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-132">However, the SOAP body has only one protection level, regardless of the number of body parts.</span></span> <span data-ttu-id="91faa-133">본문의 보호 수준은 모든 본문 부분 중 가장 큰 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> 속성 값에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-133">The protection level of the body is determined by the highest <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> property value of all the body parts.</span></span> <span data-ttu-id="91faa-134">예를 들어 다음 클래스를 예로 들어 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-134">For example, consider the following class:</span></span>  
  
```csharp  
[MessageContract]  
public class PatientRecord  
{  
   [MessageHeader(ProtectionLevel=None)] public int recordID;  
   [MessageHeader(ProtectionLevel=Sign)] public string patientName;  
   [MessageHeader(ProtectionLevel=EncryptAndSign)] public string SSN;  
   [MessageBody(ProtectionLevel=None)] public string comments;  
   [MessageBody(ProtectionLevel=Sign)] public string diagnosis;  
   [MessageBody(ProtectionLevel=EncryptAndSign)] public string medicalHistory;  
}  
```  
  
 <span data-ttu-id="91faa-135">이 예제에서는 `recordID` 헤더가 보호되지 않고, `patientName`에 서명이 수행되고, `SSN`에 대해 암호화 및 서명이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-135">In this example, the `recordID` header is not protected, `patientName` is signed, and `SSN` is encrypted and signed.</span></span> <span data-ttu-id="91faa-136">`medicalHistory` 및 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> 본문 부분에서 보호 수준을 더 낮게 지정하더라도 `comments`이 있는 본문 부분인 `diagnosis`가 적어도 하나는 있으므로 전체 메시지 본문에 대해 암호화 및 서명이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-136">There is at least one body part, `medicalHistory`, with <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> and thus the entire message body is encrypted and signed, even though the `comments` and `diagnosis` body parts specify lower protection levels.</span></span>  
  
 <span data-ttu-id="91faa-137">런타임의 보호 동작은 다음 속성에서 설정한 보호 수준 값의 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-137">The protection behavior at runtime is the combination of the protection-level values set on the following properties.</span></span> <span data-ttu-id="91faa-138">이러한 속성은 계층 구조로 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-138">These properties have a hierarchical structure.</span></span> <span data-ttu-id="91faa-139">가장 바깥쪽 값을 설정하면 더 좁은 범위에 명시적으로 다른 값을 설정하지 않는 한 모든 더 좁은 범위에 이 값이 기본 설정으로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-139">Setting the outermost value establishes the default setting for all narrower scopes unless a different value for a narrower scope is explicitly set.</span></span> <span data-ttu-id="91faa-140">이 경우 특별히 설정된 범위를 제외하고 바깥쪽 값은 모든 더 좁은 범위의 기본값으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-140">In this case, the outer value remains the default for all narrower scopes with the exception of that specifically set.</span></span>  
  
 <span data-ttu-id="91faa-141">예를 들어 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>을 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>으로 설정한 경우 더 좁은 다른 범위에는 보호 수준 설정이 없다면 작업 계약의 모든 메시지에 대해 암호화 및 서명이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-141">For example, if <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> is set to <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> and no other narrower scopes have protection level settings, all messages in an operation contract are encrypted and signed.</span></span> <span data-ttu-id="91faa-142">이러한 작업 중 하나에 <xref:System.ServiceModel.OperationContractAttribute>으로 설정된 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>이 있으면 해당 작업의 메시지에 대해서는 서명이 수행되지만, 계약의 다른 모든 메시지의 경우 암호화 및 서명이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-142">If, however, one of those operations has the <xref:System.ServiceModel.OperationContractAttribute> set to <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, then the messages for that operation are signed but all other messages in the contract are encrypted and signed.</span></span>  
  
 <span data-ttu-id="91faa-143">보호 수준의 가정 및 범위에 대 한 자세한 내용은 참조 하세요 [보호 수준을 이해](~/docs/framework/wcf/understanding-protection-level.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-143">For details about protection levels and their assumptions and scopes, see [Understanding Protection Level](~/docs/framework/wcf/understanding-protection-level.md).</span></span>  
  
 <span data-ttu-id="91faa-144">이러한 값이 설정된 범위는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-144">The scopes at which these values are set are:</span></span>  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="91faa-145"><xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType>의 <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType> 속성</span><span class="sxs-lookup"><span data-stu-id="91faa-145">The <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> property on <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="91faa-146"><xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType>의 <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType> 속성</span><span class="sxs-lookup"><span data-stu-id="91faa-146">The <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> property on <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="91faa-147">계약에 명시적으로 지정된 보호 수준이 없고 기본 바인딩이 전송 수준이나 메시지 수준에서 보안을 지원하는 경우 전체 계약에서 유효한 보호 수준은 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-147">When there is no protection level explicitly specified on the contract and the underlying binding supports security (whether at the transport or message level), the effective protection level for the whole contract is <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.</span></span> <span data-ttu-id="91faa-148">바인딩에서 보안을 지원하지 않는 경우(예: <xref:System.ServiceModel.BasicHttpBinding>) 전체 계약에서 유효한 <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType>은 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-148">If the binding does not support security (such as <xref:System.ServiceModel.BasicHttpBinding>), the effective <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> is <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> for the whole contract.</span></span> <span data-ttu-id="91faa-149">결과는 엔드포인트 바인딩에 따라 다르며, 계약에서 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>을 지정하더라도 클라이언트가 다른 메시지 수준이나 전송 수준의 보안 보호를 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="91faa-149">The result is that depending upon the endpoint binding, clients can require different message or transport level security protection even when the contract specifies <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>